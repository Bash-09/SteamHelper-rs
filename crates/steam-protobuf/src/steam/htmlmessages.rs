// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `htmlmessages.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgKeyUp {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    keyCode: ::std::option::Option<u32>,
    modifiers: ::std::option::Option<u32>,
    nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgKeyUp {
    fn default() -> &'a CMsgKeyUp {
        <CMsgKeyUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyUp {
    pub fn new() -> CMsgKeyUp {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 2;


    pub fn get_keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }
    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;


    pub fn get_modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }
    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 4;


    pub fn get_nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }
    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgKeyUp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.keyCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.modifiers = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nativeKeyCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.keyCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgKeyUp {
        CMsgKeyUp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgKeyUp| { &m.browser_handle },
                    |m: &mut CMsgKeyUp| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "keyCode",
                    |m: &CMsgKeyUp| { &m.keyCode },
                    |m: &mut CMsgKeyUp| { &mut m.keyCode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "modifiers",
                    |m: &CMsgKeyUp| { &m.modifiers },
                    |m: &mut CMsgKeyUp| { &mut m.modifiers },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "nativeKeyCode",
                    |m: &CMsgKeyUp| { &m.nativeKeyCode },
                    |m: &mut CMsgKeyUp| { &mut m.nativeKeyCode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgKeyUp>(
                    "CMsgKeyUp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgKeyUp {
        static mut instance: ::protobuf::lazy::Lazy<CMsgKeyUp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgKeyUp,
        };
        unsafe {
            instance.get(CMsgKeyUp::new)
        }
    }
}

impl ::protobuf::Clear for CMsgKeyUp {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgKeyUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKeyUp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgKeyDown {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    keyCode: ::std::option::Option<u32>,
    modifiers: ::std::option::Option<u32>,
    is_system_key: ::std::option::Option<bool>,
    nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgKeyDown {
    fn default() -> &'a CMsgKeyDown {
        <CMsgKeyDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyDown {
    pub fn new() -> CMsgKeyDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 2;


    pub fn get_keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }
    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;


    pub fn get_modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }
    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional bool is_system_key = 4;


    pub fn get_is_system_key(&self) -> bool {
        self.is_system_key.unwrap_or(false)
    }
    pub fn clear_is_system_key(&mut self) {
        self.is_system_key = ::std::option::Option::None;
    }

    pub fn has_is_system_key(&self) -> bool {
        self.is_system_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_system_key(&mut self, v: bool) {
        self.is_system_key = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 5;


    pub fn get_nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }
    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgKeyDown {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.keyCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.modifiers = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_system_key = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nativeKeyCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.keyCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_system_key {
            my_size += 2;
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_system_key {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgKeyDown {
        CMsgKeyDown::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgKeyDown| { &m.browser_handle },
                    |m: &mut CMsgKeyDown| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "keyCode",
                    |m: &CMsgKeyDown| { &m.keyCode },
                    |m: &mut CMsgKeyDown| { &mut m.keyCode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "modifiers",
                    |m: &CMsgKeyDown| { &m.modifiers },
                    |m: &mut CMsgKeyDown| { &mut m.modifiers },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_system_key",
                    |m: &CMsgKeyDown| { &m.is_system_key },
                    |m: &mut CMsgKeyDown| { &mut m.is_system_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "nativeKeyCode",
                    |m: &CMsgKeyDown| { &m.nativeKeyCode },
                    |m: &mut CMsgKeyDown| { &mut m.nativeKeyCode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgKeyDown>(
                    "CMsgKeyDown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgKeyDown {
        static mut instance: ::protobuf::lazy::Lazy<CMsgKeyDown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgKeyDown,
        };
        unsafe {
            instance.get(CMsgKeyDown::new)
        }
    }
}

impl ::protobuf::Clear for CMsgKeyDown {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.is_system_key = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgKeyDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKeyDown {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgKeyChar {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    unichar: ::std::option::Option<u32>,
    modifiers: ::std::option::Option<u32>,
    keyCode: ::std::option::Option<u32>,
    nativeKeyCode: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgKeyChar {
    fn default() -> &'a CMsgKeyChar {
        <CMsgKeyChar as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyChar {
    pub fn new() -> CMsgKeyChar {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 unichar = 2;


    pub fn get_unichar(&self) -> u32 {
        self.unichar.unwrap_or(0)
    }
    pub fn clear_unichar(&mut self) {
        self.unichar = ::std::option::Option::None;
    }

    pub fn has_unichar(&self) -> bool {
        self.unichar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unichar(&mut self, v: u32) {
        self.unichar = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;


    pub fn get_modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }
    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional uint32 keyCode = 4;


    pub fn get_keyCode(&self) -> u32 {
        self.keyCode.unwrap_or(0)
    }
    pub fn clear_keyCode(&mut self) {
        self.keyCode = ::std::option::Option::None;
    }

    pub fn has_keyCode(&self) -> bool {
        self.keyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyCode(&mut self, v: u32) {
        self.keyCode = ::std::option::Option::Some(v);
    }

    // optional uint32 nativeKeyCode = 5;


    pub fn get_nativeKeyCode(&self) -> u32 {
        self.nativeKeyCode.unwrap_or(0)
    }
    pub fn clear_nativeKeyCode(&mut self) {
        self.nativeKeyCode = ::std::option::Option::None;
    }

    pub fn has_nativeKeyCode(&self) -> bool {
        self.nativeKeyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nativeKeyCode(&mut self, v: u32) {
        self.nativeKeyCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgKeyChar {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unichar = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.modifiers = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.keyCode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nativeKeyCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unichar {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.keyCode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nativeKeyCode {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.unichar {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.keyCode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.nativeKeyCode {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgKeyChar {
        CMsgKeyChar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgKeyChar| { &m.browser_handle },
                    |m: &mut CMsgKeyChar| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "unichar",
                    |m: &CMsgKeyChar| { &m.unichar },
                    |m: &mut CMsgKeyChar| { &mut m.unichar },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "modifiers",
                    |m: &CMsgKeyChar| { &m.modifiers },
                    |m: &mut CMsgKeyChar| { &mut m.modifiers },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "keyCode",
                    |m: &CMsgKeyChar| { &m.keyCode },
                    |m: &mut CMsgKeyChar| { &mut m.keyCode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "nativeKeyCode",
                    |m: &CMsgKeyChar| { &m.nativeKeyCode },
                    |m: &mut CMsgKeyChar| { &mut m.nativeKeyCode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgKeyChar>(
                    "CMsgKeyChar",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgKeyChar {
        static mut instance: ::protobuf::lazy::Lazy<CMsgKeyChar> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgKeyChar,
        };
        unsafe {
            instance.get(CMsgKeyChar::new)
        }
    }
}

impl ::protobuf::Clear for CMsgKeyChar {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unichar = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.keyCode = ::std::option::Option::None;
        self.nativeKeyCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgKeyChar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKeyChar {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgMouseDown {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    mouse_button: ::std::option::Option<u32>,
    modifiers: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMouseDown {
    fn default() -> &'a CMsgMouseDown {
        <CMsgMouseDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseDown {
    pub fn new() -> CMsgMouseDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;


    pub fn get_mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }
    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;


    pub fn get_modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }
    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseDown {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mouse_button = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.modifiers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mouse_button {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMouseDown {
        CMsgMouseDown::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgMouseDown| { &m.browser_handle },
                    |m: &mut CMsgMouseDown| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mouse_button",
                    |m: &CMsgMouseDown| { &m.mouse_button },
                    |m: &mut CMsgMouseDown| { &mut m.mouse_button },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "modifiers",
                    |m: &CMsgMouseDown| { &m.modifiers },
                    |m: &mut CMsgMouseDown| { &mut m.modifiers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMouseDown>(
                    "CMsgMouseDown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgMouseDown {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMouseDown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMouseDown,
        };
        unsafe {
            instance.get(CMsgMouseDown::new)
        }
    }
}

impl ::protobuf::Clear for CMsgMouseDown {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMouseDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseDown {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgMouseUp {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    mouse_button: ::std::option::Option<u32>,
    modifiers: ::std::option::Option<u32>,
    is_off_panel: ::std::option::Option<bool>,
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMouseUp {
    fn default() -> &'a CMsgMouseUp {
        <CMsgMouseUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseUp {
    pub fn new() -> CMsgMouseUp {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;


    pub fn get_mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }
    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;


    pub fn get_modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }
    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }

    // optional bool is_off_panel = 4;


    pub fn get_is_off_panel(&self) -> bool {
        self.is_off_panel.unwrap_or(false)
    }
    pub fn clear_is_off_panel(&mut self) {
        self.is_off_panel = ::std::option::Option::None;
    }

    pub fn has_is_off_panel(&self) -> bool {
        self.is_off_panel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_off_panel(&mut self, v: bool) {
        self.is_off_panel = ::std::option::Option::Some(v);
    }

    // optional int32 x = 5;


    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 6;


    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseUp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mouse_button = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.modifiers = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_off_panel = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mouse_button {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_off_panel {
            my_size += 2;
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_off_panel {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMouseUp {
        CMsgMouseUp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgMouseUp| { &m.browser_handle },
                    |m: &mut CMsgMouseUp| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mouse_button",
                    |m: &CMsgMouseUp| { &m.mouse_button },
                    |m: &mut CMsgMouseUp| { &mut m.mouse_button },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "modifiers",
                    |m: &CMsgMouseUp| { &m.modifiers },
                    |m: &mut CMsgMouseUp| { &mut m.modifiers },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_off_panel",
                    |m: &CMsgMouseUp| { &m.is_off_panel },
                    |m: &mut CMsgMouseUp| { &mut m.is_off_panel },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    |m: &CMsgMouseUp| { &m.x },
                    |m: &mut CMsgMouseUp| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    |m: &CMsgMouseUp| { &m.y },
                    |m: &mut CMsgMouseUp| { &mut m.y },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMouseUp>(
                    "CMsgMouseUp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgMouseUp {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMouseUp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMouseUp,
        };
        unsafe {
            instance.get(CMsgMouseUp::new)
        }
    }
}

impl ::protobuf::Clear for CMsgMouseUp {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.is_off_panel = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMouseUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseUp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgMouseDblClick {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    mouse_button: ::std::option::Option<u32>,
    modifiers: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMouseDblClick {
    fn default() -> &'a CMsgMouseDblClick {
        <CMsgMouseDblClick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseDblClick {
    pub fn new() -> CMsgMouseDblClick {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 mouse_button = 2;


    pub fn get_mouse_button(&self) -> u32 {
        self.mouse_button.unwrap_or(0)
    }
    pub fn clear_mouse_button(&mut self) {
        self.mouse_button = ::std::option::Option::None;
    }

    pub fn has_mouse_button(&self) -> bool {
        self.mouse_button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouse_button(&mut self, v: u32) {
        self.mouse_button = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 3;


    pub fn get_modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }
    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseDblClick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mouse_button = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.modifiers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mouse_button {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mouse_button {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMouseDblClick {
        CMsgMouseDblClick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgMouseDblClick| { &m.browser_handle },
                    |m: &mut CMsgMouseDblClick| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mouse_button",
                    |m: &CMsgMouseDblClick| { &m.mouse_button },
                    |m: &mut CMsgMouseDblClick| { &mut m.mouse_button },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "modifiers",
                    |m: &CMsgMouseDblClick| { &m.modifiers },
                    |m: &mut CMsgMouseDblClick| { &mut m.modifiers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMouseDblClick>(
                    "CMsgMouseDblClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgMouseDblClick {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMouseDblClick> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMouseDblClick,
        };
        unsafe {
            instance.get(CMsgMouseDblClick::new)
        }
    }
}

impl ::protobuf::Clear for CMsgMouseDblClick {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.mouse_button = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMouseDblClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseDblClick {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgMouseWheel {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    deltax: ::std::option::Option<i32>,
    deltay: ::std::option::Option<i32>,
    modifiers: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMouseWheel {
    fn default() -> &'a CMsgMouseWheel {
        <CMsgMouseWheel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseWheel {
    pub fn new() -> CMsgMouseWheel {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 deltax = 2;


    pub fn get_deltax(&self) -> i32 {
        self.deltax.unwrap_or(0)
    }
    pub fn clear_deltax(&mut self) {
        self.deltax = ::std::option::Option::None;
    }

    pub fn has_deltax(&self) -> bool {
        self.deltax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltax(&mut self, v: i32) {
        self.deltax = ::std::option::Option::Some(v);
    }

    // optional int32 deltay = 3;


    pub fn get_deltay(&self) -> i32 {
        self.deltay.unwrap_or(0)
    }
    pub fn clear_deltay(&mut self) {
        self.deltay = ::std::option::Option::None;
    }

    pub fn has_deltay(&self) -> bool {
        self.deltay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltay(&mut self, v: i32) {
        self.deltay = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 4;


    pub fn get_modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }
    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseWheel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deltax = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deltay = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.modifiers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deltax {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deltay {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deltax {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.deltay {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMouseWheel {
        CMsgMouseWheel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgMouseWheel| { &m.browser_handle },
                    |m: &mut CMsgMouseWheel| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "deltax",
                    |m: &CMsgMouseWheel| { &m.deltax },
                    |m: &mut CMsgMouseWheel| { &mut m.deltax },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "deltay",
                    |m: &CMsgMouseWheel| { &m.deltay },
                    |m: &mut CMsgMouseWheel| { &mut m.deltay },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "modifiers",
                    |m: &CMsgMouseWheel| { &m.modifiers },
                    |m: &mut CMsgMouseWheel| { &mut m.modifiers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMouseWheel>(
                    "CMsgMouseWheel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgMouseWheel {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMouseWheel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMouseWheel,
        };
        unsafe {
            instance.get(CMsgMouseWheel::new)
        }
    }
}

impl ::protobuf::Clear for CMsgMouseWheel {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.deltax = ::std::option::Option::None;
        self.deltay = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMouseWheel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseWheel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgMouseMove {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    modifiers: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMouseMove {
    fn default() -> &'a CMsgMouseMove {
        <CMsgMouseMove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseMove {
    pub fn new() -> CMsgMouseMove {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;


    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;


    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 modifiers = 4;


    pub fn get_modifiers(&self) -> u32 {
        self.modifiers.unwrap_or(0)
    }
    pub fn clear_modifiers(&mut self) {
        self.modifiers = ::std::option::Option::None;
    }

    pub fn has_modifiers(&self) -> bool {
        self.modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifiers(&mut self, v: u32) {
        self.modifiers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseMove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.modifiers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.modifiers {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.modifiers {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMouseMove {
        CMsgMouseMove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgMouseMove| { &m.browser_handle },
                    |m: &mut CMsgMouseMove| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    |m: &CMsgMouseMove| { &m.x },
                    |m: &mut CMsgMouseMove| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    |m: &CMsgMouseMove| { &m.y },
                    |m: &mut CMsgMouseMove| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "modifiers",
                    |m: &CMsgMouseMove| { &m.modifiers },
                    |m: &mut CMsgMouseMove| { &mut m.modifiers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMouseMove>(
                    "CMsgMouseMove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgMouseMove {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMouseMove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMouseMove,
        };
        unsafe {
            instance.get(CMsgMouseMove::new)
        }
    }
}

impl ::protobuf::Clear for CMsgMouseMove {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.modifiers = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMouseMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseMove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgMouseLeave {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMouseLeave {
    fn default() -> &'a CMsgMouseLeave {
        <CMsgMouseLeave as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMouseLeave {
    pub fn new() -> CMsgMouseLeave {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMouseLeave {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMouseLeave {
        CMsgMouseLeave::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgMouseLeave| { &m.browser_handle },
                    |m: &mut CMsgMouseLeave| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMouseLeave>(
                    "CMsgMouseLeave",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgMouseLeave {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMouseLeave> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMouseLeave,
        };
        unsafe {
            instance.get(CMsgMouseLeave::new)
        }
    }
}

impl ::protobuf::Clear for CMsgMouseLeave {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMouseLeave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMouseLeave {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBrowserCreate {
    // message fields
    request_id: ::std::option::Option<u32>,
    useragent: ::protobuf::SingularField<::std::string::String>,
    user_css: ::protobuf::SingularField<::std::string::String>,
    native_dropdowns: ::std::option::Option<bool>,
    dpi_scaling: ::std::option::Option<f32>,
    offscreen: ::std::option::Option<bool>,
    initial_width: ::std::option::Option<u32>,
    initial_height: ::std::option::Option<u32>,
    window_icon: ::protobuf::SingularField<::std::string::String>,
    borderless: ::std::option::Option<bool>,
    vroverlay_key: ::protobuf::SingularField<::std::string::String>,
    browser_type: ::std::option::Option<u32>,
    initial_top: ::std::option::Option<i32>,
    initial_left: ::std::option::Option<i32>,
    only_allow_trusted_popups: ::std::option::Option<bool>,
    initial_url: ::protobuf::SingularField<::std::string::String>,
    hwnd_parent: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserCreate {
    fn default() -> &'a CMsgBrowserCreate {
        <CMsgBrowserCreate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserCreate {
    pub fn new() -> CMsgBrowserCreate {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional string useragent = 3;


    pub fn get_useragent(&self) -> &str {
        match self.useragent.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_useragent(&mut self) {
        self.useragent.clear();
    }

    pub fn has_useragent(&self) -> bool {
        self.useragent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_useragent(&mut self, v: ::std::string::String) {
        self.useragent = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_useragent(&mut self) -> &mut ::std::string::String {
        if self.useragent.is_none() {
            self.useragent.set_default();
        }
        self.useragent.as_mut().unwrap()
    }

    // Take field
    pub fn take_useragent(&mut self) -> ::std::string::String {
        self.useragent.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user_css = 5;


    pub fn get_user_css(&self) -> &str {
        match self.user_css.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user_css(&mut self) {
        self.user_css.clear();
    }

    pub fn has_user_css(&self) -> bool {
        self.user_css.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_css(&mut self, v: ::std::string::String) {
        self.user_css = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_css(&mut self) -> &mut ::std::string::String {
        if self.user_css.is_none() {
            self.user_css.set_default();
        }
        self.user_css.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_css(&mut self) -> ::std::string::String {
        self.user_css.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool native_dropdowns = 6;


    pub fn get_native_dropdowns(&self) -> bool {
        self.native_dropdowns.unwrap_or(false)
    }
    pub fn clear_native_dropdowns(&mut self) {
        self.native_dropdowns = ::std::option::Option::None;
    }

    pub fn has_native_dropdowns(&self) -> bool {
        self.native_dropdowns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_native_dropdowns(&mut self, v: bool) {
        self.native_dropdowns = ::std::option::Option::Some(v);
    }

    // optional float dpi_scaling = 7;


    pub fn get_dpi_scaling(&self) -> f32 {
        self.dpi_scaling.unwrap_or(0.)
    }
    pub fn clear_dpi_scaling(&mut self) {
        self.dpi_scaling = ::std::option::Option::None;
    }

    pub fn has_dpi_scaling(&self) -> bool {
        self.dpi_scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_scaling(&mut self, v: f32) {
        self.dpi_scaling = ::std::option::Option::Some(v);
    }

    // optional bool offscreen = 8;


    pub fn get_offscreen(&self) -> bool {
        self.offscreen.unwrap_or(true)
    }
    pub fn clear_offscreen(&mut self) {
        self.offscreen = ::std::option::Option::None;
    }

    pub fn has_offscreen(&self) -> bool {
        self.offscreen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offscreen(&mut self, v: bool) {
        self.offscreen = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_width = 9;


    pub fn get_initial_width(&self) -> u32 {
        self.initial_width.unwrap_or(0u32)
    }
    pub fn clear_initial_width(&mut self) {
        self.initial_width = ::std::option::Option::None;
    }

    pub fn has_initial_width(&self) -> bool {
        self.initial_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_width(&mut self, v: u32) {
        self.initial_width = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_height = 10;


    pub fn get_initial_height(&self) -> u32 {
        self.initial_height.unwrap_or(0u32)
    }
    pub fn clear_initial_height(&mut self) {
        self.initial_height = ::std::option::Option::None;
    }

    pub fn has_initial_height(&self) -> bool {
        self.initial_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_height(&mut self, v: u32) {
        self.initial_height = ::std::option::Option::Some(v);
    }

    // optional string window_icon = 11;


    pub fn get_window_icon(&self) -> &str {
        match self.window_icon.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_window_icon(&mut self) {
        self.window_icon.clear();
    }

    pub fn has_window_icon(&self) -> bool {
        self.window_icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_icon(&mut self, v: ::std::string::String) {
        self.window_icon = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window_icon(&mut self) -> &mut ::std::string::String {
        if self.window_icon.is_none() {
            self.window_icon.set_default();
        }
        self.window_icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_window_icon(&mut self) -> ::std::string::String {
        self.window_icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool borderless = 12;


    pub fn get_borderless(&self) -> bool {
        self.borderless.unwrap_or(false)
    }
    pub fn clear_borderless(&mut self) {
        self.borderless = ::std::option::Option::None;
    }

    pub fn has_borderless(&self) -> bool {
        self.borderless.is_some()
    }

    // Param is passed by value, moved
    pub fn set_borderless(&mut self, v: bool) {
        self.borderless = ::std::option::Option::Some(v);
    }

    // optional string vroverlay_key = 13;


    pub fn get_vroverlay_key(&self) -> &str {
        match self.vroverlay_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_vroverlay_key(&mut self) {
        self.vroverlay_key.clear();
    }

    pub fn has_vroverlay_key(&self) -> bool {
        self.vroverlay_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vroverlay_key(&mut self, v: ::std::string::String) {
        self.vroverlay_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vroverlay_key(&mut self) -> &mut ::std::string::String {
        if self.vroverlay_key.is_none() {
            self.vroverlay_key.set_default();
        }
        self.vroverlay_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_vroverlay_key(&mut self) -> ::std::string::String {
        self.vroverlay_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 browser_type = 14;


    pub fn get_browser_type(&self) -> u32 {
        self.browser_type.unwrap_or(0u32)
    }
    pub fn clear_browser_type(&mut self) {
        self.browser_type = ::std::option::Option::None;
    }

    pub fn has_browser_type(&self) -> bool {
        self.browser_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_type(&mut self, v: u32) {
        self.browser_type = ::std::option::Option::Some(v);
    }

    // optional int32 initial_top = 15;


    pub fn get_initial_top(&self) -> i32 {
        self.initial_top.unwrap_or(-2147483648i32)
    }
    pub fn clear_initial_top(&mut self) {
        self.initial_top = ::std::option::Option::None;
    }

    pub fn has_initial_top(&self) -> bool {
        self.initial_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_top(&mut self, v: i32) {
        self.initial_top = ::std::option::Option::Some(v);
    }

    // optional int32 initial_left = 16;


    pub fn get_initial_left(&self) -> i32 {
        self.initial_left.unwrap_or(-2147483648i32)
    }
    pub fn clear_initial_left(&mut self) {
        self.initial_left = ::std::option::Option::None;
    }

    pub fn has_initial_left(&self) -> bool {
        self.initial_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_left(&mut self, v: i32) {
        self.initial_left = ::std::option::Option::Some(v);
    }

    // optional bool only_allow_trusted_popups = 17;


    pub fn get_only_allow_trusted_popups(&self) -> bool {
        self.only_allow_trusted_popups.unwrap_or(false)
    }
    pub fn clear_only_allow_trusted_popups(&mut self) {
        self.only_allow_trusted_popups = ::std::option::Option::None;
    }

    pub fn has_only_allow_trusted_popups(&self) -> bool {
        self.only_allow_trusted_popups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_allow_trusted_popups(&mut self, v: bool) {
        self.only_allow_trusted_popups = ::std::option::Option::Some(v);
    }

    // optional string initial_url = 18;


    pub fn get_initial_url(&self) -> &str {
        match self.initial_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_initial_url(&mut self) {
        self.initial_url.clear();
    }

    pub fn has_initial_url(&self) -> bool {
        self.initial_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_url(&mut self, v: ::std::string::String) {
        self.initial_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_url(&mut self) -> &mut ::std::string::String {
        if self.initial_url.is_none() {
            self.initial_url.set_default();
        }
        self.initial_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_initial_url(&mut self) -> ::std::string::String {
        self.initial_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 hwnd_parent = 19;


    pub fn get_hwnd_parent(&self) -> u64 {
        self.hwnd_parent.unwrap_or(0)
    }
    pub fn clear_hwnd_parent(&mut self) {
        self.hwnd_parent = ::std::option::Option::None;
    }

    pub fn has_hwnd_parent(&self) -> bool {
        self.hwnd_parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hwnd_parent(&mut self, v: u64) {
        self.hwnd_parent = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserCreate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.useragent)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_css)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.native_dropdowns = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.dpi_scaling = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.offscreen = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_width = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_height = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.window_icon)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.borderless = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vroverlay_key)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_type = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.initial_top = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.initial_left = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.only_allow_trusted_popups = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.initial_url)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.hwnd_parent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.useragent.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.user_css.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.native_dropdowns {
            my_size += 2;
        }
        if let Some(v) = self.dpi_scaling {
            my_size += 5;
        }
        if let Some(v) = self.offscreen {
            my_size += 2;
        }
        if let Some(v) = self.initial_width {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_height {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.window_icon.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.borderless {
            my_size += 2;
        }
        if let Some(ref v) = self.vroverlay_key.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.browser_type {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_top {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_left {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.only_allow_trusted_popups {
            my_size += 3;
        }
        if let Some(ref v) = self.initial_url.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.hwnd_parent {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.useragent.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.user_css.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.native_dropdowns {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.dpi_scaling {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.offscreen {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.initial_width {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.initial_height {
            os.write_uint32(10, v)?;
        }
        if let Some(ref v) = self.window_icon.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.borderless {
            os.write_bool(12, v)?;
        }
        if let Some(ref v) = self.vroverlay_key.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.browser_type {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.initial_top {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.initial_left {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.only_allow_trusted_popups {
            os.write_bool(17, v)?;
        }
        if let Some(ref v) = self.initial_url.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(v) = self.hwnd_parent {
            os.write_fixed64(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBrowserCreate {
        CMsgBrowserCreate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    |m: &CMsgBrowserCreate| { &m.request_id },
                    |m: &mut CMsgBrowserCreate| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "useragent",
                    |m: &CMsgBrowserCreate| { &m.useragent },
                    |m: &mut CMsgBrowserCreate| { &mut m.useragent },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_css",
                    |m: &CMsgBrowserCreate| { &m.user_css },
                    |m: &mut CMsgBrowserCreate| { &mut m.user_css },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "native_dropdowns",
                    |m: &CMsgBrowserCreate| { &m.native_dropdowns },
                    |m: &mut CMsgBrowserCreate| { &mut m.native_dropdowns },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "dpi_scaling",
                    |m: &CMsgBrowserCreate| { &m.dpi_scaling },
                    |m: &mut CMsgBrowserCreate| { &mut m.dpi_scaling },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "offscreen",
                    |m: &CMsgBrowserCreate| { &m.offscreen },
                    |m: &mut CMsgBrowserCreate| { &mut m.offscreen },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "initial_width",
                    |m: &CMsgBrowserCreate| { &m.initial_width },
                    |m: &mut CMsgBrowserCreate| { &mut m.initial_width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "initial_height",
                    |m: &CMsgBrowserCreate| { &m.initial_height },
                    |m: &mut CMsgBrowserCreate| { &mut m.initial_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "window_icon",
                    |m: &CMsgBrowserCreate| { &m.window_icon },
                    |m: &mut CMsgBrowserCreate| { &mut m.window_icon },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "borderless",
                    |m: &CMsgBrowserCreate| { &m.borderless },
                    |m: &mut CMsgBrowserCreate| { &mut m.borderless },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vroverlay_key",
                    |m: &CMsgBrowserCreate| { &m.vroverlay_key },
                    |m: &mut CMsgBrowserCreate| { &mut m.vroverlay_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_type",
                    |m: &CMsgBrowserCreate| { &m.browser_type },
                    |m: &mut CMsgBrowserCreate| { &mut m.browser_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "initial_top",
                    |m: &CMsgBrowserCreate| { &m.initial_top },
                    |m: &mut CMsgBrowserCreate| { &mut m.initial_top },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "initial_left",
                    |m: &CMsgBrowserCreate| { &m.initial_left },
                    |m: &mut CMsgBrowserCreate| { &mut m.initial_left },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "only_allow_trusted_popups",
                    |m: &CMsgBrowserCreate| { &m.only_allow_trusted_popups },
                    |m: &mut CMsgBrowserCreate| { &mut m.only_allow_trusted_popups },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "initial_url",
                    |m: &CMsgBrowserCreate| { &m.initial_url },
                    |m: &mut CMsgBrowserCreate| { &mut m.initial_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "hwnd_parent",
                    |m: &CMsgBrowserCreate| { &m.hwnd_parent },
                    |m: &mut CMsgBrowserCreate| { &mut m.hwnd_parent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBrowserCreate>(
                    "CMsgBrowserCreate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBrowserCreate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBrowserCreate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBrowserCreate,
        };
        unsafe {
            instance.get(CMsgBrowserCreate::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBrowserCreate {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.useragent.clear();
        self.user_css.clear();
        self.native_dropdowns = ::std::option::Option::None;
        self.dpi_scaling = ::std::option::Option::None;
        self.offscreen = ::std::option::Option::None;
        self.initial_width = ::std::option::Option::None;
        self.initial_height = ::std::option::Option::None;
        self.window_icon.clear();
        self.borderless = ::std::option::Option::None;
        self.vroverlay_key.clear();
        self.browser_type = ::std::option::Option::None;
        self.initial_top = ::std::option::Option::None;
        self.initial_left = ::std::option::Option::None;
        self.only_allow_trusted_popups = ::std::option::Option::None;
        self.initial_url.clear();
        self.hwnd_parent = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBrowserCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserCreate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBrowserCreateResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    request_id: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserCreateResponse {
    fn default() -> &'a CMsgBrowserCreateResponse {
        <CMsgBrowserCreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserCreateResponse {
    pub fn new() -> CMsgBrowserCreateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 request_id = 2;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserCreateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBrowserCreateResponse {
        CMsgBrowserCreateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgBrowserCreateResponse| { &m.browser_handle },
                    |m: &mut CMsgBrowserCreateResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    |m: &CMsgBrowserCreateResponse| { &m.request_id },
                    |m: &mut CMsgBrowserCreateResponse| { &mut m.request_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBrowserCreateResponse>(
                    "CMsgBrowserCreateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBrowserCreateResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBrowserCreateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBrowserCreateResponse,
        };
        unsafe {
            instance.get(CMsgBrowserCreateResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBrowserCreateResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBrowserCreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserCreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBrowserRemove {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserRemove {
    fn default() -> &'a CMsgBrowserRemove {
        <CMsgBrowserRemove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserRemove {
    pub fn new() -> CMsgBrowserRemove {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserRemove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBrowserRemove {
        CMsgBrowserRemove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgBrowserRemove| { &m.browser_handle },
                    |m: &mut CMsgBrowserRemove| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBrowserRemove>(
                    "CMsgBrowserRemove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBrowserRemove {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBrowserRemove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBrowserRemove,
        };
        unsafe {
            instance.get(CMsgBrowserRemove::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBrowserRemove {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBrowserRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserRemove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetLocalFileRequestMapping {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    request_url: ::protobuf::SingularField<::std::string::String>,
    default_local_path: ::protobuf::SingularField<::std::string::String>,
    routes: ::protobuf::RepeatedField<CMsgSetLocalFileRequestMapping_AdditionalRoute>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetLocalFileRequestMapping {
    fn default() -> &'a CMsgSetLocalFileRequestMapping {
        <CMsgSetLocalFileRequestMapping as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetLocalFileRequestMapping {
    pub fn new() -> CMsgSetLocalFileRequestMapping {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string request_url = 2;


    pub fn get_request_url(&self) -> &str {
        match self.request_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_request_url(&mut self) {
        self.request_url.clear();
    }

    pub fn has_request_url(&self) -> bool {
        self.request_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_url(&mut self, v: ::std::string::String) {
        self.request_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_url(&mut self) -> &mut ::std::string::String {
        if self.request_url.is_none() {
            self.request_url.set_default();
        }
        self.request_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_url(&mut self) -> ::std::string::String {
        self.request_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string default_local_path = 3;


    pub fn get_default_local_path(&self) -> &str {
        match self.default_local_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_default_local_path(&mut self) {
        self.default_local_path.clear();
    }

    pub fn has_default_local_path(&self) -> bool {
        self.default_local_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_local_path(&mut self, v: ::std::string::String) {
        self.default_local_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_local_path(&mut self) -> &mut ::std::string::String {
        if self.default_local_path.is_none() {
            self.default_local_path.set_default();
        }
        self.default_local_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_local_path(&mut self) -> ::std::string::String {
        self.default_local_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgSetLocalFileRequestMapping.AdditionalRoute routes = 4;


    pub fn get_routes(&self) -> &[CMsgSetLocalFileRequestMapping_AdditionalRoute] {
        &self.routes
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<CMsgSetLocalFileRequestMapping_AdditionalRoute>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSetLocalFileRequestMapping_AdditionalRoute> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<CMsgSetLocalFileRequestMapping_AdditionalRoute> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSetLocalFileRequestMapping {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.request_url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.default_local_path)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.request_url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.default_local_path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.request_url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.default_local_path.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.routes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetLocalFileRequestMapping {
        CMsgSetLocalFileRequestMapping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetLocalFileRequestMapping| { &m.browser_handle },
                    |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "request_url",
                    |m: &CMsgSetLocalFileRequestMapping| { &m.request_url },
                    |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.request_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "default_local_path",
                    |m: &CMsgSetLocalFileRequestMapping| { &m.default_local_path },
                    |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.default_local_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSetLocalFileRequestMapping_AdditionalRoute>>(
                    "routes",
                    |m: &CMsgSetLocalFileRequestMapping| { &m.routes },
                    |m: &mut CMsgSetLocalFileRequestMapping| { &mut m.routes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetLocalFileRequestMapping>(
                    "CMsgSetLocalFileRequestMapping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetLocalFileRequestMapping {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetLocalFileRequestMapping> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetLocalFileRequestMapping,
        };
        unsafe {
            instance.get(CMsgSetLocalFileRequestMapping::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetLocalFileRequestMapping {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.request_url.clear();
        self.default_local_path.clear();
        self.routes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetLocalFileRequestMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetLocalFileRequestMapping {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetLocalFileRequestMapping_AdditionalRoute {
    // message fields
    relative_url: ::protobuf::SingularField<::std::string::String>,
    local_path: ::protobuf::SingularField<::std::string::String>,
    allowed_extensions: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetLocalFileRequestMapping_AdditionalRoute {
    fn default() -> &'a CMsgSetLocalFileRequestMapping_AdditionalRoute {
        <CMsgSetLocalFileRequestMapping_AdditionalRoute as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetLocalFileRequestMapping_AdditionalRoute {
    pub fn new() -> CMsgSetLocalFileRequestMapping_AdditionalRoute {
        ::std::default::Default::default()
    }

    // optional string relative_url = 1;


    pub fn get_relative_url(&self) -> &str {
        match self.relative_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_relative_url(&mut self) {
        self.relative_url.clear();
    }

    pub fn has_relative_url(&self) -> bool {
        self.relative_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relative_url(&mut self, v: ::std::string::String) {
        self.relative_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relative_url(&mut self) -> &mut ::std::string::String {
        if self.relative_url.is_none() {
            self.relative_url.set_default();
        }
        self.relative_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_relative_url(&mut self) -> ::std::string::String {
        self.relative_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string local_path = 2;


    pub fn get_local_path(&self) -> &str {
        match self.local_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_local_path(&mut self) {
        self.local_path.clear();
    }

    pub fn has_local_path(&self) -> bool {
        self.local_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_path(&mut self, v: ::std::string::String) {
        self.local_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_path(&mut self) -> &mut ::std::string::String {
        if self.local_path.is_none() {
            self.local_path.set_default();
        }
        self.local_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_path(&mut self) -> ::std::string::String {
        self.local_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string allowed_extensions = 3;


    pub fn get_allowed_extensions(&self) -> &str {
        match self.allowed_extensions.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_allowed_extensions(&mut self) {
        self.allowed_extensions.clear();
    }

    pub fn has_allowed_extensions(&self) -> bool {
        self.allowed_extensions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed_extensions(&mut self, v: ::std::string::String) {
        self.allowed_extensions = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allowed_extensions(&mut self) -> &mut ::std::string::String {
        if self.allowed_extensions.is_none() {
            self.allowed_extensions.set_default();
        }
        self.allowed_extensions.as_mut().unwrap()
    }

    // Take field
    pub fn take_allowed_extensions(&mut self) -> ::std::string::String {
        self.allowed_extensions.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSetLocalFileRequestMapping_AdditionalRoute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relative_url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.local_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.allowed_extensions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.relative_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.local_path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.allowed_extensions.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.relative_url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.local_path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.allowed_extensions.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetLocalFileRequestMapping_AdditionalRoute {
        CMsgSetLocalFileRequestMapping_AdditionalRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "relative_url",
                    |m: &CMsgSetLocalFileRequestMapping_AdditionalRoute| { &m.relative_url },
                    |m: &mut CMsgSetLocalFileRequestMapping_AdditionalRoute| { &mut m.relative_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "local_path",
                    |m: &CMsgSetLocalFileRequestMapping_AdditionalRoute| { &m.local_path },
                    |m: &mut CMsgSetLocalFileRequestMapping_AdditionalRoute| { &mut m.local_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "allowed_extensions",
                    |m: &CMsgSetLocalFileRequestMapping_AdditionalRoute| { &m.allowed_extensions },
                    |m: &mut CMsgSetLocalFileRequestMapping_AdditionalRoute| { &mut m.allowed_extensions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetLocalFileRequestMapping_AdditionalRoute>(
                    "CMsgSetLocalFileRequestMapping_AdditionalRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetLocalFileRequestMapping_AdditionalRoute {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetLocalFileRequestMapping_AdditionalRoute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetLocalFileRequestMapping_AdditionalRoute,
        };
        unsafe {
            instance.get(CMsgSetLocalFileRequestMapping_AdditionalRoute::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetLocalFileRequestMapping_AdditionalRoute {
    fn clear(&mut self) {
        self.relative_url.clear();
        self.local_path.clear();
        self.allowed_extensions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetLocalFileRequestMapping_AdditionalRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetLocalFileRequestMapping_AdditionalRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBrowserErrorStrings {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    title: ::protobuf::SingularField<::std::string::String>,
    header: ::protobuf::SingularField<::std::string::String>,
    cache_miss: ::protobuf::SingularField<::std::string::String>,
    bad_url: ::protobuf::SingularField<::std::string::String>,
    connection_problem: ::protobuf::SingularField<::std::string::String>,
    proxy_problem: ::protobuf::SingularField<::std::string::String>,
    unknown: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserErrorStrings {
    fn default() -> &'a CMsgBrowserErrorStrings {
        <CMsgBrowserErrorStrings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserErrorStrings {
    pub fn new() -> CMsgBrowserErrorStrings {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string header = 3;


    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ::std::string::String) {
        self.header = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ::std::string::String {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ::std::string::String {
        self.header.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cache_miss = 4;


    pub fn get_cache_miss(&self) -> &str {
        match self.cache_miss.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cache_miss(&mut self) {
        self.cache_miss.clear();
    }

    pub fn has_cache_miss(&self) -> bool {
        self.cache_miss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_miss(&mut self, v: ::std::string::String) {
        self.cache_miss = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cache_miss(&mut self) -> &mut ::std::string::String {
        if self.cache_miss.is_none() {
            self.cache_miss.set_default();
        }
        self.cache_miss.as_mut().unwrap()
    }

    // Take field
    pub fn take_cache_miss(&mut self) -> ::std::string::String {
        self.cache_miss.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bad_url = 5;


    pub fn get_bad_url(&self) -> &str {
        match self.bad_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bad_url(&mut self) {
        self.bad_url.clear();
    }

    pub fn has_bad_url(&self) -> bool {
        self.bad_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bad_url(&mut self, v: ::std::string::String) {
        self.bad_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bad_url(&mut self) -> &mut ::std::string::String {
        if self.bad_url.is_none() {
            self.bad_url.set_default();
        }
        self.bad_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_bad_url(&mut self) -> ::std::string::String {
        self.bad_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string connection_problem = 6;


    pub fn get_connection_problem(&self) -> &str {
        match self.connection_problem.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_connection_problem(&mut self) {
        self.connection_problem.clear();
    }

    pub fn has_connection_problem(&self) -> bool {
        self.connection_problem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_problem(&mut self, v: ::std::string::String) {
        self.connection_problem = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_problem(&mut self) -> &mut ::std::string::String {
        if self.connection_problem.is_none() {
            self.connection_problem.set_default();
        }
        self.connection_problem.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_problem(&mut self) -> ::std::string::String {
        self.connection_problem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string proxy_problem = 7;


    pub fn get_proxy_problem(&self) -> &str {
        match self.proxy_problem.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_proxy_problem(&mut self) {
        self.proxy_problem.clear();
    }

    pub fn has_proxy_problem(&self) -> bool {
        self.proxy_problem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_problem(&mut self, v: ::std::string::String) {
        self.proxy_problem = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proxy_problem(&mut self) -> &mut ::std::string::String {
        if self.proxy_problem.is_none() {
            self.proxy_problem.set_default();
        }
        self.proxy_problem.as_mut().unwrap()
    }

    // Take field
    pub fn take_proxy_problem(&mut self) -> ::std::string::String {
        self.proxy_problem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string unknown = 8;


    pub fn get_unknown(&self) -> &str {
        match self.unknown.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_unknown(&mut self) {
        self.unknown.clear();
    }

    pub fn has_unknown(&self) -> bool {
        self.unknown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unknown(&mut self, v: ::std::string::String) {
        self.unknown = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unknown(&mut self) -> &mut ::std::string::String {
        if self.unknown.is_none() {
            self.unknown.set_default();
        }
        self.unknown.as_mut().unwrap()
    }

    // Take field
    pub fn take_unknown(&mut self) -> ::std::string::String {
        self.unknown.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgBrowserErrorStrings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cache_miss)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bad_url)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.connection_problem)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.proxy_problem)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.unknown)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.cache_miss.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.bad_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.connection_problem.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.proxy_problem.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.unknown.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.header.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.cache_miss.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.bad_url.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.connection_problem.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.proxy_problem.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.unknown.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBrowserErrorStrings {
        CMsgBrowserErrorStrings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgBrowserErrorStrings| { &m.browser_handle },
                    |m: &mut CMsgBrowserErrorStrings| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &CMsgBrowserErrorStrings| { &m.title },
                    |m: &mut CMsgBrowserErrorStrings| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "header",
                    |m: &CMsgBrowserErrorStrings| { &m.header },
                    |m: &mut CMsgBrowserErrorStrings| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cache_miss",
                    |m: &CMsgBrowserErrorStrings| { &m.cache_miss },
                    |m: &mut CMsgBrowserErrorStrings| { &mut m.cache_miss },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bad_url",
                    |m: &CMsgBrowserErrorStrings| { &m.bad_url },
                    |m: &mut CMsgBrowserErrorStrings| { &mut m.bad_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "connection_problem",
                    |m: &CMsgBrowserErrorStrings| { &m.connection_problem },
                    |m: &mut CMsgBrowserErrorStrings| { &mut m.connection_problem },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "proxy_problem",
                    |m: &CMsgBrowserErrorStrings| { &m.proxy_problem },
                    |m: &mut CMsgBrowserErrorStrings| { &mut m.proxy_problem },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "unknown",
                    |m: &CMsgBrowserErrorStrings| { &m.unknown },
                    |m: &mut CMsgBrowserErrorStrings| { &mut m.unknown },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBrowserErrorStrings>(
                    "CMsgBrowserErrorStrings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBrowserErrorStrings {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBrowserErrorStrings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBrowserErrorStrings,
        };
        unsafe {
            instance.get(CMsgBrowserErrorStrings::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBrowserErrorStrings {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.title.clear();
        self.header.clear();
        self.cache_miss.clear();
        self.bad_url.clear();
        self.connection_problem.clear();
        self.proxy_problem.clear();
        self.unknown.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBrowserErrorStrings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserErrorStrings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBrowserSize {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserSize {
    fn default() -> &'a CMsgBrowserSize {
        <CMsgBrowserSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserSize {
    pub fn new() -> CMsgBrowserSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 2;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 3;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserSize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBrowserSize {
        CMsgBrowserSize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgBrowserSize| { &m.browser_handle },
                    |m: &mut CMsgBrowserSize| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "width",
                    |m: &CMsgBrowserSize| { &m.width },
                    |m: &mut CMsgBrowserSize| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    |m: &CMsgBrowserSize| { &m.height },
                    |m: &mut CMsgBrowserSize| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBrowserSize>(
                    "CMsgBrowserSize",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBrowserSize {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBrowserSize> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBrowserSize,
        };
        unsafe {
            instance.get(CMsgBrowserSize::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBrowserSize {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBrowserSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserSize {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBrowserSetMinSize {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserSetMinSize {
    fn default() -> &'a CMsgBrowserSetMinSize {
        <CMsgBrowserSetMinSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserSetMinSize {
    pub fn new() -> CMsgBrowserSetMinSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 2;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 3;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserSetMinSize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBrowserSetMinSize {
        CMsgBrowserSetMinSize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgBrowserSetMinSize| { &m.browser_handle },
                    |m: &mut CMsgBrowserSetMinSize| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "width",
                    |m: &CMsgBrowserSetMinSize| { &m.width },
                    |m: &mut CMsgBrowserSetMinSize| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    |m: &CMsgBrowserSetMinSize| { &m.height },
                    |m: &mut CMsgBrowserSetMinSize| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBrowserSetMinSize>(
                    "CMsgBrowserSetMinSize",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBrowserSetMinSize {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBrowserSetMinSize> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBrowserSetMinSize,
        };
        unsafe {
            instance.get(CMsgBrowserSetMinSize::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBrowserSetMinSize {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBrowserSetMinSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserSetMinSize {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBrowserPosition {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    x_local: ::std::option::Option<i32>,
    y_local: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserPosition {
    fn default() -> &'a CMsgBrowserPosition {
        <CMsgBrowserPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserPosition {
    pub fn new() -> CMsgBrowserPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;


    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;


    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional int32 x_local = 4;


    pub fn get_x_local(&self) -> i32 {
        self.x_local.unwrap_or(0)
    }
    pub fn clear_x_local(&mut self) {
        self.x_local = ::std::option::Option::None;
    }

    pub fn has_x_local(&self) -> bool {
        self.x_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_local(&mut self, v: i32) {
        self.x_local = ::std::option::Option::Some(v);
    }

    // optional int32 y_local = 5;


    pub fn get_y_local(&self) -> i32 {
        self.y_local.unwrap_or(0)
    }
    pub fn clear_y_local(&mut self) {
        self.y_local = ::std::option::Option::None;
    }

    pub fn has_y_local(&self) -> bool {
        self.y_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_local(&mut self, v: i32) {
        self.y_local = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x_local = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y_local = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_local {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y_local {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.x_local {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.y_local {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBrowserPosition {
        CMsgBrowserPosition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgBrowserPosition| { &m.browser_handle },
                    |m: &mut CMsgBrowserPosition| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    |m: &CMsgBrowserPosition| { &m.x },
                    |m: &mut CMsgBrowserPosition| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    |m: &CMsgBrowserPosition| { &m.y },
                    |m: &mut CMsgBrowserPosition| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x_local",
                    |m: &CMsgBrowserPosition| { &m.x_local },
                    |m: &mut CMsgBrowserPosition| { &mut m.x_local },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y_local",
                    |m: &CMsgBrowserPosition| { &m.y_local },
                    |m: &mut CMsgBrowserPosition| { &mut m.y_local },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBrowserPosition>(
                    "CMsgBrowserPosition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBrowserPosition {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBrowserPosition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBrowserPosition,
        };
        unsafe {
            instance.get(CMsgBrowserPosition::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBrowserPosition {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.x_local = ::std::option::Option::None;
        self.y_local = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBrowserPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBrowserResized {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserResized {
    fn default() -> &'a CMsgBrowserResized {
        <CMsgBrowserResized as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserResized {
    pub fn new() -> CMsgBrowserResized {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;


    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;


    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 4;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserResized {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBrowserResized {
        CMsgBrowserResized::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgBrowserResized| { &m.browser_handle },
                    |m: &mut CMsgBrowserResized| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    |m: &CMsgBrowserResized| { &m.x },
                    |m: &mut CMsgBrowserResized| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    |m: &CMsgBrowserResized| { &m.y },
                    |m: &mut CMsgBrowserResized| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "width",
                    |m: &CMsgBrowserResized| { &m.width },
                    |m: &mut CMsgBrowserResized| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    |m: &CMsgBrowserResized| { &m.height },
                    |m: &mut CMsgBrowserResized| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBrowserResized>(
                    "CMsgBrowserResized",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBrowserResized {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBrowserResized> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBrowserResized,
        };
        unsafe {
            instance.get(CMsgBrowserResized::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBrowserResized {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBrowserResized {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserResized {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgPostURL {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    post: ::protobuf::SingularField<::std::string::String>,
    pageserial: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPostURL {
    fn default() -> &'a CMsgPostURL {
        <CMsgPostURL as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPostURL {
    pub fn new() -> CMsgPostURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string post = 3;


    pub fn get_post(&self) -> &str {
        match self.post.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_post(&mut self) {
        self.post.clear();
    }

    pub fn has_post(&self) -> bool {
        self.post.is_some()
    }

    // Param is passed by value, moved
    pub fn set_post(&mut self, v: ::std::string::String) {
        self.post = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_post(&mut self) -> &mut ::std::string::String {
        if self.post.is_none() {
            self.post.set_default();
        }
        self.post.as_mut().unwrap()
    }

    // Take field
    pub fn take_post(&mut self) -> ::std::string::String {
        self.post.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 pageserial = 4;


    pub fn get_pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }
    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPostURL {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.post)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pageserial = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.post.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.post.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPostURL {
        CMsgPostURL::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgPostURL| { &m.browser_handle },
                    |m: &mut CMsgPostURL| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgPostURL| { &m.url },
                    |m: &mut CMsgPostURL| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "post",
                    |m: &CMsgPostURL| { &m.post },
                    |m: &mut CMsgPostURL| { &mut m.post },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pageserial",
                    |m: &CMsgPostURL| { &m.pageserial },
                    |m: &mut CMsgPostURL| { &mut m.pageserial },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPostURL>(
                    "CMsgPostURL",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgPostURL {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPostURL> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPostURL,
        };
        unsafe {
            instance.get(CMsgPostURL::new)
        }
    }
}

impl ::protobuf::Clear for CMsgPostURL {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.post.clear();
        self.pageserial = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPostURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPostURL {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgAddHeader {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAddHeader {
    fn default() -> &'a CMsgAddHeader {
        <CMsgAddHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAddHeader {
    pub fn new() -> CMsgAddHeader {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string key = 2;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 3;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgAddHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAddHeader {
        CMsgAddHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgAddHeader| { &m.browser_handle },
                    |m: &mut CMsgAddHeader| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &CMsgAddHeader| { &m.key },
                    |m: &mut CMsgAddHeader| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &CMsgAddHeader| { &m.value },
                    |m: &mut CMsgAddHeader| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgAddHeader>(
                    "CMsgAddHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgAddHeader {
        static mut instance: ::protobuf::lazy::Lazy<CMsgAddHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgAddHeader,
        };
        unsafe {
            instance.get(CMsgAddHeader::new)
        }
    }
}

impl ::protobuf::Clear for CMsgAddHeader {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAddHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAddHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgStopLoad {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgStopLoad {
    fn default() -> &'a CMsgStopLoad {
        <CMsgStopLoad as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStopLoad {
    pub fn new() -> CMsgStopLoad {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStopLoad {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgStopLoad {
        CMsgStopLoad::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgStopLoad| { &m.browser_handle },
                    |m: &mut CMsgStopLoad| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgStopLoad>(
                    "CMsgStopLoad",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgStopLoad {
        static mut instance: ::protobuf::lazy::Lazy<CMsgStopLoad> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgStopLoad,
        };
        unsafe {
            instance.get(CMsgStopLoad::new)
        }
    }
}

impl ::protobuf::Clear for CMsgStopLoad {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgStopLoad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStopLoad {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgReload {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgReload {
    fn default() -> &'a CMsgReload {
        <CMsgReload as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReload {
    pub fn new() -> CMsgReload {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgReload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgReload {
        CMsgReload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgReload| { &m.browser_handle },
                    |m: &mut CMsgReload| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgReload>(
                    "CMsgReload",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgReload {
        static mut instance: ::protobuf::lazy::Lazy<CMsgReload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgReload,
        };
        unsafe {
            instance.get(CMsgReload::new)
        }
    }
}

impl ::protobuf::Clear for CMsgReload {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgReload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgGoForward {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGoForward {
    fn default() -> &'a CMsgGoForward {
        <CMsgGoForward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGoForward {
    pub fn new() -> CMsgGoForward {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGoForward {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGoForward {
        CMsgGoForward::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgGoForward| { &m.browser_handle },
                    |m: &mut CMsgGoForward| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGoForward>(
                    "CMsgGoForward",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGoForward {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGoForward> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGoForward,
        };
        unsafe {
            instance.get(CMsgGoForward::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGoForward {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGoForward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGoForward {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgGoBack {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGoBack {
    fn default() -> &'a CMsgGoBack {
        <CMsgGoBack as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGoBack {
    pub fn new() -> CMsgGoBack {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGoBack {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGoBack {
        CMsgGoBack::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgGoBack| { &m.browser_handle },
                    |m: &mut CMsgGoBack| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGoBack>(
                    "CMsgGoBack",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGoBack {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGoBack> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGoBack,
        };
        unsafe {
            instance.get(CMsgGoBack::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGoBack {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGoBack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGoBack {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgWasHidden {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    hidden: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgWasHidden {
    fn default() -> &'a CMsgWasHidden {
        <CMsgWasHidden as ::protobuf::Message>::default_instance()
    }
}

impl CMsgWasHidden {
    pub fn new() -> CMsgWasHidden {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 2;


    pub fn get_hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }
    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgWasHidden {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hidden = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hidden {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgWasHidden {
        CMsgWasHidden::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgWasHidden| { &m.browser_handle },
                    |m: &mut CMsgWasHidden| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hidden",
                    |m: &CMsgWasHidden| { &m.hidden },
                    |m: &mut CMsgWasHidden| { &mut m.hidden },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgWasHidden>(
                    "CMsgWasHidden",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgWasHidden {
        static mut instance: ::protobuf::lazy::Lazy<CMsgWasHidden> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgWasHidden,
        };
        unsafe {
            instance.get(CMsgWasHidden::new)
        }
    }
}

impl ::protobuf::Clear for CMsgWasHidden {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgWasHidden {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgWasHidden {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClearHistory {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClearHistory {
    fn default() -> &'a CMsgClearHistory {
        <CMsgClearHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearHistory {
    pub fn new() -> CMsgClearHistory {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClearHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClearHistory {
        CMsgClearHistory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgClearHistory| { &m.browser_handle },
                    |m: &mut CMsgClearHistory| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClearHistory>(
                    "CMsgClearHistory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgClearHistory {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClearHistory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClearHistory,
        };
        unsafe {
            instance.get(CMsgClearHistory::new)
        }
    }
}

impl ::protobuf::Clear for CMsgClearHistory {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClearHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClearHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClearAllBrowsingData {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClearAllBrowsingData {
    fn default() -> &'a CMsgClearAllBrowsingData {
        <CMsgClearAllBrowsingData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearAllBrowsingData {
    pub fn new() -> CMsgClearAllBrowsingData {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClearAllBrowsingData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClearAllBrowsingData {
        CMsgClearAllBrowsingData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgClearAllBrowsingData| { &m.browser_handle },
                    |m: &mut CMsgClearAllBrowsingData| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClearAllBrowsingData>(
                    "CMsgClearAllBrowsingData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgClearAllBrowsingData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClearAllBrowsingData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClearAllBrowsingData,
        };
        unsafe {
            instance.get(CMsgClearAllBrowsingData::new)
        }
    }
}

impl ::protobuf::Clear for CMsgClearAllBrowsingData {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClearAllBrowsingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClearAllBrowsingData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgCopy {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCopy {
    fn default() -> &'a CMsgCopy {
        <CMsgCopy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCopy {
    pub fn new() -> CMsgCopy {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCopy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCopy {
        CMsgCopy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgCopy| { &m.browser_handle },
                    |m: &mut CMsgCopy| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCopy>(
                    "CMsgCopy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgCopy {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCopy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCopy,
        };
        unsafe {
            instance.get(CMsgCopy::new)
        }
    }
}

impl ::protobuf::Clear for CMsgCopy {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCopy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCopy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgPaste {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaste {
    fn default() -> &'a CMsgPaste {
        <CMsgPaste as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaste {
    pub fn new() -> CMsgPaste {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPaste {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaste {
        CMsgPaste::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgPaste| { &m.browser_handle },
                    |m: &mut CMsgPaste| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPaste>(
                    "CMsgPaste",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgPaste {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPaste> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPaste,
        };
        unsafe {
            instance.get(CMsgPaste::new)
        }
    }
}

impl ::protobuf::Clear for CMsgPaste {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaste {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaste {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgExecuteJavaScript {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    script: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgExecuteJavaScript {
    fn default() -> &'a CMsgExecuteJavaScript {
        <CMsgExecuteJavaScript as ::protobuf::Message>::default_instance()
    }
}

impl CMsgExecuteJavaScript {
    pub fn new() -> CMsgExecuteJavaScript {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string script = 2;


    pub fn get_script(&self) -> &str {
        match self.script.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_script(&mut self) {
        self.script.clear();
    }

    pub fn has_script(&self) -> bool {
        self.script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_script(&mut self, v: ::std::string::String) {
        self.script = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_script(&mut self) -> &mut ::std::string::String {
        if self.script.is_none() {
            self.script.set_default();
        }
        self.script.as_mut().unwrap()
    }

    // Take field
    pub fn take_script(&mut self) -> ::std::string::String {
        self.script.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgExecuteJavaScript {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.script)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.script.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.script.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgExecuteJavaScript {
        CMsgExecuteJavaScript::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgExecuteJavaScript| { &m.browser_handle },
                    |m: &mut CMsgExecuteJavaScript| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "script",
                    |m: &CMsgExecuteJavaScript| { &m.script },
                    |m: &mut CMsgExecuteJavaScript| { &mut m.script },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgExecuteJavaScript>(
                    "CMsgExecuteJavaScript",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgExecuteJavaScript {
        static mut instance: ::protobuf::lazy::Lazy<CMsgExecuteJavaScript> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgExecuteJavaScript,
        };
        unsafe {
            instance.get(CMsgExecuteJavaScript::new)
        }
    }
}

impl ::protobuf::Clear for CMsgExecuteJavaScript {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.script.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgExecuteJavaScript {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgExecuteJavaScript {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetFocus {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    focus: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetFocus {
    fn default() -> &'a CMsgSetFocus {
        <CMsgSetFocus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetFocus {
    pub fn new() -> CMsgSetFocus {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool focus = 2;


    pub fn get_focus(&self) -> bool {
        self.focus.unwrap_or(false)
    }
    pub fn clear_focus(&mut self) {
        self.focus = ::std::option::Option::None;
    }

    pub fn has_focus(&self) -> bool {
        self.focus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_focus(&mut self, v: bool) {
        self.focus = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetFocus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.focus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.focus {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.focus {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetFocus {
        CMsgSetFocus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetFocus| { &m.browser_handle },
                    |m: &mut CMsgSetFocus| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "focus",
                    |m: &CMsgSetFocus| { &m.focus },
                    |m: &mut CMsgSetFocus| { &mut m.focus },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetFocus>(
                    "CMsgSetFocus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetFocus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetFocus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetFocus,
        };
        unsafe {
            instance.get(CMsgSetFocus::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetFocus {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.focus = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetFocus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetFocus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgHorizontalScrollBarSize {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgHorizontalScrollBarSize {
    fn default() -> &'a CMsgHorizontalScrollBarSize {
        <CMsgHorizontalScrollBarSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHorizontalScrollBarSize {
    pub fn new() -> CMsgHorizontalScrollBarSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHorizontalScrollBarSize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgHorizontalScrollBarSize {
        CMsgHorizontalScrollBarSize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgHorizontalScrollBarSize| { &m.browser_handle },
                    |m: &mut CMsgHorizontalScrollBarSize| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgHorizontalScrollBarSize>(
                    "CMsgHorizontalScrollBarSize",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgHorizontalScrollBarSize {
        static mut instance: ::protobuf::lazy::Lazy<CMsgHorizontalScrollBarSize> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgHorizontalScrollBarSize,
        };
        unsafe {
            instance.get(CMsgHorizontalScrollBarSize::new)
        }
    }
}

impl ::protobuf::Clear for CMsgHorizontalScrollBarSize {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgHorizontalScrollBarSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHorizontalScrollBarSize {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgHorizontalScrollBarSizeResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    scroll_max: ::std::option::Option<u32>,
    scroll: ::std::option::Option<u32>,
    zoom: ::std::option::Option<f32>,
    visible: ::std::option::Option<bool>,
    page_size: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgHorizontalScrollBarSizeResponse {
    fn default() -> &'a CMsgHorizontalScrollBarSizeResponse {
        <CMsgHorizontalScrollBarSizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHorizontalScrollBarSizeResponse {
    pub fn new() -> CMsgHorizontalScrollBarSizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll_max = 6;


    pub fn get_scroll_max(&self) -> u32 {
        self.scroll_max.unwrap_or(0)
    }
    pub fn clear_scroll_max(&mut self) {
        self.scroll_max = ::std::option::Option::None;
    }

    pub fn has_scroll_max(&self) -> bool {
        self.scroll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_max(&mut self, v: u32) {
        self.scroll_max = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 7;


    pub fn get_scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }
    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    // optional float zoom = 8;


    pub fn get_zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }
    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    // optional bool visible = 9;


    pub fn get_visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }
    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    // optional uint32 page_size = 10;


    pub fn get_page_size(&self) -> u32 {
        self.page_size.unwrap_or(0)
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        self.page_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHorizontalScrollBarSizeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scroll_max = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scroll = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.zoom = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.visible = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scroll_max {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.zoom {
            my_size += 5;
        }
        if let Some(v) = self.visible {
            my_size += 2;
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgHorizontalScrollBarSizeResponse {
        CMsgHorizontalScrollBarSizeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgHorizontalScrollBarSizeResponse| { &m.browser_handle },
                    |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scroll_max",
                    |m: &CMsgHorizontalScrollBarSizeResponse| { &m.scroll_max },
                    |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.scroll_max },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scroll",
                    |m: &CMsgHorizontalScrollBarSizeResponse| { &m.scroll },
                    |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.scroll },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "zoom",
                    |m: &CMsgHorizontalScrollBarSizeResponse| { &m.zoom },
                    |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.zoom },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "visible",
                    |m: &CMsgHorizontalScrollBarSizeResponse| { &m.visible },
                    |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.visible },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "page_size",
                    |m: &CMsgHorizontalScrollBarSizeResponse| { &m.page_size },
                    |m: &mut CMsgHorizontalScrollBarSizeResponse| { &mut m.page_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgHorizontalScrollBarSizeResponse>(
                    "CMsgHorizontalScrollBarSizeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgHorizontalScrollBarSizeResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgHorizontalScrollBarSizeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgHorizontalScrollBarSizeResponse,
        };
        unsafe {
            instance.get(CMsgHorizontalScrollBarSizeResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgHorizontalScrollBarSizeResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll_max = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgHorizontalScrollBarSizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHorizontalScrollBarSizeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgVerticalScrollBarSize {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgVerticalScrollBarSize {
    fn default() -> &'a CMsgVerticalScrollBarSize {
        <CMsgVerticalScrollBarSize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVerticalScrollBarSize {
    pub fn new() -> CMsgVerticalScrollBarSize {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgVerticalScrollBarSize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgVerticalScrollBarSize {
        CMsgVerticalScrollBarSize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgVerticalScrollBarSize| { &m.browser_handle },
                    |m: &mut CMsgVerticalScrollBarSize| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgVerticalScrollBarSize>(
                    "CMsgVerticalScrollBarSize",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgVerticalScrollBarSize {
        static mut instance: ::protobuf::lazy::Lazy<CMsgVerticalScrollBarSize> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgVerticalScrollBarSize,
        };
        unsafe {
            instance.get(CMsgVerticalScrollBarSize::new)
        }
    }
}

impl ::protobuf::Clear for CMsgVerticalScrollBarSize {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgVerticalScrollBarSize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVerticalScrollBarSize {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgVerticalScrollBarSizeResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    scroll_max: ::std::option::Option<u32>,
    scroll: ::std::option::Option<u32>,
    zoom: ::std::option::Option<f32>,
    visible: ::std::option::Option<bool>,
    page_size: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgVerticalScrollBarSizeResponse {
    fn default() -> &'a CMsgVerticalScrollBarSizeResponse {
        <CMsgVerticalScrollBarSizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVerticalScrollBarSizeResponse {
    pub fn new() -> CMsgVerticalScrollBarSizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll_max = 6;


    pub fn get_scroll_max(&self) -> u32 {
        self.scroll_max.unwrap_or(0)
    }
    pub fn clear_scroll_max(&mut self) {
        self.scroll_max = ::std::option::Option::None;
    }

    pub fn has_scroll_max(&self) -> bool {
        self.scroll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll_max(&mut self, v: u32) {
        self.scroll_max = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 7;


    pub fn get_scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }
    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }

    // optional float zoom = 8;


    pub fn get_zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }
    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    // optional bool visible = 9;


    pub fn get_visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }
    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    // optional uint32 page_size = 10;


    pub fn get_page_size(&self) -> u32 {
        self.page_size.unwrap_or(0)
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = ::std::option::Option::None;
    }

    pub fn has_page_size(&self) -> bool {
        self.page_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgVerticalScrollBarSizeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scroll_max = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scroll = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.zoom = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.visible = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scroll_max {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.zoom {
            my_size += 5;
        }
        if let Some(v) = self.visible {
            my_size += 2;
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgVerticalScrollBarSizeResponse {
        CMsgVerticalScrollBarSizeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgVerticalScrollBarSizeResponse| { &m.browser_handle },
                    |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scroll_max",
                    |m: &CMsgVerticalScrollBarSizeResponse| { &m.scroll_max },
                    |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.scroll_max },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scroll",
                    |m: &CMsgVerticalScrollBarSizeResponse| { &m.scroll },
                    |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.scroll },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "zoom",
                    |m: &CMsgVerticalScrollBarSizeResponse| { &m.zoom },
                    |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.zoom },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "visible",
                    |m: &CMsgVerticalScrollBarSizeResponse| { &m.visible },
                    |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.visible },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "page_size",
                    |m: &CMsgVerticalScrollBarSizeResponse| { &m.page_size },
                    |m: &mut CMsgVerticalScrollBarSizeResponse| { &mut m.page_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgVerticalScrollBarSizeResponse>(
                    "CMsgVerticalScrollBarSizeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgVerticalScrollBarSizeResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgVerticalScrollBarSizeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgVerticalScrollBarSizeResponse,
        };
        unsafe {
            instance.get(CMsgVerticalScrollBarSizeResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgVerticalScrollBarSizeResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll_max = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.page_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgVerticalScrollBarSizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVerticalScrollBarSizeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgFind {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    find: ::protobuf::SingularField<::std::string::String>,
    infind: ::std::option::Option<bool>,
    reverse: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFind {
    fn default() -> &'a CMsgFind {
        <CMsgFind as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFind {
    pub fn new() -> CMsgFind {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string find = 2;


    pub fn get_find(&self) -> &str {
        match self.find.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_find(&mut self) {
        self.find.clear();
    }

    pub fn has_find(&self) -> bool {
        self.find.is_some()
    }

    // Param is passed by value, moved
    pub fn set_find(&mut self, v: ::std::string::String) {
        self.find = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_find(&mut self) -> &mut ::std::string::String {
        if self.find.is_none() {
            self.find.set_default();
        }
        self.find.as_mut().unwrap()
    }

    // Take field
    pub fn take_find(&mut self) -> ::std::string::String {
        self.find.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool infind = 3;


    pub fn get_infind(&self) -> bool {
        self.infind.unwrap_or(false)
    }
    pub fn clear_infind(&mut self) {
        self.infind = ::std::option::Option::None;
    }

    pub fn has_infind(&self) -> bool {
        self.infind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infind(&mut self, v: bool) {
        self.infind = ::std::option::Option::Some(v);
    }

    // optional bool reverse = 4;


    pub fn get_reverse(&self) -> bool {
        self.reverse.unwrap_or(false)
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = ::std::option::Option::None;
    }

    pub fn has_reverse(&self) -> bool {
        self.reverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.find)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.infind = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.find.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.infind {
            my_size += 2;
        }
        if let Some(v) = self.reverse {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.find.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.infind {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFind {
        CMsgFind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgFind| { &m.browser_handle },
                    |m: &mut CMsgFind| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "find",
                    |m: &CMsgFind| { &m.find },
                    |m: &mut CMsgFind| { &mut m.find },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "infind",
                    |m: &CMsgFind| { &m.infind },
                    |m: &mut CMsgFind| { &mut m.infind },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reverse",
                    |m: &CMsgFind| { &m.reverse },
                    |m: &mut CMsgFind| { &mut m.reverse },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgFind>(
                    "CMsgFind",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgFind {
        static mut instance: ::protobuf::lazy::Lazy<CMsgFind> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgFind,
        };
        unsafe {
            instance.get(CMsgFind::new)
        }
    }
}

impl ::protobuf::Clear for CMsgFind {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.find.clear();
        self.infind = ::std::option::Option::None;
        self.reverse = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFind {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgStopFind {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgStopFind {
    fn default() -> &'a CMsgStopFind {
        <CMsgStopFind as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStopFind {
    pub fn new() -> CMsgStopFind {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStopFind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgStopFind {
        CMsgStopFind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgStopFind| { &m.browser_handle },
                    |m: &mut CMsgStopFind| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgStopFind>(
                    "CMsgStopFind",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgStopFind {
        static mut instance: ::protobuf::lazy::Lazy<CMsgStopFind> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgStopFind,
        };
        unsafe {
            instance.get(CMsgStopFind::new)
        }
    }
}

impl ::protobuf::Clear for CMsgStopFind {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgStopFind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStopFind {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetHorizontalScroll {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    scroll: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetHorizontalScroll {
    fn default() -> &'a CMsgSetHorizontalScroll {
        <CMsgSetHorizontalScroll as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetHorizontalScroll {
    pub fn new() -> CMsgSetHorizontalScroll {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 2;


    pub fn get_scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }
    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetHorizontalScroll {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scroll = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetHorizontalScroll {
        CMsgSetHorizontalScroll::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetHorizontalScroll| { &m.browser_handle },
                    |m: &mut CMsgSetHorizontalScroll| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scroll",
                    |m: &CMsgSetHorizontalScroll| { &m.scroll },
                    |m: &mut CMsgSetHorizontalScroll| { &mut m.scroll },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetHorizontalScroll>(
                    "CMsgSetHorizontalScroll",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetHorizontalScroll {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetHorizontalScroll> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetHorizontalScroll,
        };
        unsafe {
            instance.get(CMsgSetHorizontalScroll::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetHorizontalScroll {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetHorizontalScroll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetHorizontalScroll {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetVerticalScroll {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    scroll: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetVerticalScroll {
    fn default() -> &'a CMsgSetVerticalScroll {
        <CMsgSetVerticalScroll as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetVerticalScroll {
    pub fn new() -> CMsgSetVerticalScroll {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scroll = 2;


    pub fn get_scroll(&self) -> u32 {
        self.scroll.unwrap_or(0)
    }
    pub fn clear_scroll(&mut self) {
        self.scroll = ::std::option::Option::None;
    }

    pub fn has_scroll(&self) -> bool {
        self.scroll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scroll(&mut self, v: u32) {
        self.scroll = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetVerticalScroll {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scroll = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scroll {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scroll {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetVerticalScroll {
        CMsgSetVerticalScroll::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetVerticalScroll| { &m.browser_handle },
                    |m: &mut CMsgSetVerticalScroll| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scroll",
                    |m: &CMsgSetVerticalScroll| { &m.scroll },
                    |m: &mut CMsgSetVerticalScroll| { &mut m.scroll },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetVerticalScroll>(
                    "CMsgSetVerticalScroll",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetVerticalScroll {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetVerticalScroll> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetVerticalScroll,
        };
        unsafe {
            instance.get(CMsgSetVerticalScroll::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetVerticalScroll {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scroll = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetVerticalScroll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetVerticalScroll {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetZoomLevel {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    zoom: ::std::option::Option<f64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetZoomLevel {
    fn default() -> &'a CMsgSetZoomLevel {
        <CMsgSetZoomLevel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetZoomLevel {
    pub fn new() -> CMsgSetZoomLevel {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional double zoom = 2;


    pub fn get_zoom(&self) -> f64 {
        self.zoom.unwrap_or(0.)
    }
    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f64) {
        self.zoom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetZoomLevel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.zoom = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.zoom {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetZoomLevel {
        CMsgSetZoomLevel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetZoomLevel| { &m.browser_handle },
                    |m: &mut CMsgSetZoomLevel| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "zoom",
                    |m: &CMsgSetZoomLevel| { &m.zoom },
                    |m: &mut CMsgSetZoomLevel| { &mut m.zoom },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetZoomLevel>(
                    "CMsgSetZoomLevel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetZoomLevel {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetZoomLevel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetZoomLevel,
        };
        unsafe {
            instance.get(CMsgSetZoomLevel::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetZoomLevel {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetZoomLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetZoomLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgViewSource {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgViewSource {
    fn default() -> &'a CMsgViewSource {
        <CMsgViewSource as ::protobuf::Message>::default_instance()
    }
}

impl CMsgViewSource {
    pub fn new() -> CMsgViewSource {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgViewSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgViewSource {
        CMsgViewSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgViewSource| { &m.browser_handle },
                    |m: &mut CMsgViewSource| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgViewSource>(
                    "CMsgViewSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgViewSource {
        static mut instance: ::protobuf::lazy::Lazy<CMsgViewSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgViewSource,
        };
        unsafe {
            instance.get(CMsgViewSource::new)
        }
    }
}

impl ::protobuf::Clear for CMsgViewSource {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgViewSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgViewSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBrowserReady {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    vr_overlay_key: ::protobuf::SingularField<::std::string::String>,
    hwnd_browser: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBrowserReady {
    fn default() -> &'a CMsgBrowserReady {
        <CMsgBrowserReady as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBrowserReady {
    pub fn new() -> CMsgBrowserReady {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string vr_overlay_key = 2;


    pub fn get_vr_overlay_key(&self) -> &str {
        match self.vr_overlay_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_vr_overlay_key(&mut self) {
        self.vr_overlay_key.clear();
    }

    pub fn has_vr_overlay_key(&self) -> bool {
        self.vr_overlay_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_overlay_key(&mut self, v: ::std::string::String) {
        self.vr_overlay_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_overlay_key(&mut self) -> &mut ::std::string::String {
        if self.vr_overlay_key.is_none() {
            self.vr_overlay_key.set_default();
        }
        self.vr_overlay_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_overlay_key(&mut self) -> ::std::string::String {
        self.vr_overlay_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 hwnd_browser = 3;


    pub fn get_hwnd_browser(&self) -> u64 {
        self.hwnd_browser.unwrap_or(0)
    }
    pub fn clear_hwnd_browser(&mut self) {
        self.hwnd_browser = ::std::option::Option::None;
    }

    pub fn has_hwnd_browser(&self) -> bool {
        self.hwnd_browser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hwnd_browser(&mut self, v: u64) {
        self.hwnd_browser = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBrowserReady {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vr_overlay_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.hwnd_browser = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.vr_overlay_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.hwnd_browser {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.vr_overlay_key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.hwnd_browser {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBrowserReady {
        CMsgBrowserReady::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgBrowserReady| { &m.browser_handle },
                    |m: &mut CMsgBrowserReady| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vr_overlay_key",
                    |m: &CMsgBrowserReady| { &m.vr_overlay_key },
                    |m: &mut CMsgBrowserReady| { &mut m.vr_overlay_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "hwnd_browser",
                    |m: &CMsgBrowserReady| { &m.hwnd_browser },
                    |m: &mut CMsgBrowserReady| { &mut m.hwnd_browser },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBrowserReady>(
                    "CMsgBrowserReady",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBrowserReady {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBrowserReady> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBrowserReady,
        };
        unsafe {
            instance.get(CMsgBrowserReady::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBrowserReady {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.vr_overlay_key.clear();
        self.hwnd_browser = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBrowserReady {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBrowserReady {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgURLChanged {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    postData: ::protobuf::SingularField<::std::string::String>,
    bIsRedirect: ::std::option::Option<bool>,
    pagetitle: ::protobuf::SingularField<::std::string::String>,
    bNewNavigation: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgURLChanged {
    fn default() -> &'a CMsgURLChanged {
        <CMsgURLChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgURLChanged {
    pub fn new() -> CMsgURLChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postData = 3;


    pub fn get_postData(&self) -> &str {
        match self.postData.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_postData(&mut self) {
        self.postData.clear();
    }

    pub fn has_postData(&self) -> bool {
        self.postData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postData(&mut self, v: ::std::string::String) {
        self.postData = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postData(&mut self) -> &mut ::std::string::String {
        if self.postData.is_none() {
            self.postData.set_default();
        }
        self.postData.as_mut().unwrap()
    }

    // Take field
    pub fn take_postData(&mut self) -> ::std::string::String {
        self.postData.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bIsRedirect = 4;


    pub fn get_bIsRedirect(&self) -> bool {
        self.bIsRedirect.unwrap_or(false)
    }
    pub fn clear_bIsRedirect(&mut self) {
        self.bIsRedirect = ::std::option::Option::None;
    }

    pub fn has_bIsRedirect(&self) -> bool {
        self.bIsRedirect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsRedirect(&mut self, v: bool) {
        self.bIsRedirect = ::std::option::Option::Some(v);
    }

    // optional string pagetitle = 5;


    pub fn get_pagetitle(&self) -> &str {
        match self.pagetitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pagetitle(&mut self) {
        self.pagetitle.clear();
    }

    pub fn has_pagetitle(&self) -> bool {
        self.pagetitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagetitle(&mut self, v: ::std::string::String) {
        self.pagetitle = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagetitle(&mut self) -> &mut ::std::string::String {
        if self.pagetitle.is_none() {
            self.pagetitle.set_default();
        }
        self.pagetitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagetitle(&mut self) -> ::std::string::String {
        self.pagetitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bNewNavigation = 6;


    pub fn get_bNewNavigation(&self) -> bool {
        self.bNewNavigation.unwrap_or(false)
    }
    pub fn clear_bNewNavigation(&mut self) {
        self.bNewNavigation = ::std::option::Option::None;
    }

    pub fn has_bNewNavigation(&self) -> bool {
        self.bNewNavigation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bNewNavigation(&mut self, v: bool) {
        self.bNewNavigation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgURLChanged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postData)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bIsRedirect = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pagetitle)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bNewNavigation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.postData.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.bIsRedirect {
            my_size += 2;
        }
        if let Some(ref v) = self.pagetitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bNewNavigation {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.postData.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.bIsRedirect {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.pagetitle.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.bNewNavigation {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgURLChanged {
        CMsgURLChanged::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgURLChanged| { &m.browser_handle },
                    |m: &mut CMsgURLChanged| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgURLChanged| { &m.url },
                    |m: &mut CMsgURLChanged| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "postData",
                    |m: &CMsgURLChanged| { &m.postData },
                    |m: &mut CMsgURLChanged| { &mut m.postData },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bIsRedirect",
                    |m: &CMsgURLChanged| { &m.bIsRedirect },
                    |m: &mut CMsgURLChanged| { &mut m.bIsRedirect },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pagetitle",
                    |m: &CMsgURLChanged| { &m.pagetitle },
                    |m: &mut CMsgURLChanged| { &mut m.pagetitle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bNewNavigation",
                    |m: &CMsgURLChanged| { &m.bNewNavigation },
                    |m: &mut CMsgURLChanged| { &mut m.bNewNavigation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgURLChanged>(
                    "CMsgURLChanged",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgURLChanged {
        static mut instance: ::protobuf::lazy::Lazy<CMsgURLChanged> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgURLChanged,
        };
        unsafe {
            instance.get(CMsgURLChanged::new)
        }
    }
}

impl ::protobuf::Clear for CMsgURLChanged {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.postData.clear();
        self.bIsRedirect = ::std::option::Option::None;
        self.pagetitle.clear();
        self.bNewNavigation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgURLChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgURLChanged {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CHTMLHeader {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CHTMLHeader {
    fn default() -> &'a CHTMLHeader {
        <CHTMLHeader as ::protobuf::Message>::default_instance()
    }
}

impl CHTMLHeader {
    pub fn new() -> CHTMLHeader {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CHTMLHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CHTMLHeader {
        CHTMLHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &CHTMLHeader| { &m.key },
                    |m: &mut CHTMLHeader| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &CHTMLHeader| { &m.value },
                    |m: &mut CHTMLHeader| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CHTMLHeader>(
                    "CHTMLHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CHTMLHeader {
        static mut instance: ::protobuf::lazy::Lazy<CHTMLHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CHTMLHeader,
        };
        unsafe {
            instance.get(CHTMLHeader::new)
        }
    }
}

impl ::protobuf::Clear for CHTMLHeader {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CHTMLHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CHTMLHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CHTMLPageSecurityInfo {
    // message fields
    bIsSecure: ::std::option::Option<bool>,
    bHasCertError: ::std::option::Option<bool>,
    issuerName: ::protobuf::SingularField<::std::string::String>,
    certName: ::protobuf::SingularField<::std::string::String>,
    certExpiry: ::std::option::Option<i32>,
    nCertBits: ::std::option::Option<i32>,
    bIsEVCert: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CHTMLPageSecurityInfo {
    fn default() -> &'a CHTMLPageSecurityInfo {
        <CHTMLPageSecurityInfo as ::protobuf::Message>::default_instance()
    }
}

impl CHTMLPageSecurityInfo {
    pub fn new() -> CHTMLPageSecurityInfo {
        ::std::default::Default::default()
    }

    // optional bool bIsSecure = 1;


    pub fn get_bIsSecure(&self) -> bool {
        self.bIsSecure.unwrap_or(false)
    }
    pub fn clear_bIsSecure(&mut self) {
        self.bIsSecure = ::std::option::Option::None;
    }

    pub fn has_bIsSecure(&self) -> bool {
        self.bIsSecure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsSecure(&mut self, v: bool) {
        self.bIsSecure = ::std::option::Option::Some(v);
    }

    // optional bool bHasCertError = 2;


    pub fn get_bHasCertError(&self) -> bool {
        self.bHasCertError.unwrap_or(false)
    }
    pub fn clear_bHasCertError(&mut self) {
        self.bHasCertError = ::std::option::Option::None;
    }

    pub fn has_bHasCertError(&self) -> bool {
        self.bHasCertError.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bHasCertError(&mut self, v: bool) {
        self.bHasCertError = ::std::option::Option::Some(v);
    }

    // optional string issuerName = 3;


    pub fn get_issuerName(&self) -> &str {
        match self.issuerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_issuerName(&mut self) {
        self.issuerName.clear();
    }

    pub fn has_issuerName(&self) -> bool {
        self.issuerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuerName(&mut self, v: ::std::string::String) {
        self.issuerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuerName(&mut self) -> &mut ::std::string::String {
        if self.issuerName.is_none() {
            self.issuerName.set_default();
        }
        self.issuerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_issuerName(&mut self) -> ::std::string::String {
        self.issuerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string certName = 4;


    pub fn get_certName(&self) -> &str {
        match self.certName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_certName(&mut self) {
        self.certName.clear();
    }

    pub fn has_certName(&self) -> bool {
        self.certName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certName(&mut self, v: ::std::string::String) {
        self.certName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certName(&mut self) -> &mut ::std::string::String {
        if self.certName.is_none() {
            self.certName.set_default();
        }
        self.certName.as_mut().unwrap()
    }

    // Take field
    pub fn take_certName(&mut self) -> ::std::string::String {
        self.certName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 certExpiry = 5;


    pub fn get_certExpiry(&self) -> i32 {
        self.certExpiry.unwrap_or(0i32)
    }
    pub fn clear_certExpiry(&mut self) {
        self.certExpiry = ::std::option::Option::None;
    }

    pub fn has_certExpiry(&self) -> bool {
        self.certExpiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certExpiry(&mut self, v: i32) {
        self.certExpiry = ::std::option::Option::Some(v);
    }

    // optional int32 nCertBits = 6;


    pub fn get_nCertBits(&self) -> i32 {
        self.nCertBits.unwrap_or(0i32)
    }
    pub fn clear_nCertBits(&mut self) {
        self.nCertBits = ::std::option::Option::None;
    }

    pub fn has_nCertBits(&self) -> bool {
        self.nCertBits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nCertBits(&mut self, v: i32) {
        self.nCertBits = ::std::option::Option::Some(v);
    }

    // optional bool bIsEVCert = 7;


    pub fn get_bIsEVCert(&self) -> bool {
        self.bIsEVCert.unwrap_or(false)
    }
    pub fn clear_bIsEVCert(&mut self) {
        self.bIsEVCert = ::std::option::Option::None;
    }

    pub fn has_bIsEVCert(&self) -> bool {
        self.bIsEVCert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsEVCert(&mut self, v: bool) {
        self.bIsEVCert = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CHTMLPageSecurityInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bIsSecure = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bHasCertError = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.issuerName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.certName)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.certExpiry = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nCertBits = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bIsEVCert = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bIsSecure {
            my_size += 2;
        }
        if let Some(v) = self.bHasCertError {
            my_size += 2;
        }
        if let Some(ref v) = self.issuerName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.certName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.certExpiry {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nCertBits {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bIsEVCert {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bIsSecure {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bHasCertError {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.issuerName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.certName.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.certExpiry {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.nCertBits {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.bIsEVCert {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CHTMLPageSecurityInfo {
        CHTMLPageSecurityInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bIsSecure",
                    |m: &CHTMLPageSecurityInfo| { &m.bIsSecure },
                    |m: &mut CHTMLPageSecurityInfo| { &mut m.bIsSecure },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bHasCertError",
                    |m: &CHTMLPageSecurityInfo| { &m.bHasCertError },
                    |m: &mut CHTMLPageSecurityInfo| { &mut m.bHasCertError },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "issuerName",
                    |m: &CHTMLPageSecurityInfo| { &m.issuerName },
                    |m: &mut CHTMLPageSecurityInfo| { &mut m.issuerName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "certName",
                    |m: &CHTMLPageSecurityInfo| { &m.certName },
                    |m: &mut CHTMLPageSecurityInfo| { &mut m.certName },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "certExpiry",
                    |m: &CHTMLPageSecurityInfo| { &m.certExpiry },
                    |m: &mut CHTMLPageSecurityInfo| { &mut m.certExpiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "nCertBits",
                    |m: &CHTMLPageSecurityInfo| { &m.nCertBits },
                    |m: &mut CHTMLPageSecurityInfo| { &mut m.nCertBits },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bIsEVCert",
                    |m: &CHTMLPageSecurityInfo| { &m.bIsEVCert },
                    |m: &mut CHTMLPageSecurityInfo| { &mut m.bIsEVCert },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CHTMLPageSecurityInfo>(
                    "CHTMLPageSecurityInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CHTMLPageSecurityInfo {
        static mut instance: ::protobuf::lazy::Lazy<CHTMLPageSecurityInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CHTMLPageSecurityInfo,
        };
        unsafe {
            instance.get(CHTMLPageSecurityInfo::new)
        }
    }
}

impl ::protobuf::Clear for CHTMLPageSecurityInfo {
    fn clear(&mut self) {
        self.bIsSecure = ::std::option::Option::None;
        self.bHasCertError = ::std::option::Option::None;
        self.issuerName.clear();
        self.certName.clear();
        self.certExpiry = ::std::option::Option::None;
        self.nCertBits = ::std::option::Option::None;
        self.bIsEVCert = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CHTMLPageSecurityInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CHTMLPageSecurityInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgFinishedRequest {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    pageTitle: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFinishedRequest {
    fn default() -> &'a CMsgFinishedRequest {
        <CMsgFinishedRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFinishedRequest {
    pub fn new() -> CMsgFinishedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pageTitle = 3;


    pub fn get_pageTitle(&self) -> &str {
        match self.pageTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pageTitle(&mut self) {
        self.pageTitle.clear();
    }

    pub fn has_pageTitle(&self) -> bool {
        self.pageTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageTitle(&mut self, v: ::std::string::String) {
        self.pageTitle = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pageTitle(&mut self) -> &mut ::std::string::String {
        if self.pageTitle.is_none() {
            self.pageTitle.set_default();
        }
        self.pageTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pageTitle(&mut self) -> ::std::string::String {
        self.pageTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgFinishedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pageTitle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.pageTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.pageTitle.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFinishedRequest {
        CMsgFinishedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgFinishedRequest| { &m.browser_handle },
                    |m: &mut CMsgFinishedRequest| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgFinishedRequest| { &m.url },
                    |m: &mut CMsgFinishedRequest| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pageTitle",
                    |m: &CMsgFinishedRequest| { &m.pageTitle },
                    |m: &mut CMsgFinishedRequest| { &mut m.pageTitle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgFinishedRequest>(
                    "CMsgFinishedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgFinishedRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgFinishedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgFinishedRequest,
        };
        unsafe {
            instance.get(CMsgFinishedRequest::new)
        }
    }
}

impl ::protobuf::Clear for CMsgFinishedRequest {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.pageTitle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFinishedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFinishedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgLoadedRequest {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    pageTitle: ::protobuf::SingularField<::std::string::String>,
    headers: ::protobuf::RepeatedField<CHTMLHeader>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLoadedRequest {
    fn default() -> &'a CMsgLoadedRequest {
        <CMsgLoadedRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLoadedRequest {
    pub fn new() -> CMsgLoadedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pageTitle = 3;


    pub fn get_pageTitle(&self) -> &str {
        match self.pageTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pageTitle(&mut self) {
        self.pageTitle.clear();
    }

    pub fn has_pageTitle(&self) -> bool {
        self.pageTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageTitle(&mut self, v: ::std::string::String) {
        self.pageTitle = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pageTitle(&mut self) -> &mut ::std::string::String {
        if self.pageTitle.is_none() {
            self.pageTitle.set_default();
        }
        self.pageTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_pageTitle(&mut self) -> ::std::string::String {
        self.pageTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CHTMLHeader headers = 5;


    pub fn get_headers(&self) -> &[CHTMLHeader] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<CHTMLHeader>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<CHTMLHeader> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<CHTMLHeader> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgLoadedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pageTitle)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.pageTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.pageTitle.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.headers {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLoadedRequest {
        CMsgLoadedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgLoadedRequest| { &m.browser_handle },
                    |m: &mut CMsgLoadedRequest| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgLoadedRequest| { &m.url },
                    |m: &mut CMsgLoadedRequest| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pageTitle",
                    |m: &CMsgLoadedRequest| { &m.pageTitle },
                    |m: &mut CMsgLoadedRequest| { &mut m.pageTitle },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CHTMLHeader>>(
                    "headers",
                    |m: &CMsgLoadedRequest| { &m.headers },
                    |m: &mut CMsgLoadedRequest| { &mut m.headers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLoadedRequest>(
                    "CMsgLoadedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgLoadedRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLoadedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLoadedRequest,
        };
        unsafe {
            instance.get(CMsgLoadedRequest::new)
        }
    }
}

impl ::protobuf::Clear for CMsgLoadedRequest {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.pageTitle.clear();
        self.headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLoadedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLoadedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgPageSecurity {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    security_info: ::protobuf::SingularPtrField<CHTMLPageSecurityInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPageSecurity {
    fn default() -> &'a CMsgPageSecurity {
        <CMsgPageSecurity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPageSecurity {
    pub fn new() -> CMsgPageSecurity {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CHTMLPageSecurityInfo security_info = 3;


    pub fn get_security_info(&self) -> &CHTMLPageSecurityInfo {
        self.security_info.as_ref().unwrap_or_else(|| CHTMLPageSecurityInfo::default_instance())
    }
    pub fn clear_security_info(&mut self) {
        self.security_info.clear();
    }

    pub fn has_security_info(&self) -> bool {
        self.security_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_security_info(&mut self, v: CHTMLPageSecurityInfo) {
        self.security_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_info(&mut self) -> &mut CHTMLPageSecurityInfo {
        if self.security_info.is_none() {
            self.security_info.set_default();
        }
        self.security_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_security_info(&mut self) -> CHTMLPageSecurityInfo {
        self.security_info.take().unwrap_or_else(|| CHTMLPageSecurityInfo::new())
    }
}

impl ::protobuf::Message for CMsgPageSecurity {
    fn is_initialized(&self) -> bool {
        for v in &self.security_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.security_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.security_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.security_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPageSecurity {
        CMsgPageSecurity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgPageSecurity| { &m.browser_handle },
                    |m: &mut CMsgPageSecurity| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgPageSecurity| { &m.url },
                    |m: &mut CMsgPageSecurity| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CHTMLPageSecurityInfo>>(
                    "security_info",
                    |m: &CMsgPageSecurity| { &m.security_info },
                    |m: &mut CMsgPageSecurity| { &mut m.security_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPageSecurity>(
                    "CMsgPageSecurity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgPageSecurity {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPageSecurity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPageSecurity,
        };
        unsafe {
            instance.get(CMsgPageSecurity::new)
        }
    }
}

impl ::protobuf::Clear for CMsgPageSecurity {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.security_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPageSecurity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPageSecurity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgStartRequest {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    target: ::protobuf::SingularField<::std::string::String>,
    postData: ::protobuf::SingularField<::std::string::String>,
    bIsRedirect: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgStartRequest {
    fn default() -> &'a CMsgStartRequest {
        <CMsgStartRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartRequest {
    pub fn new() -> CMsgStartRequest {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string target = 3;


    pub fn get_target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postData = 4;


    pub fn get_postData(&self) -> &str {
        match self.postData.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_postData(&mut self) {
        self.postData.clear();
    }

    pub fn has_postData(&self) -> bool {
        self.postData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postData(&mut self, v: ::std::string::String) {
        self.postData = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postData(&mut self) -> &mut ::std::string::String {
        if self.postData.is_none() {
            self.postData.set_default();
        }
        self.postData.as_mut().unwrap()
    }

    // Take field
    pub fn take_postData(&mut self) -> ::std::string::String {
        self.postData.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bIsRedirect = 5;


    pub fn get_bIsRedirect(&self) -> bool {
        self.bIsRedirect.unwrap_or(false)
    }
    pub fn clear_bIsRedirect(&mut self) {
        self.bIsRedirect = ::std::option::Option::None;
    }

    pub fn has_bIsRedirect(&self) -> bool {
        self.bIsRedirect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bIsRedirect(&mut self, v: bool) {
        self.bIsRedirect = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStartRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.target)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postData)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bIsRedirect = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.postData.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.bIsRedirect {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.postData.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.bIsRedirect {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgStartRequest {
        CMsgStartRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgStartRequest| { &m.browser_handle },
                    |m: &mut CMsgStartRequest| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgStartRequest| { &m.url },
                    |m: &mut CMsgStartRequest| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "target",
                    |m: &CMsgStartRequest| { &m.target },
                    |m: &mut CMsgStartRequest| { &mut m.target },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "postData",
                    |m: &CMsgStartRequest| { &m.postData },
                    |m: &mut CMsgStartRequest| { &mut m.postData },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bIsRedirect",
                    |m: &CMsgStartRequest| { &m.bIsRedirect },
                    |m: &mut CMsgStartRequest| { &mut m.bIsRedirect },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgStartRequest>(
                    "CMsgStartRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgStartRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgStartRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgStartRequest,
        };
        unsafe {
            instance.get(CMsgStartRequest::new)
        }
    }
}

impl ::protobuf::Clear for CMsgStartRequest {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.target.clear();
        self.postData.clear();
        self.bIsRedirect = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgStartRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStartRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgStartRequestResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    bAllow: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgStartRequestResponse {
    fn default() -> &'a CMsgStartRequestResponse {
        <CMsgStartRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartRequestResponse {
    pub fn new() -> CMsgStartRequestResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bAllow = 2;


    pub fn get_bAllow(&self) -> bool {
        self.bAllow.unwrap_or(false)
    }
    pub fn clear_bAllow(&mut self) {
        self.bAllow = ::std::option::Option::None;
    }

    pub fn has_bAllow(&self) -> bool {
        self.bAllow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bAllow(&mut self, v: bool) {
        self.bAllow = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStartRequestResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bAllow = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bAllow {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bAllow {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgStartRequestResponse {
        CMsgStartRequestResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgStartRequestResponse| { &m.browser_handle },
                    |m: &mut CMsgStartRequestResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bAllow",
                    |m: &CMsgStartRequestResponse| { &m.bAllow },
                    |m: &mut CMsgStartRequestResponse| { &mut m.bAllow },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgStartRequestResponse>(
                    "CMsgStartRequestResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgStartRequestResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgStartRequestResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgStartRequestResponse,
        };
        unsafe {
            instance.get(CMsgStartRequestResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgStartRequestResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bAllow = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgStartRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStartRequestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgShowPopup {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgShowPopup {
    fn default() -> &'a CMsgShowPopup {
        <CMsgShowPopup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowPopup {
    pub fn new() -> CMsgShowPopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgShowPopup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgShowPopup {
        CMsgShowPopup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgShowPopup| { &m.browser_handle },
                    |m: &mut CMsgShowPopup| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgShowPopup>(
                    "CMsgShowPopup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgShowPopup {
        static mut instance: ::protobuf::lazy::Lazy<CMsgShowPopup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgShowPopup,
        };
        unsafe {
            instance.get(CMsgShowPopup::new)
        }
    }
}

impl ::protobuf::Clear for CMsgShowPopup {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgShowPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgShowPopup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgHidePopup {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgHidePopup {
    fn default() -> &'a CMsgHidePopup {
        <CMsgHidePopup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHidePopup {
    pub fn new() -> CMsgHidePopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHidePopup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgHidePopup {
        CMsgHidePopup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgHidePopup| { &m.browser_handle },
                    |m: &mut CMsgHidePopup| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgHidePopup>(
                    "CMsgHidePopup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgHidePopup {
        static mut instance: ::protobuf::lazy::Lazy<CMsgHidePopup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgHidePopup,
        };
        unsafe {
            instance.get(CMsgHidePopup::new)
        }
    }
}

impl ::protobuf::Clear for CMsgHidePopup {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgHidePopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHidePopup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSizePopup {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    wide: ::std::option::Option<u32>,
    tall: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSizePopup {
    fn default() -> &'a CMsgSizePopup {
        <CMsgSizePopup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSizePopup {
    pub fn new() -> CMsgSizePopup {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;


    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;


    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 4;


    pub fn get_wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }
    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 5;


    pub fn get_tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }
    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSizePopup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wide = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tall = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSizePopup {
        CMsgSizePopup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSizePopup| { &m.browser_handle },
                    |m: &mut CMsgSizePopup| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    |m: &CMsgSizePopup| { &m.x },
                    |m: &mut CMsgSizePopup| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    |m: &CMsgSizePopup| { &m.y },
                    |m: &mut CMsgSizePopup| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wide",
                    |m: &CMsgSizePopup| { &m.wide },
                    |m: &mut CMsgSizePopup| { &mut m.wide },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tall",
                    |m: &CMsgSizePopup| { &m.tall },
                    |m: &mut CMsgSizePopup| { &mut m.tall },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSizePopup>(
                    "CMsgSizePopup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSizePopup {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSizePopup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSizePopup,
        };
        unsafe {
            instance.get(CMsgSizePopup::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSizePopup {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSizePopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSizePopup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgOpenNewTab {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    bForeground: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgOpenNewTab {
    fn default() -> &'a CMsgOpenNewTab {
        <CMsgOpenNewTab as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpenNewTab {
    pub fn new() -> CMsgOpenNewTab {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bForeground = 3;


    pub fn get_bForeground(&self) -> bool {
        self.bForeground.unwrap_or(false)
    }
    pub fn clear_bForeground(&mut self) {
        self.bForeground = ::std::option::Option::None;
    }

    pub fn has_bForeground(&self) -> bool {
        self.bForeground.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bForeground(&mut self, v: bool) {
        self.bForeground = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgOpenNewTab {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bForeground = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.bForeground {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.bForeground {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgOpenNewTab {
        CMsgOpenNewTab::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgOpenNewTab| { &m.browser_handle },
                    |m: &mut CMsgOpenNewTab| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgOpenNewTab| { &m.url },
                    |m: &mut CMsgOpenNewTab| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bForeground",
                    |m: &CMsgOpenNewTab| { &m.bForeground },
                    |m: &mut CMsgOpenNewTab| { &mut m.bForeground },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgOpenNewTab>(
                    "CMsgOpenNewTab",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgOpenNewTab {
        static mut instance: ::protobuf::lazy::Lazy<CMsgOpenNewTab> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgOpenNewTab,
        };
        unsafe {
            instance.get(CMsgOpenNewTab::new)
        }
    }
}

impl ::protobuf::Clear for CMsgOpenNewTab {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.bForeground = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgOpenNewTab {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgOpenNewTab {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgPopupHTMLWindow {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    wide: ::std::option::Option<u32>,
    tall: ::std::option::Option<u32>,
    popup_index: ::std::option::Option<u32>,
    trusted_creator: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPopupHTMLWindow {
    fn default() -> &'a CMsgPopupHTMLWindow {
        <CMsgPopupHTMLWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopupHTMLWindow {
    pub fn new() -> CMsgPopupHTMLWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 x = 3;


    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(-2147483648i32)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 4;


    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(-2147483648i32)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 5;


    pub fn get_wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }
    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 6;


    pub fn get_tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }
    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint32 popup_index = 7;


    pub fn get_popup_index(&self) -> u32 {
        self.popup_index.unwrap_or(0)
    }
    pub fn clear_popup_index(&mut self) {
        self.popup_index = ::std::option::Option::None;
    }

    pub fn has_popup_index(&self) -> bool {
        self.popup_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popup_index(&mut self, v: u32) {
        self.popup_index = ::std::option::Option::Some(v);
    }

    // optional bool trusted_creator = 8;


    pub fn get_trusted_creator(&self) -> bool {
        self.trusted_creator.unwrap_or(false)
    }
    pub fn clear_trusted_creator(&mut self) {
        self.trusted_creator = ::std::option::Option::None;
    }

    pub fn has_trusted_creator(&self) -> bool {
        self.trusted_creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted_creator(&mut self, v: bool) {
        self.trusted_creator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPopupHTMLWindow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wide = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tall = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.popup_index = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trusted_creator = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.popup_index {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trusted_creator {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.popup_index {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.trusted_creator {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPopupHTMLWindow {
        CMsgPopupHTMLWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgPopupHTMLWindow| { &m.browser_handle },
                    |m: &mut CMsgPopupHTMLWindow| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgPopupHTMLWindow| { &m.url },
                    |m: &mut CMsgPopupHTMLWindow| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    |m: &CMsgPopupHTMLWindow| { &m.x },
                    |m: &mut CMsgPopupHTMLWindow| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    |m: &CMsgPopupHTMLWindow| { &m.y },
                    |m: &mut CMsgPopupHTMLWindow| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wide",
                    |m: &CMsgPopupHTMLWindow| { &m.wide },
                    |m: &mut CMsgPopupHTMLWindow| { &mut m.wide },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tall",
                    |m: &CMsgPopupHTMLWindow| { &m.tall },
                    |m: &mut CMsgPopupHTMLWindow| { &mut m.tall },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "popup_index",
                    |m: &CMsgPopupHTMLWindow| { &m.popup_index },
                    |m: &mut CMsgPopupHTMLWindow| { &mut m.popup_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "trusted_creator",
                    |m: &CMsgPopupHTMLWindow| { &m.trusted_creator },
                    |m: &mut CMsgPopupHTMLWindow| { &mut m.trusted_creator },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPopupHTMLWindow>(
                    "CMsgPopupHTMLWindow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgPopupHTMLWindow {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPopupHTMLWindow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPopupHTMLWindow,
        };
        unsafe {
            instance.get(CMsgPopupHTMLWindow::new)
        }
    }
}

impl ::protobuf::Clear for CMsgPopupHTMLWindow {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.popup_index = ::std::option::Option::None;
        self.trusted_creator = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPopupHTMLWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPopupHTMLWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgPopupHTMLWindowResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    bAllow: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPopupHTMLWindowResponse {
    fn default() -> &'a CMsgPopupHTMLWindowResponse {
        <CMsgPopupHTMLWindowResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPopupHTMLWindowResponse {
    pub fn new() -> CMsgPopupHTMLWindowResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bAllow = 2;


    pub fn get_bAllow(&self) -> bool {
        self.bAllow.unwrap_or(false)
    }
    pub fn clear_bAllow(&mut self) {
        self.bAllow = ::std::option::Option::None;
    }

    pub fn has_bAllow(&self) -> bool {
        self.bAllow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bAllow(&mut self, v: bool) {
        self.bAllow = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPopupHTMLWindowResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bAllow = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bAllow {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bAllow {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPopupHTMLWindowResponse {
        CMsgPopupHTMLWindowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgPopupHTMLWindowResponse| { &m.browser_handle },
                    |m: &mut CMsgPopupHTMLWindowResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bAllow",
                    |m: &CMsgPopupHTMLWindowResponse| { &m.bAllow },
                    |m: &mut CMsgPopupHTMLWindowResponse| { &mut m.bAllow },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPopupHTMLWindowResponse>(
                    "CMsgPopupHTMLWindowResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgPopupHTMLWindowResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPopupHTMLWindowResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPopupHTMLWindowResponse,
        };
        unsafe {
            instance.get(CMsgPopupHTMLWindowResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgPopupHTMLWindowResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bAllow = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPopupHTMLWindowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPopupHTMLWindowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetHTMLTitle {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    title: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetHTMLTitle {
    fn default() -> &'a CMsgSetHTMLTitle {
        <CMsgSetHTMLTitle as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetHTMLTitle {
    pub fn new() -> CMsgSetHTMLTitle {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSetHTMLTitle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetHTMLTitle {
        CMsgSetHTMLTitle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetHTMLTitle| { &m.browser_handle },
                    |m: &mut CMsgSetHTMLTitle| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &CMsgSetHTMLTitle| { &m.title },
                    |m: &mut CMsgSetHTMLTitle| { &mut m.title },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetHTMLTitle>(
                    "CMsgSetHTMLTitle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetHTMLTitle {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetHTMLTitle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetHTMLTitle,
        };
        unsafe {
            instance.get(CMsgSetHTMLTitle::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetHTMLTitle {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.title.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetHTMLTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetHTMLTitle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgLoadingResource {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLoadingResource {
    fn default() -> &'a CMsgLoadingResource {
        <CMsgLoadingResource as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLoadingResource {
    pub fn new() -> CMsgLoadingResource {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgLoadingResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLoadingResource {
        CMsgLoadingResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgLoadingResource| { &m.browser_handle },
                    |m: &mut CMsgLoadingResource| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgLoadingResource| { &m.url },
                    |m: &mut CMsgLoadingResource| { &mut m.url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLoadingResource>(
                    "CMsgLoadingResource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgLoadingResource {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLoadingResource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLoadingResource,
        };
        unsafe {
            instance.get(CMsgLoadingResource::new)
        }
    }
}

impl ::protobuf::Clear for CMsgLoadingResource {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLoadingResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLoadingResource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgStatusText {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgStatusText {
    fn default() -> &'a CMsgStatusText {
        <CMsgStatusText as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStatusText {
    pub fn new() -> CMsgStatusText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgStatusText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgStatusText {
        CMsgStatusText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgStatusText| { &m.browser_handle },
                    |m: &mut CMsgStatusText| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CMsgStatusText| { &m.text },
                    |m: &mut CMsgStatusText| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgStatusText>(
                    "CMsgStatusText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgStatusText {
        static mut instance: ::protobuf::lazy::Lazy<CMsgStatusText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgStatusText,
        };
        unsafe {
            instance.get(CMsgStatusText::new)
        }
    }
}

impl ::protobuf::Clear for CMsgStatusText {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgStatusText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStatusText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetCursor {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    cursor: ::std::option::Option<u32>,
    custom_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    wide: ::std::option::Option<u32>,
    tall: ::std::option::Option<u32>,
    xhotspot: ::std::option::Option<u32>,
    yhotspot: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetCursor {
    fn default() -> &'a CMsgSetCursor {
        <CMsgSetCursor as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetCursor {
    pub fn new() -> CMsgSetCursor {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 cursor = 2;


    pub fn get_cursor(&self) -> u32 {
        self.cursor.unwrap_or(0)
    }
    pub fn clear_cursor(&mut self) {
        self.cursor = ::std::option::Option::None;
    }

    pub fn has_cursor(&self) -> bool {
        self.cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: u32) {
        self.cursor = ::std::option::Option::Some(v);
    }

    // optional bytes custom_data = 3;


    pub fn get_custom_data(&self) -> &[u8] {
        match self.custom_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_custom_data(&mut self) {
        self.custom_data.clear();
    }

    pub fn has_custom_data(&self) -> bool {
        self.custom_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.custom_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.custom_data.is_none() {
            self.custom_data.set_default();
        }
        self.custom_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_data(&mut self) -> ::std::vec::Vec<u8> {
        self.custom_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 wide = 4;


    pub fn get_wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }
    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 5;


    pub fn get_tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }
    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint32 xhotspot = 6;


    pub fn get_xhotspot(&self) -> u32 {
        self.xhotspot.unwrap_or(0)
    }
    pub fn clear_xhotspot(&mut self) {
        self.xhotspot = ::std::option::Option::None;
    }

    pub fn has_xhotspot(&self) -> bool {
        self.xhotspot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xhotspot(&mut self, v: u32) {
        self.xhotspot = ::std::option::Option::Some(v);
    }

    // optional uint32 yhotspot = 7;


    pub fn get_yhotspot(&self) -> u32 {
        self.yhotspot.unwrap_or(0)
    }
    pub fn clear_yhotspot(&mut self) {
        self.yhotspot = ::std::option::Option::None;
    }

    pub fn has_yhotspot(&self) -> bool {
        self.yhotspot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_yhotspot(&mut self, v: u32) {
        self.yhotspot = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetCursor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cursor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.custom_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wide = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tall = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xhotspot = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.yhotspot = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cursor {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.custom_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xhotspot {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.yhotspot {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cursor {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.custom_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.xhotspot {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.yhotspot {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetCursor {
        CMsgSetCursor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetCursor| { &m.browser_handle },
                    |m: &mut CMsgSetCursor| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cursor",
                    |m: &CMsgSetCursor| { &m.cursor },
                    |m: &mut CMsgSetCursor| { &mut m.cursor },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "custom_data",
                    |m: &CMsgSetCursor| { &m.custom_data },
                    |m: &mut CMsgSetCursor| { &mut m.custom_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wide",
                    |m: &CMsgSetCursor| { &m.wide },
                    |m: &mut CMsgSetCursor| { &mut m.wide },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tall",
                    |m: &CMsgSetCursor| { &m.tall },
                    |m: &mut CMsgSetCursor| { &mut m.tall },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xhotspot",
                    |m: &CMsgSetCursor| { &m.xhotspot },
                    |m: &mut CMsgSetCursor| { &mut m.xhotspot },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "yhotspot",
                    |m: &CMsgSetCursor| { &m.yhotspot },
                    |m: &mut CMsgSetCursor| { &mut m.yhotspot },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetCursor>(
                    "CMsgSetCursor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetCursor {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetCursor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetCursor,
        };
        unsafe {
            instance.get(CMsgSetCursor::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetCursor {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.cursor = ::std::option::Option::None;
        self.custom_data.clear();
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.xhotspot = ::std::option::Option::None;
        self.yhotspot = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetCursor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetCursor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgFileLoadDialog {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    title: ::protobuf::SingularField<::std::string::String>,
    initialFile: ::protobuf::SingularField<::std::string::String>,
    accept_types: ::protobuf::RepeatedField<::std::string::String>,
    is_save: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFileLoadDialog {
    fn default() -> &'a CMsgFileLoadDialog {
        <CMsgFileLoadDialog as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFileLoadDialog {
    pub fn new() -> CMsgFileLoadDialog {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string initialFile = 3;


    pub fn get_initialFile(&self) -> &str {
        match self.initialFile.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_initialFile(&mut self) {
        self.initialFile.clear();
    }

    pub fn has_initialFile(&self) -> bool {
        self.initialFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialFile(&mut self, v: ::std::string::String) {
        self.initialFile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initialFile(&mut self) -> &mut ::std::string::String {
        if self.initialFile.is_none() {
            self.initialFile.set_default();
        }
        self.initialFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_initialFile(&mut self) -> ::std::string::String {
        self.initialFile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string accept_types = 4;


    pub fn get_accept_types(&self) -> &[::std::string::String] {
        &self.accept_types
    }
    pub fn clear_accept_types(&mut self) {
        self.accept_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_accept_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accept_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accept_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accept_types
    }

    // Take field
    pub fn take_accept_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accept_types, ::protobuf::RepeatedField::new())
    }

    // optional bool is_save = 5;


    pub fn get_is_save(&self) -> bool {
        self.is_save.unwrap_or(false)
    }
    pub fn clear_is_save(&mut self) {
        self.is_save = ::std::option::Option::None;
    }

    pub fn has_is_save(&self) -> bool {
        self.is_save.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_save(&mut self, v: bool) {
        self.is_save = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFileLoadDialog {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.initialFile)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accept_types)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_save = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.initialFile.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.accept_types {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.is_save {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.initialFile.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.accept_types {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.is_save {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFileLoadDialog {
        CMsgFileLoadDialog::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgFileLoadDialog| { &m.browser_handle },
                    |m: &mut CMsgFileLoadDialog| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &CMsgFileLoadDialog| { &m.title },
                    |m: &mut CMsgFileLoadDialog| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "initialFile",
                    |m: &CMsgFileLoadDialog| { &m.initialFile },
                    |m: &mut CMsgFileLoadDialog| { &mut m.initialFile },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "accept_types",
                    |m: &CMsgFileLoadDialog| { &m.accept_types },
                    |m: &mut CMsgFileLoadDialog| { &mut m.accept_types },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_save",
                    |m: &CMsgFileLoadDialog| { &m.is_save },
                    |m: &mut CMsgFileLoadDialog| { &mut m.is_save },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgFileLoadDialog>(
                    "CMsgFileLoadDialog",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgFileLoadDialog {
        static mut instance: ::protobuf::lazy::Lazy<CMsgFileLoadDialog> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgFileLoadDialog,
        };
        unsafe {
            instance.get(CMsgFileLoadDialog::new)
        }
    }
}

impl ::protobuf::Clear for CMsgFileLoadDialog {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.title.clear();
        self.initialFile.clear();
        self.accept_types.clear();
        self.is_save = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFileLoadDialog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFileLoadDialog {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgFileLoadDialogResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    files: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFileLoadDialogResponse {
    fn default() -> &'a CMsgFileLoadDialogResponse {
        <CMsgFileLoadDialogResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFileLoadDialogResponse {
    pub fn new() -> CMsgFileLoadDialogResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // repeated string files = 2;


    pub fn get_files(&self) -> &[::std::string::String] {
        &self.files
    }
    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgFileLoadDialogResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.files {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFileLoadDialogResponse {
        CMsgFileLoadDialogResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgFileLoadDialogResponse| { &m.browser_handle },
                    |m: &mut CMsgFileLoadDialogResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "files",
                    |m: &CMsgFileLoadDialogResponse| { &m.files },
                    |m: &mut CMsgFileLoadDialogResponse| { &mut m.files },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgFileLoadDialogResponse>(
                    "CMsgFileLoadDialogResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgFileLoadDialogResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgFileLoadDialogResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgFileLoadDialogResponse,
        };
        unsafe {
            instance.get(CMsgFileLoadDialogResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgFileLoadDialogResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFileLoadDialogResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFileLoadDialogResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgShowToolTip {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgShowToolTip {
    fn default() -> &'a CMsgShowToolTip {
        <CMsgShowToolTip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowToolTip {
    pub fn new() -> CMsgShowToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgShowToolTip {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgShowToolTip {
        CMsgShowToolTip::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgShowToolTip| { &m.browser_handle },
                    |m: &mut CMsgShowToolTip| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CMsgShowToolTip| { &m.text },
                    |m: &mut CMsgShowToolTip| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgShowToolTip>(
                    "CMsgShowToolTip",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgShowToolTip {
        static mut instance: ::protobuf::lazy::Lazy<CMsgShowToolTip> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgShowToolTip,
        };
        unsafe {
            instance.get(CMsgShowToolTip::new)
        }
    }
}

impl ::protobuf::Clear for CMsgShowToolTip {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgShowToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgShowToolTip {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgUpdateToolTip {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateToolTip {
    fn default() -> &'a CMsgUpdateToolTip {
        <CMsgUpdateToolTip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateToolTip {
    pub fn new() -> CMsgUpdateToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgUpdateToolTip {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgUpdateToolTip {
        CMsgUpdateToolTip::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgUpdateToolTip| { &m.browser_handle },
                    |m: &mut CMsgUpdateToolTip| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CMsgUpdateToolTip| { &m.text },
                    |m: &mut CMsgUpdateToolTip| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgUpdateToolTip>(
                    "CMsgUpdateToolTip",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgUpdateToolTip {
        static mut instance: ::protobuf::lazy::Lazy<CMsgUpdateToolTip> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgUpdateToolTip,
        };
        unsafe {
            instance.get(CMsgUpdateToolTip::new)
        }
    }
}

impl ::protobuf::Clear for CMsgUpdateToolTip {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUpdateToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdateToolTip {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgHideToolTip {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgHideToolTip {
    fn default() -> &'a CMsgHideToolTip {
        <CMsgHideToolTip as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHideToolTip {
    pub fn new() -> CMsgHideToolTip {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHideToolTip {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgHideToolTip {
        CMsgHideToolTip::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgHideToolTip| { &m.browser_handle },
                    |m: &mut CMsgHideToolTip| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgHideToolTip>(
                    "CMsgHideToolTip",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgHideToolTip {
        static mut instance: ::protobuf::lazy::Lazy<CMsgHideToolTip> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgHideToolTip,
        };
        unsafe {
            instance.get(CMsgHideToolTip::new)
        }
    }
}

impl ::protobuf::Clear for CMsgHideToolTip {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgHideToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHideToolTip {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSearchResults {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    activeMatch: ::std::option::Option<i32>,
    results: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSearchResults {
    fn default() -> &'a CMsgSearchResults {
        <CMsgSearchResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSearchResults {
    pub fn new() -> CMsgSearchResults {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 activeMatch = 2;


    pub fn get_activeMatch(&self) -> i32 {
        self.activeMatch.unwrap_or(0)
    }
    pub fn clear_activeMatch(&mut self) {
        self.activeMatch = ::std::option::Option::None;
    }

    pub fn has_activeMatch(&self) -> bool {
        self.activeMatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activeMatch(&mut self, v: i32) {
        self.activeMatch = ::std::option::Option::Some(v);
    }

    // optional int32 results = 3;


    pub fn get_results(&self) -> i32 {
        self.results.unwrap_or(0)
    }
    pub fn clear_results(&mut self) {
        self.results = ::std::option::Option::None;
    }

    pub fn has_results(&self) -> bool {
        self.results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: i32) {
        self.results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSearchResults {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.activeMatch = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.results = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.activeMatch {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.activeMatch {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.results {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSearchResults {
        CMsgSearchResults::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSearchResults| { &m.browser_handle },
                    |m: &mut CMsgSearchResults| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "activeMatch",
                    |m: &CMsgSearchResults| { &m.activeMatch },
                    |m: &mut CMsgSearchResults| { &mut m.activeMatch },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "results",
                    |m: &CMsgSearchResults| { &m.results },
                    |m: &mut CMsgSearchResults| { &mut m.results },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSearchResults>(
                    "CMsgSearchResults",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSearchResults {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSearchResults> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSearchResults,
        };
        unsafe {
            instance.get(CMsgSearchResults::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSearchResults {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.activeMatch = ::std::option::Option::None;
        self.results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSearchResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSearchResults {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClose {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClose {
    fn default() -> &'a CMsgClose {
        <CMsgClose as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClose {
    pub fn new() -> CMsgClose {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClose {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClose {
        CMsgClose::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgClose| { &m.browser_handle },
                    |m: &mut CMsgClose| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClose>(
                    "CMsgClose",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgClose {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClose> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClose,
        };
        unsafe {
            instance.get(CMsgClose::new)
        }
    }
}

impl ::protobuf::Clear for CMsgClose {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClose {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetSharedPaintBuffers {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    wide: ::std::option::Option<u32>,
    tall: ::std::option::Option<u32>,
    source_pid: ::std::option::Option<u64>,
    source_handle: ::std::option::Option<u64>,
    handle: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetSharedPaintBuffers {
    fn default() -> &'a CMsgSetSharedPaintBuffers {
        <CMsgSetSharedPaintBuffers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetSharedPaintBuffers {
    pub fn new() -> CMsgSetSharedPaintBuffers {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 wide = 2;


    pub fn get_wide(&self) -> u32 {
        self.wide.unwrap_or(0)
    }
    pub fn clear_wide(&mut self) {
        self.wide = ::std::option::Option::None;
    }

    pub fn has_wide(&self) -> bool {
        self.wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wide(&mut self, v: u32) {
        self.wide = ::std::option::Option::Some(v);
    }

    // optional uint32 tall = 3;


    pub fn get_tall(&self) -> u32 {
        self.tall.unwrap_or(0)
    }
    pub fn clear_tall(&mut self) {
        self.tall = ::std::option::Option::None;
    }

    pub fn has_tall(&self) -> bool {
        self.tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tall(&mut self, v: u32) {
        self.tall = ::std::option::Option::Some(v);
    }

    // optional uint64 source_pid = 4;


    pub fn get_source_pid(&self) -> u64 {
        self.source_pid.unwrap_or(0)
    }
    pub fn clear_source_pid(&mut self) {
        self.source_pid = ::std::option::Option::None;
    }

    pub fn has_source_pid(&self) -> bool {
        self.source_pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_pid(&mut self, v: u64) {
        self.source_pid = ::std::option::Option::Some(v);
    }

    // optional uint64 source_handle = 5;


    pub fn get_source_handle(&self) -> u64 {
        self.source_handle.unwrap_or(0)
    }
    pub fn clear_source_handle(&mut self) {
        self.source_handle = ::std::option::Option::None;
    }

    pub fn has_source_handle(&self) -> bool {
        self.source_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_handle(&mut self, v: u64) {
        self.source_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 handle = 6;


    pub fn get_handle(&self) -> u64 {
        self.handle.unwrap_or(0)
    }
    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: u64) {
        self.handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetSharedPaintBuffers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wide = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tall = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.source_pid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.source_handle = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wide {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tall {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.source_pid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.source_handle {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wide {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tall {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.source_pid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.source_handle {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.handle {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetSharedPaintBuffers {
        CMsgSetSharedPaintBuffers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetSharedPaintBuffers| { &m.browser_handle },
                    |m: &mut CMsgSetSharedPaintBuffers| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wide",
                    |m: &CMsgSetSharedPaintBuffers| { &m.wide },
                    |m: &mut CMsgSetSharedPaintBuffers| { &mut m.wide },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tall",
                    |m: &CMsgSetSharedPaintBuffers| { &m.tall },
                    |m: &mut CMsgSetSharedPaintBuffers| { &mut m.tall },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "source_pid",
                    |m: &CMsgSetSharedPaintBuffers| { &m.source_pid },
                    |m: &mut CMsgSetSharedPaintBuffers| { &mut m.source_pid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "source_handle",
                    |m: &CMsgSetSharedPaintBuffers| { &m.source_handle },
                    |m: &mut CMsgSetSharedPaintBuffers| { &mut m.source_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "handle",
                    |m: &CMsgSetSharedPaintBuffers| { &m.handle },
                    |m: &mut CMsgSetSharedPaintBuffers| { &mut m.handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetSharedPaintBuffers>(
                    "CMsgSetSharedPaintBuffers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetSharedPaintBuffers {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetSharedPaintBuffers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetSharedPaintBuffers,
        };
        unsafe {
            instance.get(CMsgSetSharedPaintBuffers::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetSharedPaintBuffers {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.wide = ::std::option::Option::None;
        self.tall = ::std::option::Option::None;
        self.source_pid = ::std::option::Option::None;
        self.source_handle = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetSharedPaintBuffers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetSharedPaintBuffers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgAckSharedPaintBuffers {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAckSharedPaintBuffers {
    fn default() -> &'a CMsgAckSharedPaintBuffers {
        <CMsgAckSharedPaintBuffers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAckSharedPaintBuffers {
    pub fn new() -> CMsgAckSharedPaintBuffers {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAckSharedPaintBuffers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAckSharedPaintBuffers {
        CMsgAckSharedPaintBuffers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgAckSharedPaintBuffers| { &m.browser_handle },
                    |m: &mut CMsgAckSharedPaintBuffers| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgAckSharedPaintBuffers>(
                    "CMsgAckSharedPaintBuffers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgAckSharedPaintBuffers {
        static mut instance: ::protobuf::lazy::Lazy<CMsgAckSharedPaintBuffers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgAckSharedPaintBuffers,
        };
        unsafe {
            instance.get(CMsgAckSharedPaintBuffers::new)
        }
    }
}

impl ::protobuf::Clear for CMsgAckSharedPaintBuffers {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAckSharedPaintBuffers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAckSharedPaintBuffers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgNeedsPaint {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    scrollx: ::std::option::Option<u32>,
    scrolly: ::std::option::Option<u32>,
    pagescale: ::std::option::Option<f32>,
    pageserial: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgNeedsPaint {
    fn default() -> &'a CMsgNeedsPaint {
        <CMsgNeedsPaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNeedsPaint {
    pub fn new() -> CMsgNeedsPaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 10;


    pub fn get_scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }
    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 11;


    pub fn get_scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }
    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 12;


    pub fn get_pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }
    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 15;


    pub fn get_pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }
    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNeedsPaint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scrollx = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scrolly = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pagescale = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pageserial = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scrollx {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scrolly {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pagescale {
            my_size += 5;
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgNeedsPaint {
        CMsgNeedsPaint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgNeedsPaint| { &m.browser_handle },
                    |m: &mut CMsgNeedsPaint| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scrollx",
                    |m: &CMsgNeedsPaint| { &m.scrollx },
                    |m: &mut CMsgNeedsPaint| { &mut m.scrollx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scrolly",
                    |m: &CMsgNeedsPaint| { &m.scrolly },
                    |m: &mut CMsgNeedsPaint| { &mut m.scrolly },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pagescale",
                    |m: &CMsgNeedsPaint| { &m.pagescale },
                    |m: &mut CMsgNeedsPaint| { &mut m.pagescale },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pageserial",
                    |m: &CMsgNeedsPaint| { &m.pageserial },
                    |m: &mut CMsgNeedsPaint| { &mut m.pageserial },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgNeedsPaint>(
                    "CMsgNeedsPaint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgNeedsPaint {
        static mut instance: ::protobuf::lazy::Lazy<CMsgNeedsPaint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgNeedsPaint,
        };
        unsafe {
            instance.get(CMsgNeedsPaint::new)
        }
    }
}

impl ::protobuf::Clear for CMsgNeedsPaint {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgNeedsPaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNeedsPaint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgComboNeedsPaint {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    rgba: ::std::option::Option<u64>,
    combobox_wide: ::std::option::Option<u32>,
    combobox_tall: ::std::option::Option<u32>,
    shared_memory_handle: ::std::option::Option<u64>,
    shared_memory_size: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgComboNeedsPaint {
    fn default() -> &'a CMsgComboNeedsPaint {
        <CMsgComboNeedsPaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgComboNeedsPaint {
    pub fn new() -> CMsgComboNeedsPaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 rgba = 2;


    pub fn get_rgba(&self) -> u64 {
        self.rgba.unwrap_or(0)
    }
    pub fn clear_rgba(&mut self) {
        self.rgba = ::std::option::Option::None;
    }

    pub fn has_rgba(&self) -> bool {
        self.rgba.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rgba(&mut self, v: u64) {
        self.rgba = ::std::option::Option::Some(v);
    }

    // optional uint32 combobox_wide = 3;


    pub fn get_combobox_wide(&self) -> u32 {
        self.combobox_wide.unwrap_or(0u32)
    }
    pub fn clear_combobox_wide(&mut self) {
        self.combobox_wide = ::std::option::Option::None;
    }

    pub fn has_combobox_wide(&self) -> bool {
        self.combobox_wide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combobox_wide(&mut self, v: u32) {
        self.combobox_wide = ::std::option::Option::Some(v);
    }

    // optional uint32 combobox_tall = 4;


    pub fn get_combobox_tall(&self) -> u32 {
        self.combobox_tall.unwrap_or(0u32)
    }
    pub fn clear_combobox_tall(&mut self) {
        self.combobox_tall = ::std::option::Option::None;
    }

    pub fn has_combobox_tall(&self) -> bool {
        self.combobox_tall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_combobox_tall(&mut self, v: u32) {
        self.combobox_tall = ::std::option::Option::Some(v);
    }

    // optional uint64 shared_memory_handle = 5;


    pub fn get_shared_memory_handle(&self) -> u64 {
        self.shared_memory_handle.unwrap_or(0u64)
    }
    pub fn clear_shared_memory_handle(&mut self) {
        self.shared_memory_handle = ::std::option::Option::None;
    }

    pub fn has_shared_memory_handle(&self) -> bool {
        self.shared_memory_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_memory_handle(&mut self, v: u64) {
        self.shared_memory_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 shared_memory_size = 7;


    pub fn get_shared_memory_size(&self) -> u64 {
        self.shared_memory_size.unwrap_or(0u64)
    }
    pub fn clear_shared_memory_size(&mut self) {
        self.shared_memory_size = ::std::option::Option::None;
    }

    pub fn has_shared_memory_size(&self) -> bool {
        self.shared_memory_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_memory_size(&mut self, v: u64) {
        self.shared_memory_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgComboNeedsPaint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rgba = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.combobox_wide = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.combobox_tall = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.shared_memory_handle = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.shared_memory_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rgba {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.combobox_wide {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.combobox_tall {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shared_memory_handle {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shared_memory_size {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rgba {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.combobox_wide {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.combobox_tall {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.shared_memory_handle {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.shared_memory_size {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgComboNeedsPaint {
        CMsgComboNeedsPaint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgComboNeedsPaint| { &m.browser_handle },
                    |m: &mut CMsgComboNeedsPaint| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rgba",
                    |m: &CMsgComboNeedsPaint| { &m.rgba },
                    |m: &mut CMsgComboNeedsPaint| { &mut m.rgba },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "combobox_wide",
                    |m: &CMsgComboNeedsPaint| { &m.combobox_wide },
                    |m: &mut CMsgComboNeedsPaint| { &mut m.combobox_wide },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "combobox_tall",
                    |m: &CMsgComboNeedsPaint| { &m.combobox_tall },
                    |m: &mut CMsgComboNeedsPaint| { &mut m.combobox_tall },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "shared_memory_handle",
                    |m: &CMsgComboNeedsPaint| { &m.shared_memory_handle },
                    |m: &mut CMsgComboNeedsPaint| { &mut m.shared_memory_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "shared_memory_size",
                    |m: &CMsgComboNeedsPaint| { &m.shared_memory_size },
                    |m: &mut CMsgComboNeedsPaint| { &mut m.shared_memory_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgComboNeedsPaint>(
                    "CMsgComboNeedsPaint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgComboNeedsPaint {
        static mut instance: ::protobuf::lazy::Lazy<CMsgComboNeedsPaint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgComboNeedsPaint,
        };
        unsafe {
            instance.get(CMsgComboNeedsPaint::new)
        }
    }
}

impl ::protobuf::Clear for CMsgComboNeedsPaint {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.rgba = ::std::option::Option::None;
        self.combobox_wide = ::std::option::Option::None;
        self.combobox_tall = ::std::option::Option::None;
        self.shared_memory_handle = ::std::option::Option::None;
        self.shared_memory_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgComboNeedsPaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgComboNeedsPaint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgNeedsSharedTexturePaint {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    share_handle: ::std::option::Option<u32>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    scrollx: ::std::option::Option<u32>,
    scrolly: ::std::option::Option<u32>,
    pagescale: ::std::option::Option<f32>,
    pageserial: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgNeedsSharedTexturePaint {
    fn default() -> &'a CMsgNeedsSharedTexturePaint {
        <CMsgNeedsSharedTexturePaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNeedsSharedTexturePaint {
    pub fn new() -> CMsgNeedsSharedTexturePaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 share_handle = 2;


    pub fn get_share_handle(&self) -> u32 {
        self.share_handle.unwrap_or(0)
    }
    pub fn clear_share_handle(&mut self) {
        self.share_handle = ::std::option::Option::None;
    }

    pub fn has_share_handle(&self) -> bool {
        self.share_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_share_handle(&mut self, v: u32) {
        self.share_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 3;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 4;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 5;


    pub fn get_scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }
    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 6;


    pub fn get_scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }
    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 7;


    pub fn get_pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }
    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 8;


    pub fn get_pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }
    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNeedsSharedTexturePaint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.share_handle = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scrollx = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scrolly = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pagescale = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pageserial = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.share_handle {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scrollx {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scrolly {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pagescale {
            my_size += 5;
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.share_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgNeedsSharedTexturePaint {
        CMsgNeedsSharedTexturePaint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgNeedsSharedTexturePaint| { &m.browser_handle },
                    |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "share_handle",
                    |m: &CMsgNeedsSharedTexturePaint| { &m.share_handle },
                    |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.share_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "width",
                    |m: &CMsgNeedsSharedTexturePaint| { &m.width },
                    |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    |m: &CMsgNeedsSharedTexturePaint| { &m.height },
                    |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.height },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scrollx",
                    |m: &CMsgNeedsSharedTexturePaint| { &m.scrollx },
                    |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.scrollx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scrolly",
                    |m: &CMsgNeedsSharedTexturePaint| { &m.scrolly },
                    |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.scrolly },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pagescale",
                    |m: &CMsgNeedsSharedTexturePaint| { &m.pagescale },
                    |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.pagescale },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pageserial",
                    |m: &CMsgNeedsSharedTexturePaint| { &m.pageserial },
                    |m: &mut CMsgNeedsSharedTexturePaint| { &mut m.pageserial },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgNeedsSharedTexturePaint>(
                    "CMsgNeedsSharedTexturePaint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgNeedsSharedTexturePaint {
        static mut instance: ::protobuf::lazy::Lazy<CMsgNeedsSharedTexturePaint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgNeedsSharedTexturePaint,
        };
        unsafe {
            instance.get(CMsgNeedsSharedTexturePaint::new)
        }
    }
}

impl ::protobuf::Clear for CMsgNeedsSharedTexturePaint {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.share_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgNeedsSharedTexturePaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNeedsSharedTexturePaint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgGameOverlayTexturePaint {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    scrollx: ::std::option::Option<u32>,
    scrolly: ::std::option::Option<u32>,
    pagescale: ::std::option::Option<f32>,
    pageserial: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameOverlayTexturePaint {
    fn default() -> &'a CMsgGameOverlayTexturePaint {
        <CMsgGameOverlayTexturePaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameOverlayTexturePaint {
    pub fn new() -> CMsgGameOverlayTexturePaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 3;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 4;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 scrollx = 5;


    pub fn get_scrollx(&self) -> u32 {
        self.scrollx.unwrap_or(0)
    }
    pub fn clear_scrollx(&mut self) {
        self.scrollx = ::std::option::Option::None;
    }

    pub fn has_scrollx(&self) -> bool {
        self.scrollx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrollx(&mut self, v: u32) {
        self.scrollx = ::std::option::Option::Some(v);
    }

    // optional uint32 scrolly = 6;


    pub fn get_scrolly(&self) -> u32 {
        self.scrolly.unwrap_or(0)
    }
    pub fn clear_scrolly(&mut self) {
        self.scrolly = ::std::option::Option::None;
    }

    pub fn has_scrolly(&self) -> bool {
        self.scrolly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scrolly(&mut self, v: u32) {
        self.scrolly = ::std::option::Option::Some(v);
    }

    // optional float pagescale = 7;


    pub fn get_pagescale(&self) -> f32 {
        self.pagescale.unwrap_or(0.)
    }
    pub fn clear_pagescale(&mut self) {
        self.pagescale = ::std::option::Option::None;
    }

    pub fn has_pagescale(&self) -> bool {
        self.pagescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagescale(&mut self, v: f32) {
        self.pagescale = ::std::option::Option::Some(v);
    }

    // optional uint32 pageserial = 8;


    pub fn get_pageserial(&self) -> u32 {
        self.pageserial.unwrap_or(0)
    }
    pub fn clear_pageserial(&mut self) {
        self.pageserial = ::std::option::Option::None;
    }

    pub fn has_pageserial(&self) -> bool {
        self.pageserial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageserial(&mut self, v: u32) {
        self.pageserial = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameOverlayTexturePaint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scrollx = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scrolly = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pagescale = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pageserial = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scrollx {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scrolly {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pagescale {
            my_size += 5;
        }
        if let Some(v) = self.pageserial {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.scrollx {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scrolly {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.pagescale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pageserial {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameOverlayTexturePaint {
        CMsgGameOverlayTexturePaint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgGameOverlayTexturePaint| { &m.browser_handle },
                    |m: &mut CMsgGameOverlayTexturePaint| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "width",
                    |m: &CMsgGameOverlayTexturePaint| { &m.width },
                    |m: &mut CMsgGameOverlayTexturePaint| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    |m: &CMsgGameOverlayTexturePaint| { &m.height },
                    |m: &mut CMsgGameOverlayTexturePaint| { &mut m.height },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scrollx",
                    |m: &CMsgGameOverlayTexturePaint| { &m.scrollx },
                    |m: &mut CMsgGameOverlayTexturePaint| { &mut m.scrollx },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scrolly",
                    |m: &CMsgGameOverlayTexturePaint| { &m.scrolly },
                    |m: &mut CMsgGameOverlayTexturePaint| { &mut m.scrolly },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pagescale",
                    |m: &CMsgGameOverlayTexturePaint| { &m.pagescale },
                    |m: &mut CMsgGameOverlayTexturePaint| { &mut m.pagescale },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pageserial",
                    |m: &CMsgGameOverlayTexturePaint| { &m.pageserial },
                    |m: &mut CMsgGameOverlayTexturePaint| { &mut m.pageserial },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameOverlayTexturePaint>(
                    "CMsgGameOverlayTexturePaint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGameOverlayTexturePaint {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameOverlayTexturePaint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameOverlayTexturePaint,
        };
        unsafe {
            instance.get(CMsgGameOverlayTexturePaint::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGameOverlayTexturePaint {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.scrollx = ::std::option::Option::None;
        self.scrolly = ::std::option::Option::None;
        self.pagescale = ::std::option::Option::None;
        self.pageserial = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameOverlayTexturePaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameOverlayTexturePaint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgGetZoom {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGetZoom {
    fn default() -> &'a CMsgGetZoom {
        <CMsgGetZoom as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetZoom {
    pub fn new() -> CMsgGetZoom {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGetZoom {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGetZoom {
        CMsgGetZoom::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgGetZoom| { &m.browser_handle },
                    |m: &mut CMsgGetZoom| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGetZoom>(
                    "CMsgGetZoom",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGetZoom {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGetZoom> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGetZoom,
        };
        unsafe {
            instance.get(CMsgGetZoom::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGetZoom {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGetZoom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGetZoom {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgGetZoomResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    zoom: ::std::option::Option<f32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGetZoomResponse {
    fn default() -> &'a CMsgGetZoomResponse {
        <CMsgGetZoomResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetZoomResponse {
    pub fn new() -> CMsgGetZoomResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float zoom = 2;


    pub fn get_zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }
    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGetZoomResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.zoom = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.zoom {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGetZoomResponse {
        CMsgGetZoomResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgGetZoomResponse| { &m.browser_handle },
                    |m: &mut CMsgGetZoomResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "zoom",
                    |m: &CMsgGetZoomResponse| { &m.zoom },
                    |m: &mut CMsgGetZoomResponse| { &mut m.zoom },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGetZoomResponse>(
                    "CMsgGetZoomResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGetZoomResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGetZoomResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGetZoomResponse,
        };
        unsafe {
            instance.get(CMsgGetZoomResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGetZoomResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGetZoomResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGetZoomResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgLinkAtPosition {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    x: ::std::option::Option<u32>,
    y: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLinkAtPosition {
    fn default() -> &'a CMsgLinkAtPosition {
        <CMsgLinkAtPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLinkAtPosition {
    pub fn new() -> CMsgLinkAtPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;


    pub fn get_x(&self) -> u32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;


    pub fn get_y(&self) -> u32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgLinkAtPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLinkAtPosition {
        CMsgLinkAtPosition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgLinkAtPosition| { &m.browser_handle },
                    |m: &mut CMsgLinkAtPosition| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "x",
                    |m: &CMsgLinkAtPosition| { &m.x },
                    |m: &mut CMsgLinkAtPosition| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "y",
                    |m: &CMsgLinkAtPosition| { &m.y },
                    |m: &mut CMsgLinkAtPosition| { &mut m.y },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLinkAtPosition>(
                    "CMsgLinkAtPosition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgLinkAtPosition {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLinkAtPosition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLinkAtPosition,
        };
        unsafe {
            instance.get(CMsgLinkAtPosition::new)
        }
    }
}

impl ::protobuf::Clear for CMsgLinkAtPosition {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLinkAtPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLinkAtPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgLinkAtPositionResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    x: ::std::option::Option<u32>,
    y: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    blivelink: ::std::option::Option<bool>,
    binput: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLinkAtPositionResponse {
    fn default() -> &'a CMsgLinkAtPositionResponse {
        <CMsgLinkAtPositionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLinkAtPositionResponse {
    pub fn new() -> CMsgLinkAtPositionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;


    pub fn get_x(&self) -> u32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;


    pub fn get_y(&self) -> u32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional string url = 4;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool blivelink = 5;


    pub fn get_blivelink(&self) -> bool {
        self.blivelink.unwrap_or(false)
    }
    pub fn clear_blivelink(&mut self) {
        self.blivelink = ::std::option::Option::None;
    }

    pub fn has_blivelink(&self) -> bool {
        self.blivelink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blivelink(&mut self, v: bool) {
        self.blivelink = ::std::option::Option::Some(v);
    }

    // optional bool binput = 6;


    pub fn get_binput(&self) -> bool {
        self.binput.unwrap_or(false)
    }
    pub fn clear_binput(&mut self) {
        self.binput = ::std::option::Option::None;
    }

    pub fn has_binput(&self) -> bool {
        self.binput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binput(&mut self, v: bool) {
        self.binput = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgLinkAtPositionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blivelink = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.binput = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.blivelink {
            my_size += 2;
        }
        if let Some(v) = self.binput {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.blivelink {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.binput {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLinkAtPositionResponse {
        CMsgLinkAtPositionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgLinkAtPositionResponse| { &m.browser_handle },
                    |m: &mut CMsgLinkAtPositionResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "x",
                    |m: &CMsgLinkAtPositionResponse| { &m.x },
                    |m: &mut CMsgLinkAtPositionResponse| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "y",
                    |m: &CMsgLinkAtPositionResponse| { &m.y },
                    |m: &mut CMsgLinkAtPositionResponse| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgLinkAtPositionResponse| { &m.url },
                    |m: &mut CMsgLinkAtPositionResponse| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "blivelink",
                    |m: &CMsgLinkAtPositionResponse| { &m.blivelink },
                    |m: &mut CMsgLinkAtPositionResponse| { &mut m.blivelink },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "binput",
                    |m: &CMsgLinkAtPositionResponse| { &m.binput },
                    |m: &mut CMsgLinkAtPositionResponse| { &mut m.binput },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLinkAtPositionResponse>(
                    "CMsgLinkAtPositionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgLinkAtPositionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLinkAtPositionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLinkAtPositionResponse,
        };
        unsafe {
            instance.get(CMsgLinkAtPositionResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgLinkAtPositionResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.url.clear();
        self.blivelink = ::std::option::Option::None;
        self.binput = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLinkAtPositionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLinkAtPositionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgZoomToElementAtPosition {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    x: ::std::option::Option<u32>,
    y: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToElementAtPosition {
    fn default() -> &'a CMsgZoomToElementAtPosition {
        <CMsgZoomToElementAtPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgZoomToElementAtPosition {
    pub fn new() -> CMsgZoomToElementAtPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;


    pub fn get_x(&self) -> u32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;


    pub fn get_y(&self) -> u32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgZoomToElementAtPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgZoomToElementAtPosition {
        CMsgZoomToElementAtPosition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgZoomToElementAtPosition| { &m.browser_handle },
                    |m: &mut CMsgZoomToElementAtPosition| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "x",
                    |m: &CMsgZoomToElementAtPosition| { &m.x },
                    |m: &mut CMsgZoomToElementAtPosition| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "y",
                    |m: &CMsgZoomToElementAtPosition| { &m.y },
                    |m: &mut CMsgZoomToElementAtPosition| { &mut m.y },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgZoomToElementAtPosition>(
                    "CMsgZoomToElementAtPosition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgZoomToElementAtPosition {
        static mut instance: ::protobuf::lazy::Lazy<CMsgZoomToElementAtPosition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgZoomToElementAtPosition,
        };
        unsafe {
            instance.get(CMsgZoomToElementAtPosition::new)
        }
    }
}

impl ::protobuf::Clear for CMsgZoomToElementAtPosition {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgZoomToElementAtPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgZoomToElementAtPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgZoomToElementAtPositionResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    scale: ::std::option::Option<f32>,
    duration: ::std::option::Option<f32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToElementAtPositionResponse {
    fn default() -> &'a CMsgZoomToElementAtPositionResponse {
        <CMsgZoomToElementAtPositionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgZoomToElementAtPositionResponse {
    pub fn new() -> CMsgZoomToElementAtPositionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float scale = 2;


    pub fn get_scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }
    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;


    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgZoomToElementAtPositionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scale = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scale {
            my_size += 5;
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgZoomToElementAtPositionResponse {
        CMsgZoomToElementAtPositionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgZoomToElementAtPositionResponse| { &m.browser_handle },
                    |m: &mut CMsgZoomToElementAtPositionResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scale",
                    |m: &CMsgZoomToElementAtPositionResponse| { &m.scale },
                    |m: &mut CMsgZoomToElementAtPositionResponse| { &mut m.scale },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "duration",
                    |m: &CMsgZoomToElementAtPositionResponse| { &m.duration },
                    |m: &mut CMsgZoomToElementAtPositionResponse| { &mut m.duration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgZoomToElementAtPositionResponse>(
                    "CMsgZoomToElementAtPositionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgZoomToElementAtPositionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgZoomToElementAtPositionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgZoomToElementAtPositionResponse,
        };
        unsafe {
            instance.get(CMsgZoomToElementAtPositionResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgZoomToElementAtPositionResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgZoomToElementAtPositionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgZoomToElementAtPositionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgScalePageToValue {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    scale: ::std::option::Option<f32>,
    x: ::std::option::Option<f32>,
    y: ::std::option::Option<f32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgScalePageToValue {
    fn default() -> &'a CMsgScalePageToValue {
        <CMsgScalePageToValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScalePageToValue {
    pub fn new() -> CMsgScalePageToValue {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float scale = 2;


    pub fn get_scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }
    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float x = 3;


    pub fn get_x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 4;


    pub fn get_y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgScalePageToValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scale = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scale {
            my_size += 5;
        }
        if let Some(v) = self.x {
            my_size += 5;
        }
        if let Some(v) = self.y {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgScalePageToValue {
        CMsgScalePageToValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgScalePageToValue| { &m.browser_handle },
                    |m: &mut CMsgScalePageToValue| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scale",
                    |m: &CMsgScalePageToValue| { &m.scale },
                    |m: &mut CMsgScalePageToValue| { &mut m.scale },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x",
                    |m: &CMsgScalePageToValue| { &m.x },
                    |m: &mut CMsgScalePageToValue| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y",
                    |m: &CMsgScalePageToValue| { &m.y },
                    |m: &mut CMsgScalePageToValue| { &mut m.y },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgScalePageToValue>(
                    "CMsgScalePageToValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgScalePageToValue {
        static mut instance: ::protobuf::lazy::Lazy<CMsgScalePageToValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgScalePageToValue,
        };
        unsafe {
            instance.get(CMsgScalePageToValue::new)
        }
    }
}

impl ::protobuf::Clear for CMsgScalePageToValue {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgScalePageToValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgScalePageToValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgForcePopupsToDirectHWND {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    force_direct_hwnd_popups: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgForcePopupsToDirectHWND {
    fn default() -> &'a CMsgForcePopupsToDirectHWND {
        <CMsgForcePopupsToDirectHWND as ::protobuf::Message>::default_instance()
    }
}

impl CMsgForcePopupsToDirectHWND {
    pub fn new() -> CMsgForcePopupsToDirectHWND {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool force_direct_hwnd_popups = 2;


    pub fn get_force_direct_hwnd_popups(&self) -> bool {
        self.force_direct_hwnd_popups.unwrap_or(false)
    }
    pub fn clear_force_direct_hwnd_popups(&mut self) {
        self.force_direct_hwnd_popups = ::std::option::Option::None;
    }

    pub fn has_force_direct_hwnd_popups(&self) -> bool {
        self.force_direct_hwnd_popups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_direct_hwnd_popups(&mut self, v: bool) {
        self.force_direct_hwnd_popups = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgForcePopupsToDirectHWND {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_direct_hwnd_popups = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.force_direct_hwnd_popups {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.force_direct_hwnd_popups {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgForcePopupsToDirectHWND {
        CMsgForcePopupsToDirectHWND::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgForcePopupsToDirectHWND| { &m.browser_handle },
                    |m: &mut CMsgForcePopupsToDirectHWND| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force_direct_hwnd_popups",
                    |m: &CMsgForcePopupsToDirectHWND| { &m.force_direct_hwnd_popups },
                    |m: &mut CMsgForcePopupsToDirectHWND| { &mut m.force_direct_hwnd_popups },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgForcePopupsToDirectHWND>(
                    "CMsgForcePopupsToDirectHWND",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgForcePopupsToDirectHWND {
        static mut instance: ::protobuf::lazy::Lazy<CMsgForcePopupsToDirectHWND> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgForcePopupsToDirectHWND,
        };
        unsafe {
            instance.get(CMsgForcePopupsToDirectHWND::new)
        }
    }
}

impl ::protobuf::Clear for CMsgForcePopupsToDirectHWND {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.force_direct_hwnd_popups = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgForcePopupsToDirectHWND {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgForcePopupsToDirectHWND {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgScalePageToValueResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    zoom: ::std::option::Option<f32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgScalePageToValueResponse {
    fn default() -> &'a CMsgScalePageToValueResponse {
        <CMsgScalePageToValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScalePageToValueResponse {
    pub fn new() -> CMsgScalePageToValueResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float zoom = 2;


    pub fn get_zoom(&self) -> f32 {
        self.zoom.unwrap_or(0.)
    }
    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: f32) {
        self.zoom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgScalePageToValueResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.zoom = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.zoom {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.zoom {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgScalePageToValueResponse {
        CMsgScalePageToValueResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgScalePageToValueResponse| { &m.browser_handle },
                    |m: &mut CMsgScalePageToValueResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "zoom",
                    |m: &CMsgScalePageToValueResponse| { &m.zoom },
                    |m: &mut CMsgScalePageToValueResponse| { &mut m.zoom },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgScalePageToValueResponse>(
                    "CMsgScalePageToValueResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgScalePageToValueResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgScalePageToValueResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgScalePageToValueResponse,
        };
        unsafe {
            instance.get(CMsgScalePageToValueResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgScalePageToValueResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.zoom = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgScalePageToValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgScalePageToValueResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSavePageToJPEG {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    filename: ::protobuf::SingularField<::std::string::String>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSavePageToJPEG {
    fn default() -> &'a CMsgSavePageToJPEG {
        <CMsgSavePageToJPEG as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSavePageToJPEG {
    pub fn new() -> CMsgSavePageToJPEG {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string filename = 3;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 width = 4;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSavePageToJPEG {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSavePageToJPEG {
        CMsgSavePageToJPEG::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSavePageToJPEG| { &m.browser_handle },
                    |m: &mut CMsgSavePageToJPEG| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgSavePageToJPEG| { &m.url },
                    |m: &mut CMsgSavePageToJPEG| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    |m: &CMsgSavePageToJPEG| { &m.filename },
                    |m: &mut CMsgSavePageToJPEG| { &mut m.filename },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "width",
                    |m: &CMsgSavePageToJPEG| { &m.width },
                    |m: &mut CMsgSavePageToJPEG| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    |m: &CMsgSavePageToJPEG| { &m.height },
                    |m: &mut CMsgSavePageToJPEG| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSavePageToJPEG>(
                    "CMsgSavePageToJPEG",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSavePageToJPEG {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSavePageToJPEG> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSavePageToJPEG,
        };
        unsafe {
            instance.get(CMsgSavePageToJPEG::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSavePageToJPEG {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.filename.clear();
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSavePageToJPEG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSavePageToJPEG {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSavePageToJPEGResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSavePageToJPEGResponse {
    fn default() -> &'a CMsgSavePageToJPEGResponse {
        <CMsgSavePageToJPEGResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSavePageToJPEGResponse {
    pub fn new() -> CMsgSavePageToJPEGResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string filename = 3;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSavePageToJPEGResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSavePageToJPEGResponse {
        CMsgSavePageToJPEGResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSavePageToJPEGResponse| { &m.browser_handle },
                    |m: &mut CMsgSavePageToJPEGResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgSavePageToJPEGResponse| { &m.url },
                    |m: &mut CMsgSavePageToJPEGResponse| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    |m: &CMsgSavePageToJPEGResponse| { &m.filename },
                    |m: &mut CMsgSavePageToJPEGResponse| { &mut m.filename },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSavePageToJPEGResponse>(
                    "CMsgSavePageToJPEGResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSavePageToJPEGResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSavePageToJPEGResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSavePageToJPEGResponse,
        };
        unsafe {
            instance.get(CMsgSavePageToJPEGResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSavePageToJPEGResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.filename.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSavePageToJPEGResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSavePageToJPEGResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJSAlert {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJSAlert {
    fn default() -> &'a CMsgJSAlert {
        <CMsgJSAlert as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSAlert {
    pub fn new() -> CMsgJSAlert {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgJSAlert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJSAlert {
        CMsgJSAlert::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgJSAlert| { &m.browser_handle },
                    |m: &mut CMsgJSAlert| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CMsgJSAlert| { &m.message },
                    |m: &mut CMsgJSAlert| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJSAlert>(
                    "CMsgJSAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJSAlert {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJSAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJSAlert,
        };
        unsafe {
            instance.get(CMsgJSAlert::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJSAlert {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJSAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJSConfirm {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJSConfirm {
    fn default() -> &'a CMsgJSConfirm {
        <CMsgJSConfirm as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSConfirm {
    pub fn new() -> CMsgJSConfirm {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgJSConfirm {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJSConfirm {
        CMsgJSConfirm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgJSConfirm| { &m.browser_handle },
                    |m: &mut CMsgJSConfirm| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CMsgJSConfirm| { &m.message },
                    |m: &mut CMsgJSConfirm| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJSConfirm>(
                    "CMsgJSConfirm",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJSConfirm {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJSConfirm> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJSConfirm,
        };
        unsafe {
            instance.get(CMsgJSConfirm::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJSConfirm {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJSConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSConfirm {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJSDialogResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    result: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJSDialogResponse {
    fn default() -> &'a CMsgJSDialogResponse {
        <CMsgJSDialogResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSDialogResponse {
    pub fn new() -> CMsgJSDialogResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool result = 2;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgJSDialogResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJSDialogResponse {
        CMsgJSDialogResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgJSDialogResponse| { &m.browser_handle },
                    |m: &mut CMsgJSDialogResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &CMsgJSDialogResponse| { &m.result },
                    |m: &mut CMsgJSDialogResponse| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJSDialogResponse>(
                    "CMsgJSDialogResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJSDialogResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJSDialogResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJSDialogResponse,
        };
        unsafe {
            instance.get(CMsgJSDialogResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJSDialogResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJSDialogResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSDialogResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgCanGoBackAndForward {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    bgoback: ::std::option::Option<bool>,
    bgoforward: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCanGoBackAndForward {
    fn default() -> &'a CMsgCanGoBackAndForward {
        <CMsgCanGoBackAndForward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCanGoBackAndForward {
    pub fn new() -> CMsgCanGoBackAndForward {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bgoback = 2;


    pub fn get_bgoback(&self) -> bool {
        self.bgoback.unwrap_or(false)
    }
    pub fn clear_bgoback(&mut self) {
        self.bgoback = ::std::option::Option::None;
    }

    pub fn has_bgoback(&self) -> bool {
        self.bgoback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgoback(&mut self, v: bool) {
        self.bgoback = ::std::option::Option::Some(v);
    }

    // optional bool bgoforward = 3;


    pub fn get_bgoforward(&self) -> bool {
        self.bgoforward.unwrap_or(false)
    }
    pub fn clear_bgoforward(&mut self) {
        self.bgoforward = ::std::option::Option::None;
    }

    pub fn has_bgoforward(&self) -> bool {
        self.bgoforward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgoforward(&mut self, v: bool) {
        self.bgoforward = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCanGoBackAndForward {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bgoback = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bgoforward = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bgoback {
            my_size += 2;
        }
        if let Some(v) = self.bgoforward {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bgoback {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bgoforward {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCanGoBackAndForward {
        CMsgCanGoBackAndForward::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgCanGoBackAndForward| { &m.browser_handle },
                    |m: &mut CMsgCanGoBackAndForward| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bgoback",
                    |m: &CMsgCanGoBackAndForward| { &m.bgoback },
                    |m: &mut CMsgCanGoBackAndForward| { &mut m.bgoback },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bgoforward",
                    |m: &CMsgCanGoBackAndForward| { &m.bgoforward },
                    |m: &mut CMsgCanGoBackAndForward| { &mut m.bgoforward },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCanGoBackAndForward>(
                    "CMsgCanGoBackAndForward",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgCanGoBackAndForward {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCanGoBackAndForward> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCanGoBackAndForward,
        };
        unsafe {
            instance.get(CMsgCanGoBackAndForward::new)
        }
    }
}

impl ::protobuf::Clear for CMsgCanGoBackAndForward {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bgoback = ::std::option::Option::None;
        self.bgoforward = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCanGoBackAndForward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCanGoBackAndForward {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgOpenSteamURL {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    referrer: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgOpenSteamURL {
    fn default() -> &'a CMsgOpenSteamURL {
        <CMsgOpenSteamURL as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpenSteamURL {
    pub fn new() -> CMsgOpenSteamURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string referrer = 3;


    pub fn get_referrer(&self) -> &str {
        match self.referrer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_referrer(&mut self) {
        self.referrer.clear();
    }

    pub fn has_referrer(&self) -> bool {
        self.referrer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_referrer(&mut self, v: ::std::string::String) {
        self.referrer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_referrer(&mut self) -> &mut ::std::string::String {
        if self.referrer.is_none() {
            self.referrer.set_default();
        }
        self.referrer.as_mut().unwrap()
    }

    // Take field
    pub fn take_referrer(&mut self) -> ::std::string::String {
        self.referrer.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgOpenSteamURL {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.referrer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.referrer.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.referrer.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgOpenSteamURL {
        CMsgOpenSteamURL::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgOpenSteamURL| { &m.browser_handle },
                    |m: &mut CMsgOpenSteamURL| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgOpenSteamURL| { &m.url },
                    |m: &mut CMsgOpenSteamURL| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "referrer",
                    |m: &CMsgOpenSteamURL| { &m.referrer },
                    |m: &mut CMsgOpenSteamURL| { &mut m.referrer },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgOpenSteamURL>(
                    "CMsgOpenSteamURL",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgOpenSteamURL {
        static mut instance: ::protobuf::lazy::Lazy<CMsgOpenSteamURL> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgOpenSteamURL,
        };
        unsafe {
            instance.get(CMsgOpenSteamURL::new)
        }
    }
}

impl ::protobuf::Clear for CMsgOpenSteamURL {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.referrer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgOpenSteamURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgOpenSteamURL {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetCookie {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    host: ::protobuf::SingularField<::std::string::String>,
    expires: ::std::option::Option<u32>,
    secure: ::std::option::Option<bool>,
    httponly: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetCookie {
    fn default() -> &'a CMsgSetCookie {
        <CMsgSetCookie as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetCookie {
    pub fn new() -> CMsgSetCookie {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 3;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host = 4;


    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 expires = 5;


    pub fn get_expires(&self) -> u32 {
        self.expires.unwrap_or(0)
    }
    pub fn clear_expires(&mut self) {
        self.expires = ::std::option::Option::None;
    }

    pub fn has_expires(&self) -> bool {
        self.expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expires(&mut self, v: u32) {
        self.expires = ::std::option::Option::Some(v);
    }

    // optional bool secure = 6;


    pub fn get_secure(&self) -> bool {
        self.secure.unwrap_or(false)
    }
    pub fn clear_secure(&mut self) {
        self.secure = ::std::option::Option::None;
    }

    pub fn has_secure(&self) -> bool {
        self.secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure(&mut self, v: bool) {
        self.secure = ::std::option::Option::Some(v);
    }

    // optional bool httponly = 7;


    pub fn get_httponly(&self) -> bool {
        self.httponly.unwrap_or(false)
    }
    pub fn clear_httponly(&mut self) {
        self.httponly = ::std::option::Option::None;
    }

    pub fn has_httponly(&self) -> bool {
        self.httponly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httponly(&mut self, v: bool) {
        self.httponly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetCookie {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expires = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.secure = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.httponly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.expires {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.secure {
            my_size += 2;
        }
        if let Some(v) = self.httponly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.expires {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.secure {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.httponly {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetCookie {
        CMsgSetCookie::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &CMsgSetCookie| { &m.key },
                    |m: &mut CMsgSetCookie| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &CMsgSetCookie| { &m.value },
                    |m: &mut CMsgSetCookie| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &CMsgSetCookie| { &m.path },
                    |m: &mut CMsgSetCookie| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host",
                    |m: &CMsgSetCookie| { &m.host },
                    |m: &mut CMsgSetCookie| { &mut m.host },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expires",
                    |m: &CMsgSetCookie| { &m.expires },
                    |m: &mut CMsgSetCookie| { &mut m.expires },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "secure",
                    |m: &CMsgSetCookie| { &m.secure },
                    |m: &mut CMsgSetCookie| { &mut m.secure },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "httponly",
                    |m: &CMsgSetCookie| { &m.httponly },
                    |m: &mut CMsgSetCookie| { &mut m.httponly },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetCookie>(
                    "CMsgSetCookie",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetCookie {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetCookie> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetCookie,
        };
        unsafe {
            instance.get(CMsgSetCookie::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetCookie {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.path.clear();
        self.host.clear();
        self.expires = ::std::option::Option::None;
        self.secure = ::std::option::Option::None;
        self.httponly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetCookie {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetTargetFrameRate {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    nTargetFrameRate: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetTargetFrameRate {
    fn default() -> &'a CMsgSetTargetFrameRate {
        <CMsgSetTargetFrameRate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetTargetFrameRate {
    pub fn new() -> CMsgSetTargetFrameRate {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 nTargetFrameRate = 2;


    pub fn get_nTargetFrameRate(&self) -> u32 {
        self.nTargetFrameRate.unwrap_or(0)
    }
    pub fn clear_nTargetFrameRate(&mut self) {
        self.nTargetFrameRate = ::std::option::Option::None;
    }

    pub fn has_nTargetFrameRate(&self) -> bool {
        self.nTargetFrameRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nTargetFrameRate(&mut self, v: u32) {
        self.nTargetFrameRate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetTargetFrameRate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nTargetFrameRate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nTargetFrameRate {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nTargetFrameRate {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetTargetFrameRate {
        CMsgSetTargetFrameRate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetTargetFrameRate| { &m.browser_handle },
                    |m: &mut CMsgSetTargetFrameRate| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "nTargetFrameRate",
                    |m: &CMsgSetTargetFrameRate| { &m.nTargetFrameRate },
                    |m: &mut CMsgSetTargetFrameRate| { &mut m.nTargetFrameRate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetTargetFrameRate>(
                    "CMsgSetTargetFrameRate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetTargetFrameRate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetTargetFrameRate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetTargetFrameRate,
        };
        unsafe {
            instance.get(CMsgSetTargetFrameRate::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetTargetFrameRate {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.nTargetFrameRate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetTargetFrameRate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetTargetFrameRate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgPauseRepaint {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPauseRepaint {
    fn default() -> &'a CMsgPauseRepaint {
        <CMsgPauseRepaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPauseRepaint {
    pub fn new() -> CMsgPauseRepaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPauseRepaint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPauseRepaint {
        CMsgPauseRepaint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgPauseRepaint| { &m.browser_handle },
                    |m: &mut CMsgPauseRepaint| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPauseRepaint>(
                    "CMsgPauseRepaint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgPauseRepaint {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPauseRepaint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPauseRepaint,
        };
        unsafe {
            instance.get(CMsgPauseRepaint::new)
        }
    }
}

impl ::protobuf::Clear for CMsgPauseRepaint {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPauseRepaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPauseRepaint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgFullRepaint {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFullRepaint {
    fn default() -> &'a CMsgFullRepaint {
        <CMsgFullRepaint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFullRepaint {
    pub fn new() -> CMsgFullRepaint {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFullRepaint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFullRepaint {
        CMsgFullRepaint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgFullRepaint| { &m.browser_handle },
                    |m: &mut CMsgFullRepaint| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgFullRepaint>(
                    "CMsgFullRepaint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgFullRepaint {
        static mut instance: ::protobuf::lazy::Lazy<CMsgFullRepaint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgFullRepaint,
        };
        unsafe {
            instance.get(CMsgFullRepaint::new)
        }
    }
}

impl ::protobuf::Clear for CMsgFullRepaint {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFullRepaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFullRepaint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgRequestFullScreen {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRequestFullScreen {
    fn default() -> &'a CMsgRequestFullScreen {
        <CMsgRequestFullScreen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestFullScreen {
    pub fn new() -> CMsgRequestFullScreen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRequestFullScreen {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRequestFullScreen {
        CMsgRequestFullScreen::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgRequestFullScreen| { &m.browser_handle },
                    |m: &mut CMsgRequestFullScreen| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestFullScreen>(
                    "CMsgRequestFullScreen",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgRequestFullScreen {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestFullScreen> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestFullScreen,
        };
        unsafe {
            instance.get(CMsgRequestFullScreen::new)
        }
    }
}

impl ::protobuf::Clear for CMsgRequestFullScreen {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestFullScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestFullScreen {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgExitFullScreen {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgExitFullScreen {
    fn default() -> &'a CMsgExitFullScreen {
        <CMsgExitFullScreen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgExitFullScreen {
    pub fn new() -> CMsgExitFullScreen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgExitFullScreen {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgExitFullScreen {
        CMsgExitFullScreen::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgExitFullScreen| { &m.browser_handle },
                    |m: &mut CMsgExitFullScreen| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgExitFullScreen>(
                    "CMsgExitFullScreen",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgExitFullScreen {
        static mut instance: ::protobuf::lazy::Lazy<CMsgExitFullScreen> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgExitFullScreen,
        };
        unsafe {
            instance.get(CMsgExitFullScreen::new)
        }
    }
}

impl ::protobuf::Clear for CMsgExitFullScreen {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgExitFullScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgExitFullScreen {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgToggleFindInPageDialog {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgToggleFindInPageDialog {
    fn default() -> &'a CMsgToggleFindInPageDialog {
        <CMsgToggleFindInPageDialog as ::protobuf::Message>::default_instance()
    }
}

impl CMsgToggleFindInPageDialog {
    pub fn new() -> CMsgToggleFindInPageDialog {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgToggleFindInPageDialog {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgToggleFindInPageDialog {
        CMsgToggleFindInPageDialog::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgToggleFindInPageDialog| { &m.browser_handle },
                    |m: &mut CMsgToggleFindInPageDialog| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgToggleFindInPageDialog>(
                    "CMsgToggleFindInPageDialog",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgToggleFindInPageDialog {
        static mut instance: ::protobuf::lazy::Lazy<CMsgToggleFindInPageDialog> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgToggleFindInPageDialog,
        };
        unsafe {
            instance.get(CMsgToggleFindInPageDialog::new)
        }
    }
}

impl ::protobuf::Clear for CMsgToggleFindInPageDialog {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgToggleFindInPageDialog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgToggleFindInPageDialog {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetPIDShuttingDown {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetPIDShuttingDown {
    fn default() -> &'a CMsgSetPIDShuttingDown {
        <CMsgSetPIDShuttingDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetPIDShuttingDown {
    pub fn new() -> CMsgSetPIDShuttingDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetPIDShuttingDown {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetPIDShuttingDown {
        CMsgSetPIDShuttingDown::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetPIDShuttingDown| { &m.browser_handle },
                    |m: &mut CMsgSetPIDShuttingDown| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetPIDShuttingDown>(
                    "CMsgSetPIDShuttingDown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetPIDShuttingDown {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetPIDShuttingDown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetPIDShuttingDown,
        };
        unsafe {
            instance.get(CMsgSetPIDShuttingDown::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetPIDShuttingDown {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetPIDShuttingDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetPIDShuttingDown {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgDisableBackgroundThrottling {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDisableBackgroundThrottling {
    fn default() -> &'a CMsgDisableBackgroundThrottling {
        <CMsgDisableBackgroundThrottling as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDisableBackgroundThrottling {
    pub fn new() -> CMsgDisableBackgroundThrottling {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDisableBackgroundThrottling {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDisableBackgroundThrottling {
        CMsgDisableBackgroundThrottling::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgDisableBackgroundThrottling| { &m.browser_handle },
                    |m: &mut CMsgDisableBackgroundThrottling| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDisableBackgroundThrottling>(
                    "CMsgDisableBackgroundThrottling",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgDisableBackgroundThrottling {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDisableBackgroundThrottling> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDisableBackgroundThrottling,
        };
        unsafe {
            instance.get(CMsgDisableBackgroundThrottling::new)
        }
    }
}

impl ::protobuf::Clear for CMsgDisableBackgroundThrottling {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDisableBackgroundThrottling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDisableBackgroundThrottling {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgAckPIDShuttingDown {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAckPIDShuttingDown {
    fn default() -> &'a CMsgAckPIDShuttingDown {
        <CMsgAckPIDShuttingDown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAckPIDShuttingDown {
    pub fn new() -> CMsgAckPIDShuttingDown {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAckPIDShuttingDown {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAckPIDShuttingDown {
        CMsgAckPIDShuttingDown::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgAckPIDShuttingDown| { &m.browser_handle },
                    |m: &mut CMsgAckPIDShuttingDown| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgAckPIDShuttingDown>(
                    "CMsgAckPIDShuttingDown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgAckPIDShuttingDown {
        static mut instance: ::protobuf::lazy::Lazy<CMsgAckPIDShuttingDown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgAckPIDShuttingDown,
        };
        unsafe {
            instance.get(CMsgAckPIDShuttingDown::new)
        }
    }
}

impl ::protobuf::Clear for CMsgAckPIDShuttingDown {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAckPIDShuttingDown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAckPIDShuttingDown {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgGetCookiesForURL {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGetCookiesForURL {
    fn default() -> &'a CMsgGetCookiesForURL {
        <CMsgGetCookiesForURL as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetCookiesForURL {
    pub fn new() -> CMsgGetCookiesForURL {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGetCookiesForURL {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGetCookiesForURL {
        CMsgGetCookiesForURL::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgGetCookiesForURL| { &m.browser_handle },
                    |m: &mut CMsgGetCookiesForURL| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgGetCookiesForURL| { &m.url },
                    |m: &mut CMsgGetCookiesForURL| { &mut m.url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGetCookiesForURL>(
                    "CMsgGetCookiesForURL",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGetCookiesForURL {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGetCookiesForURL> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGetCookiesForURL,
        };
        unsafe {
            instance.get(CMsgGetCookiesForURL::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGetCookiesForURL {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGetCookiesForURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGetCookiesForURL {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CCookie {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    domain: ::protobuf::SingularField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCookie {
    fn default() -> &'a CCookie {
        <CCookie as ::protobuf::Message>::default_instance()
    }
}

impl CCookie {
    pub fn new() -> CCookie {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string domain = 3;


    pub fn get_domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain.set_default();
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 4;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCookie {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.domain)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.domain.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCookie {
        CCookie::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CCookie| { &m.name },
                    |m: &mut CCookie| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &CCookie| { &m.value },
                    |m: &mut CCookie| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "domain",
                    |m: &CCookie| { &m.domain },
                    |m: &mut CCookie| { &mut m.domain },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &CCookie| { &m.path },
                    |m: &mut CCookie| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CCookie>(
                    "CCookie",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CCookie {
        static mut instance: ::protobuf::lazy::Lazy<CCookie> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CCookie,
        };
        unsafe {
            instance.get(CCookie::new)
        }
    }
}

impl ::protobuf::Clear for CCookie {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.domain.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCookie {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgGetCookiesForURLResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    cookies: ::protobuf::RepeatedField<CCookie>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGetCookiesForURLResponse {
    fn default() -> &'a CMsgGetCookiesForURLResponse {
        <CMsgGetCookiesForURLResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGetCookiesForURLResponse {
    pub fn new() -> CMsgGetCookiesForURLResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CCookie cookies = 3;


    pub fn get_cookies(&self) -> &[CCookie] {
        &self.cookies
    }
    pub fn clear_cookies(&mut self) {
        self.cookies.clear();
    }

    // Param is passed by value, moved
    pub fn set_cookies(&mut self, v: ::protobuf::RepeatedField<CCookie>) {
        self.cookies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cookies(&mut self) -> &mut ::protobuf::RepeatedField<CCookie> {
        &mut self.cookies
    }

    // Take field
    pub fn take_cookies(&mut self) -> ::protobuf::RepeatedField<CCookie> {
        ::std::mem::replace(&mut self.cookies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGetCookiesForURLResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.cookies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cookies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.cookies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.cookies {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGetCookiesForURLResponse {
        CMsgGetCookiesForURLResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgGetCookiesForURLResponse| { &m.browser_handle },
                    |m: &mut CMsgGetCookiesForURLResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgGetCookiesForURLResponse| { &m.url },
                    |m: &mut CMsgGetCookiesForURLResponse| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCookie>>(
                    "cookies",
                    |m: &CMsgGetCookiesForURLResponse| { &m.cookies },
                    |m: &mut CMsgGetCookiesForURLResponse| { &mut m.cookies },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGetCookiesForURLResponse>(
                    "CMsgGetCookiesForURLResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGetCookiesForURLResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGetCookiesForURLResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGetCookiesForURLResponse,
        };
        unsafe {
            instance.get(CMsgGetCookiesForURLResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGetCookiesForURLResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.cookies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGetCookiesForURLResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGetCookiesForURLResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgNodeHasFocus {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    bInput: ::std::option::Option<bool>,
    name: ::protobuf::SingularField<::std::string::String>,
    elementtagname: ::protobuf::SingularField<::std::string::String>,
    searchbuttontext: ::protobuf::SingularField<::std::string::String>,
    bHasMultipleInputs: ::std::option::Option<bool>,
    input_type: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgNodeHasFocus {
    fn default() -> &'a CMsgNodeHasFocus {
        <CMsgNodeHasFocus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNodeHasFocus {
    pub fn new() -> CMsgNodeHasFocus {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool bInput = 2;


    pub fn get_bInput(&self) -> bool {
        self.bInput.unwrap_or(false)
    }
    pub fn clear_bInput(&mut self) {
        self.bInput = ::std::option::Option::None;
    }

    pub fn has_bInput(&self) -> bool {
        self.bInput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bInput(&mut self, v: bool) {
        self.bInput = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string elementtagname = 4;


    pub fn get_elementtagname(&self) -> &str {
        match self.elementtagname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_elementtagname(&mut self) {
        self.elementtagname.clear();
    }

    pub fn has_elementtagname(&self) -> bool {
        self.elementtagname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elementtagname(&mut self, v: ::std::string::String) {
        self.elementtagname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_elementtagname(&mut self) -> &mut ::std::string::String {
        if self.elementtagname.is_none() {
            self.elementtagname.set_default();
        }
        self.elementtagname.as_mut().unwrap()
    }

    // Take field
    pub fn take_elementtagname(&mut self) -> ::std::string::String {
        self.elementtagname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string searchbuttontext = 5;


    pub fn get_searchbuttontext(&self) -> &str {
        match self.searchbuttontext.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_searchbuttontext(&mut self) {
        self.searchbuttontext.clear();
    }

    pub fn has_searchbuttontext(&self) -> bool {
        self.searchbuttontext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_searchbuttontext(&mut self, v: ::std::string::String) {
        self.searchbuttontext = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_searchbuttontext(&mut self) -> &mut ::std::string::String {
        if self.searchbuttontext.is_none() {
            self.searchbuttontext.set_default();
        }
        self.searchbuttontext.as_mut().unwrap()
    }

    // Take field
    pub fn take_searchbuttontext(&mut self) -> ::std::string::String {
        self.searchbuttontext.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool bHasMultipleInputs = 6;


    pub fn get_bHasMultipleInputs(&self) -> bool {
        self.bHasMultipleInputs.unwrap_or(false)
    }
    pub fn clear_bHasMultipleInputs(&mut self) {
        self.bHasMultipleInputs = ::std::option::Option::None;
    }

    pub fn has_bHasMultipleInputs(&self) -> bool {
        self.bHasMultipleInputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bHasMultipleInputs(&mut self, v: bool) {
        self.bHasMultipleInputs = ::std::option::Option::Some(v);
    }

    // optional string input_type = 7;


    pub fn get_input_type(&self) -> &str {
        match self.input_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_input_type(&mut self) {
        self.input_type.clear();
    }

    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_type(&mut self, v: ::std::string::String) {
        self.input_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_type(&mut self) -> &mut ::std::string::String {
        if self.input_type.is_none() {
            self.input_type.set_default();
        }
        self.input_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_type(&mut self) -> ::std::string::String {
        self.input_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgNodeHasFocus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bInput = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.elementtagname)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.searchbuttontext)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bHasMultipleInputs = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.input_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bInput {
            my_size += 2;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.elementtagname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.searchbuttontext.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bHasMultipleInputs {
            my_size += 2;
        }
        if let Some(ref v) = self.input_type.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bInput {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.elementtagname.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.searchbuttontext.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.bHasMultipleInputs {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.input_type.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgNodeHasFocus {
        CMsgNodeHasFocus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgNodeHasFocus| { &m.browser_handle },
                    |m: &mut CMsgNodeHasFocus| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bInput",
                    |m: &CMsgNodeHasFocus| { &m.bInput },
                    |m: &mut CMsgNodeHasFocus| { &mut m.bInput },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CMsgNodeHasFocus| { &m.name },
                    |m: &mut CMsgNodeHasFocus| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "elementtagname",
                    |m: &CMsgNodeHasFocus| { &m.elementtagname },
                    |m: &mut CMsgNodeHasFocus| { &mut m.elementtagname },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "searchbuttontext",
                    |m: &CMsgNodeHasFocus| { &m.searchbuttontext },
                    |m: &mut CMsgNodeHasFocus| { &mut m.searchbuttontext },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bHasMultipleInputs",
                    |m: &CMsgNodeHasFocus| { &m.bHasMultipleInputs },
                    |m: &mut CMsgNodeHasFocus| { &mut m.bHasMultipleInputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "input_type",
                    |m: &CMsgNodeHasFocus| { &m.input_type },
                    |m: &mut CMsgNodeHasFocus| { &mut m.input_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgNodeHasFocus>(
                    "CMsgNodeHasFocus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgNodeHasFocus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgNodeHasFocus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgNodeHasFocus,
        };
        unsafe {
            instance.get(CMsgNodeHasFocus::new)
        }
    }
}

impl ::protobuf::Clear for CMsgNodeHasFocus {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.bInput = ::std::option::Option::None;
        self.name.clear();
        self.elementtagname.clear();
        self.searchbuttontext.clear();
        self.bHasMultipleInputs = ::std::option::Option::None;
        self.input_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgNodeHasFocus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNodeHasFocus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgZoomToFocusedElement {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgZoomToFocusedElement {
    fn default() -> &'a CMsgZoomToFocusedElement {
        <CMsgZoomToFocusedElement as ::protobuf::Message>::default_instance()
    }
}

impl CMsgZoomToFocusedElement {
    pub fn new() -> CMsgZoomToFocusedElement {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgZoomToFocusedElement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgZoomToFocusedElement {
        CMsgZoomToFocusedElement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgZoomToFocusedElement| { &m.browser_handle },
                    |m: &mut CMsgZoomToFocusedElement| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgZoomToFocusedElement>(
                    "CMsgZoomToFocusedElement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgZoomToFocusedElement {
        static mut instance: ::protobuf::lazy::Lazy<CMsgZoomToFocusedElement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgZoomToFocusedElement,
        };
        unsafe {
            instance.get(CMsgZoomToFocusedElement::new)
        }
    }
}

impl ::protobuf::Clear for CMsgZoomToFocusedElement {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgZoomToFocusedElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgZoomToFocusedElement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgCloseFullScreenFlashIfOpen {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCloseFullScreenFlashIfOpen {
    fn default() -> &'a CMsgCloseFullScreenFlashIfOpen {
        <CMsgCloseFullScreenFlashIfOpen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCloseFullScreenFlashIfOpen {
    pub fn new() -> CMsgCloseFullScreenFlashIfOpen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCloseFullScreenFlashIfOpen {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCloseFullScreenFlashIfOpen {
        CMsgCloseFullScreenFlashIfOpen::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgCloseFullScreenFlashIfOpen| { &m.browser_handle },
                    |m: &mut CMsgCloseFullScreenFlashIfOpen| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCloseFullScreenFlashIfOpen>(
                    "CMsgCloseFullScreenFlashIfOpen",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgCloseFullScreenFlashIfOpen {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCloseFullScreenFlashIfOpen> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCloseFullScreenFlashIfOpen,
        };
        unsafe {
            instance.get(CMsgCloseFullScreenFlashIfOpen::new)
        }
    }
}

impl ::protobuf::Clear for CMsgCloseFullScreenFlashIfOpen {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCloseFullScreenFlashIfOpen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCloseFullScreenFlashIfOpen {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgPauseFullScreenFlashMovieIfOpen {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPauseFullScreenFlashMovieIfOpen {
    fn default() -> &'a CMsgPauseFullScreenFlashMovieIfOpen {
        <CMsgPauseFullScreenFlashMovieIfOpen as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPauseFullScreenFlashMovieIfOpen {
    pub fn new() -> CMsgPauseFullScreenFlashMovieIfOpen {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPauseFullScreenFlashMovieIfOpen {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPauseFullScreenFlashMovieIfOpen {
        CMsgPauseFullScreenFlashMovieIfOpen::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgPauseFullScreenFlashMovieIfOpen| { &m.browser_handle },
                    |m: &mut CMsgPauseFullScreenFlashMovieIfOpen| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPauseFullScreenFlashMovieIfOpen>(
                    "CMsgPauseFullScreenFlashMovieIfOpen",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgPauseFullScreenFlashMovieIfOpen {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPauseFullScreenFlashMovieIfOpen> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPauseFullScreenFlashMovieIfOpen,
        };
        unsafe {
            instance.get(CMsgPauseFullScreenFlashMovieIfOpen::new)
        }
    }
}

impl ::protobuf::Clear for CMsgPauseFullScreenFlashMovieIfOpen {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPauseFullScreenFlashMovieIfOpen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPauseFullScreenFlashMovieIfOpen {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgFocusedNodeText {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFocusedNodeText {
    fn default() -> &'a CMsgFocusedNodeText {
        <CMsgFocusedNodeText as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFocusedNodeText {
    pub fn new() -> CMsgFocusedNodeText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFocusedNodeText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFocusedNodeText {
        CMsgFocusedNodeText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgFocusedNodeText| { &m.browser_handle },
                    |m: &mut CMsgFocusedNodeText| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgFocusedNodeText>(
                    "CMsgFocusedNodeText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgFocusedNodeText {
        static mut instance: ::protobuf::lazy::Lazy<CMsgFocusedNodeText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgFocusedNodeText,
        };
        unsafe {
            instance.get(CMsgFocusedNodeText::new)
        }
    }
}

impl ::protobuf::Clear for CMsgFocusedNodeText {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFocusedNodeText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFocusedNodeText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgFocusedNodeTextResponse {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFocusedNodeTextResponse {
    fn default() -> &'a CMsgFocusedNodeTextResponse {
        <CMsgFocusedNodeTextResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFocusedNodeTextResponse {
    pub fn new() -> CMsgFocusedNodeTextResponse {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgFocusedNodeTextResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFocusedNodeTextResponse {
        CMsgFocusedNodeTextResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgFocusedNodeTextResponse| { &m.browser_handle },
                    |m: &mut CMsgFocusedNodeTextResponse| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &CMsgFocusedNodeTextResponse| { &m.value },
                    |m: &mut CMsgFocusedNodeTextResponse| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgFocusedNodeTextResponse>(
                    "CMsgFocusedNodeTextResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgFocusedNodeTextResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgFocusedNodeTextResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgFocusedNodeTextResponse,
        };
        unsafe {
            instance.get(CMsgFocusedNodeTextResponse::new)
        }
    }
}

impl ::protobuf::Clear for CMsgFocusedNodeTextResponse {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFocusedNodeTextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFocusedNodeTextResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBuildID {
    // message fields
    build_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBuildID {
    fn default() -> &'a CMsgBuildID {
        <CMsgBuildID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBuildID {
    pub fn new() -> CMsgBuildID {
        ::std::default::Default::default()
    }

    // optional uint64 build_id = 1;


    pub fn get_build_id(&self) -> u64 {
        self.build_id.unwrap_or(0)
    }
    pub fn clear_build_id(&mut self) {
        self.build_id = ::std::option::Option::None;
    }

    pub fn has_build_id(&self) -> bool {
        self.build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_id(&mut self, v: u64) {
        self.build_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBuildID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.build_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.build_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.build_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBuildID {
        CMsgBuildID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "build_id",
                    |m: &CMsgBuildID| { &m.build_id },
                    |m: &mut CMsgBuildID| { &mut m.build_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBuildID>(
                    "CMsgBuildID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBuildID {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBuildID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBuildID,
        };
        unsafe {
            instance.get(CMsgBuildID::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBuildID {
    fn clear(&mut self) {
        self.build_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBuildID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBuildID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgOpenDevTools {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgOpenDevTools {
    fn default() -> &'a CMsgOpenDevTools {
        <CMsgOpenDevTools as ::protobuf::Message>::default_instance()
    }
}

impl CMsgOpenDevTools {
    pub fn new() -> CMsgOpenDevTools {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgOpenDevTools {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgOpenDevTools {
        CMsgOpenDevTools::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgOpenDevTools| { &m.browser_handle },
                    |m: &mut CMsgOpenDevTools| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgOpenDevTools>(
                    "CMsgOpenDevTools",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgOpenDevTools {
        static mut instance: ::protobuf::lazy::Lazy<CMsgOpenDevTools> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgOpenDevTools,
        };
        unsafe {
            instance.get(CMsgOpenDevTools::new)
        }
    }
}

impl ::protobuf::Clear for CMsgOpenDevTools {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgOpenDevTools {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgOpenDevTools {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgCloseDevTools {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCloseDevTools {
    fn default() -> &'a CMsgCloseDevTools {
        <CMsgCloseDevTools as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCloseDevTools {
    pub fn new() -> CMsgCloseDevTools {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCloseDevTools {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCloseDevTools {
        CMsgCloseDevTools::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgCloseDevTools| { &m.browser_handle },
                    |m: &mut CMsgCloseDevTools| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCloseDevTools>(
                    "CMsgCloseDevTools",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgCloseDevTools {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCloseDevTools> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCloseDevTools,
        };
        unsafe {
            instance.get(CMsgCloseDevTools::new)
        }
    }
}

impl ::protobuf::Clear for CMsgCloseDevTools {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCloseDevTools {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCloseDevTools {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgUnlockH264 {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    unlock_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgUnlockH264 {
    fn default() -> &'a CMsgUnlockH264 {
        <CMsgUnlockH264 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUnlockH264 {
    pub fn new() -> CMsgUnlockH264 {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string unlock_code = 2;


    pub fn get_unlock_code(&self) -> &str {
        match self.unlock_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_unlock_code(&mut self) {
        self.unlock_code.clear();
    }

    pub fn has_unlock_code(&self) -> bool {
        self.unlock_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlock_code(&mut self, v: ::std::string::String) {
        self.unlock_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unlock_code(&mut self) -> &mut ::std::string::String {
        if self.unlock_code.is_none() {
            self.unlock_code.set_default();
        }
        self.unlock_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_unlock_code(&mut self) -> ::std::string::String {
        self.unlock_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgUnlockH264 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.unlock_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.unlock_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.unlock_code.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgUnlockH264 {
        CMsgUnlockH264::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgUnlockH264| { &m.browser_handle },
                    |m: &mut CMsgUnlockH264| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "unlock_code",
                    |m: &CMsgUnlockH264| { &m.unlock_code },
                    |m: &mut CMsgUnlockH264| { &mut m.unlock_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgUnlockH264>(
                    "CMsgUnlockH264",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgUnlockH264 {
        static mut instance: ::protobuf::lazy::Lazy<CMsgUnlockH264> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgUnlockH264,
        };
        unsafe {
            instance.get(CMsgUnlockH264::new)
        }
    }
}

impl ::protobuf::Clear for CMsgUnlockH264 {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unlock_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUnlockH264 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUnlockH264 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgScreenInformationChanged {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    override_width: ::std::option::Option<u32>,
    override_height: ::std::option::Option<u32>,
    monitor_left: ::std::option::Option<u32>,
    monitor_top: ::std::option::Option<u32>,
    monitor_right: ::std::option::Option<u32>,
    monitor_bottom: ::std::option::Option<u32>,
    usable_left: ::std::option::Option<u32>,
    usable_top: ::std::option::Option<u32>,
    usable_right: ::std::option::Option<u32>,
    usable_bottom: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgScreenInformationChanged {
    fn default() -> &'a CMsgScreenInformationChanged {
        <CMsgScreenInformationChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScreenInformationChanged {
    pub fn new() -> CMsgScreenInformationChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 override_width = 2;


    pub fn get_override_width(&self) -> u32 {
        self.override_width.unwrap_or(0)
    }
    pub fn clear_override_width(&mut self) {
        self.override_width = ::std::option::Option::None;
    }

    pub fn has_override_width(&self) -> bool {
        self.override_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_width(&mut self, v: u32) {
        self.override_width = ::std::option::Option::Some(v);
    }

    // optional uint32 override_height = 3;


    pub fn get_override_height(&self) -> u32 {
        self.override_height.unwrap_or(0)
    }
    pub fn clear_override_height(&mut self) {
        self.override_height = ::std::option::Option::None;
    }

    pub fn has_override_height(&self) -> bool {
        self.override_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_height(&mut self, v: u32) {
        self.override_height = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_left = 4;


    pub fn get_monitor_left(&self) -> u32 {
        self.monitor_left.unwrap_or(0)
    }
    pub fn clear_monitor_left(&mut self) {
        self.monitor_left = ::std::option::Option::None;
    }

    pub fn has_monitor_left(&self) -> bool {
        self.monitor_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_left(&mut self, v: u32) {
        self.monitor_left = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_top = 5;


    pub fn get_monitor_top(&self) -> u32 {
        self.monitor_top.unwrap_or(0)
    }
    pub fn clear_monitor_top(&mut self) {
        self.monitor_top = ::std::option::Option::None;
    }

    pub fn has_monitor_top(&self) -> bool {
        self.monitor_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_top(&mut self, v: u32) {
        self.monitor_top = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_right = 6;


    pub fn get_monitor_right(&self) -> u32 {
        self.monitor_right.unwrap_or(0)
    }
    pub fn clear_monitor_right(&mut self) {
        self.monitor_right = ::std::option::Option::None;
    }

    pub fn has_monitor_right(&self) -> bool {
        self.monitor_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_right(&mut self, v: u32) {
        self.monitor_right = ::std::option::Option::Some(v);
    }

    // optional uint32 monitor_bottom = 7;


    pub fn get_monitor_bottom(&self) -> u32 {
        self.monitor_bottom.unwrap_or(0)
    }
    pub fn clear_monitor_bottom(&mut self) {
        self.monitor_bottom = ::std::option::Option::None;
    }

    pub fn has_monitor_bottom(&self) -> bool {
        self.monitor_bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monitor_bottom(&mut self, v: u32) {
        self.monitor_bottom = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_left = 8;


    pub fn get_usable_left(&self) -> u32 {
        self.usable_left.unwrap_or(0)
    }
    pub fn clear_usable_left(&mut self) {
        self.usable_left = ::std::option::Option::None;
    }

    pub fn has_usable_left(&self) -> bool {
        self.usable_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_left(&mut self, v: u32) {
        self.usable_left = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_top = 9;


    pub fn get_usable_top(&self) -> u32 {
        self.usable_top.unwrap_or(0)
    }
    pub fn clear_usable_top(&mut self) {
        self.usable_top = ::std::option::Option::None;
    }

    pub fn has_usable_top(&self) -> bool {
        self.usable_top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_top(&mut self, v: u32) {
        self.usable_top = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_right = 10;


    pub fn get_usable_right(&self) -> u32 {
        self.usable_right.unwrap_or(0)
    }
    pub fn clear_usable_right(&mut self) {
        self.usable_right = ::std::option::Option::None;
    }

    pub fn has_usable_right(&self) -> bool {
        self.usable_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_right(&mut self, v: u32) {
        self.usable_right = ::std::option::Option::Some(v);
    }

    // optional uint32 usable_bottom = 11;


    pub fn get_usable_bottom(&self) -> u32 {
        self.usable_bottom.unwrap_or(0)
    }
    pub fn clear_usable_bottom(&mut self) {
        self.usable_bottom = ::std::option::Option::None;
    }

    pub fn has_usable_bottom(&self) -> bool {
        self.usable_bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usable_bottom(&mut self, v: u32) {
        self.usable_bottom = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgScreenInformationChanged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.override_width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.override_height = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.monitor_left = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.monitor_top = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.monitor_right = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.monitor_bottom = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.usable_left = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.usable_top = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.usable_right = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.usable_bottom = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.override_width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.override_height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.monitor_left {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.monitor_top {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.monitor_right {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.monitor_bottom {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.usable_left {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.usable_top {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.usable_right {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.usable_bottom {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.override_width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.override_height {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.monitor_left {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.monitor_top {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.monitor_right {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.monitor_bottom {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.usable_left {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.usable_top {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.usable_right {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.usable_bottom {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgScreenInformationChanged {
        CMsgScreenInformationChanged::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgScreenInformationChanged| { &m.browser_handle },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "override_width",
                    |m: &CMsgScreenInformationChanged| { &m.override_width },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.override_width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "override_height",
                    |m: &CMsgScreenInformationChanged| { &m.override_height },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.override_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "monitor_left",
                    |m: &CMsgScreenInformationChanged| { &m.monitor_left },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_left },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "monitor_top",
                    |m: &CMsgScreenInformationChanged| { &m.monitor_top },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_top },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "monitor_right",
                    |m: &CMsgScreenInformationChanged| { &m.monitor_right },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_right },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "monitor_bottom",
                    |m: &CMsgScreenInformationChanged| { &m.monitor_bottom },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.monitor_bottom },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "usable_left",
                    |m: &CMsgScreenInformationChanged| { &m.usable_left },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.usable_left },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "usable_top",
                    |m: &CMsgScreenInformationChanged| { &m.usable_top },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.usable_top },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "usable_right",
                    |m: &CMsgScreenInformationChanged| { &m.usable_right },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.usable_right },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "usable_bottom",
                    |m: &CMsgScreenInformationChanged| { &m.usable_bottom },
                    |m: &mut CMsgScreenInformationChanged| { &mut m.usable_bottom },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgScreenInformationChanged>(
                    "CMsgScreenInformationChanged",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgScreenInformationChanged {
        static mut instance: ::protobuf::lazy::Lazy<CMsgScreenInformationChanged> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgScreenInformationChanged,
        };
        unsafe {
            instance.get(CMsgScreenInformationChanged::new)
        }
    }
}

impl ::protobuf::Clear for CMsgScreenInformationChanged {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.override_width = ::std::option::Option::None;
        self.override_height = ::std::option::Option::None;
        self.monitor_left = ::std::option::Option::None;
        self.monitor_top = ::std::option::Option::None;
        self.monitor_right = ::std::option::Option::None;
        self.monitor_bottom = ::std::option::Option::None;
        self.usable_left = ::std::option::Option::None;
        self.usable_top = ::std::option::Option::None;
        self.usable_right = ::std::option::Option::None;
        self.usable_bottom = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgScreenInformationChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgScreenInformationChanged {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClearAllCookies {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClearAllCookies {
    fn default() -> &'a CMsgClearAllCookies {
        <CMsgClearAllCookies as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearAllCookies {
    pub fn new() -> CMsgClearAllCookies {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClearAllCookies {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClearAllCookies {
        CMsgClearAllCookies::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgClearAllCookies| { &m.browser_handle },
                    |m: &mut CMsgClearAllCookies| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClearAllCookies>(
                    "CMsgClearAllCookies",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgClearAllCookies {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClearAllCookies> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClearAllCookies,
        };
        unsafe {
            instance.get(CMsgClearAllCookies::new)
        }
    }
}

impl ::protobuf::Clear for CMsgClearAllCookies {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClearAllCookies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClearAllCookies {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgScreenDPI {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    dpi_scaling: ::std::option::Option<f32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgScreenDPI {
    fn default() -> &'a CMsgScreenDPI {
        <CMsgScreenDPI as ::protobuf::Message>::default_instance()
    }
}

impl CMsgScreenDPI {
    pub fn new() -> CMsgScreenDPI {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional float dpi_scaling = 2;


    pub fn get_dpi_scaling(&self) -> f32 {
        self.dpi_scaling.unwrap_or(0.)
    }
    pub fn clear_dpi_scaling(&mut self) {
        self.dpi_scaling = ::std::option::Option::None;
    }

    pub fn has_dpi_scaling(&self) -> bool {
        self.dpi_scaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpi_scaling(&mut self, v: f32) {
        self.dpi_scaling = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgScreenDPI {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.dpi_scaling = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dpi_scaling {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.dpi_scaling {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgScreenDPI {
        CMsgScreenDPI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgScreenDPI| { &m.browser_handle },
                    |m: &mut CMsgScreenDPI| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "dpi_scaling",
                    |m: &CMsgScreenDPI| { &m.dpi_scaling },
                    |m: &mut CMsgScreenDPI| { &mut m.dpi_scaling },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgScreenDPI>(
                    "CMsgScreenDPI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgScreenDPI {
        static mut instance: ::protobuf::lazy::Lazy<CMsgScreenDPI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgScreenDPI,
        };
        unsafe {
            instance.get(CMsgScreenDPI::new)
        }
    }
}

impl ::protobuf::Clear for CMsgScreenDPI {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.dpi_scaling = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgScreenDPI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgScreenDPI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgAuthedSteamDomains {
    // message fields
    domains: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAuthedSteamDomains {
    fn default() -> &'a CMsgAuthedSteamDomains {
        <CMsgAuthedSteamDomains as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAuthedSteamDomains {
    pub fn new() -> CMsgAuthedSteamDomains {
        ::std::default::Default::default()
    }

    // repeated string domains = 1;


    pub fn get_domains(&self) -> &[::std::string::String] {
        &self.domains
    }
    pub fn clear_domains(&mut self) {
        self.domains.clear();
    }

    // Param is passed by value, moved
    pub fn set_domains(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.domains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_domains(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.domains
    }

    // Take field
    pub fn take_domains(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.domains, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgAuthedSteamDomains {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.domains)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.domains {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.domains {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAuthedSteamDomains {
        CMsgAuthedSteamDomains::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "domains",
                    |m: &CMsgAuthedSteamDomains| { &m.domains },
                    |m: &mut CMsgAuthedSteamDomains| { &mut m.domains },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgAuthedSteamDomains>(
                    "CMsgAuthedSteamDomains",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgAuthedSteamDomains {
        static mut instance: ::protobuf::lazy::Lazy<CMsgAuthedSteamDomains> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgAuthedSteamDomains,
        };
        unsafe {
            instance.get(CMsgAuthedSteamDomains::new)
        }
    }
}

impl ::protobuf::Clear for CMsgAuthedSteamDomains {
    fn clear(&mut self) {
        self.domains.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAuthedSteamDomains {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAuthedSteamDomains {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamAuthNeeded {
    // message fields
    filler: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamAuthNeeded {
    fn default() -> &'a CMsgSteamAuthNeeded {
        <CMsgSteamAuthNeeded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamAuthNeeded {
    pub fn new() -> CMsgSteamAuthNeeded {
        ::std::default::Default::default()
    }

    // optional bool filler = 1;


    pub fn get_filler(&self) -> bool {
        self.filler.unwrap_or(false)
    }
    pub fn clear_filler(&mut self) {
        self.filler = ::std::option::Option::None;
    }

    pub fn has_filler(&self) -> bool {
        self.filler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filler(&mut self, v: bool) {
        self.filler = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamAuthNeeded {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.filler = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.filler {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.filler {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamAuthNeeded {
        CMsgSteamAuthNeeded::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "filler",
                    |m: &CMsgSteamAuthNeeded| { &m.filler },
                    |m: &mut CMsgSteamAuthNeeded| { &mut m.filler },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSteamAuthNeeded>(
                    "CMsgSteamAuthNeeded",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSteamAuthNeeded {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSteamAuthNeeded> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSteamAuthNeeded,
        };
        unsafe {
            instance.get(CMsgSteamAuthNeeded::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSteamAuthNeeded {
    fn clear(&mut self) {
        self.filler = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamAuthNeeded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamAuthNeeded {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamAuthCookiesSet {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamAuthCookiesSet {
    fn default() -> &'a CMsgSteamAuthCookiesSet {
        <CMsgSteamAuthCookiesSet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamAuthCookiesSet {
    pub fn new() -> CMsgSteamAuthCookiesSet {
        ::std::default::Default::default()
    }

    // optional bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }
    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamAuthCookiesSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamAuthCookiesSet {
        CMsgSteamAuthCookiesSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &CMsgSteamAuthCookiesSet| { &m.success },
                    |m: &mut CMsgSteamAuthCookiesSet| { &mut m.success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSteamAuthCookiesSet>(
                    "CMsgSteamAuthCookiesSet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSteamAuthCookiesSet {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSteamAuthCookiesSet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSteamAuthCookiesSet,
        };
        unsafe {
            instance.get(CMsgSteamAuthCookiesSet::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSteamAuthCookiesSet {
    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamAuthCookiesSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamAuthCookiesSet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJSRegisterMethod {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    method_type: ::std::option::Option<EJSRegisterMethodType>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJSRegisterMethod {
    fn default() -> &'a CMsgJSRegisterMethod {
        <CMsgJSRegisterMethod as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSRegisterMethod {
    pub fn new() -> CMsgJSRegisterMethod {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EJSRegisterMethodType method_type = 3;


    pub fn get_method_type(&self) -> EJSRegisterMethodType {
        self.method_type.unwrap_or(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid)
    }
    pub fn clear_method_type(&mut self) {
        self.method_type = ::std::option::Option::None;
    }

    pub fn has_method_type(&self) -> bool {
        self.method_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_type(&mut self, v: EJSRegisterMethodType) {
        self.method_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgJSRegisterMethod {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.method_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.method_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.method_type {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJSRegisterMethod {
        CMsgJSRegisterMethod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgJSRegisterMethod| { &m.browser_handle },
                    |m: &mut CMsgJSRegisterMethod| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CMsgJSRegisterMethod| { &m.name },
                    |m: &mut CMsgJSRegisterMethod| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EJSRegisterMethodType>>(
                    "method_type",
                    |m: &CMsgJSRegisterMethod| { &m.method_type },
                    |m: &mut CMsgJSRegisterMethod| { &mut m.method_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJSRegisterMethod>(
                    "CMsgJSRegisterMethod",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJSRegisterMethod {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJSRegisterMethod> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJSRegisterMethod,
        };
        unsafe {
            instance.get(CMsgJSRegisterMethod::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJSRegisterMethod {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.name.clear();
        self.method_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJSRegisterMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSRegisterMethod {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CJSMethodArgument {
    // message fields
    json_data: ::protobuf::SingularField<::std::string::String>,
    function_handle: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CJSMethodArgument {
    fn default() -> &'a CJSMethodArgument {
        <CJSMethodArgument as ::protobuf::Message>::default_instance()
    }
}

impl CJSMethodArgument {
    pub fn new() -> CJSMethodArgument {
        ::std::default::Default::default()
    }

    // optional string json_data = 1;


    pub fn get_json_data(&self) -> &str {
        match self.json_data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_json_data(&mut self) {
        self.json_data.clear();
    }

    pub fn has_json_data(&self) -> bool {
        self.json_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_data(&mut self, v: ::std::string::String) {
        self.json_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_data(&mut self) -> &mut ::std::string::String {
        if self.json_data.is_none() {
            self.json_data.set_default();
        }
        self.json_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_data(&mut self) -> ::std::string::String {
        self.json_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 function_handle = 2;


    pub fn get_function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }
    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CJSMethodArgument {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.json_data)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.function_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.json_data.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.json_data.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CJSMethodArgument {
        CJSMethodArgument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "json_data",
                    |m: &CJSMethodArgument| { &m.json_data },
                    |m: &mut CJSMethodArgument| { &mut m.json_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "function_handle",
                    |m: &CJSMethodArgument| { &m.function_handle },
                    |m: &mut CJSMethodArgument| { &mut m.function_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CJSMethodArgument>(
                    "CJSMethodArgument",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CJSMethodArgument {
        static mut instance: ::protobuf::lazy::Lazy<CJSMethodArgument> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CJSMethodArgument,
        };
        unsafe {
            instance.get(CJSMethodArgument::new)
        }
    }
}

impl ::protobuf::Clear for CJSMethodArgument {
    fn clear(&mut self) {
        self.json_data.clear();
        self.function_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CJSMethodArgument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CJSMethodArgument {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJSValue {
    // message fields
    bool_value: ::std::option::Option<bool>,
    int_value: ::std::option::Option<i32>,
    uint_value: ::std::option::Option<u32>,
    double_value: ::std::option::Option<f64>,
    string_value: ::protobuf::SingularField<::std::string::String>,
    function_handle: ::std::option::Option<u64>,
    is_array: ::std::option::Option<bool>,
    array_values: ::protobuf::RepeatedField<CMsgJSValue>,
    is_object: ::std::option::Option<bool>,
    object_properties: ::protobuf::RepeatedField<CMsgJSValue_JSObjectProperty>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJSValue {
    fn default() -> &'a CMsgJSValue {
        <CMsgJSValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSValue {
    pub fn new() -> CMsgJSValue {
        ::std::default::Default::default()
    }

    // optional bool bool_value = 1;


    pub fn get_bool_value(&self) -> bool {
        self.bool_value.unwrap_or(false)
    }
    pub fn clear_bool_value(&mut self) {
        self.bool_value = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        self.bool_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.bool_value = ::std::option::Option::Some(v);
    }

    // optional int32 int_value = 2;


    pub fn get_int_value(&self) -> i32 {
        self.int_value.unwrap_or(0)
    }
    pub fn clear_int_value(&mut self) {
        self.int_value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        self.int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.int_value = ::std::option::Option::Some(v);
    }

    // optional uint32 uint_value = 3;


    pub fn get_uint_value(&self) -> u32 {
        self.uint_value.unwrap_or(0)
    }
    pub fn clear_uint_value(&mut self) {
        self.uint_value = ::std::option::Option::None;
    }

    pub fn has_uint_value(&self) -> bool {
        self.uint_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint_value(&mut self, v: u32) {
        self.uint_value = ::std::option::Option::Some(v);
    }

    // optional double double_value = 4;


    pub fn get_double_value(&self) -> f64 {
        self.double_value.unwrap_or(0.)
    }
    pub fn clear_double_value(&mut self) {
        self.double_value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 5;


    pub fn get_string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.string_value.clear();
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value.set_default();
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 function_handle = 6;


    pub fn get_function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }
    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }

    // optional bool is_array = 8;


    pub fn get_is_array(&self) -> bool {
        self.is_array.unwrap_or(false)
    }
    pub fn clear_is_array(&mut self) {
        self.is_array = ::std::option::Option::None;
    }

    pub fn has_is_array(&self) -> bool {
        self.is_array.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_array(&mut self, v: bool) {
        self.is_array = ::std::option::Option::Some(v);
    }

    // repeated .CMsgJSValue array_values = 9;


    pub fn get_array_values(&self) -> &[CMsgJSValue] {
        &self.array_values
    }
    pub fn clear_array_values(&mut self) {
        self.array_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_array_values(&mut self, v: ::protobuf::RepeatedField<CMsgJSValue>) {
        self.array_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_array_values(&mut self) -> &mut ::protobuf::RepeatedField<CMsgJSValue> {
        &mut self.array_values
    }

    // Take field
    pub fn take_array_values(&mut self) -> ::protobuf::RepeatedField<CMsgJSValue> {
        ::std::mem::replace(&mut self.array_values, ::protobuf::RepeatedField::new())
    }

    // optional bool is_object = 10;


    pub fn get_is_object(&self) -> bool {
        self.is_object.unwrap_or(false)
    }
    pub fn clear_is_object(&mut self) {
        self.is_object = ::std::option::Option::None;
    }

    pub fn has_is_object(&self) -> bool {
        self.is_object.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_object(&mut self, v: bool) {
        self.is_object = ::std::option::Option::Some(v);
    }

    // repeated .CMsgJSValue.JSObjectProperty object_properties = 11;


    pub fn get_object_properties(&self) -> &[CMsgJSValue_JSObjectProperty] {
        &self.object_properties
    }
    pub fn clear_object_properties(&mut self) {
        self.object_properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_properties(&mut self, v: ::protobuf::RepeatedField<CMsgJSValue_JSObjectProperty>) {
        self.object_properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_object_properties(&mut self) -> &mut ::protobuf::RepeatedField<CMsgJSValue_JSObjectProperty> {
        &mut self.object_properties
    }

    // Take field
    pub fn take_object_properties(&mut self) -> ::protobuf::RepeatedField<CMsgJSValue_JSObjectProperty> {
        ::std::mem::replace(&mut self.object_properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgJSValue {
    fn is_initialized(&self) -> bool {
        for v in &self.array_values {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.object_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bool_value = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.int_value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.uint_value = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.double_value = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.string_value)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.function_handle = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_array = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.array_values)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_object = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.object_properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bool_value {
            my_size += 2;
        }
        if let Some(v) = self.int_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.uint_value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.double_value {
            my_size += 9;
        }
        if let Some(ref v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_array {
            my_size += 2;
        }
        for value in &self.array_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.is_object {
            my_size += 2;
        }
        for value in &self.object_properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bool_value {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.int_value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.uint_value {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.double_value {
            os.write_double(4, v)?;
        }
        if let Some(ref v) = self.string_value.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.is_array {
            os.write_bool(8, v)?;
        }
        for v in &self.array_values {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.is_object {
            os.write_bool(10, v)?;
        }
        for v in &self.object_properties {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJSValue {
        CMsgJSValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bool_value",
                    |m: &CMsgJSValue| { &m.bool_value },
                    |m: &mut CMsgJSValue| { &mut m.bool_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "int_value",
                    |m: &CMsgJSValue| { &m.int_value },
                    |m: &mut CMsgJSValue| { &mut m.int_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "uint_value",
                    |m: &CMsgJSValue| { &m.uint_value },
                    |m: &mut CMsgJSValue| { &mut m.uint_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "double_value",
                    |m: &CMsgJSValue| { &m.double_value },
                    |m: &mut CMsgJSValue| { &mut m.double_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "string_value",
                    |m: &CMsgJSValue| { &m.string_value },
                    |m: &mut CMsgJSValue| { &mut m.string_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "function_handle",
                    |m: &CMsgJSValue| { &m.function_handle },
                    |m: &mut CMsgJSValue| { &mut m.function_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_array",
                    |m: &CMsgJSValue| { &m.is_array },
                    |m: &mut CMsgJSValue| { &mut m.is_array },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgJSValue>>(
                    "array_values",
                    |m: &CMsgJSValue| { &m.array_values },
                    |m: &mut CMsgJSValue| { &mut m.array_values },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_object",
                    |m: &CMsgJSValue| { &m.is_object },
                    |m: &mut CMsgJSValue| { &mut m.is_object },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgJSValue_JSObjectProperty>>(
                    "object_properties",
                    |m: &CMsgJSValue| { &m.object_properties },
                    |m: &mut CMsgJSValue| { &mut m.object_properties },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJSValue>(
                    "CMsgJSValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJSValue {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJSValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJSValue,
        };
        unsafe {
            instance.get(CMsgJSValue::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJSValue {
    fn clear(&mut self) {
        self.bool_value = ::std::option::Option::None;
        self.int_value = ::std::option::Option::None;
        self.uint_value = ::std::option::Option::None;
        self.double_value = ::std::option::Option::None;
        self.string_value.clear();
        self.function_handle = ::std::option::Option::None;
        self.is_array = ::std::option::Option::None;
        self.array_values.clear();
        self.is_object = ::std::option::Option::None;
        self.object_properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJSValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJSValue_JSObjectProperty {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularPtrField<CMsgJSValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJSValue_JSObjectProperty {
    fn default() -> &'a CMsgJSValue_JSObjectProperty {
        <CMsgJSValue_JSObjectProperty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSValue_JSObjectProperty {
    pub fn new() -> CMsgJSValue_JSObjectProperty {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgJSValue value = 2;


    pub fn get_value(&self) -> &CMsgJSValue {
        self.value.as_ref().unwrap_or_else(|| CMsgJSValue::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CMsgJSValue) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut CMsgJSValue {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> CMsgJSValue {
        self.value.take().unwrap_or_else(|| CMsgJSValue::new())
    }
}

impl ::protobuf::Message for CMsgJSValue_JSObjectProperty {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJSValue_JSObjectProperty {
        CMsgJSValue_JSObjectProperty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CMsgJSValue_JSObjectProperty| { &m.name },
                    |m: &mut CMsgJSValue_JSObjectProperty| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgJSValue>>(
                    "value",
                    |m: &CMsgJSValue_JSObjectProperty| { &m.value },
                    |m: &mut CMsgJSValue_JSObjectProperty| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJSValue_JSObjectProperty>(
                    "CMsgJSValue_JSObjectProperty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJSValue_JSObjectProperty {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJSValue_JSObjectProperty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJSValue_JSObjectProperty,
        };
        unsafe {
            instance.get(CMsgJSValue_JSObjectProperty::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJSValue_JSObjectProperty {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJSValue_JSObjectProperty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSValue_JSObjectProperty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJSMethodCall {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    arguments: ::protobuf::RepeatedField<CMsgJSValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJSMethodCall {
    fn default() -> &'a CMsgJSMethodCall {
        <CMsgJSMethodCall as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSMethodCall {
    pub fn new() -> CMsgJSMethodCall {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgJSValue arguments = 3;


    pub fn get_arguments(&self) -> &[CMsgJSValue] {
        &self.arguments
    }
    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<CMsgJSValue>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::protobuf::RepeatedField<CMsgJSValue> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<CMsgJSValue> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgJSMethodCall {
    fn is_initialized(&self) -> bool {
        for v in &self.arguments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arguments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.arguments {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJSMethodCall {
        CMsgJSMethodCall::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgJSMethodCall| { &m.browser_handle },
                    |m: &mut CMsgJSMethodCall| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CMsgJSMethodCall| { &m.name },
                    |m: &mut CMsgJSMethodCall| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgJSValue>>(
                    "arguments",
                    |m: &CMsgJSMethodCall| { &m.arguments },
                    |m: &mut CMsgJSMethodCall| { &mut m.arguments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJSMethodCall>(
                    "CMsgJSMethodCall",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJSMethodCall {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJSMethodCall> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJSMethodCall,
        };
        unsafe {
            instance.get(CMsgJSMethodCall::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJSMethodCall {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.name.clear();
        self.arguments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJSMethodCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSMethodCall {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJSExecuteCallback {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    function_handle: ::std::option::Option<u64>,
    arguments: ::protobuf::RepeatedField<CMsgJSValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJSExecuteCallback {
    fn default() -> &'a CMsgJSExecuteCallback {
        <CMsgJSExecuteCallback as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSExecuteCallback {
    pub fn new() -> CMsgJSExecuteCallback {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 function_handle = 2;


    pub fn get_function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }
    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }

    // repeated .CMsgJSValue arguments = 3;


    pub fn get_arguments(&self) -> &[CMsgJSValue] {
        &self.arguments
    }
    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<CMsgJSValue>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::protobuf::RepeatedField<CMsgJSValue> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<CMsgJSValue> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgJSExecuteCallback {
    fn is_initialized(&self) -> bool {
        for v in &self.arguments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.function_handle = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arguments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(2, v)?;
        }
        for v in &self.arguments {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJSExecuteCallback {
        CMsgJSExecuteCallback::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgJSExecuteCallback| { &m.browser_handle },
                    |m: &mut CMsgJSExecuteCallback| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "function_handle",
                    |m: &CMsgJSExecuteCallback| { &m.function_handle },
                    |m: &mut CMsgJSExecuteCallback| { &mut m.function_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgJSValue>>(
                    "arguments",
                    |m: &CMsgJSExecuteCallback| { &m.arguments },
                    |m: &mut CMsgJSExecuteCallback| { &mut m.arguments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJSExecuteCallback>(
                    "CMsgJSExecuteCallback",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJSExecuteCallback {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJSExecuteCallback> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJSExecuteCallback,
        };
        unsafe {
            instance.get(CMsgJSExecuteCallback::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJSExecuteCallback {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.arguments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJSExecuteCallback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSExecuteCallback {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJSReleaseCallback {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    function_handle: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJSReleaseCallback {
    fn default() -> &'a CMsgJSReleaseCallback {
        <CMsgJSReleaseCallback as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSReleaseCallback {
    pub fn new() -> CMsgJSReleaseCallback {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint64 function_handle = 2;


    pub fn get_function_handle(&self) -> u64 {
        self.function_handle.unwrap_or(0)
    }
    pub fn clear_function_handle(&mut self) {
        self.function_handle = ::std::option::Option::None;
    }

    pub fn has_function_handle(&self) -> bool {
        self.function_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_handle(&mut self, v: u64) {
        self.function_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgJSReleaseCallback {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.function_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.function_handle {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.function_handle {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJSReleaseCallback {
        CMsgJSReleaseCallback::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgJSReleaseCallback| { &m.browser_handle },
                    |m: &mut CMsgJSReleaseCallback| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "function_handle",
                    |m: &CMsgJSReleaseCallback| { &m.function_handle },
                    |m: &mut CMsgJSReleaseCallback| { &mut m.function_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJSReleaseCallback>(
                    "CMsgJSReleaseCallback",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJSReleaseCallback {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJSReleaseCallback> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJSReleaseCallback,
        };
        unsafe {
            instance.get(CMsgJSReleaseCallback::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJSReleaseCallback {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.function_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJSReleaseCallback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSReleaseCallback {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJSRaiseException {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    exception: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJSRaiseException {
    fn default() -> &'a CMsgJSRaiseException {
        <CMsgJSRaiseException as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJSRaiseException {
    pub fn new() -> CMsgJSRaiseException {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string exception = 2;


    pub fn get_exception(&self) -> &str {
        match self.exception.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_exception(&mut self) {
        self.exception.clear();
    }

    pub fn has_exception(&self) -> bool {
        self.exception.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception(&mut self, v: ::std::string::String) {
        self.exception = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception(&mut self) -> &mut ::std::string::String {
        if self.exception.is_none() {
            self.exception.set_default();
        }
        self.exception.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception(&mut self) -> ::std::string::String {
        self.exception.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgJSRaiseException {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.exception)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.exception.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.exception.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJSRaiseException {
        CMsgJSRaiseException::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgJSRaiseException| { &m.browser_handle },
                    |m: &mut CMsgJSRaiseException| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "exception",
                    |m: &CMsgJSRaiseException| { &m.exception },
                    |m: &mut CMsgJSRaiseException| { &mut m.exception },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJSRaiseException>(
                    "CMsgJSRaiseException",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJSRaiseException {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJSRaiseException> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJSRaiseException,
        };
        unsafe {
            instance.get(CMsgJSRaiseException::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJSRaiseException {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.exception.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJSRaiseException {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJSRaiseException {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgLoadLocalization {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    localization_path: ::protobuf::SingularField<::std::string::String>,
    language: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLoadLocalization {
    fn default() -> &'a CMsgLoadLocalization {
        <CMsgLoadLocalization as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLoadLocalization {
    pub fn new() -> CMsgLoadLocalization {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string localization_path = 2;


    pub fn get_localization_path(&self) -> &str {
        match self.localization_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_localization_path(&mut self) {
        self.localization_path.clear();
    }

    pub fn has_localization_path(&self) -> bool {
        self.localization_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localization_path(&mut self, v: ::std::string::String) {
        self.localization_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localization_path(&mut self) -> &mut ::std::string::String {
        if self.localization_path.is_none() {
            self.localization_path.set_default();
        }
        self.localization_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_localization_path(&mut self) -> ::std::string::String {
        self.localization_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language = 3;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgLoadLocalization {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localization_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.localization_path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.localization_path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLoadLocalization {
        CMsgLoadLocalization::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgLoadLocalization| { &m.browser_handle },
                    |m: &mut CMsgLoadLocalization| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "localization_path",
                    |m: &CMsgLoadLocalization| { &m.localization_path },
                    |m: &mut CMsgLoadLocalization| { &mut m.localization_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &CMsgLoadLocalization| { &m.language },
                    |m: &mut CMsgLoadLocalization| { &mut m.language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLoadLocalization>(
                    "CMsgLoadLocalization",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgLoadLocalization {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLoadLocalization> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLoadLocalization,
        };
        unsafe {
            instance.get(CMsgLoadLocalization::new)
        }
    }
}

impl ::protobuf::Clear for CMsgLoadLocalization {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.localization_path.clear();
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLoadLocalization {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLoadLocalization {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgJumpListLink {
    // message fields
    display_name: ::protobuf::SingularField<::std::string::String>,
    url_link: ::protobuf::SingularField<::std::string::String>,
    icon_path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgJumpListLink {
    fn default() -> &'a CMsgJumpListLink {
        <CMsgJumpListLink as ::protobuf::Message>::default_instance()
    }
}

impl CMsgJumpListLink {
    pub fn new() -> CMsgJumpListLink {
        ::std::default::Default::default()
    }

    // optional string display_name = 1;


    pub fn get_display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name.set_default();
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url_link = 2;


    pub fn get_url_link(&self) -> &str {
        match self.url_link.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url_link(&mut self) {
        self.url_link.clear();
    }

    pub fn has_url_link(&self) -> bool {
        self.url_link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url_link(&mut self, v: ::std::string::String) {
        self.url_link = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url_link(&mut self) -> &mut ::std::string::String {
        if self.url_link.is_none() {
            self.url_link.set_default();
        }
        self.url_link.as_mut().unwrap()
    }

    // Take field
    pub fn take_url_link(&mut self) -> ::std::string::String {
        self.url_link.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon_path = 3;


    pub fn get_icon_path(&self) -> &str {
        match self.icon_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_icon_path(&mut self) {
        self.icon_path.clear();
    }

    pub fn has_icon_path(&self) -> bool {
        self.icon_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_path(&mut self, v: ::std::string::String) {
        self.icon_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon_path(&mut self) -> &mut ::std::string::String {
        if self.icon_path.is_none() {
            self.icon_path.set_default();
        }
        self.icon_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon_path(&mut self) -> ::std::string::String {
        self.icon_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgJumpListLink {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.display_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url_link)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.icon_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.url_link.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.icon_path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.display_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.url_link.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.icon_path.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgJumpListLink {
        CMsgJumpListLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "display_name",
                    |m: &CMsgJumpListLink| { &m.display_name },
                    |m: &mut CMsgJumpListLink| { &mut m.display_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url_link",
                    |m: &CMsgJumpListLink| { &m.url_link },
                    |m: &mut CMsgJumpListLink| { &mut m.url_link },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "icon_path",
                    |m: &CMsgJumpListLink| { &m.icon_path },
                    |m: &mut CMsgJumpListLink| { &mut m.icon_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgJumpListLink>(
                    "CMsgJumpListLink",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgJumpListLink {
        static mut instance: ::protobuf::lazy::Lazy<CMsgJumpListLink> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgJumpListLink,
        };
        unsafe {
            instance.get(CMsgJumpListLink::new)
        }
    }
}

impl ::protobuf::Clear for CMsgJumpListLink {
    fn clear(&mut self) {
        self.display_name.clear();
        self.url_link.clear();
        self.icon_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgJumpListLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgJumpListLink {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMSgJumpListMRUApp {
    // message fields
    appid: ::std::option::Option<u32>,
    display_name: ::protobuf::SingularField<::std::string::String>,
    url_link: ::protobuf::SingularField<::std::string::String>,
    icon_path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMSgJumpListMRUApp {
    fn default() -> &'a CMSgJumpListMRUApp {
        <CMSgJumpListMRUApp as ::protobuf::Message>::default_instance()
    }
}

impl CMSgJumpListMRUApp {
    pub fn new() -> CMSgJumpListMRUApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name.set_default();
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url_link = 3;


    pub fn get_url_link(&self) -> &str {
        match self.url_link.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url_link(&mut self) {
        self.url_link.clear();
    }

    pub fn has_url_link(&self) -> bool {
        self.url_link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url_link(&mut self, v: ::std::string::String) {
        self.url_link = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url_link(&mut self) -> &mut ::std::string::String {
        if self.url_link.is_none() {
            self.url_link.set_default();
        }
        self.url_link.as_mut().unwrap()
    }

    // Take field
    pub fn take_url_link(&mut self) -> ::std::string::String {
        self.url_link.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon_path = 4;


    pub fn get_icon_path(&self) -> &str {
        match self.icon_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_icon_path(&mut self) {
        self.icon_path.clear();
    }

    pub fn has_icon_path(&self) -> bool {
        self.icon_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_path(&mut self, v: ::std::string::String) {
        self.icon_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon_path(&mut self) -> &mut ::std::string::String {
        if self.icon_path.is_none() {
            self.icon_path.set_default();
        }
        self.icon_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon_path(&mut self) -> ::std::string::String {
        self.icon_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMSgJumpListMRUApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url_link)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.icon_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.url_link.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.icon_path.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.display_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.url_link.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.icon_path.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMSgJumpListMRUApp {
        CMSgJumpListMRUApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CMSgJumpListMRUApp| { &m.appid },
                    |m: &mut CMSgJumpListMRUApp| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "display_name",
                    |m: &CMSgJumpListMRUApp| { &m.display_name },
                    |m: &mut CMSgJumpListMRUApp| { &mut m.display_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url_link",
                    |m: &CMSgJumpListMRUApp| { &m.url_link },
                    |m: &mut CMSgJumpListMRUApp| { &mut m.url_link },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "icon_path",
                    |m: &CMSgJumpListMRUApp| { &m.icon_path },
                    |m: &mut CMSgJumpListMRUApp| { &mut m.icon_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMSgJumpListMRUApp>(
                    "CMSgJumpListMRUApp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMSgJumpListMRUApp {
        static mut instance: ::protobuf::lazy::Lazy<CMSgJumpListMRUApp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMSgJumpListMRUApp,
        };
        unsafe {
            instance.get(CMSgJumpListMRUApp::new)
        }
    }
}

impl ::protobuf::Clear for CMSgJumpListMRUApp {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.display_name.clear();
        self.url_link.clear();
        self.icon_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMSgJumpListMRUApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMSgJumpListMRUApp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetJumpList {
    // message fields
    steam_path: ::protobuf::SingularField<::std::string::String>,
    mru_title: ::protobuf::SingularField<::std::string::String>,
    apps: ::protobuf::RepeatedField<CMSgJumpListMRUApp>,
    links: ::protobuf::RepeatedField<CMsgJumpListLink>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetJumpList {
    fn default() -> &'a CMsgSetJumpList {
        <CMsgSetJumpList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetJumpList {
    pub fn new() -> CMsgSetJumpList {
        ::std::default::Default::default()
    }

    // optional string steam_path = 1;


    pub fn get_steam_path(&self) -> &str {
        match self.steam_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_steam_path(&mut self) {
        self.steam_path.clear();
    }

    pub fn has_steam_path(&self) -> bool {
        self.steam_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_path(&mut self, v: ::std::string::String) {
        self.steam_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steam_path(&mut self) -> &mut ::std::string::String {
        if self.steam_path.is_none() {
            self.steam_path.set_default();
        }
        self.steam_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_steam_path(&mut self) -> ::std::string::String {
        self.steam_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mru_title = 2;


    pub fn get_mru_title(&self) -> &str {
        match self.mru_title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mru_title(&mut self) {
        self.mru_title.clear();
    }

    pub fn has_mru_title(&self) -> bool {
        self.mru_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mru_title(&mut self, v: ::std::string::String) {
        self.mru_title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mru_title(&mut self) -> &mut ::std::string::String {
        if self.mru_title.is_none() {
            self.mru_title.set_default();
        }
        self.mru_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_mru_title(&mut self) -> ::std::string::String {
        self.mru_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMSgJumpListMRUApp apps = 3;


    pub fn get_apps(&self) -> &[CMSgJumpListMRUApp] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMSgJumpListMRUApp>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<CMSgJumpListMRUApp> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMSgJumpListMRUApp> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgJumpListLink links = 4;


    pub fn get_links(&self) -> &[CMsgJumpListLink] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<CMsgJumpListLink>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<CMsgJumpListLink> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<CMsgJumpListLink> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSetJumpList {
    fn is_initialized(&self) -> bool {
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.steam_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mru_title)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.steam_path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.mru_title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.steam_path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.mru_title.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.apps {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.links {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetJumpList {
        CMsgSetJumpList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "steam_path",
                    |m: &CMsgSetJumpList| { &m.steam_path },
                    |m: &mut CMsgSetJumpList| { &mut m.steam_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mru_title",
                    |m: &CMsgSetJumpList| { &m.mru_title },
                    |m: &mut CMsgSetJumpList| { &mut m.mru_title },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMSgJumpListMRUApp>>(
                    "apps",
                    |m: &CMsgSetJumpList| { &m.apps },
                    |m: &mut CMsgSetJumpList| { &mut m.apps },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgJumpListLink>>(
                    "links",
                    |m: &CMsgSetJumpList| { &m.links },
                    |m: &mut CMsgSetJumpList| { &mut m.links },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetJumpList>(
                    "CMsgSetJumpList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetJumpList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetJumpList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetJumpList,
        };
        unsafe {
            instance.get(CMsgSetJumpList::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetJumpList {
    fn clear(&mut self) {
        self.steam_path.clear();
        self.mru_title.clear();
        self.apps.clear();
        self.links.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetJumpList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetJumpList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetGameOverlayTargetPIDs {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    target_pid: ::std::vec::Vec<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetGameOverlayTargetPIDs {
    fn default() -> &'a CMsgSetGameOverlayTargetPIDs {
        <CMsgSetGameOverlayTargetPIDs as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetGameOverlayTargetPIDs {
    pub fn new() -> CMsgSetGameOverlayTargetPIDs {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // repeated uint32 target_pid = 2;


    pub fn get_target_pid(&self) -> &[u32] {
        &self.target_pid
    }
    pub fn clear_target_pid(&mut self) {
        self.target_pid.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_pid(&mut self, v: ::std::vec::Vec<u32>) {
        self.target_pid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_target_pid(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.target_pid
    }

    // Take field
    pub fn take_target_pid(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.target_pid, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgSetGameOverlayTargetPIDs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.target_pid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.target_pid {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.target_pid {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetGameOverlayTargetPIDs {
        CMsgSetGameOverlayTargetPIDs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetGameOverlayTargetPIDs| { &m.browser_handle },
                    |m: &mut CMsgSetGameOverlayTargetPIDs| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_pid",
                    |m: &CMsgSetGameOverlayTargetPIDs| { &m.target_pid },
                    |m: &mut CMsgSetGameOverlayTargetPIDs| { &mut m.target_pid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetGameOverlayTargetPIDs>(
                    "CMsgSetGameOverlayTargetPIDs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetGameOverlayTargetPIDs {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetGameOverlayTargetPIDs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetGameOverlayTargetPIDs,
        };
        unsafe {
            instance.get(CMsgSetGameOverlayTargetPIDs::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetGameOverlayTargetPIDs {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.target_pid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetGameOverlayTargetPIDs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetGameOverlayTargetPIDs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgGameOverlayTargetTextureID {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    target_pid: ::std::option::Option<u32>,
    texture_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameOverlayTargetTextureID {
    fn default() -> &'a CMsgGameOverlayTargetTextureID {
        <CMsgGameOverlayTargetTextureID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameOverlayTargetTextureID {
    pub fn new() -> CMsgGameOverlayTargetTextureID {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 target_pid = 2;


    pub fn get_target_pid(&self) -> u32 {
        self.target_pid.unwrap_or(0)
    }
    pub fn clear_target_pid(&mut self) {
        self.target_pid = ::std::option::Option::None;
    }

    pub fn has_target_pid(&self) -> bool {
        self.target_pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_pid(&mut self, v: u32) {
        self.target_pid = ::std::option::Option::Some(v);
    }

    // optional uint32 texture_handle = 3;


    pub fn get_texture_handle(&self) -> u32 {
        self.texture_handle.unwrap_or(0)
    }
    pub fn clear_texture_handle(&mut self) {
        self.texture_handle = ::std::option::Option::None;
    }

    pub fn has_texture_handle(&self) -> bool {
        self.texture_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_handle(&mut self, v: u32) {
        self.texture_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameOverlayTargetTextureID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_pid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.texture_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_pid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.texture_handle {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_pid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.texture_handle {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameOverlayTargetTextureID {
        CMsgGameOverlayTargetTextureID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgGameOverlayTargetTextureID| { &m.browser_handle },
                    |m: &mut CMsgGameOverlayTargetTextureID| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_pid",
                    |m: &CMsgGameOverlayTargetTextureID| { &m.target_pid },
                    |m: &mut CMsgGameOverlayTargetTextureID| { &mut m.target_pid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "texture_handle",
                    |m: &CMsgGameOverlayTargetTextureID| { &m.texture_handle },
                    |m: &mut CMsgGameOverlayTargetTextureID| { &mut m.texture_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameOverlayTargetTextureID>(
                    "CMsgGameOverlayTargetTextureID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgGameOverlayTargetTextureID {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameOverlayTargetTextureID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameOverlayTargetTextureID,
        };
        unsafe {
            instance.get(CMsgGameOverlayTargetTextureID::new)
        }
    }
}

impl ::protobuf::Clear for CMsgGameOverlayTargetTextureID {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.target_pid = ::std::option::Option::None;
        self.texture_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameOverlayTargetTextureID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameOverlayTargetTextureID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgDraggableRegionsChanged {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    rects: ::protobuf::RepeatedField<CMsgDraggableRegionsChanged_DraggableRects>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDraggableRegionsChanged {
    fn default() -> &'a CMsgDraggableRegionsChanged {
        <CMsgDraggableRegionsChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDraggableRegionsChanged {
    pub fn new() -> CMsgDraggableRegionsChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // repeated .CMsgDraggableRegionsChanged.DraggableRects rects = 2;


    pub fn get_rects(&self) -> &[CMsgDraggableRegionsChanged_DraggableRects] {
        &self.rects
    }
    pub fn clear_rects(&mut self) {
        self.rects.clear();
    }

    // Param is passed by value, moved
    pub fn set_rects(&mut self, v: ::protobuf::RepeatedField<CMsgDraggableRegionsChanged_DraggableRects>) {
        self.rects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rects(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDraggableRegionsChanged_DraggableRects> {
        &mut self.rects
    }

    // Take field
    pub fn take_rects(&mut self) -> ::protobuf::RepeatedField<CMsgDraggableRegionsChanged_DraggableRects> {
        ::std::mem::replace(&mut self.rects, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgDraggableRegionsChanged {
    fn is_initialized(&self) -> bool {
        for v in &self.rects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rects)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.rects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        for v in &self.rects {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDraggableRegionsChanged {
        CMsgDraggableRegionsChanged::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgDraggableRegionsChanged| { &m.browser_handle },
                    |m: &mut CMsgDraggableRegionsChanged| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDraggableRegionsChanged_DraggableRects>>(
                    "rects",
                    |m: &CMsgDraggableRegionsChanged| { &m.rects },
                    |m: &mut CMsgDraggableRegionsChanged| { &mut m.rects },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDraggableRegionsChanged>(
                    "CMsgDraggableRegionsChanged",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgDraggableRegionsChanged {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDraggableRegionsChanged> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDraggableRegionsChanged,
        };
        unsafe {
            instance.get(CMsgDraggableRegionsChanged::new)
        }
    }
}

impl ::protobuf::Clear for CMsgDraggableRegionsChanged {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.rects.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDraggableRegionsChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDraggableRegionsChanged {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgDraggableRegionsChanged_DraggableRects {
    // message fields
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    draggable: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDraggableRegionsChanged_DraggableRects {
    fn default() -> &'a CMsgDraggableRegionsChanged_DraggableRects {
        <CMsgDraggableRegionsChanged_DraggableRects as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDraggableRegionsChanged_DraggableRects {
    pub fn new() -> CMsgDraggableRegionsChanged_DraggableRects {
        ::std::default::Default::default()
    }

    // optional int32 x = 1;


    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 2;


    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional int32 width = 3;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 4;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional bool draggable = 5;


    pub fn get_draggable(&self) -> bool {
        self.draggable.unwrap_or(false)
    }
    pub fn clear_draggable(&mut self) {
        self.draggable = ::std::option::Option::None;
    }

    pub fn has_draggable(&self) -> bool {
        self.draggable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_draggable(&mut self, v: bool) {
        self.draggable = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDraggableRegionsChanged_DraggableRects {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.draggable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.draggable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.x {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.draggable {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDraggableRegionsChanged_DraggableRects {
        CMsgDraggableRegionsChanged_DraggableRects::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    |m: &CMsgDraggableRegionsChanged_DraggableRects| { &m.x },
                    |m: &mut CMsgDraggableRegionsChanged_DraggableRects| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    |m: &CMsgDraggableRegionsChanged_DraggableRects| { &m.y },
                    |m: &mut CMsgDraggableRegionsChanged_DraggableRects| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "width",
                    |m: &CMsgDraggableRegionsChanged_DraggableRects| { &m.width },
                    |m: &mut CMsgDraggableRegionsChanged_DraggableRects| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "height",
                    |m: &CMsgDraggableRegionsChanged_DraggableRects| { &m.height },
                    |m: &mut CMsgDraggableRegionsChanged_DraggableRects| { &mut m.height },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "draggable",
                    |m: &CMsgDraggableRegionsChanged_DraggableRects| { &m.draggable },
                    |m: &mut CMsgDraggableRegionsChanged_DraggableRects| { &mut m.draggable },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDraggableRegionsChanged_DraggableRects>(
                    "CMsgDraggableRegionsChanged_DraggableRects",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgDraggableRegionsChanged_DraggableRects {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDraggableRegionsChanged_DraggableRects> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDraggableRegionsChanged_DraggableRects,
        };
        unsafe {
            instance.get(CMsgDraggableRegionsChanged_DraggableRects::new)
        }
    }
}

impl ::protobuf::Clear for CMsgDraggableRegionsChanged_DraggableRects {
    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.draggable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDraggableRegionsChanged_DraggableRects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDraggableRegionsChanged_DraggableRects {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgResizeGripChanged {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgResizeGripChanged {
    fn default() -> &'a CMsgResizeGripChanged {
        <CMsgResizeGripChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgResizeGripChanged {
    pub fn new() -> CMsgResizeGripChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgResizeGripChanged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgResizeGripChanged {
        CMsgResizeGripChanged::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgResizeGripChanged| { &m.browser_handle },
                    |m: &mut CMsgResizeGripChanged| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "width",
                    |m: &CMsgResizeGripChanged| { &m.width },
                    |m: &mut CMsgResizeGripChanged| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "height",
                    |m: &CMsgResizeGripChanged| { &m.height },
                    |m: &mut CMsgResizeGripChanged| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgResizeGripChanged>(
                    "CMsgResizeGripChanged",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgResizeGripChanged {
        static mut instance: ::protobuf::lazy::Lazy<CMsgResizeGripChanged> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgResizeGripChanged,
        };
        unsafe {
            instance.get(CMsgResizeGripChanged::new)
        }
    }
}

impl ::protobuf::Clear for CMsgResizeGripChanged {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgResizeGripChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgResizeGripChanged {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetWindowPosition {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetWindowPosition {
    fn default() -> &'a CMsgSetWindowPosition {
        <CMsgSetWindowPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetWindowPosition {
    pub fn new() -> CMsgSetWindowPosition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional int32 x = 2;


    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional int32 y = 3;


    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional int32 width = 4;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 5;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetWindowPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetWindowPosition {
        CMsgSetWindowPosition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetWindowPosition| { &m.browser_handle },
                    |m: &mut CMsgSetWindowPosition| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    |m: &CMsgSetWindowPosition| { &m.x },
                    |m: &mut CMsgSetWindowPosition| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    |m: &CMsgSetWindowPosition| { &m.y },
                    |m: &mut CMsgSetWindowPosition| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "width",
                    |m: &CMsgSetWindowPosition| { &m.width },
                    |m: &mut CMsgSetWindowPosition| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "height",
                    |m: &CMsgSetWindowPosition| { &m.height },
                    |m: &mut CMsgSetWindowPosition| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetWindowPosition>(
                    "CMsgSetWindowPosition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetWindowPosition {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetWindowPosition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetWindowPosition,
        };
        unsafe {
            instance.get(CMsgSetWindowPosition::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetWindowPosition {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetWindowPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetWindowPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgShowWindow {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgShowWindow {
    fn default() -> &'a CMsgShowWindow {
        <CMsgShowWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowWindow {
    pub fn new() -> CMsgShowWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgShowWindow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgShowWindow {
        CMsgShowWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgShowWindow| { &m.browser_handle },
                    |m: &mut CMsgShowWindow| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgShowWindow>(
                    "CMsgShowWindow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgShowWindow {
        static mut instance: ::protobuf::lazy::Lazy<CMsgShowWindow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgShowWindow,
        };
        unsafe {
            instance.get(CMsgShowWindow::new)
        }
    }
}

impl ::protobuf::Clear for CMsgShowWindow {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgShowWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgShowWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgHideWindow {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgHideWindow {
    fn default() -> &'a CMsgHideWindow {
        <CMsgHideWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHideWindow {
    pub fn new() -> CMsgHideWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHideWindow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgHideWindow {
        CMsgHideWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgHideWindow| { &m.browser_handle },
                    |m: &mut CMsgHideWindow| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgHideWindow>(
                    "CMsgHideWindow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgHideWindow {
        static mut instance: ::protobuf::lazy::Lazy<CMsgHideWindow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgHideWindow,
        };
        unsafe {
            instance.get(CMsgHideWindow::new)
        }
    }
}

impl ::protobuf::Clear for CMsgHideWindow {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgHideWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHideWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgBringWindowToFront {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBringWindowToFront {
    fn default() -> &'a CMsgBringWindowToFront {
        <CMsgBringWindowToFront as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBringWindowToFront {
    pub fn new() -> CMsgBringWindowToFront {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBringWindowToFront {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBringWindowToFront {
        CMsgBringWindowToFront::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgBringWindowToFront| { &m.browser_handle },
                    |m: &mut CMsgBringWindowToFront| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBringWindowToFront>(
                    "CMsgBringWindowToFront",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgBringWindowToFront {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBringWindowToFront> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBringWindowToFront,
        };
        unsafe {
            instance.get(CMsgBringWindowToFront::new)
        }
    }
}

impl ::protobuf::Clear for CMsgBringWindowToFront {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBringWindowToFront {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBringWindowToFront {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSetForegroundWindow {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetForegroundWindow {
    fn default() -> &'a CMsgSetForegroundWindow {
        <CMsgSetForegroundWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetForegroundWindow {
    pub fn new() -> CMsgSetForegroundWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetForegroundWindow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetForegroundWindow {
        CMsgSetForegroundWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgSetForegroundWindow| { &m.browser_handle },
                    |m: &mut CMsgSetForegroundWindow| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetForegroundWindow>(
                    "CMsgSetForegroundWindow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgSetForegroundWindow {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetForegroundWindow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetForegroundWindow,
        };
        unsafe {
            instance.get(CMsgSetForegroundWindow::new)
        }
    }
}

impl ::protobuf::Clear for CMsgSetForegroundWindow {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetForegroundWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetForegroundWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgMaximizeRestoreWindow {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMaximizeRestoreWindow {
    fn default() -> &'a CMsgMaximizeRestoreWindow {
        <CMsgMaximizeRestoreWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMaximizeRestoreWindow {
    pub fn new() -> CMsgMaximizeRestoreWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMaximizeRestoreWindow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMaximizeRestoreWindow {
        CMsgMaximizeRestoreWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgMaximizeRestoreWindow| { &m.browser_handle },
                    |m: &mut CMsgMaximizeRestoreWindow| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMaximizeRestoreWindow>(
                    "CMsgMaximizeRestoreWindow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgMaximizeRestoreWindow {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMaximizeRestoreWindow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMaximizeRestoreWindow,
        };
        unsafe {
            instance.get(CMsgMaximizeRestoreWindow::new)
        }
    }
}

impl ::protobuf::Clear for CMsgMaximizeRestoreWindow {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMaximizeRestoreWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMaximizeRestoreWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgMinimizeWindow {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMinimizeWindow {
    fn default() -> &'a CMsgMinimizeWindow {
        <CMsgMinimizeWindow as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMinimizeWindow {
    pub fn new() -> CMsgMinimizeWindow {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMinimizeWindow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMinimizeWindow {
        CMsgMinimizeWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgMinimizeWindow| { &m.browser_handle },
                    |m: &mut CMsgMinimizeWindow| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMinimizeWindow>(
                    "CMsgMinimizeWindow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgMinimizeWindow {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMinimizeWindow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMinimizeWindow,
        };
        unsafe {
            instance.get(CMsgMinimizeWindow::new)
        }
    }
}

impl ::protobuf::Clear for CMsgMinimizeWindow {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMinimizeWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMinimizeWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgShowBrowserContextMenu {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgShowBrowserContextMenu {
    fn default() -> &'a CMsgShowBrowserContextMenu {
        <CMsgShowBrowserContextMenu as ::protobuf::Message>::default_instance()
    }
}

impl CMsgShowBrowserContextMenu {
    pub fn new() -> CMsgShowBrowserContextMenu {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgShowBrowserContextMenu {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgShowBrowserContextMenu {
        CMsgShowBrowserContextMenu::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgShowBrowserContextMenu| { &m.browser_handle },
                    |m: &mut CMsgShowBrowserContextMenu| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgShowBrowserContextMenu>(
                    "CMsgShowBrowserContextMenu",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgShowBrowserContextMenu {
        static mut instance: ::protobuf::lazy::Lazy<CMsgShowBrowserContextMenu> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgShowBrowserContextMenu,
        };
        unsafe {
            instance.get(CMsgShowBrowserContextMenu::new)
        }
    }
}

impl ::protobuf::Clear for CMsgShowBrowserContextMenu {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgShowBrowserContextMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgShowBrowserContextMenu {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgImeSetComposition {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgImeSetComposition {
    fn default() -> &'a CMsgImeSetComposition {
        <CMsgImeSetComposition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeSetComposition {
    pub fn new() -> CMsgImeSetComposition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgImeSetComposition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgImeSetComposition {
        CMsgImeSetComposition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgImeSetComposition| { &m.browser_handle },
                    |m: &mut CMsgImeSetComposition| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CMsgImeSetComposition| { &m.text },
                    |m: &mut CMsgImeSetComposition| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgImeSetComposition>(
                    "CMsgImeSetComposition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgImeSetComposition {
        static mut instance: ::protobuf::lazy::Lazy<CMsgImeSetComposition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgImeSetComposition,
        };
        unsafe {
            instance.get(CMsgImeSetComposition::new)
        }
    }
}

impl ::protobuf::Clear for CMsgImeSetComposition {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgImeSetComposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgImeSetComposition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgImeCommitText {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgImeCommitText {
    fn default() -> &'a CMsgImeCommitText {
        <CMsgImeCommitText as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeCommitText {
    pub fn new() -> CMsgImeCommitText {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgImeCommitText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgImeCommitText {
        CMsgImeCommitText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgImeCommitText| { &m.browser_handle },
                    |m: &mut CMsgImeCommitText| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &CMsgImeCommitText| { &m.text },
                    |m: &mut CMsgImeCommitText| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgImeCommitText>(
                    "CMsgImeCommitText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgImeCommitText {
        static mut instance: ::protobuf::lazy::Lazy<CMsgImeCommitText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgImeCommitText,
        };
        unsafe {
            instance.get(CMsgImeCommitText::new)
        }
    }
}

impl ::protobuf::Clear for CMsgImeCommitText {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgImeCommitText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgImeCommitText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgImeCancelComposition {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgImeCancelComposition {
    fn default() -> &'a CMsgImeCancelComposition {
        <CMsgImeCancelComposition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeCancelComposition {
    pub fn new() -> CMsgImeCancelComposition {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgImeCancelComposition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgImeCancelComposition {
        CMsgImeCancelComposition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgImeCancelComposition| { &m.browser_handle },
                    |m: &mut CMsgImeCancelComposition| { &mut m.browser_handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgImeCancelComposition>(
                    "CMsgImeCancelComposition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgImeCancelComposition {
        static mut instance: ::protobuf::lazy::Lazy<CMsgImeCancelComposition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgImeCancelComposition,
        };
        unsafe {
            instance.get(CMsgImeCancelComposition::new)
        }
    }
}

impl ::protobuf::Clear for CMsgImeCancelComposition {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgImeCancelComposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgImeCancelComposition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgImeCompositionRangeChanged {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    x: ::std::option::Option<u32>,
    y: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgImeCompositionRangeChanged {
    fn default() -> &'a CMsgImeCompositionRangeChanged {
        <CMsgImeCompositionRangeChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgImeCompositionRangeChanged {
    pub fn new() -> CMsgImeCompositionRangeChanged {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;


    pub fn get_x(&self) -> u32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;


    pub fn get_y(&self) -> u32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgImeCompositionRangeChanged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgImeCompositionRangeChanged {
        CMsgImeCompositionRangeChanged::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgImeCompositionRangeChanged| { &m.browser_handle },
                    |m: &mut CMsgImeCompositionRangeChanged| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "x",
                    |m: &CMsgImeCompositionRangeChanged| { &m.x },
                    |m: &mut CMsgImeCompositionRangeChanged| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "y",
                    |m: &CMsgImeCompositionRangeChanged| { &m.y },
                    |m: &mut CMsgImeCompositionRangeChanged| { &mut m.y },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgImeCompositionRangeChanged>(
                    "CMsgImeCompositionRangeChanged",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgImeCompositionRangeChanged {
        static mut instance: ::protobuf::lazy::Lazy<CMsgImeCompositionRangeChanged> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgImeCompositionRangeChanged,
        };
        unsafe {
            instance.get(CMsgImeCompositionRangeChanged::new)
        }
    }
}

impl ::protobuf::Clear for CMsgImeCompositionRangeChanged {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgImeCompositionRangeChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgImeCompositionRangeChanged {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgInspectElement {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    x: ::std::option::Option<u32>,
    y: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgInspectElement {
    fn default() -> &'a CMsgInspectElement {
        <CMsgInspectElement as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInspectElement {
    pub fn new() -> CMsgInspectElement {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 x = 2;


    pub fn get_x(&self) -> u32 {
        self.x.unwrap_or(0)
    }
    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: u32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional uint32 y = 3;


    pub fn get_y(&self) -> u32 {
        self.y.unwrap_or(0)
    }
    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: u32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgInspectElement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgInspectElement {
        CMsgInspectElement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgInspectElement| { &m.browser_handle },
                    |m: &mut CMsgInspectElement| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "x",
                    |m: &CMsgInspectElement| { &m.x },
                    |m: &mut CMsgInspectElement| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "y",
                    |m: &CMsgInspectElement| { &m.y },
                    |m: &mut CMsgInspectElement| { &mut m.y },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgInspectElement>(
                    "CMsgInspectElement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgInspectElement {
        static mut instance: ::protobuf::lazy::Lazy<CMsgInspectElement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgInspectElement,
        };
        unsafe {
            instance.get(CMsgInspectElement::new)
        }
    }
}

impl ::protobuf::Clear for CMsgInspectElement {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgInspectElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInspectElement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgDisableF5 {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    disable: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDisableF5 {
    fn default() -> &'a CMsgDisableF5 {
        <CMsgDisableF5 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDisableF5 {
    pub fn new() -> CMsgDisableF5 {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional bool disable = 2;


    pub fn get_disable(&self) -> bool {
        self.disable.unwrap_or(false)
    }
    pub fn clear_disable(&mut self) {
        self.disable = ::std::option::Option::None;
    }

    pub fn has_disable(&self) -> bool {
        self.disable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable(&mut self, v: bool) {
        self.disable = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDisableF5 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.disable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.disable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDisableF5 {
        CMsgDisableF5::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgDisableF5| { &m.browser_handle },
                    |m: &mut CMsgDisableF5| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disable",
                    |m: &CMsgDisableF5| { &m.disable },
                    |m: &mut CMsgDisableF5| { &mut m.disable },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDisableF5>(
                    "CMsgDisableF5",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgDisableF5 {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDisableF5> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDisableF5,
        };
        unsafe {
            instance.get(CMsgDisableF5::new)
        }
    }
}

impl ::protobuf::Clear for CMsgDisableF5 {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.disable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDisableF5 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDisableF5 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgStartDownload {
    // message fields
    browser_handle: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgStartDownload {
    fn default() -> &'a CMsgStartDownload {
        <CMsgStartDownload as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStartDownload {
    pub fn new() -> CMsgStartDownload {
        ::std::default::Default::default()
    }

    // optional uint32 browser_handle = 1;


    pub fn get_browser_handle(&self) -> u32 {
        self.browser_handle.unwrap_or(0)
    }
    pub fn clear_browser_handle(&mut self) {
        self.browser_handle = ::std::option::Option::None;
    }

    pub fn has_browser_handle(&self) -> bool {
        self.browser_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_browser_handle(&mut self, v: u32) {
        self.browser_handle = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgStartDownload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.browser_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.browser_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.browser_handle {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgStartDownload {
        CMsgStartDownload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "browser_handle",
                    |m: &CMsgStartDownload| { &m.browser_handle },
                    |m: &mut CMsgStartDownload| { &mut m.browser_handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CMsgStartDownload| { &m.url },
                    |m: &mut CMsgStartDownload| { &mut m.url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgStartDownload>(
                    "CMsgStartDownload",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CMsgStartDownload {
        static mut instance: ::protobuf::lazy::Lazy<CMsgStartDownload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgStartDownload,
        };
        unsafe {
            instance.get(CMsgStartDownload::new)
        }
    }
}

impl ::protobuf::Clear for CMsgStartDownload {
    fn clear(&mut self) {
        self.browser_handle = ::std::option::Option::None;
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgStartDownload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStartDownload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EJSRegisterMethodType {
    k_EJSRegisterMethodType_Invalid = 0,
    k_EJSRegisterMethodType_Function = 1,
    k_EJSRegisterMethodType_Callback = 2,
    k_EJSRegisterMethodType_Promise = 3,
}

impl ::protobuf::ProtobufEnum for EJSRegisterMethodType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EJSRegisterMethodType> {
        match value {
            0 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid),
            1 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Function),
            2 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Callback),
            3 => ::std::option::Option::Some(EJSRegisterMethodType::k_EJSRegisterMethodType_Promise),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EJSRegisterMethodType] = &[
            EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid,
            EJSRegisterMethodType::k_EJSRegisterMethodType_Function,
            EJSRegisterMethodType::k_EJSRegisterMethodType_Callback,
            EJSRegisterMethodType::k_EJSRegisterMethodType_Promise,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EJSRegisterMethodType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EJSRegisterMethodType {
}

impl ::std::default::Default for EJSRegisterMethodType {
    fn default() -> Self {
        EJSRegisterMethodType::k_EJSRegisterMethodType_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EJSRegisterMethodType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12htmlmessages.proto\"\x90\x01\n\tCMsgKeyUp\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\x07keyCode\x18\x02\x20\x01\
    (\rR\x07keyCode\x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\x12$\
    \n\rnativeKeyCode\x18\x04\x20\x01(\rR\rnativeKeyCode\"\xb6\x01\n\x0bCMsg\
    KeyDown\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\
    \x18\n\x07keyCode\x18\x02\x20\x01(\rR\x07keyCode\x12\x1c\n\tmodifiers\
    \x18\x03\x20\x01(\rR\tmodifiers\x12\"\n\ris_system_key\x18\x04\x20\x01(\
    \x08R\x0bisSystemKey\x12$\n\rnativeKeyCode\x18\x05\x20\x01(\rR\rnativeKe\
    yCode\"\xac\x01\n\x0bCMsgKeyChar\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x18\n\x07unichar\x18\x02\x20\x01(\rR\x07unic\
    har\x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\x12\x18\n\x07key\
    Code\x18\x04\x20\x01(\rR\x07keyCode\x12$\n\rnativeKeyCode\x18\x05\x20\
    \x01(\rR\rnativeKeyCode\"w\n\rCMsgMouseDown\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12!\n\x0cmouse_button\x18\x02\x20\x01(\
    \rR\x0bmouseButton\x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\"\
    \xb3\x01\n\x0bCMsgMouseUp\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\r\
    browserHandle\x12!\n\x0cmouse_button\x18\x02\x20\x01(\rR\x0bmouseButton\
    \x12\x1c\n\tmodifiers\x18\x03\x20\x01(\rR\tmodifiers\x12\x20\n\x0cis_off\
    _panel\x18\x04\x20\x01(\x08R\nisOffPanel\x12\x0c\n\x01x\x18\x05\x20\x01(\
    \x05R\x01x\x12\x0c\n\x01y\x18\x06\x20\x01(\x05R\x01y\"{\n\x11CMsgMouseDb\
    lClick\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12!\
    \n\x0cmouse_button\x18\x02\x20\x01(\rR\x0bmouseButton\x12\x1c\n\tmodifie\
    rs\x18\x03\x20\x01(\rR\tmodifiers\"\x85\x01\n\x0eCMsgMouseWheel\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06delta\
    x\x18\x02\x20\x01(\x05R\x06deltax\x12\x16\n\x06deltay\x18\x03\x20\x01(\
    \x05R\x06deltay\x12\x1c\n\tmodifiers\x18\x04\x20\x01(\rR\tmodifiers\"p\n\
    \rCMsgMouseMove\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHan\
    dle\x12\x0c\n\x01x\x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x03\x20\
    \x01(\x05R\x01y\x12\x1c\n\tmodifiers\x18\x04\x20\x01(\rR\tmodifiers\"7\n\
    \x0eCMsgMouseLeave\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowser\
    Handle\"\xa2\x05\n\x11CMsgBrowserCreate\x12\x1d\n\nrequest_id\x18\x01\
    \x20\x01(\rR\trequestId\x12\x1c\n\tuseragent\x18\x03\x20\x01(\tR\tuserag\
    ent\x12\x19\n\x08user_css\x18\x05\x20\x01(\tR\x07userCss\x12)\n\x10nativ\
    e_dropdowns\x18\x06\x20\x01(\x08R\x0fnativeDropdowns\x12\x1f\n\x0bdpi_sc\
    aling\x18\x07\x20\x01(\x02R\ndpiScaling\x12\"\n\toffscreen\x18\x08\x20\
    \x01(\x08:\x04trueR\toffscreen\x12&\n\rinitial_width\x18\t\x20\x01(\r:\
    \x010R\x0cinitialWidth\x12(\n\x0einitial_height\x18\n\x20\x01(\r:\x010R\
    \rinitialHeight\x12\x1f\n\x0bwindow_icon\x18\x0b\x20\x01(\tR\nwindowIcon\
    \x12%\n\nborderless\x18\x0c\x20\x01(\x08:\x05falseR\nborderless\x12#\n\r\
    vroverlay_key\x18\r\x20\x01(\tR\x0cvroverlayKey\x12$\n\x0cbrowser_type\
    \x18\x0e\x20\x01(\r:\x010R\x0bbrowserType\x12,\n\x0binitial_top\x18\x0f\
    \x20\x01(\x05:\x0b-2147483648R\ninitialTop\x12.\n\x0cinitial_left\x18\
    \x10\x20\x01(\x05:\x0b-2147483648R\x0binitialLeft\x12@\n\x19only_allow_t\
    rusted_popups\x18\x11\x20\x01(\x08:\x05falseR\x16onlyAllowTrustedPopups\
    \x12\x1f\n\x0binitial_url\x18\x12\x20\x01(\tR\ninitialUrl\x12\x1f\n\x0bh\
    wnd_parent\x18\x13\x20\x01(\x06R\nhwndParent\"a\n\x19CMsgBrowserCreateRe\
    sponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\
    \x1d\n\nrequest_id\x18\x02\x20\x01(\rR\trequestId\":\n\x11CMsgBrowserRem\
    ove\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"\xe4\
    \x02\n\x1eCMsgSetLocalFileRequestMapping\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x1f\n\x0brequest_url\x18\x02\x20\x01\
    (\tR\nrequestUrl\x12,\n\x12default_local_path\x18\x03\x20\x01(\tR\x10def\
    aultLocalPath\x12G\n\x06routes\x18\x04\x20\x03(\x0b2/.CMsgSetLocalFileRe\
    questMapping.AdditionalRouteR\x06routes\x1a\x82\x01\n\x0fAdditionalRoute\
    \x12!\n\x0crelative_url\x18\x01\x20\x01(\tR\x0brelativeUrl\x12\x1d\n\nlo\
    cal_path\x18\x02\x20\x01(\tR\tlocalPath\x12-\n\x12allowed_extensions\x18\
    \x03\x20\x01(\tR\x11allowedExtensions\"\x94\x02\n\x17CMsgBrowserErrorStr\
    ings\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\
    \n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x16\n\x06header\x18\x03\x20\
    \x01(\tR\x06header\x12\x1d\n\ncache_miss\x18\x04\x20\x01(\tR\tcacheMiss\
    \x12\x17\n\x07bad_url\x18\x05\x20\x01(\tR\x06badUrl\x12-\n\x12connection\
    _problem\x18\x06\x20\x01(\tR\x11connectionProblem\x12#\n\rproxy_problem\
    \x18\x07\x20\x01(\tR\x0cproxyProblem\x12\x18\n\x07unknown\x18\x08\x20\
    \x01(\tR\x07unknown\"f\n\x0fCMsgBrowserSize\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05width\x18\x02\x20\x01(\rR\
    \x05width\x12\x16\n\x06height\x18\x03\x20\x01(\rR\x06height\"l\n\x15CMsg\
    BrowserSetMinSize\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\x12\x14\n\x05width\x18\x02\x20\x01(\rR\x05width\x12\x16\n\x06heigh\
    t\x18\x03\x20\x01(\rR\x06height\"\x8a\x01\n\x13CMsgBrowserPosition\x12%\
    \n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\
    \x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x05R\x01y\
    \x12\x17\n\x07x_local\x18\x04\x20\x01(\x05R\x06xLocal\x12\x17\n\x07y_loc\
    al\x18\x05\x20\x01(\x05R\x06yLocal\"\x85\x01\n\x12CMsgBrowserResized\x12\
    %\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\
    \x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x05R\x01y\
    \x12\x14\n\x05width\x18\x04\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\
    \x05\x20\x01(\rR\x06height\"z\n\x0bCMsgPostURL\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\
    \x03url\x12\x12\n\x04post\x18\x03\x20\x01(\tR\x04post\x12\x1e\n\npageser\
    ial\x18\x04\x20\x01(\rR\npageserial\"^\n\rCMsgAddHeader\x12%\n\x0ebrowse\
    r_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03key\x18\x02\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x03\x20\x01(\tR\x05value\"5\n\x0c\
    CMsgStopLoad\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \"3\n\nCMsgReload\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\"6\n\rCMsgGoForward\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\r\
    browserHandle\"3\n\nCMsgGoBack\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\
    \rR\rbrowserHandle\"N\n\rCMsgWasHidden\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\x12\x16\n\x06hidden\x18\x02\x20\x01(\x08R\
    \x06hidden\"9\n\x10CMsgClearHistory\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"A\n\x18CMsgClearAllBrowsingData\x12%\n\x0ebrows\
    er_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"1\n\x08CMsgCopy\x12%\n\x0e\
    browser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"2\n\tCMsgPaste\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"V\n\x15CMsgExecut\
    eJavaScript\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x16\n\x06script\x18\x02\x20\x01(\tR\x06script\"K\n\x0cCMsgSetFocus\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\
    \x05focus\x18\x02\x20\x01(\x08R\x05focus\"D\n\x1bCMsgHorizontalScrollBar\
    Size\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"\xce\
    \x01\n#CMsgHorizontalScrollBarSizeResponse\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x1d\n\nscroll_max\x18\x06\x20\x01(\r\
    R\tscrollMax\x12\x16\n\x06scroll\x18\x07\x20\x01(\rR\x06scroll\x12\x12\n\
    \x04zoom\x18\x08\x20\x01(\x02R\x04zoom\x12\x18\n\x07visible\x18\t\x20\
    \x01(\x08R\x07visible\x12\x1b\n\tpage_size\x18\n\x20\x01(\rR\x08pageSize\
    \"B\n\x19CMsgVerticalScrollBarSize\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"\xcc\x01\n!CMsgVerticalScrollBarSizeResponse\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1d\n\n\
    scroll_max\x18\x06\x20\x01(\rR\tscrollMax\x12\x16\n\x06scroll\x18\x07\
    \x20\x01(\rR\x06scroll\x12\x12\n\x04zoom\x18\x08\x20\x01(\x02R\x04zoom\
    \x12\x18\n\x07visible\x18\t\x20\x01(\x08R\x07visible\x12\x1b\n\tpage_siz\
    e\x18\n\x20\x01(\rR\x08pageSize\"~\n\x08CMsgFind\x12%\n\x0ebrowser_handl\
    e\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04find\x18\x02\x20\x01(\
    \tR\x04find\x12\x16\n\x06infind\x18\x03\x20\x01(\x08R\x06infind\x12\x1f\
    \n\x07reverse\x18\x04\x20\x01(\x08:\x05falseR\x07reverse\"5\n\x0cCMsgSto\
    pFind\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"X\n\
    \x17CMsgSetHorizontalScroll\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12\x16\n\x06scroll\x18\x02\x20\x01(\rR\x06scroll\"V\n\
    \x15CMsgSetVerticalScroll\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\r\
    browserHandle\x12\x16\n\x06scroll\x18\x02\x20\x01(\rR\x06scroll\"M\n\x10\
    CMsgSetZoomLevel\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHa\
    ndle\x12\x12\n\x04zoom\x18\x02\x20\x01(\x01R\x04zoom\"7\n\x0eCMsgViewSou\
    rce\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"\x82\
    \x01\n\x10CMsgBrowserReady\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12$\n\x0evr_overlay_key\x18\x02\x20\x01(\tR\x0cvrOverla\
    yKey\x12!\n\x0chwnd_browser\x18\x03\x20\x01(\x06R\x0bhwndBrowser\"\xcd\
    \x01\n\x0eCMsgURLChanged\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rb\
    rowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x1a\n\x08po\
    stData\x18\x03\x20\x01(\tR\x08postData\x12\x20\n\x0bbIsRedirect\x18\x04\
    \x20\x01(\x08R\x0bbIsRedirect\x12\x1c\n\tpagetitle\x18\x05\x20\x01(\tR\t\
    pagetitle\x12&\n\x0ebNewNavigation\x18\x06\x20\x01(\x08R\x0ebNewNavigati\
    on\"5\n\x0bCHTMLHeader\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x8e\x02\n\x15CHTMLPageSec\
    urityInfo\x12#\n\tbIsSecure\x18\x01\x20\x01(\x08:\x05falseR\tbIsSecure\
    \x12+\n\rbHasCertError\x18\x02\x20\x01(\x08:\x05falseR\rbHasCertError\
    \x12\x1e\n\nissuerName\x18\x03\x20\x01(\tR\nissuerName\x12\x1a\n\x08cert\
    Name\x18\x04\x20\x01(\tR\x08certName\x12!\n\ncertExpiry\x18\x05\x20\x01(\
    \x05:\x010R\ncertExpiry\x12\x1f\n\tnCertBits\x18\x06\x20\x01(\x05:\x010R\
    \tnCertBits\x12#\n\tbIsEVCert\x18\x07\x20\x01(\x08:\x05falseR\tbIsEVCert\
    \"l\n\x13CMsgFinishedRequest\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\r\
    R\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x1c\n\t\
    pageTitle\x18\x03\x20\x01(\tR\tpageTitle\"\x92\x01\n\x11CMsgLoadedReques\
    t\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\
    \x03url\x18\x02\x20\x01(\tR\x03url\x12\x1c\n\tpageTitle\x18\x03\x20\x01(\
    \tR\tpageTitle\x12&\n\x07headers\x18\x05\x20\x03(\x0b2\x0c.CHTMLHeaderR\
    \x07headers\"\x88\x01\n\x10CMsgPageSecurity\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03\
    url\x12;\n\rsecurity_info\x18\x03\x20\x01(\x0b2\x16.CHTMLPageSecurityInf\
    oR\x0csecurityInfo\"\xa1\x01\n\x10CMsgStartRequest\x12%\n\x0ebrowser_han\
    dle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\
    \tR\x03url\x12\x16\n\x06target\x18\x03\x20\x01(\tR\x06target\x12\x1a\n\
    \x08postData\x18\x04\x20\x01(\tR\x08postData\x12\x20\n\x0bbIsRedirect\
    \x18\x05\x20\x01(\x08R\x0bbIsRedirect\"Y\n\x18CMsgStartRequestResponse\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\
    \x06bAllow\x18\x02\x20\x01(\x08R\x06bAllow\"6\n\rCMsgShowPopup\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"6\n\rCMsgHidePopu\
    p\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"z\n\rCMsg\
    SizePopup\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x0c\n\x01x\x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x03\x20\
    \x01(\x05R\x01y\x12\x12\n\x04wide\x18\x04\x20\x01(\rR\x04wide\x12\x12\n\
    \x04tall\x18\x05\x20\x01(\rR\x04tall\"k\n\x0eCMsgOpenNewTab\x12%\n\x0ebr\
    owser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\
    \x20\x01(\tR\x03url\x12\x20\n\x0bbForeground\x18\x03\x20\x01(\x08R\x0bbF\
    oreground\"\xf6\x01\n\x13CMsgPopupHTMLWindow\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\
    \x03url\x12\x19\n\x01x\x18\x03\x20\x01(\x05:\x0b-2147483648R\x01x\x12\
    \x19\n\x01y\x18\x04\x20\x01(\x05:\x0b-2147483648R\x01y\x12\x12\n\x04wide\
    \x18\x05\x20\x01(\rR\x04wide\x12\x12\n\x04tall\x18\x06\x20\x01(\rR\x04ta\
    ll\x12\x1f\n\x0bpopup_index\x18\x07\x20\x01(\rR\npopupIndex\x12'\n\x0ftr\
    usted_creator\x18\x08\x20\x01(\x08R\x0etrustedCreator\"\\\n\x1bCMsgPopup\
    HTMLWindowResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowser\
    Handle\x12\x16\n\x06bAllow\x18\x02\x20\x01(\x08R\x06bAllow\"O\n\x10CMsgS\
    etHTMLTitle\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\"N\n\x13CMsgLoadingReso\
    urce\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\
    \n\x03url\x18\x02\x20\x01(\tR\x03url\"K\n\x0eCMsgStatusText\x12%\n\x0ebr\
    owser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\
    \x02\x20\x01(\tR\x04text\"\xcf\x01\n\rCMsgSetCursor\x12%\n\x0ebrowser_ha\
    ndle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06cursor\x18\x02\x20\
    \x01(\rR\x06cursor\x12\x1f\n\x0bcustom_data\x18\x03\x20\x01(\x0cR\ncusto\
    mData\x12\x12\n\x04wide\x18\x04\x20\x01(\rR\x04wide\x12\x12\n\x04tall\
    \x18\x05\x20\x01(\rR\x04tall\x12\x1a\n\x08xhotspot\x18\x06\x20\x01(\rR\
    \x08xhotspot\x12\x1a\n\x08yhotspot\x18\x07\x20\x01(\rR\x08yhotspot\"\xaf\
    \x01\n\x12CMsgFileLoadDialog\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\r\
    R\rbrowserHandle\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x20\
    \n\x0binitialFile\x18\x03\x20\x01(\tR\x0binitialFile\x12!\n\x0caccept_ty\
    pes\x18\x04\x20\x03(\tR\x0bacceptTypes\x12\x17\n\x07is_save\x18\x05\x20\
    \x01(\x08R\x06isSave\"Y\n\x1aCMsgFileLoadDialogResponse\x12%\n\x0ebrowse\
    r_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05files\x18\x02\
    \x20\x03(\tR\x05files\"L\n\x0fCMsgShowToolTip\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\x02\x20\x01(\t\
    R\x04text\"N\n\x11CMsgUpdateToolTip\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\"8\
    \n\x0fCMsgHideToolTip\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrow\
    serHandle\"v\n\x11CMsgSearchResults\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x20\n\x0bactiveMatch\x18\x02\x20\x01(\x05R\
    \x0bactiveMatch\x12\x18\n\x07results\x18\x03\x20\x01(\x05R\x07results\"2\
    \n\tCMsgClose\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandl\
    e\"\xc6\x01\n\x19CMsgSetSharedPaintBuffers\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04wide\x18\x02\x20\x01(\rR\
    \x04wide\x12\x12\n\x04tall\x18\x03\x20\x01(\rR\x04tall\x12\x1d\n\nsource\
    _pid\x18\x04\x20\x01(\x04R\tsourcePid\x12#\n\rsource_handle\x18\x05\x20\
    \x01(\x04R\x0csourceHandle\x12\x16\n\x06handle\x18\x06\x20\x01(\x04R\x06\
    handle\"B\n\x19CMsgAckSharedPaintBuffers\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\"\xa9\x01\n\x0eCMsgNeedsPaint\x12%\n\x0e\
    browser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\x07scrollx\
    \x18\n\x20\x01(\rR\x07scrollx\x12\x18\n\x07scrolly\x18\x0b\x20\x01(\rR\
    \x07scrolly\x12\x1c\n\tpagescale\x18\x0c\x20\x01(\x02R\tpagescale\x12\
    \x1e\n\npageserial\x18\x0f\x20\x01(\rR\npageserial\"\x86\x02\n\x13CMsgCo\
    mboNeedsPaint\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandl\
    e\x12\x12\n\x04rgba\x18\x02\x20\x01(\x04R\x04rgba\x12&\n\rcombobox_wide\
    \x18\x03\x20\x01(\r:\x010R\x0ccomboboxWide\x12&\n\rcombobox_tall\x18\x04\
    \x20\x01(\r:\x010R\x0ccomboboxTall\x123\n\x14shared_memory_handle\x18\
    \x05\x20\x01(\x04:\x010R\x12sharedMemoryHandle\x12/\n\x12shared_memory_s\
    ize\x18\x07\x20\x01(\x04:\x010R\x10sharedMemorySize\"\x87\x02\n\x1bCMsgN\
    eedsSharedTexturePaint\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbro\
    wserHandle\x12!\n\x0cshare_handle\x18\x02\x20\x01(\rR\x0bshareHandle\x12\
    \x14\n\x05width\x18\x03\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x04\
    \x20\x01(\rR\x06height\x12\x18\n\x07scrollx\x18\x05\x20\x01(\rR\x07scrol\
    lx\x12\x18\n\x07scrolly\x18\x06\x20\x01(\rR\x07scrolly\x12\x1c\n\tpagesc\
    ale\x18\x07\x20\x01(\x02R\tpagescale\x12\x1e\n\npageserial\x18\x08\x20\
    \x01(\rR\npageserial\"\xe4\x01\n\x1bCMsgGameOverlayTexturePaint\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05width\
    \x18\x03\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x04\x20\x01(\rR\
    \x06height\x12\x18\n\x07scrollx\x18\x05\x20\x01(\rR\x07scrollx\x12\x18\n\
    \x07scrolly\x18\x06\x20\x01(\rR\x07scrolly\x12\x1c\n\tpagescale\x18\x07\
    \x20\x01(\x02R\tpagescale\x12\x1e\n\npageserial\x18\x08\x20\x01(\rR\npag\
    eserial\"4\n\x0bCMsgGetZoom\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\"P\n\x13CMsgGetZoomResponse\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04zoom\x18\x02\x20\x01(\x02R\
    \x04zoom\"W\n\x12CMsgLinkAtPosition\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\
    \n\x01y\x18\x03\x20\x01(\rR\x01y\"\xa7\x01\n\x1aCMsgLinkAtPositionRespon\
    se\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\
    \x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\rR\x01y\
    \x12\x10\n\x03url\x18\x04\x20\x01(\tR\x03url\x12\x1c\n\tblivelink\x18\
    \x05\x20\x01(\x08R\tblivelink\x12\x16\n\x06binput\x18\x06\x20\x01(\x08R\
    \x06binput\"`\n\x1bCMsgZoomToElementAtPosition\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\rR\
    \x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\rR\x01y\"~\n#CMsgZoomToElementAtPo\
    sitionResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHand\
    le\x12\x14\n\x05scale\x18\x02\x20\x01(\x02R\x05scale\x12\x1a\n\x08durati\
    on\x18\x03\x20\x01(\x02R\x08duration\"o\n\x14CMsgScalePageToValue\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05scale\
    \x18\x02\x20\x01(\x02R\x05scale\x12\x0c\n\x01x\x18\x03\x20\x01(\x02R\x01\
    x\x12\x0c\n\x01y\x18\x04\x20\x01(\x02R\x01y\"}\n\x1bCMsgForcePopupsToDir\
    ectHWND\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x127\
    \n\x18force_direct_hwnd_popups\x18\x02\x20\x01(\x08R\x15forceDirectHwndP\
    opups\"Y\n\x1cCMsgScalePageToValueResponse\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04zoom\x18\x02\x20\x01(\x02R\
    \x04zoom\"\x97\x01\n\x12CMsgSavePageToJPEG\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03\
    url\x12\x1a\n\x08filename\x18\x03\x20\x01(\tR\x08filename\x12\x14\n\x05w\
    idth\x18\x04\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x05\x20\x01(\r\
    R\x06height\"q\n\x1aCMsgSavePageToJPEGResponse\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\
    \x03url\x12\x1a\n\x08filename\x18\x03\x20\x01(\tR\x08filename\"N\n\x0bCM\
    sgJSAlert\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"P\n\rCMsgJSConfirm\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\
    \x07message\x18\x02\x20\x01(\tR\x07message\"U\n\x14CMsgJSDialogResponse\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\
    \x06result\x18\x02\x20\x01(\x08R\x06result\"z\n\x17CMsgCanGoBackAndForwa\
    rd\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\
    \x07bgoback\x18\x02\x20\x01(\x08R\x07bgoback\x12\x1e\n\nbgoforward\x18\
    \x03\x20\x01(\x08R\nbgoforward\"g\n\x10CMsgOpenSteamURL\x12%\n\x0ebrowse\
    r_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\
    \x01(\tR\x03url\x12\x1a\n\x08referrer\x18\x03\x20\x01(\tR\x08referrer\"\
    \xad\x01\n\rCMsgSetCookie\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12\x12\n\x04path\x18\
    \x03\x20\x01(\tR\x04path\x12\x12\n\x04host\x18\x04\x20\x01(\tR\x04host\
    \x12\x18\n\x07expires\x18\x05\x20\x01(\rR\x07expires\x12\x16\n\x06secure\
    \x18\x06\x20\x01(\x08R\x06secure\x12\x1a\n\x08httponly\x18\x07\x20\x01(\
    \x08R\x08httponly\"k\n\x16CMsgSetTargetFrameRate\x12%\n\x0ebrowser_handl\
    e\x18\x01\x20\x01(\rR\rbrowserHandle\x12*\n\x10nTargetFrameRate\x18\x02\
    \x20\x01(\rR\x10nTargetFrameRate\"9\n\x10CMsgPauseRepaint\x12%\n\x0ebrow\
    ser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"8\n\x0fCMsgFullRepaint\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\">\n\x15CMs\
    gRequestFullScreen\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowser\
    Handle\";\n\x12CMsgExitFullScreen\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"C\n\x1aCMsgToggleFindInPageDialog\x12%\n\x0ebro\
    wser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"?\n\x16CMsgSetPIDShuttin\
    gDown\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"H\n\
    \x1fCMsgDisableBackgroundThrottling\x12%\n\x0ebrowser_handle\x18\x01\x20\
    \x01(\rR\rbrowserHandle\"?\n\x16CMsgAckPIDShuttingDown\x12%\n\x0ebrowser\
    _handle\x18\x01\x20\x01(\rR\rbrowserHandle\"O\n\x14CMsgGetCookiesForURL\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\
    \x03url\x18\x02\x20\x01(\tR\x03url\"_\n\x07CCookie\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\
    \x12\x16\n\x06domain\x18\x03\x20\x01(\tR\x06domain\x12\x12\n\x04path\x18\
    \x04\x20\x01(\tR\x04path\"{\n\x1cCMsgGetCookiesForURLResponse\x12%\n\x0e\
    browser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\
    \x02\x20\x01(\tR\x03url\x12\"\n\x07cookies\x18\x03\x20\x03(\x0b2\x08.CCo\
    okieR\x07cookies\"\x88\x02\n\x10CMsgNodeHasFocus\x12%\n\x0ebrowser_handl\
    e\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x16\n\x06bInput\x18\x02\x20\x01\
    (\x08R\x06bInput\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12&\n\
    \x0eelementtagname\x18\x04\x20\x01(\tR\x0eelementtagname\x12*\n\x10searc\
    hbuttontext\x18\x05\x20\x01(\tR\x10searchbuttontext\x12.\n\x12bHasMultip\
    leInputs\x18\x06\x20\x01(\x08R\x12bHasMultipleInputs\x12\x1d\n\ninput_ty\
    pe\x18\x07\x20\x01(\tR\tinputType\"A\n\x18CMsgZoomToFocusedElement\x12%\
    \n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"G\n\x1eCMsgClos\
    eFullScreenFlashIfOpen\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbro\
    wserHandle\"L\n#CMsgPauseFullScreenFlashMovieIfOpen\x12%\n\x0ebrowser_ha\
    ndle\x18\x01\x20\x01(\rR\rbrowserHandle\"<\n\x13CMsgFocusedNodeText\x12%\
    \n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"Z\n\x1bCMsgFocu\
    sedNodeTextResponse\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowse\
    rHandle\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"(\n\x0bCMsgBuil\
    dID\x12\x19\n\x08build_id\x18\x01\x20\x01(\x04R\x07buildId\"9\n\x10CMsgO\
    penDevTools\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\
    \":\n\x11CMsgCloseDevTools\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\"X\n\x0eCMsgUnlockH264\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\x12\x1f\n\x0bunlock_code\x18\x02\x20\x01(\tR\
    \nunlockCode\"\xad\x03\n\x1cCMsgScreenInformationChanged\x12%\n\x0ebrows\
    er_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12%\n\x0eoverride_width\
    \x18\x02\x20\x01(\rR\roverrideWidth\x12'\n\x0foverride_height\x18\x03\
    \x20\x01(\rR\x0eoverrideHeight\x12!\n\x0cmonitor_left\x18\x04\x20\x01(\r\
    R\x0bmonitorLeft\x12\x1f\n\x0bmonitor_top\x18\x05\x20\x01(\rR\nmonitorTo\
    p\x12#\n\rmonitor_right\x18\x06\x20\x01(\rR\x0cmonitorRight\x12%\n\x0emo\
    nitor_bottom\x18\x07\x20\x01(\rR\rmonitorBottom\x12\x1f\n\x0busable_left\
    \x18\x08\x20\x01(\rR\nusableLeft\x12\x1d\n\nusable_top\x18\t\x20\x01(\rR\
    \tusableTop\x12!\n\x0cusable_right\x18\n\x20\x01(\rR\x0busableRight\x12#\
    \n\rusable_bottom\x18\x0b\x20\x01(\rR\x0cusableBottom\"<\n\x13CMsgClearA\
    llCookies\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"W\
    \n\rCMsgScreenDPI\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\x12\x1f\n\x0bdpi_scaling\x18\x02\x20\x01(\x02R\ndpiScaling\"2\n\
    \x16CMsgAuthedSteamDomains\x12\x18\n\x07domains\x18\x01\x20\x03(\tR\x07d\
    omains\"-\n\x13CMsgSteamAuthNeeded\x12\x16\n\x06filler\x18\x01\x20\x01(\
    \x08R\x06filler\"3\n\x17CMsgSteamAuthCookiesSet\x12\x18\n\x07success\x18\
    \x01\x20\x01(\x08R\x07success\"\xab\x01\n\x14CMsgJSRegisterMethod\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12X\n\x0bmethod_type\x18\x03\x20\x01(\x0e2\
    \x16.EJSRegisterMethodType:\x1fk_EJSRegisterMethodType_InvalidR\nmethodT\
    ype\"Y\n\x11CJSMethodArgument\x12\x1b\n\tjson_data\x18\x01\x20\x01(\tR\
    \x08jsonData\x12'\n\x0ffunction_handle\x18\x02\x20\x01(\x04R\x0efunction\
    Handle\"\xd8\x03\n\x0bCMsgJSValue\x12\x1d\n\nbool_value\x18\x01\x20\x01(\
    \x08R\tboolValue\x12\x1b\n\tint_value\x18\x02\x20\x01(\x05R\x08intValue\
    \x12\x1d\n\nuint_value\x18\x03\x20\x01(\rR\tuintValue\x12!\n\x0cdouble_v\
    alue\x18\x04\x20\x01(\x01R\x0bdoubleValue\x12!\n\x0cstring_value\x18\x05\
    \x20\x01(\tR\x0bstringValue\x12'\n\x0ffunction_handle\x18\x06\x20\x01(\
    \x04R\x0efunctionHandle\x12\x19\n\x08is_array\x18\x08\x20\x01(\x08R\x07i\
    sArray\x12/\n\x0carray_values\x18\t\x20\x03(\x0b2\x0c.CMsgJSValueR\x0bar\
    rayValues\x12\x1b\n\tis_object\x18\n\x20\x01(\x08R\x08isObject\x12J\n\
    \x11object_properties\x18\x0b\x20\x03(\x0b2\x1d.CMsgJSValue.JSObjectProp\
    ertyR\x10objectProperties\x1aJ\n\x10JSObjectProperty\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\"\n\x05value\x18\x02\x20\x01(\x0b2\x0c.\
    CMsgJSValueR\x05value\"y\n\x10CMsgJSMethodCall\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04name\x18\x02\x20\x01(\t\
    R\x04name\x12*\n\targuments\x18\x03\x20\x03(\x0b2\x0c.CMsgJSValueR\targu\
    ments\"\x93\x01\n\x15CMsgJSExecuteCallback\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12'\n\x0ffunction_handle\x18\x02\x20\
    \x01(\x04R\x0efunctionHandle\x12*\n\targuments\x18\x03\x20\x03(\x0b2\x0c\
    .CMsgJSValueR\targuments\"g\n\x15CMsgJSReleaseCallback\x12%\n\x0ebrowser\
    _handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12'\n\x0ffunction_handle\x18\
    \x02\x20\x01(\x04R\x0efunctionHandle\"[\n\x14CMsgJSRaiseException\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1c\n\texcepti\
    on\x18\x02\x20\x01(\tR\texception\"\x86\x01\n\x14CMsgLoadLocalization\
    \x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12+\n\x11l\
    ocalization_path\x18\x02\x20\x01(\tR\x10localizationPath\x12\x1a\n\x08la\
    nguage\x18\x03\x20\x01(\tR\x08language\"m\n\x10CMsgJumpListLink\x12!\n\
    \x0cdisplay_name\x18\x01\x20\x01(\tR\x0bdisplayName\x12\x19\n\x08url_lin\
    k\x18\x02\x20\x01(\tR\x07urlLink\x12\x1b\n\ticon_path\x18\x03\x20\x01(\t\
    R\x08iconPath\"\x85\x01\n\x12CMSgJumpListMRUApp\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12!\n\x0cdisplay_name\x18\x02\x20\x01(\tR\x0b\
    displayName\x12\x19\n\x08url_link\x18\x03\x20\x01(\tR\x07urlLink\x12\x1b\
    \n\ticon_path\x18\x04\x20\x01(\tR\x08iconPath\"\x9f\x01\n\x0fCMsgSetJump\
    List\x12\x1d\n\nsteam_path\x18\x01\x20\x01(\tR\tsteamPath\x12\x1b\n\tmru\
    _title\x18\x02\x20\x01(\tR\x08mruTitle\x12'\n\x04apps\x18\x03\x20\x03(\
    \x0b2\x13.CMSgJumpListMRUAppR\x04apps\x12'\n\x05links\x18\x04\x20\x03(\
    \x0b2\x11.CMsgJumpListLinkR\x05links\"d\n\x1cCMsgSetGameOverlayTargetPID\
    s\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x1d\n\
    \ntarget_pid\x18\x02\x20\x03(\rR\ttargetPid\"\x8d\x01\n\x1eCMsgGameOverl\
    ayTargetTextureID\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\x12\x1d\n\ntarget_pid\x18\x02\x20\x01(\rR\ttargetPid\x12%\n\x0etex\
    ture_handle\x18\x03\x20\x01(\rR\rtextureHandle\"\x81\x02\n\x1bCMsgDragga\
    bleRegionsChanged\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserH\
    andle\x12A\n\x05rects\x18\x02\x20\x03(\x0b2+.CMsgDraggableRegionsChanged\
    .DraggableRectsR\x05rects\x1ax\n\x0eDraggableRects\x12\x0c\n\x01x\x18\
    \x01\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x05R\x01y\x12\
    \x14\n\x05width\x18\x03\x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\
    \x04\x20\x01(\x05R\x06height\x12\x1c\n\tdraggable\x18\x05\x20\x01(\x08R\
    \tdraggable\"l\n\x15CMsgResizeGripChanged\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x14\n\x05width\x18\x02\x20\x01(\x05R\
    \x05width\x12\x16\n\x06height\x18\x03\x20\x01(\x05R\x06height\"\x88\x01\
    \n\x15CMsgSetWindowPosition\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\x05R\x01x\x12\x0c\n\x01y\
    \x18\x03\x20\x01(\x05R\x01y\x12\x14\n\x05width\x18\x04\x20\x01(\x05R\x05\
    width\x12\x16\n\x06height\x18\x05\x20\x01(\x05R\x06height\"7\n\x0eCMsgSh\
    owWindow\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"7\
    \n\x0eCMsgHideWindow\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrows\
    erHandle\"?\n\x16CMsgBringWindowToFront\x12%\n\x0ebrowser_handle\x18\x01\
    \x20\x01(\rR\rbrowserHandle\"@\n\x17CMsgSetForegroundWindow\x12%\n\x0ebr\
    owser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\"B\n\x19CMsgMaximizeRest\
    oreWindow\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\";\
    \n\x12CMsgMinimizeWindow\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rb\
    rowserHandle\"C\n\x1aCMsgShowBrowserContextMenu\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\"R\n\x15CMsgImeSetComposition\x12%\n\
    \x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\
    \x18\x02\x20\x01(\tR\x04text\"N\n\x11CMsgImeCommitText\x12%\n\x0ebrowser\
    _handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x12\n\x04text\x18\x02\x20\
    \x01(\tR\x04text\"A\n\x18CMsgImeCancelComposition\x12%\n\x0ebrowser_hand\
    le\x18\x01\x20\x01(\rR\rbrowserHandle\"c\n\x1eCMsgImeCompositionRangeCha\
    nged\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\rbrowserHandle\x12\x0c\
    \n\x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\rR\x01y\
    \"W\n\x12CMsgInspectElement\x12%\n\x0ebrowser_handle\x18\x01\x20\x01(\rR\
    \rbrowserHandle\x12\x0c\n\x01x\x18\x02\x20\x01(\rR\x01x\x12\x0c\n\x01y\
    \x18\x03\x20\x01(\rR\x01y\"P\n\rCMsgDisableF5\x12%\n\x0ebrowser_handle\
    \x18\x01\x20\x01(\rR\rbrowserHandle\x12\x18\n\x07disable\x18\x02\x20\x01\
    (\x08R\x07disable\"L\n\x11CMsgStartDownload\x12%\n\x0ebrowser_handle\x18\
    \x01\x20\x01(\rR\rbrowserHandle\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03\
    url*\xad\x01\n\x15EJSRegisterMethodType\x12#\n\x1fk_EJSRegisterMethodTyp\
    e_Invalid\x10\0\x12$\n\x20k_EJSRegisterMethodType_Function\x10\x01\x12$\
    \n\x20k_EJSRegisterMethodType_Callback\x10\x02\x12#\n\x1fk_EJSRegisterMe\
    thodType_Promise\x10\x03B\x05H\x01\x80\x01\0\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
