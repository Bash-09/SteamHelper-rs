// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_contentsystem.steamclient.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CContentServerDirectory_GetServersForSteamPipe_Request {
    // message fields
    cell_id: ::std::option::Option<u32>,
    max_servers: ::std::option::Option<u32>,
    ip_override: ::protobuf::SingularField<::std::string::String>,
    launcher_type: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CContentServerDirectory_GetServersForSteamPipe_Request {
    fn default() -> &'a CContentServerDirectory_GetServersForSteamPipe_Request {
        <CContentServerDirectory_GetServersForSteamPipe_Request as ::protobuf::Message>::default_instance()
    }
}

impl CContentServerDirectory_GetServersForSteamPipe_Request {
    pub fn new() -> CContentServerDirectory_GetServersForSteamPipe_Request {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;


    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }
    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 max_servers = 2;


    pub fn get_max_servers(&self) -> u32 {
        self.max_servers.unwrap_or(20u32)
    }
    pub fn clear_max_servers(&mut self) {
        self.max_servers = ::std::option::Option::None;
    }

    pub fn has_max_servers(&self) -> bool {
        self.max_servers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_servers(&mut self, v: u32) {
        self.max_servers = ::std::option::Option::Some(v);
    }

    // optional string ip_override = 3;


    pub fn get_ip_override(&self) -> &str {
        match self.ip_override.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ip_override(&mut self) {
        self.ip_override.clear();
    }

    pub fn has_ip_override(&self) -> bool {
        self.ip_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_override(&mut self, v: ::std::string::String) {
        self.ip_override = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_override(&mut self) -> &mut ::std::string::String {
        if self.ip_override.is_none() {
            self.ip_override.set_default();
        }
        self.ip_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_override(&mut self) -> ::std::string::String {
        self.ip_override.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 launcher_type = 4;


    pub fn get_launcher_type(&self) -> i32 {
        self.launcher_type.unwrap_or(0i32)
    }
    pub fn clear_launcher_type(&mut self) {
        self.launcher_type = ::std::option::Option::None;
    }

    pub fn has_launcher_type(&self) -> bool {
        self.launcher_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launcher_type(&mut self, v: i32) {
        self.launcher_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CContentServerDirectory_GetServersForSteamPipe_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_servers = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_override)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.launcher_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_servers {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ip_override.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.launcher_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_servers {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.ip_override.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.launcher_type {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CContentServerDirectory_GetServersForSteamPipe_Request {
        CContentServerDirectory_GetServersForSteamPipe_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cell_id",
                    |m: &CContentServerDirectory_GetServersForSteamPipe_Request| { &m.cell_id },
                    |m: &mut CContentServerDirectory_GetServersForSteamPipe_Request| { &mut m.cell_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_servers",
                    |m: &CContentServerDirectory_GetServersForSteamPipe_Request| { &m.max_servers },
                    |m: &mut CContentServerDirectory_GetServersForSteamPipe_Request| { &mut m.max_servers },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip_override",
                    |m: &CContentServerDirectory_GetServersForSteamPipe_Request| { &m.ip_override },
                    |m: &mut CContentServerDirectory_GetServersForSteamPipe_Request| { &mut m.ip_override },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "launcher_type",
                    |m: &CContentServerDirectory_GetServersForSteamPipe_Request| { &m.launcher_type },
                    |m: &mut CContentServerDirectory_GetServersForSteamPipe_Request| { &mut m.launcher_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CContentServerDirectory_GetServersForSteamPipe_Request>(
                    "CContentServerDirectory_GetServersForSteamPipe_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CContentServerDirectory_GetServersForSteamPipe_Request {
        static mut instance: ::protobuf::lazy::Lazy<CContentServerDirectory_GetServersForSteamPipe_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CContentServerDirectory_GetServersForSteamPipe_Request,
        };
        unsafe {
            instance.get(CContentServerDirectory_GetServersForSteamPipe_Request::new)
        }
    }
}

impl ::protobuf::Clear for CContentServerDirectory_GetServersForSteamPipe_Request {
    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.max_servers = ::std::option::Option::None;
        self.ip_override.clear();
        self.launcher_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CContentServerDirectory_GetServersForSteamPipe_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CContentServerDirectory_GetServersForSteamPipe_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CContentServerDirectory_ServerInfo {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    source_id: ::std::option::Option<i32>,
    cell_id: ::std::option::Option<i32>,
    load: ::std::option::Option<i32>,
    weighted_load: ::std::option::Option<f32>,
    num_entries_in_client_list: ::std::option::Option<i32>,
    steam_china_only: ::std::option::Option<bool>,
    host: ::protobuf::SingularField<::std::string::String>,
    vhost: ::protobuf::SingularField<::std::string::String>,
    use_as_proxy: ::std::option::Option<bool>,
    proxy_request_path_template: ::protobuf::SingularField<::std::string::String>,
    https_support: ::protobuf::SingularField<::std::string::String>,
    allowed_app_ids: ::std::vec::Vec<u32>,
    preferred_server: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CContentServerDirectory_ServerInfo {
    fn default() -> &'a CContentServerDirectory_ServerInfo {
        <CContentServerDirectory_ServerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CContentServerDirectory_ServerInfo {
    pub fn new() -> CContentServerDirectory_ServerInfo {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 source_id = 2;


    pub fn get_source_id(&self) -> i32 {
        self.source_id.unwrap_or(0)
    }
    pub fn clear_source_id(&mut self) {
        self.source_id = ::std::option::Option::None;
    }

    pub fn has_source_id(&self) -> bool {
        self.source_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_id(&mut self, v: i32) {
        self.source_id = ::std::option::Option::Some(v);
    }

    // optional int32 cell_id = 3;


    pub fn get_cell_id(&self) -> i32 {
        self.cell_id.unwrap_or(0)
    }
    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: i32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional int32 load = 4;


    pub fn get_load(&self) -> i32 {
        self.load.unwrap_or(0)
    }
    pub fn clear_load(&mut self) {
        self.load = ::std::option::Option::None;
    }

    pub fn has_load(&self) -> bool {
        self.load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load(&mut self, v: i32) {
        self.load = ::std::option::Option::Some(v);
    }

    // optional float weighted_load = 5;


    pub fn get_weighted_load(&self) -> f32 {
        self.weighted_load.unwrap_or(0.)
    }
    pub fn clear_weighted_load(&mut self) {
        self.weighted_load = ::std::option::Option::None;
    }

    pub fn has_weighted_load(&self) -> bool {
        self.weighted_load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weighted_load(&mut self, v: f32) {
        self.weighted_load = ::std::option::Option::Some(v);
    }

    // optional int32 num_entries_in_client_list = 6;


    pub fn get_num_entries_in_client_list(&self) -> i32 {
        self.num_entries_in_client_list.unwrap_or(0)
    }
    pub fn clear_num_entries_in_client_list(&mut self) {
        self.num_entries_in_client_list = ::std::option::Option::None;
    }

    pub fn has_num_entries_in_client_list(&self) -> bool {
        self.num_entries_in_client_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries_in_client_list(&mut self, v: i32) {
        self.num_entries_in_client_list = ::std::option::Option::Some(v);
    }

    // optional bool steam_china_only = 7;


    pub fn get_steam_china_only(&self) -> bool {
        self.steam_china_only.unwrap_or(false)
    }
    pub fn clear_steam_china_only(&mut self) {
        self.steam_china_only = ::std::option::Option::None;
    }

    pub fn has_steam_china_only(&self) -> bool {
        self.steam_china_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_china_only(&mut self, v: bool) {
        self.steam_china_only = ::std::option::Option::Some(v);
    }

    // optional string host = 8;


    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string vhost = 9;


    pub fn get_vhost(&self) -> &str {
        match self.vhost.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_vhost(&mut self) {
        self.vhost.clear();
    }

    pub fn has_vhost(&self) -> bool {
        self.vhost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vhost(&mut self, v: ::std::string::String) {
        self.vhost = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vhost(&mut self) -> &mut ::std::string::String {
        if self.vhost.is_none() {
            self.vhost.set_default();
        }
        self.vhost.as_mut().unwrap()
    }

    // Take field
    pub fn take_vhost(&mut self) -> ::std::string::String {
        self.vhost.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool use_as_proxy = 10;


    pub fn get_use_as_proxy(&self) -> bool {
        self.use_as_proxy.unwrap_or(false)
    }
    pub fn clear_use_as_proxy(&mut self) {
        self.use_as_proxy = ::std::option::Option::None;
    }

    pub fn has_use_as_proxy(&self) -> bool {
        self.use_as_proxy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_as_proxy(&mut self, v: bool) {
        self.use_as_proxy = ::std::option::Option::Some(v);
    }

    // optional string proxy_request_path_template = 11;


    pub fn get_proxy_request_path_template(&self) -> &str {
        match self.proxy_request_path_template.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_proxy_request_path_template(&mut self) {
        self.proxy_request_path_template.clear();
    }

    pub fn has_proxy_request_path_template(&self) -> bool {
        self.proxy_request_path_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_request_path_template(&mut self, v: ::std::string::String) {
        self.proxy_request_path_template = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proxy_request_path_template(&mut self) -> &mut ::std::string::String {
        if self.proxy_request_path_template.is_none() {
            self.proxy_request_path_template.set_default();
        }
        self.proxy_request_path_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_proxy_request_path_template(&mut self) -> ::std::string::String {
        self.proxy_request_path_template.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string https_support = 12;


    pub fn get_https_support(&self) -> &str {
        match self.https_support.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_https_support(&mut self) {
        self.https_support.clear();
    }

    pub fn has_https_support(&self) -> bool {
        self.https_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_https_support(&mut self, v: ::std::string::String) {
        self.https_support = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_https_support(&mut self) -> &mut ::std::string::String {
        if self.https_support.is_none() {
            self.https_support.set_default();
        }
        self.https_support.as_mut().unwrap()
    }

    // Take field
    pub fn take_https_support(&mut self) -> ::std::string::String {
        self.https_support.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint32 allowed_app_ids = 13;


    pub fn get_allowed_app_ids(&self) -> &[u32] {
        &self.allowed_app_ids
    }
    pub fn clear_allowed_app_ids(&mut self) {
        self.allowed_app_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_app_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.allowed_app_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_app_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.allowed_app_ids
    }

    // Take field
    pub fn take_allowed_app_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.allowed_app_ids, ::std::vec::Vec::new())
    }

    // optional bool preferred_server = 14;


    pub fn get_preferred_server(&self) -> bool {
        self.preferred_server.unwrap_or(false)
    }
    pub fn clear_preferred_server(&mut self) {
        self.preferred_server = ::std::option::Option::None;
    }

    pub fn has_preferred_server(&self) -> bool {
        self.preferred_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_server(&mut self, v: bool) {
        self.preferred_server = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CContentServerDirectory_ServerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.source_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.load = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.weighted_load = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_entries_in_client_list = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.steam_china_only = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vhost)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_as_proxy = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.proxy_request_path_template)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.https_support)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.allowed_app_ids)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.preferred_server = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.source_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.load {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.weighted_load {
            my_size += 5;
        }
        if let Some(v) = self.num_entries_in_client_list {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_china_only {
            my_size += 2;
        }
        if let Some(ref v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.vhost.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.use_as_proxy {
            my_size += 2;
        }
        if let Some(ref v) = self.proxy_request_path_template.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.https_support.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        for value in &self.allowed_app_ids {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.preferred_server {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.source_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.load {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.weighted_load {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.num_entries_in_client_list {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_china_only {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.vhost.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.use_as_proxy {
            os.write_bool(10, v)?;
        }
        if let Some(ref v) = self.proxy_request_path_template.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.https_support.as_ref() {
            os.write_string(12, &v)?;
        }
        for v in &self.allowed_app_ids {
            os.write_uint32(13, *v)?;
        };
        if let Some(v) = self.preferred_server {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CContentServerDirectory_ServerInfo {
        CContentServerDirectory_ServerInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &CContentServerDirectory_ServerInfo| { &m.field_type },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "source_id",
                    |m: &CContentServerDirectory_ServerInfo| { &m.source_id },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.source_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "cell_id",
                    |m: &CContentServerDirectory_ServerInfo| { &m.cell_id },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.cell_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "load",
                    |m: &CContentServerDirectory_ServerInfo| { &m.load },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.load },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "weighted_load",
                    |m: &CContentServerDirectory_ServerInfo| { &m.weighted_load },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.weighted_load },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_entries_in_client_list",
                    |m: &CContentServerDirectory_ServerInfo| { &m.num_entries_in_client_list },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.num_entries_in_client_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "steam_china_only",
                    |m: &CContentServerDirectory_ServerInfo| { &m.steam_china_only },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.steam_china_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host",
                    |m: &CContentServerDirectory_ServerInfo| { &m.host },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.host },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vhost",
                    |m: &CContentServerDirectory_ServerInfo| { &m.vhost },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.vhost },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_as_proxy",
                    |m: &CContentServerDirectory_ServerInfo| { &m.use_as_proxy },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.use_as_proxy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "proxy_request_path_template",
                    |m: &CContentServerDirectory_ServerInfo| { &m.proxy_request_path_template },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.proxy_request_path_template },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "https_support",
                    |m: &CContentServerDirectory_ServerInfo| { &m.https_support },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.https_support },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "allowed_app_ids",
                    |m: &CContentServerDirectory_ServerInfo| { &m.allowed_app_ids },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.allowed_app_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "preferred_server",
                    |m: &CContentServerDirectory_ServerInfo| { &m.preferred_server },
                    |m: &mut CContentServerDirectory_ServerInfo| { &mut m.preferred_server },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CContentServerDirectory_ServerInfo>(
                    "CContentServerDirectory_ServerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CContentServerDirectory_ServerInfo {
        static mut instance: ::protobuf::lazy::Lazy<CContentServerDirectory_ServerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CContentServerDirectory_ServerInfo,
        };
        unsafe {
            instance.get(CContentServerDirectory_ServerInfo::new)
        }
    }
}

impl ::protobuf::Clear for CContentServerDirectory_ServerInfo {
    fn clear(&mut self) {
        self.field_type.clear();
        self.source_id = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.load = ::std::option::Option::None;
        self.weighted_load = ::std::option::Option::None;
        self.num_entries_in_client_list = ::std::option::Option::None;
        self.steam_china_only = ::std::option::Option::None;
        self.host.clear();
        self.vhost.clear();
        self.use_as_proxy = ::std::option::Option::None;
        self.proxy_request_path_template.clear();
        self.https_support.clear();
        self.allowed_app_ids.clear();
        self.preferred_server = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CContentServerDirectory_ServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CContentServerDirectory_ServerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CContentServerDirectory_GetServersForSteamPipe_Response {
    // message fields
    servers: ::protobuf::RepeatedField<CContentServerDirectory_ServerInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CContentServerDirectory_GetServersForSteamPipe_Response {
    fn default() -> &'a CContentServerDirectory_GetServersForSteamPipe_Response {
        <CContentServerDirectory_GetServersForSteamPipe_Response as ::protobuf::Message>::default_instance()
    }
}

impl CContentServerDirectory_GetServersForSteamPipe_Response {
    pub fn new() -> CContentServerDirectory_GetServersForSteamPipe_Response {
        ::std::default::Default::default()
    }

    // repeated .CContentServerDirectory_ServerInfo servers = 1;


    pub fn get_servers(&self) -> &[CContentServerDirectory_ServerInfo] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<CContentServerDirectory_ServerInfo>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<CContentServerDirectory_ServerInfo> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<CContentServerDirectory_ServerInfo> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CContentServerDirectory_GetServersForSteamPipe_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.servers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CContentServerDirectory_GetServersForSteamPipe_Response {
        CContentServerDirectory_GetServersForSteamPipe_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CContentServerDirectory_ServerInfo>>(
                    "servers",
                    |m: &CContentServerDirectory_GetServersForSteamPipe_Response| { &m.servers },
                    |m: &mut CContentServerDirectory_GetServersForSteamPipe_Response| { &mut m.servers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CContentServerDirectory_GetServersForSteamPipe_Response>(
                    "CContentServerDirectory_GetServersForSteamPipe_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CContentServerDirectory_GetServersForSteamPipe_Response {
        static mut instance: ::protobuf::lazy::Lazy<CContentServerDirectory_GetServersForSteamPipe_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CContentServerDirectory_GetServersForSteamPipe_Response,
        };
        unsafe {
            instance.get(CContentServerDirectory_GetServersForSteamPipe_Response::new)
        }
    }
}

impl ::protobuf::Clear for CContentServerDirectory_GetServersForSteamPipe_Response {
    fn clear(&mut self) {
        self.servers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CContentServerDirectory_GetServersForSteamPipe_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CContentServerDirectory_GetServersForSteamPipe_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CContentServerDirectory_GetDepotPatchInfo_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    depotid: ::std::option::Option<u32>,
    source_manifestid: ::std::option::Option<u64>,
    target_manifestid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CContentServerDirectory_GetDepotPatchInfo_Request {
    fn default() -> &'a CContentServerDirectory_GetDepotPatchInfo_Request {
        <CContentServerDirectory_GetDepotPatchInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CContentServerDirectory_GetDepotPatchInfo_Request {
    pub fn new() -> CContentServerDirectory_GetDepotPatchInfo_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 depotid = 2;


    pub fn get_depotid(&self) -> u32 {
        self.depotid.unwrap_or(0)
    }
    pub fn clear_depotid(&mut self) {
        self.depotid = ::std::option::Option::None;
    }

    pub fn has_depotid(&self) -> bool {
        self.depotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depotid(&mut self, v: u32) {
        self.depotid = ::std::option::Option::Some(v);
    }

    // optional uint64 source_manifestid = 3;


    pub fn get_source_manifestid(&self) -> u64 {
        self.source_manifestid.unwrap_or(0)
    }
    pub fn clear_source_manifestid(&mut self) {
        self.source_manifestid = ::std::option::Option::None;
    }

    pub fn has_source_manifestid(&self) -> bool {
        self.source_manifestid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_manifestid(&mut self, v: u64) {
        self.source_manifestid = ::std::option::Option::Some(v);
    }

    // optional uint64 target_manifestid = 4;


    pub fn get_target_manifestid(&self) -> u64 {
        self.target_manifestid.unwrap_or(0)
    }
    pub fn clear_target_manifestid(&mut self) {
        self.target_manifestid = ::std::option::Option::None;
    }

    pub fn has_target_manifestid(&self) -> bool {
        self.target_manifestid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_manifestid(&mut self, v: u64) {
        self.target_manifestid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CContentServerDirectory_GetDepotPatchInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.depotid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.source_manifestid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.target_manifestid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.depotid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.source_manifestid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_manifestid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.depotid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.source_manifestid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.target_manifestid {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CContentServerDirectory_GetDepotPatchInfo_Request {
        CContentServerDirectory_GetDepotPatchInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CContentServerDirectory_GetDepotPatchInfo_Request| { &m.appid },
                    |m: &mut CContentServerDirectory_GetDepotPatchInfo_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "depotid",
                    |m: &CContentServerDirectory_GetDepotPatchInfo_Request| { &m.depotid },
                    |m: &mut CContentServerDirectory_GetDepotPatchInfo_Request| { &mut m.depotid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "source_manifestid",
                    |m: &CContentServerDirectory_GetDepotPatchInfo_Request| { &m.source_manifestid },
                    |m: &mut CContentServerDirectory_GetDepotPatchInfo_Request| { &mut m.source_manifestid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "target_manifestid",
                    |m: &CContentServerDirectory_GetDepotPatchInfo_Request| { &m.target_manifestid },
                    |m: &mut CContentServerDirectory_GetDepotPatchInfo_Request| { &mut m.target_manifestid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CContentServerDirectory_GetDepotPatchInfo_Request>(
                    "CContentServerDirectory_GetDepotPatchInfo_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CContentServerDirectory_GetDepotPatchInfo_Request {
        static mut instance: ::protobuf::lazy::Lazy<CContentServerDirectory_GetDepotPatchInfo_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CContentServerDirectory_GetDepotPatchInfo_Request,
        };
        unsafe {
            instance.get(CContentServerDirectory_GetDepotPatchInfo_Request::new)
        }
    }
}

impl ::protobuf::Clear for CContentServerDirectory_GetDepotPatchInfo_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.depotid = ::std::option::Option::None;
        self.source_manifestid = ::std::option::Option::None;
        self.target_manifestid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CContentServerDirectory_GetDepotPatchInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CContentServerDirectory_GetDepotPatchInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CContentServerDirectory_GetDepotPatchInfo_Response {
    // message fields
    is_available: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CContentServerDirectory_GetDepotPatchInfo_Response {
    fn default() -> &'a CContentServerDirectory_GetDepotPatchInfo_Response {
        <CContentServerDirectory_GetDepotPatchInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CContentServerDirectory_GetDepotPatchInfo_Response {
    pub fn new() -> CContentServerDirectory_GetDepotPatchInfo_Response {
        ::std::default::Default::default()
    }

    // optional bool is_available = 1;


    pub fn get_is_available(&self) -> bool {
        self.is_available.unwrap_or(false)
    }
    pub fn clear_is_available(&mut self) {
        self.is_available = ::std::option::Option::None;
    }

    pub fn has_is_available(&self) -> bool {
        self.is_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_available(&mut self, v: bool) {
        self.is_available = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CContentServerDirectory_GetDepotPatchInfo_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_available = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_available {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_available {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CContentServerDirectory_GetDepotPatchInfo_Response {
        CContentServerDirectory_GetDepotPatchInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_available",
                    |m: &CContentServerDirectory_GetDepotPatchInfo_Response| { &m.is_available },
                    |m: &mut CContentServerDirectory_GetDepotPatchInfo_Response| { &mut m.is_available },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CContentServerDirectory_GetDepotPatchInfo_Response>(
                    "CContentServerDirectory_GetDepotPatchInfo_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CContentServerDirectory_GetDepotPatchInfo_Response {
        static mut instance: ::protobuf::lazy::Lazy<CContentServerDirectory_GetDepotPatchInfo_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CContentServerDirectory_GetDepotPatchInfo_Response,
        };
        unsafe {
            instance.get(CContentServerDirectory_GetDepotPatchInfo_Response::new)
        }
    }
}

impl ::protobuf::Clear for CContentServerDirectory_GetDepotPatchInfo_Response {
    fn clear(&mut self) {
        self.is_available = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CContentServerDirectory_GetDepotPatchInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CContentServerDirectory_GetDepotPatchInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-steammessages_contentsystem.steamclient.proto\x1a,steammessages_unifi\
    ed_base.steamclient.proto\"\x9f\x02\n6CContentServerDirectory_GetServers\
    ForSteamPipe_Request\x12+\n\x07cell_id\x18\x01\x20\x01(\rR\x06cellIdB\
    \x12\x82\xb5\x18\x0eclient\x20Cell\x20ID\x12E\n\x0bmax_servers\x18\x02\
    \x20\x01(\r:\x0220R\nmaxServersB\x20\x82\xb5\x18\x1cmax\x20servers\x20in\
    \x20response\x20list\x126\n\x0bip_override\x18\x03\x20\x01(\tR\nipOverri\
    deB\x15\x82\xb5\x18\x11client\x20IP\x20address\x129\n\rlauncher_type\x18\
    \x04\x20\x01(\x05:\x010R\x0clauncherTypeB\x11\x82\xb5\x18\rlauncher\x20t\
    ype\"\x90\x04\n\"CContentServerDirectory_ServerInfo\x12\x12\n\x04type\
    \x18\x01\x20\x01(\tR\x04type\x12\x1b\n\tsource_id\x18\x02\x20\x01(\x05R\
    \x08sourceId\x12\x17\n\x07cell_id\x18\x03\x20\x01(\x05R\x06cellId\x12\
    \x12\n\x04load\x18\x04\x20\x01(\x05R\x04load\x12#\n\rweighted_load\x18\
    \x05\x20\x01(\x02R\x0cweightedLoad\x12:\n\x1anum_entries_in_client_list\
    \x18\x06\x20\x01(\x05R\x16numEntriesInClientList\x12(\n\x10steam_china_o\
    nly\x18\x07\x20\x01(\x08R\x0esteamChinaOnly\x12\x12\n\x04host\x18\x08\
    \x20\x01(\tR\x04host\x12\x14\n\x05vhost\x18\t\x20\x01(\tR\x05vhost\x12\
    \x20\n\x0cuse_as_proxy\x18\n\x20\x01(\x08R\nuseAsProxy\x12=\n\x1bproxy_r\
    equest_path_template\x18\x0b\x20\x01(\tR\x18proxyRequestPathTemplate\x12\
    #\n\rhttps_support\x18\x0c\x20\x01(\tR\x0chttpsSupport\x12&\n\x0fallowed\
    _app_ids\x18\r\x20\x03(\rR\rallowedAppIds\x12)\n\x10preferred_server\x18\
    \x0e\x20\x01(\x08R\x0fpreferredServer\"x\n7CContentServerDirectory_GetSe\
    rversForSteamPipe_Response\x12=\n\x07servers\x18\x01\x20\x03(\x0b2#.CCon\
    tentServerDirectory_ServerInfoR\x07servers\"\xbd\x01\n1CContentServerDir\
    ectory_GetDepotPatchInfo_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\
    \x05appid\x12\x18\n\x07depotid\x18\x02\x20\x01(\rR\x07depotid\x12+\n\x11\
    source_manifestid\x18\x03\x20\x01(\x04R\x10sourceManifestid\x12+\n\x11ta\
    rget_manifestid\x18\x04\x20\x01(\x04R\x10targetManifestid\"W\n2CContentS\
    erverDirectory_GetDepotPatchInfo_Response\x12!\n\x0cis_available\x18\x01\
    \x20\x01(\x08R\x0bisAvailable2\xca\x02\n\x16ContentServerDirectory\x12\
    \x8b\x01\n\x16GetServersForSteamPipe\x127.CContentServerDirectory_GetSer\
    versForSteamPipe_Request\x1a8.CContentServerDirectory_GetServersForSteam\
    Pipe_Response\x12|\n\x11GetDepotPatchInfo\x122.CContentServerDirectory_G\
    etDepotPatchInfo_Request\x1a3.CContentServerDirectory_GetDepotPatchInfo_\
    Response\x1a$\x82\xb5\x18\x20Content\x20Server\x20and\x20CDN\x20director\
    yB\x03\x80\x01\x01\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
