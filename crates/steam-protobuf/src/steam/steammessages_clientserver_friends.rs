// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.10.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//! Generated file from `steammessages_clientserver_friends.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFriendMsg {
    // message fields
    steamid: ::std::option::Option<u64>,
    chat_entry_type: ::std::option::Option<i32>,
    message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rtime32_server_timestamp: ::std::option::Option<u32>,
    echo_to_sender: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendMsg {
    fn default() -> &'a CMsgClientFriendMsg {
        <CMsgClientFriendMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendMsg {
    pub fn new() -> CMsgClientFriendMsg {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 chat_entry_type = 2;

    pub fn get_chat_entry_type(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }

    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    // optional bytes message = 3;

    pub fn get_message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 rtime32_server_timestamp = 4;

    pub fn get_rtime32_server_timestamp(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }

    // optional bool echo_to_sender = 5;

    pub fn get_echo_to_sender(&self) -> bool {
        self.echo_to_sender.unwrap_or(false)
    }

    pub fn clear_echo_to_sender(&mut self) {
        self.echo_to_sender = ::std::option::Option::None;
    }

    pub fn has_echo_to_sender(&self) -> bool {
        self.echo_to_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_echo_to_sender(&mut self, v: bool) {
        self.echo_to_sender = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chat_entry_type = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rtime32_server_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.echo_to_sender = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.chat_entry_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.rtime32_server_timestamp {
            my_size += 5;
        }
        if let Some(v) = self.echo_to_sender {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_entry_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.rtime32_server_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.echo_to_sender {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendMsg {
        CMsgClientFriendMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CMsgClientFriendMsg| { &m.steamid },
                |m: &mut CMsgClientFriendMsg| { &mut m.steamid },
                CMsgClientFriendMsg::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "chat_entry_type",
                |m: &CMsgClientFriendMsg| { &m.chat_entry_type },
                |m: &mut CMsgClientFriendMsg| { &mut m.chat_entry_type },
                CMsgClientFriendMsg::get_chat_entry_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "message",
                |m: &CMsgClientFriendMsg| { &m.message },
                |m: &mut CMsgClientFriendMsg| { &mut m.message },
                CMsgClientFriendMsg::get_message,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "rtime32_server_timestamp",
                |m: &CMsgClientFriendMsg| { &m.rtime32_server_timestamp },
                |m: &mut CMsgClientFriendMsg| { &mut m.rtime32_server_timestamp },
                CMsgClientFriendMsg::get_rtime32_server_timestamp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "echo_to_sender",
                |m: &CMsgClientFriendMsg| { &m.echo_to_sender },
                |m: &mut CMsgClientFriendMsg| { &mut m.echo_to_sender },
                CMsgClientFriendMsg::get_echo_to_sender,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendMsg>(
                "CMsgClientFriendMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendMsg {
        static instance: ::protobuf::rt::Lazy<CMsgClientFriendMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientFriendMsg::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendMsg {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.chat_entry_type = ::std::option::Option::None;
        self.message.clear();
        self.rtime32_server_timestamp = ::std::option::Option::None;
        self.echo_to_sender = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFriendMsgIncoming {
    // message fields
    steamid_from: ::std::option::Option<u64>,
    chat_entry_type: ::std::option::Option<i32>,
    from_limited_account: ::std::option::Option<bool>,
    message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rtime32_server_timestamp: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendMsgIncoming {
    fn default() -> &'a CMsgClientFriendMsgIncoming {
        <CMsgClientFriendMsgIncoming as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendMsgIncoming {
    pub fn new() -> CMsgClientFriendMsgIncoming {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_from = 1;

    pub fn get_steamid_from(&self) -> u64 {
        self.steamid_from.unwrap_or(0)
    }

    pub fn clear_steamid_from(&mut self) {
        self.steamid_from = ::std::option::Option::None;
    }

    pub fn has_steamid_from(&self) -> bool {
        self.steamid_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_from(&mut self, v: u64) {
        self.steamid_from = ::std::option::Option::Some(v);
    }

    // optional int32 chat_entry_type = 2;

    pub fn get_chat_entry_type(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }

    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    // optional bool from_limited_account = 3;

    pub fn get_from_limited_account(&self) -> bool {
        self.from_limited_account.unwrap_or(false)
    }

    pub fn clear_from_limited_account(&mut self) {
        self.from_limited_account = ::std::option::Option::None;
    }

    pub fn has_from_limited_account(&self) -> bool {
        self.from_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_limited_account(&mut self, v: bool) {
        self.from_limited_account = ::std::option::Option::Some(v);
    }

    // optional bytes message = 4;

    pub fn get_message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 rtime32_server_timestamp = 5;

    pub fn get_rtime32_server_timestamp(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendMsgIncoming {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_from = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chat_entry_type = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.from_limited_account = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rtime32_server_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_from {
            my_size += 9;
        }
        if let Some(v) = self.chat_entry_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_limited_account {
            my_size += 2;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.rtime32_server_timestamp {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_from {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_entry_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_limited_account {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.rtime32_server_timestamp {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendMsgIncoming {
        CMsgClientFriendMsgIncoming::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_from",
                |m: &CMsgClientFriendMsgIncoming| { &m.steamid_from },
                |m: &mut CMsgClientFriendMsgIncoming| { &mut m.steamid_from },
                CMsgClientFriendMsgIncoming::get_steamid_from,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "chat_entry_type",
                |m: &CMsgClientFriendMsgIncoming| { &m.chat_entry_type },
                |m: &mut CMsgClientFriendMsgIncoming| { &mut m.chat_entry_type },
                CMsgClientFriendMsgIncoming::get_chat_entry_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "from_limited_account",
                |m: &CMsgClientFriendMsgIncoming| { &m.from_limited_account },
                |m: &mut CMsgClientFriendMsgIncoming| { &mut m.from_limited_account },
                CMsgClientFriendMsgIncoming::get_from_limited_account,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "message",
                |m: &CMsgClientFriendMsgIncoming| { &m.message },
                |m: &mut CMsgClientFriendMsgIncoming| { &mut m.message },
                CMsgClientFriendMsgIncoming::get_message,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "rtime32_server_timestamp",
                |m: &CMsgClientFriendMsgIncoming| { &m.rtime32_server_timestamp },
                |m: &mut CMsgClientFriendMsgIncoming| { &mut m.rtime32_server_timestamp },
                CMsgClientFriendMsgIncoming::get_rtime32_server_timestamp,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendMsgIncoming>(
                "CMsgClientFriendMsgIncoming",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendMsgIncoming {
        static instance: ::protobuf::rt::Lazy<CMsgClientFriendMsgIncoming> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientFriendMsgIncoming::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendMsgIncoming {
    fn clear(&mut self) {
        self.steamid_from = ::std::option::Option::None;
        self.chat_entry_type = ::std::option::Option::None;
        self.from_limited_account = ::std::option::Option::None;
        self.message.clear();
        self.rtime32_server_timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendMsgIncoming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendMsgIncoming {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAddFriend {
    // message fields
    steamid_to_add: ::std::option::Option<u64>,
    accountname_or_email_to_add: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriend {
    fn default() -> &'a CMsgClientAddFriend {
        <CMsgClientAddFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriend {
    pub fn new() -> CMsgClientAddFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_to_add = 1;

    pub fn get_steamid_to_add(&self) -> u64 {
        self.steamid_to_add.unwrap_or(0)
    }

    pub fn clear_steamid_to_add(&mut self) {
        self.steamid_to_add = ::std::option::Option::None;
    }

    pub fn has_steamid_to_add(&self) -> bool {
        self.steamid_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_to_add(&mut self, v: u64) {
        self.steamid_to_add = ::std::option::Option::Some(v);
    }

    // optional string accountname_or_email_to_add = 2;

    pub fn get_accountname_or_email_to_add(&self) -> &str {
        match self.accountname_or_email_to_add.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_accountname_or_email_to_add(&mut self) {
        self.accountname_or_email_to_add.clear();
    }

    pub fn has_accountname_or_email_to_add(&self) -> bool {
        self.accountname_or_email_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountname_or_email_to_add(&mut self, v: ::std::string::String) {
        self.accountname_or_email_to_add = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountname_or_email_to_add(&mut self) -> &mut ::std::string::String {
        if self.accountname_or_email_to_add.is_none() {
            self.accountname_or_email_to_add.set_default();
        }
        self.accountname_or_email_to_add.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountname_or_email_to_add(&mut self) -> ::std::string::String {
        self.accountname_or_email_to_add.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientAddFriend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_to_add = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.accountname_or_email_to_add)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_to_add {
            my_size += 9;
        }
        if let Some(v) = self.accountname_or_email_to_add.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_to_add {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.accountname_or_email_to_add.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAddFriend {
        CMsgClientAddFriend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_to_add",
                |m: &CMsgClientAddFriend| { &m.steamid_to_add },
                |m: &mut CMsgClientAddFriend| { &mut m.steamid_to_add },
                CMsgClientAddFriend::get_steamid_to_add,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "accountname_or_email_to_add",
                |m: &CMsgClientAddFriend| { &m.accountname_or_email_to_add },
                |m: &mut CMsgClientAddFriend| { &mut m.accountname_or_email_to_add },
                CMsgClientAddFriend::get_accountname_or_email_to_add,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAddFriend>(
                "CMsgClientAddFriend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAddFriend {
        static instance: ::protobuf::rt::Lazy<CMsgClientAddFriend> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAddFriend::new)
    }
}

impl ::protobuf::Clear for CMsgClientAddFriend {
    fn clear(&mut self) {
        self.steamid_to_add = ::std::option::Option::None;
        self.accountname_or_email_to_add.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAddFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAddFriend {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAddFriendResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    steam_id_added: ::std::option::Option<u64>,
    persona_name_added: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendResponse {
    fn default() -> &'a CMsgClientAddFriendResponse {
        <CMsgClientAddFriendResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriendResponse {
    pub fn new() -> CMsgClientAddFriendResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_added = 2;

    pub fn get_steam_id_added(&self) -> u64 {
        self.steam_id_added.unwrap_or(0)
    }

    pub fn clear_steam_id_added(&mut self) {
        self.steam_id_added = ::std::option::Option::None;
    }

    pub fn has_steam_id_added(&self) -> bool {
        self.steam_id_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_added(&mut self, v: u64) {
        self.steam_id_added = ::std::option::Option::Some(v);
    }

    // optional string persona_name_added = 3;

    pub fn get_persona_name_added(&self) -> &str {
        match self.persona_name_added.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name_added(&mut self) {
        self.persona_name_added.clear();
    }

    pub fn has_persona_name_added(&self) -> bool {
        self.persona_name_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_added(&mut self, v: ::std::string::String) {
        self.persona_name_added = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_added(&mut self) -> &mut ::std::string::String {
        if self.persona_name_added.is_none() {
            self.persona_name_added.set_default();
        }
        self.persona_name_added.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_added(&mut self) -> ::std::string::String {
        self.persona_name_added.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientAddFriendResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_added = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name_added)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_added {
            my_size += 9;
        }
        if let Some(v) = self.persona_name_added.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steam_id_added {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.persona_name_added.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAddFriendResponse {
        CMsgClientAddFriendResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientAddFriendResponse| { &m.eresult },
                |m: &mut CMsgClientAddFriendResponse| { &mut m.eresult },
                CMsgClientAddFriendResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_added",
                |m: &CMsgClientAddFriendResponse| { &m.steam_id_added },
                |m: &mut CMsgClientAddFriendResponse| { &mut m.steam_id_added },
                CMsgClientAddFriendResponse::get_steam_id_added,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "persona_name_added",
                |m: &CMsgClientAddFriendResponse| { &m.persona_name_added },
                |m: &mut CMsgClientAddFriendResponse| { &mut m.persona_name_added },
                CMsgClientAddFriendResponse::get_persona_name_added,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAddFriendResponse>(
                "CMsgClientAddFriendResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAddFriendResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientAddFriendResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAddFriendResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientAddFriendResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steam_id_added = ::std::option::Option::None;
        self.persona_name_added.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAddFriendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAddFriendResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRemoveFriend {
    // message fields
    friendid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriend {
    fn default() -> &'a CMsgClientRemoveFriend {
        <CMsgClientRemoveFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriend {
    pub fn new() -> CMsgClientRemoveFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 friendid = 1;

    pub fn get_friendid(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }

    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRemoveFriend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.friendid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friendid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friendid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRemoveFriend {
        CMsgClientRemoveFriend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "friendid",
                |m: &CMsgClientRemoveFriend| { &m.friendid },
                |m: &mut CMsgClientRemoveFriend| { &mut m.friendid },
                CMsgClientRemoveFriend::get_friendid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRemoveFriend>(
                "CMsgClientRemoveFriend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRemoveFriend {
        static instance: ::protobuf::rt::Lazy<CMsgClientRemoveFriend> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRemoveFriend::new)
    }
}

impl ::protobuf::Clear for CMsgClientRemoveFriend {
    fn clear(&mut self) {
        self.friendid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRemoveFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRemoveFriend {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientHideFriend {
    // message fields
    friendid: ::std::option::Option<u64>,
    hide: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientHideFriend {
    fn default() -> &'a CMsgClientHideFriend {
        <CMsgClientHideFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientHideFriend {
    pub fn new() -> CMsgClientHideFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 friendid = 1;

    pub fn get_friendid(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }

    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }

    // optional bool hide = 2;

    pub fn get_hide(&self) -> bool {
        self.hide.unwrap_or(false)
    }

    pub fn clear_hide(&mut self) {
        self.hide = ::std::option::Option::None;
    }

    pub fn has_hide(&self) -> bool {
        self.hide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide(&mut self, v: bool) {
        self.hide = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientHideFriend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.friendid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hide = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friendid {
            my_size += 9;
        }
        if let Some(v) = self.hide {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friendid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.hide {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientHideFriend {
        CMsgClientHideFriend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "friendid",
                |m: &CMsgClientHideFriend| { &m.friendid },
                |m: &mut CMsgClientHideFriend| { &mut m.friendid },
                CMsgClientHideFriend::get_friendid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "hide",
                |m: &CMsgClientHideFriend| { &m.hide },
                |m: &mut CMsgClientHideFriend| { &mut m.hide },
                CMsgClientHideFriend::get_hide,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientHideFriend>(
                "CMsgClientHideFriend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientHideFriend {
        static instance: ::protobuf::rt::Lazy<CMsgClientHideFriend> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientHideFriend::new)
    }
}

impl ::protobuf::Clear for CMsgClientHideFriend {
    fn clear(&mut self) {
        self.friendid = ::std::option::Option::None;
        self.hide = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientHideFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientHideFriend {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFriendsList {
    // message fields
    bincremental: ::std::option::Option<bool>,
    pub friends: ::protobuf::RepeatedField<cmsg_client_friends_list::Friend>,
    max_friend_count: ::std::option::Option<u32>,
    active_friend_count: ::std::option::Option<u32>,
    friends_limit_hit: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsList {
    fn default() -> &'a CMsgClientFriendsList {
        <CMsgClientFriendsList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendsList {
    pub fn new() -> CMsgClientFriendsList {
        ::std::default::Default::default()
    }

    // optional bool bincremental = 1;

    pub fn get_bincremental(&self) -> bool {
        self.bincremental.unwrap_or(false)
    }

    pub fn clear_bincremental(&mut self) {
        self.bincremental = ::std::option::Option::None;
    }

    pub fn has_bincremental(&self) -> bool {
        self.bincremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bincremental(&mut self, v: bool) {
        self.bincremental = ::std::option::Option::Some(v);
    }

    // optional uint32 max_friend_count = 3;

    pub fn get_max_friend_count(&self) -> u32 {
        self.max_friend_count.unwrap_or(0)
    }

    pub fn clear_max_friend_count(&mut self) {
        self.max_friend_count = ::std::option::Option::None;
    }

    pub fn has_max_friend_count(&self) -> bool {
        self.max_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_friend_count(&mut self, v: u32) {
        self.max_friend_count = ::std::option::Option::Some(v);
    }

    // optional uint32 active_friend_count = 4;

    pub fn get_active_friend_count(&self) -> u32 {
        self.active_friend_count.unwrap_or(0)
    }

    pub fn clear_active_friend_count(&mut self) {
        self.active_friend_count = ::std::option::Option::None;
    }

    pub fn has_active_friend_count(&self) -> bool {
        self.active_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_friend_count(&mut self, v: u32) {
        self.active_friend_count = ::std::option::Option::Some(v);
    }

    // optional bool friends_limit_hit = 5;

    pub fn get_friends_limit_hit(&self) -> bool {
        self.friends_limit_hit.unwrap_or(false)
    }

    pub fn clear_friends_limit_hit(&mut self) {
        self.friends_limit_hit = ::std::option::Option::None;
    }

    pub fn has_friends_limit_hit(&self) -> bool {
        self.friends_limit_hit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_limit_hit(&mut self, v: bool) {
        self.friends_limit_hit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendsList {
    fn is_initialized(&self) -> bool {
        for v in &self.friends {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bincremental = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.friends)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.max_friend_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.active_friend_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.friends_limit_hit = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bincremental {
            my_size += 2;
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.max_friend_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_friend_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_limit_hit {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bincremental {
            os.write_bool(1, v)?;
        }
        for v in &self.friends {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.max_friend_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active_friend_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.friends_limit_hit {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendsList {
        CMsgClientFriendsList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "bincremental",
                |m: &CMsgClientFriendsList| { &m.bincremental },
                |m: &mut CMsgClientFriendsList| { &mut m.bincremental },
                CMsgClientFriendsList::get_bincremental,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_friends_list::Friend>>(
                "friends",
                |m: &CMsgClientFriendsList| { &m.friends },
                |m: &mut CMsgClientFriendsList| { &mut m.friends },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "max_friend_count",
                |m: &CMsgClientFriendsList| { &m.max_friend_count },
                |m: &mut CMsgClientFriendsList| { &mut m.max_friend_count },
                CMsgClientFriendsList::get_max_friend_count,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "active_friend_count",
                |m: &CMsgClientFriendsList| { &m.active_friend_count },
                |m: &mut CMsgClientFriendsList| { &mut m.active_friend_count },
                CMsgClientFriendsList::get_active_friend_count,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "friends_limit_hit",
                |m: &CMsgClientFriendsList| { &m.friends_limit_hit },
                |m: &mut CMsgClientFriendsList| { &mut m.friends_limit_hit },
                CMsgClientFriendsList::get_friends_limit_hit,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendsList>(
                "CMsgClientFriendsList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendsList {
        static instance: ::protobuf::rt::Lazy<CMsgClientFriendsList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientFriendsList::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendsList {
    fn clear(&mut self) {
        self.bincremental = ::std::option::Option::None;
        self.friends.clear();
        self.max_friend_count = ::std::option::Option::None;
        self.active_friend_count = ::std::option::Option::None;
        self.friends_limit_hit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendsList {
}

/// Nested message and enums of message `CMsgClientFriendsList`
pub mod cmsg_client_friends_list {
    #[derive(PartialEq,Clone,Default)]
    pub struct Friend {
        // message fields
        ulfriendid: ::std::option::Option<u64>,
        efriendrelationship: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Friend {
        fn default() -> &'a Friend {
            <Friend as ::protobuf::Message>::default_instance()
        }
    }

    impl Friend {
        pub fn new() -> Friend {
            ::std::default::Default::default()
        }

        // optional fixed64 ulfriendid = 1;

        pub fn get_ulfriendid(&self) -> u64 {
            self.ulfriendid.unwrap_or(0)
        }

        pub fn clear_ulfriendid(&mut self) {
            self.ulfriendid = ::std::option::Option::None;
        }

        pub fn has_ulfriendid(&self) -> bool {
            self.ulfriendid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ulfriendid(&mut self, v: u64) {
            self.ulfriendid = ::std::option::Option::Some(v);
        }

        // optional uint32 efriendrelationship = 2;

        pub fn get_efriendrelationship(&self) -> u32 {
            self.efriendrelationship.unwrap_or(0)
        }

        pub fn clear_efriendrelationship(&mut self) {
            self.efriendrelationship = ::std::option::Option::None;
        }

        pub fn has_efriendrelationship(&self) -> bool {
            self.efriendrelationship.is_some()
        }

        // Param is passed by value, moved
        pub fn set_efriendrelationship(&mut self, v: u32) {
            self.efriendrelationship = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Friend {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.ulfriendid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.efriendrelationship = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.ulfriendid {
                my_size += 9;
            }
            if let Some(v) = self.efriendrelationship {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.ulfriendid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.efriendrelationship {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Friend {
            Friend::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "ulfriendid",
                    |m: &Friend| { &m.ulfriendid },
                    |m: &mut Friend| { &mut m.ulfriendid },
                    Friend::get_ulfriendid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "efriendrelationship",
                    |m: &Friend| { &m.efriendrelationship },
                    |m: &mut Friend| { &mut m.efriendrelationship },
                    Friend::get_efriendrelationship,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Friend>(
                    "CMsgClientFriendsList.Friend",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Friend {
            static instance: ::protobuf::rt::Lazy<Friend> = ::protobuf::rt::Lazy::INIT;
            instance.get(Friend::new)
        }
    }

    impl ::protobuf::Clear for Friend {
        fn clear(&mut self) {
            self.ulfriendid = ::std::option::Option::None;
            self.efriendrelationship = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Friend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Friend {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFriendsGroupsList {
    // message fields
    bremoval: ::std::option::Option<bool>,
    bincremental: ::std::option::Option<bool>,
    pub friendGroups: ::protobuf::RepeatedField<cmsg_client_friends_groups_list::FriendGroup>,
    pub memberships: ::protobuf::RepeatedField<cmsg_client_friends_groups_list::FriendGroupsMembership>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsGroupsList {
    fn default() -> &'a CMsgClientFriendsGroupsList {
        <CMsgClientFriendsGroupsList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendsGroupsList {
    pub fn new() -> CMsgClientFriendsGroupsList {
        ::std::default::Default::default()
    }

    // optional bool bremoval = 1;

    pub fn get_bremoval(&self) -> bool {
        self.bremoval.unwrap_or(false)
    }

    pub fn clear_bremoval(&mut self) {
        self.bremoval = ::std::option::Option::None;
    }

    pub fn has_bremoval(&self) -> bool {
        self.bremoval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bremoval(&mut self, v: bool) {
        self.bremoval = ::std::option::Option::Some(v);
    }

    // optional bool bincremental = 2;

    pub fn get_bincremental(&self) -> bool {
        self.bincremental.unwrap_or(false)
    }

    pub fn clear_bincremental(&mut self) {
        self.bincremental = ::std::option::Option::None;
    }

    pub fn has_bincremental(&self) -> bool {
        self.bincremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bincremental(&mut self, v: bool) {
        self.bincremental = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendsGroupsList {
    fn is_initialized(&self) -> bool {
        for v in &self.friendGroups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.memberships {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bremoval = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bincremental = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.friendGroups)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.memberships)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bremoval {
            my_size += 2;
        }
        if let Some(v) = self.bincremental {
            my_size += 2;
        }
        for value in &self.friendGroups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.memberships {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bremoval {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bincremental {
            os.write_bool(2, v)?;
        }
        for v in &self.friendGroups {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.memberships {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendsGroupsList {
        CMsgClientFriendsGroupsList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "bremoval",
                |m: &CMsgClientFriendsGroupsList| { &m.bremoval },
                |m: &mut CMsgClientFriendsGroupsList| { &mut m.bremoval },
                CMsgClientFriendsGroupsList::get_bremoval,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "bincremental",
                |m: &CMsgClientFriendsGroupsList| { &m.bincremental },
                |m: &mut CMsgClientFriendsGroupsList| { &mut m.bincremental },
                CMsgClientFriendsGroupsList::get_bincremental,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_friends_groups_list::FriendGroup>>(
                "friendGroups",
                |m: &CMsgClientFriendsGroupsList| { &m.friendGroups },
                |m: &mut CMsgClientFriendsGroupsList| { &mut m.friendGroups },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_friends_groups_list::FriendGroupsMembership>>(
                "memberships",
                |m: &CMsgClientFriendsGroupsList| { &m.memberships },
                |m: &mut CMsgClientFriendsGroupsList| { &mut m.memberships },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendsGroupsList>(
                "CMsgClientFriendsGroupsList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendsGroupsList {
        static instance: ::protobuf::rt::Lazy<CMsgClientFriendsGroupsList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientFriendsGroupsList::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendsGroupsList {
    fn clear(&mut self) {
        self.bremoval = ::std::option::Option::None;
        self.bincremental = ::std::option::Option::None;
        self.friendGroups.clear();
        self.memberships.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsGroupsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendsGroupsList {
}

/// Nested message and enums of message `CMsgClientFriendsGroupsList`
pub mod cmsg_client_friends_groups_list {
    #[derive(PartialEq,Clone,Default)]
    pub struct FriendGroup {
        // message fields
        nGroupID: ::std::option::Option<i32>,
        strGroupName: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a FriendGroup {
        fn default() -> &'a FriendGroup {
            <FriendGroup as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendGroup {
        pub fn new() -> FriendGroup {
            ::std::default::Default::default()
        }

        // optional int32 nGroupID = 1;

        pub fn get_nGroupID(&self) -> i32 {
            self.nGroupID.unwrap_or(0)
        }

        pub fn clear_nGroupID(&mut self) {
            self.nGroupID = ::std::option::Option::None;
        }

        pub fn has_nGroupID(&self) -> bool {
            self.nGroupID.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nGroupID(&mut self, v: i32) {
            self.nGroupID = ::std::option::Option::Some(v);
        }

        // optional string strGroupName = 2;

        pub fn get_strGroupName(&self) -> &str {
            match self.strGroupName.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_strGroupName(&mut self) {
            self.strGroupName.clear();
        }

        pub fn has_strGroupName(&self) -> bool {
            self.strGroupName.is_some()
        }

        // Param is passed by value, moved
        pub fn set_strGroupName(&mut self, v: ::std::string::String) {
            self.strGroupName = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_strGroupName(&mut self) -> &mut ::std::string::String {
            if self.strGroupName.is_none() {
                self.strGroupName.set_default();
            }
            self.strGroupName.as_mut().unwrap()
        }

        // Take field
        pub fn take_strGroupName(&mut self) -> ::std::string::String {
            self.strGroupName.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for FriendGroup {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.nGroupID = ::std::option::Option::Some(is.read_int32()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.strGroupName)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.nGroupID {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.strGroupName.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.nGroupID {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.strGroupName.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> FriendGroup {
            FriendGroup::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "nGroupID",
                    |m: &FriendGroup| { &m.nGroupID },
                    |m: &mut FriendGroup| { &mut m.nGroupID },
                    FriendGroup::get_nGroupID,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "strGroupName",
                    |m: &FriendGroup| { &m.strGroupName },
                    |m: &mut FriendGroup| { &mut m.strGroupName },
                    FriendGroup::get_strGroupName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FriendGroup>(
                    "CMsgClientFriendsGroupsList.FriendGroup",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static FriendGroup {
            static instance: ::protobuf::rt::Lazy<FriendGroup> = ::protobuf::rt::Lazy::INIT;
            instance.get(FriendGroup::new)
        }
    }

    impl ::protobuf::Clear for FriendGroup {
        fn clear(&mut self) {
            self.nGroupID = ::std::option::Option::None;
            self.strGroupName.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for FriendGroup {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FriendGroup {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct FriendGroupsMembership {
        // message fields
        ulSteamID: ::std::option::Option<u64>,
        nGroupID: ::std::option::Option<i32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a FriendGroupsMembership {
        fn default() -> &'a FriendGroupsMembership {
            <FriendGroupsMembership as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendGroupsMembership {
        pub fn new() -> FriendGroupsMembership {
            ::std::default::Default::default()
        }

        // optional fixed64 ulSteamID = 1;

        pub fn get_ulSteamID(&self) -> u64 {
            self.ulSteamID.unwrap_or(0)
        }

        pub fn clear_ulSteamID(&mut self) {
            self.ulSteamID = ::std::option::Option::None;
        }

        pub fn has_ulSteamID(&self) -> bool {
            self.ulSteamID.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ulSteamID(&mut self, v: u64) {
            self.ulSteamID = ::std::option::Option::Some(v);
        }

        // optional int32 nGroupID = 2;

        pub fn get_nGroupID(&self) -> i32 {
            self.nGroupID.unwrap_or(0)
        }

        pub fn clear_nGroupID(&mut self) {
            self.nGroupID = ::std::option::Option::None;
        }

        pub fn has_nGroupID(&self) -> bool {
            self.nGroupID.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nGroupID(&mut self, v: i32) {
            self.nGroupID = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for FriendGroupsMembership {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.ulSteamID = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.nGroupID = ::std::option::Option::Some(is.read_int32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.ulSteamID {
                my_size += 9;
            }
            if let Some(v) = self.nGroupID {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.ulSteamID {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.nGroupID {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> FriendGroupsMembership {
            FriendGroupsMembership::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "ulSteamID",
                    |m: &FriendGroupsMembership| { &m.ulSteamID },
                    |m: &mut FriendGroupsMembership| { &mut m.ulSteamID },
                    FriendGroupsMembership::get_ulSteamID,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "nGroupID",
                    |m: &FriendGroupsMembership| { &m.nGroupID },
                    |m: &mut FriendGroupsMembership| { &mut m.nGroupID },
                    FriendGroupsMembership::get_nGroupID,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FriendGroupsMembership>(
                    "CMsgClientFriendsGroupsList.FriendGroupsMembership",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static FriendGroupsMembership {
            static instance: ::protobuf::rt::Lazy<FriendGroupsMembership> = ::protobuf::rt::Lazy::INIT;
            instance.get(FriendGroupsMembership::new)
        }
    }

    impl ::protobuf::Clear for FriendGroupsMembership {
        fn clear(&mut self) {
            self.ulSteamID = ::std::option::Option::None;
            self.nGroupID = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for FriendGroupsMembership {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FriendGroupsMembership {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPlayerNicknameList {
    // message fields
    removal: ::std::option::Option<bool>,
    incremental: ::std::option::Option<bool>,
    pub nicknames: ::protobuf::RepeatedField<cmsg_client_player_nickname_list::PlayerNickname>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPlayerNicknameList {
    fn default() -> &'a CMsgClientPlayerNicknameList {
        <CMsgClientPlayerNicknameList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPlayerNicknameList {
    pub fn new() -> CMsgClientPlayerNicknameList {
        ::std::default::Default::default()
    }

    // optional bool removal = 1;

    pub fn get_removal(&self) -> bool {
        self.removal.unwrap_or(false)
    }

    pub fn clear_removal(&mut self) {
        self.removal = ::std::option::Option::None;
    }

    pub fn has_removal(&self) -> bool {
        self.removal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_removal(&mut self, v: bool) {
        self.removal = ::std::option::Option::Some(v);
    }

    // optional bool incremental = 2;

    pub fn get_incremental(&self) -> bool {
        self.incremental.unwrap_or(false)
    }

    pub fn clear_incremental(&mut self) {
        self.incremental = ::std::option::Option::None;
    }

    pub fn has_incremental(&self) -> bool {
        self.incremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incremental(&mut self, v: bool) {
        self.incremental = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPlayerNicknameList {
    fn is_initialized(&self) -> bool {
        for v in &self.nicknames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.removal = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.incremental = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.nicknames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.removal {
            my_size += 2;
        }
        if let Some(v) = self.incremental {
            my_size += 2;
        }
        for value in &self.nicknames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.removal {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.incremental {
            os.write_bool(2, v)?;
        }
        for v in &self.nicknames {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPlayerNicknameList {
        CMsgClientPlayerNicknameList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "removal",
                |m: &CMsgClientPlayerNicknameList| { &m.removal },
                |m: &mut CMsgClientPlayerNicknameList| { &mut m.removal },
                CMsgClientPlayerNicknameList::get_removal,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "incremental",
                |m: &CMsgClientPlayerNicknameList| { &m.incremental },
                |m: &mut CMsgClientPlayerNicknameList| { &mut m.incremental },
                CMsgClientPlayerNicknameList::get_incremental,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_player_nickname_list::PlayerNickname>>(
                "nicknames",
                |m: &CMsgClientPlayerNicknameList| { &m.nicknames },
                |m: &mut CMsgClientPlayerNicknameList| { &mut m.nicknames },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPlayerNicknameList>(
                "CMsgClientPlayerNicknameList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPlayerNicknameList {
        static instance: ::protobuf::rt::Lazy<CMsgClientPlayerNicknameList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPlayerNicknameList::new)
    }
}

impl ::protobuf::Clear for CMsgClientPlayerNicknameList {
    fn clear(&mut self) {
        self.removal = ::std::option::Option::None;
        self.incremental = ::std::option::Option::None;
        self.nicknames.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPlayerNicknameList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPlayerNicknameList {
}

/// Nested message and enums of message `CMsgClientPlayerNicknameList`
pub mod cmsg_client_player_nickname_list {
    #[derive(PartialEq,Clone,Default)]
    pub struct PlayerNickname {
        // message fields
        steamid: ::std::option::Option<u64>,
        nickname: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PlayerNickname {
        fn default() -> &'a PlayerNickname {
            <PlayerNickname as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerNickname {
        pub fn new() -> PlayerNickname {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn get_steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional string nickname = 3;

        pub fn get_nickname(&self) -> &str {
            match self.nickname.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_nickname(&mut self) {
            self.nickname.clear();
        }

        pub fn has_nickname(&self) -> bool {
            self.nickname.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nickname(&mut self, v: ::std::string::String) {
            self.nickname = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
            if self.nickname.is_none() {
                self.nickname.set_default();
            }
            self.nickname.as_mut().unwrap()
        }

        // Take field
        pub fn take_nickname(&mut self) -> ::std::string::String {
            self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for PlayerNickname {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    3 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 9;
            }
            if let Some(v) = self.nickname.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.nickname.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PlayerNickname {
            PlayerNickname::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steamid",
                    |m: &PlayerNickname| { &m.steamid },
                    |m: &mut PlayerNickname| { &mut m.steamid },
                    PlayerNickname::get_steamid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "nickname",
                    |m: &PlayerNickname| { &m.nickname },
                    |m: &mut PlayerNickname| { &mut m.nickname },
                    PlayerNickname::get_nickname,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerNickname>(
                    "CMsgClientPlayerNicknameList.PlayerNickname",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PlayerNickname {
            static instance: ::protobuf::rt::Lazy<PlayerNickname> = ::protobuf::rt::Lazy::INIT;
            instance.get(PlayerNickname::new)
        }
    }

    impl ::protobuf::Clear for PlayerNickname {
        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.nickname.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PlayerNickname {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerNickname {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSetPlayerNickname {
    // message fields
    steamid: ::std::option::Option<u64>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetPlayerNickname {
    fn default() -> &'a CMsgClientSetPlayerNickname {
        <CMsgClientSetPlayerNickname as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetPlayerNickname {
    pub fn new() -> CMsgClientSetPlayerNickname {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;

    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientSetPlayerNickname {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.nickname.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSetPlayerNickname {
        CMsgClientSetPlayerNickname::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CMsgClientSetPlayerNickname| { &m.steamid },
                |m: &mut CMsgClientSetPlayerNickname| { &mut m.steamid },
                CMsgClientSetPlayerNickname::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "nickname",
                |m: &CMsgClientSetPlayerNickname| { &m.nickname },
                |m: &mut CMsgClientSetPlayerNickname| { &mut m.nickname },
                CMsgClientSetPlayerNickname::get_nickname,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSetPlayerNickname>(
                "CMsgClientSetPlayerNickname",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSetPlayerNickname {
        static instance: ::protobuf::rt::Lazy<CMsgClientSetPlayerNickname> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientSetPlayerNickname::new)
    }
}

impl ::protobuf::Clear for CMsgClientSetPlayerNickname {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.nickname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSetPlayerNickname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSetPlayerNickname {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSetPlayerNicknameResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetPlayerNicknameResponse {
    fn default() -> &'a CMsgClientSetPlayerNicknameResponse {
        <CMsgClientSetPlayerNicknameResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetPlayerNicknameResponse {
    pub fn new() -> CMsgClientSetPlayerNicknameResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSetPlayerNicknameResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSetPlayerNicknameResponse {
        CMsgClientSetPlayerNicknameResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientSetPlayerNicknameResponse| { &m.eresult },
                |m: &mut CMsgClientSetPlayerNicknameResponse| { &mut m.eresult },
                CMsgClientSetPlayerNicknameResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSetPlayerNicknameResponse>(
                "CMsgClientSetPlayerNicknameResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSetPlayerNicknameResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientSetPlayerNicknameResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientSetPlayerNicknameResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientSetPlayerNicknameResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSetPlayerNicknameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSetPlayerNicknameResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestFriendData {
    // message fields
    persona_state_requested: ::std::option::Option<u32>,
    pub friends: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFriendData {
    fn default() -> &'a CMsgClientRequestFriendData {
        <CMsgClientRequestFriendData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFriendData {
    pub fn new() -> CMsgClientRequestFriendData {
        ::std::default::Default::default()
    }

    // optional uint32 persona_state_requested = 1;

    pub fn get_persona_state_requested(&self) -> u32 {
        self.persona_state_requested.unwrap_or(0)
    }

    pub fn clear_persona_state_requested(&mut self) {
        self.persona_state_requested = ::std::option::Option::None;
    }

    pub fn has_persona_state_requested(&self) -> bool {
        self.persona_state_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_requested(&mut self, v: u32) {
        self.persona_state_requested = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestFriendData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.persona_state_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.friends)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.persona_state_requested {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 9 * self.friends.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.persona_state_requested {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestFriendData {
        CMsgClientRequestFriendData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "persona_state_requested",
                |m: &CMsgClientRequestFriendData| { &m.persona_state_requested },
                |m: &mut CMsgClientRequestFriendData| { &mut m.persona_state_requested },
                CMsgClientRequestFriendData::get_persona_state_requested,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "friends",
                |m: &CMsgClientRequestFriendData| { &m.friends },
                |m: &mut CMsgClientRequestFriendData| { &mut m.friends },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestFriendData>(
                "CMsgClientRequestFriendData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestFriendData {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestFriendData> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestFriendData::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestFriendData {
    fn clear(&mut self) {
        self.persona_state_requested = ::std::option::Option::None;
        self.friends.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestFriendData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestFriendData {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientChangeStatus {
    // message fields
    persona_state: ::std::option::Option<u32>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    is_auto_generated_name: ::std::option::Option<bool>,
    high_priority: ::std::option::Option<bool>,
    persona_set_by_user: ::std::option::Option<bool>,
    persona_state_flags: ::std::option::Option<u32>,
    need_persona_response: ::std::option::Option<bool>,
    is_client_idle: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChangeStatus {
    fn default() -> &'a CMsgClientChangeStatus {
        <CMsgClientChangeStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChangeStatus {
    pub fn new() -> CMsgClientChangeStatus {
        ::std::default::Default::default()
    }

    // optional uint32 persona_state = 1;

    pub fn get_persona_state(&self) -> u32 {
        self.persona_state.unwrap_or(0)
    }

    pub fn clear_persona_state(&mut self) {
        self.persona_state = ::std::option::Option::None;
    }

    pub fn has_persona_state(&self) -> bool {
        self.persona_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state(&mut self, v: u32) {
        self.persona_state = ::std::option::Option::Some(v);
    }

    // optional string player_name = 2;

    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_auto_generated_name = 3;

    pub fn get_is_auto_generated_name(&self) -> bool {
        self.is_auto_generated_name.unwrap_or(false)
    }

    pub fn clear_is_auto_generated_name(&mut self) {
        self.is_auto_generated_name = ::std::option::Option::None;
    }

    pub fn has_is_auto_generated_name(&self) -> bool {
        self.is_auto_generated_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_auto_generated_name(&mut self, v: bool) {
        self.is_auto_generated_name = ::std::option::Option::Some(v);
    }

    // optional bool high_priority = 4;

    pub fn get_high_priority(&self) -> bool {
        self.high_priority.unwrap_or(false)
    }

    pub fn clear_high_priority(&mut self) {
        self.high_priority = ::std::option::Option::None;
    }

    pub fn has_high_priority(&self) -> bool {
        self.high_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority(&mut self, v: bool) {
        self.high_priority = ::std::option::Option::Some(v);
    }

    // optional bool persona_set_by_user = 5;

    pub fn get_persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.unwrap_or(false)
    }

    pub fn clear_persona_set_by_user(&mut self) {
        self.persona_set_by_user = ::std::option::Option::None;
    }

    pub fn has_persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_set_by_user(&mut self, v: bool) {
        self.persona_set_by_user = ::std::option::Option::Some(v);
    }

    // optional uint32 persona_state_flags = 6;

    pub fn get_persona_state_flags(&self) -> u32 {
        self.persona_state_flags.unwrap_or(0u32)
    }

    pub fn clear_persona_state_flags(&mut self) {
        self.persona_state_flags = ::std::option::Option::None;
    }

    pub fn has_persona_state_flags(&self) -> bool {
        self.persona_state_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_flags(&mut self, v: u32) {
        self.persona_state_flags = ::std::option::Option::Some(v);
    }

    // optional bool need_persona_response = 7;

    pub fn get_need_persona_response(&self) -> bool {
        self.need_persona_response.unwrap_or(false)
    }

    pub fn clear_need_persona_response(&mut self) {
        self.need_persona_response = ::std::option::Option::None;
    }

    pub fn has_need_persona_response(&self) -> bool {
        self.need_persona_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_persona_response(&mut self, v: bool) {
        self.need_persona_response = ::std::option::Option::Some(v);
    }

    // optional bool is_client_idle = 8;

    pub fn get_is_client_idle(&self) -> bool {
        self.is_client_idle.unwrap_or(false)
    }

    pub fn clear_is_client_idle(&mut self) {
        self.is_client_idle = ::std::option::Option::None;
    }

    pub fn has_is_client_idle(&self) -> bool {
        self.is_client_idle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_client_idle(&mut self, v: bool) {
        self.is_client_idle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChangeStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.persona_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_auto_generated_name = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.high_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.persona_set_by_user = ::std::option::Option::Some(is.read_bool()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.persona_state_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.need_persona_response = ::std::option::Option::Some(is.read_bool()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_client_idle = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.persona_state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_auto_generated_name {
            my_size += 2;
        }
        if let Some(v) = self.high_priority {
            my_size += 2;
        }
        if let Some(v) = self.persona_set_by_user {
            my_size += 2;
        }
        if let Some(v) = self.persona_state_flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.need_persona_response {
            my_size += 2;
        }
        if let Some(v) = self.is_client_idle {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.persona_state {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_auto_generated_name {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.high_priority {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.persona_set_by_user {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.persona_state_flags {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.need_persona_response {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.is_client_idle {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChangeStatus {
        CMsgClientChangeStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "persona_state",
                |m: &CMsgClientChangeStatus| { &m.persona_state },
                |m: &mut CMsgClientChangeStatus| { &mut m.persona_state },
                CMsgClientChangeStatus::get_persona_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "player_name",
                |m: &CMsgClientChangeStatus| { &m.player_name },
                |m: &mut CMsgClientChangeStatus| { &mut m.player_name },
                CMsgClientChangeStatus::get_player_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_auto_generated_name",
                |m: &CMsgClientChangeStatus| { &m.is_auto_generated_name },
                |m: &mut CMsgClientChangeStatus| { &mut m.is_auto_generated_name },
                CMsgClientChangeStatus::get_is_auto_generated_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "high_priority",
                |m: &CMsgClientChangeStatus| { &m.high_priority },
                |m: &mut CMsgClientChangeStatus| { &mut m.high_priority },
                CMsgClientChangeStatus::get_high_priority,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "persona_set_by_user",
                |m: &CMsgClientChangeStatus| { &m.persona_set_by_user },
                |m: &mut CMsgClientChangeStatus| { &mut m.persona_set_by_user },
                CMsgClientChangeStatus::get_persona_set_by_user,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "persona_state_flags",
                |m: &CMsgClientChangeStatus| { &m.persona_state_flags },
                |m: &mut CMsgClientChangeStatus| { &mut m.persona_state_flags },
                CMsgClientChangeStatus::get_persona_state_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "need_persona_response",
                |m: &CMsgClientChangeStatus| { &m.need_persona_response },
                |m: &mut CMsgClientChangeStatus| { &mut m.need_persona_response },
                CMsgClientChangeStatus::get_need_persona_response,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_client_idle",
                |m: &CMsgClientChangeStatus| { &m.is_client_idle },
                |m: &mut CMsgClientChangeStatus| { &mut m.is_client_idle },
                CMsgClientChangeStatus::get_is_client_idle,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientChangeStatus>(
                "CMsgClientChangeStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChangeStatus {
        static instance: ::protobuf::rt::Lazy<CMsgClientChangeStatus> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientChangeStatus::new)
    }
}

impl ::protobuf::Clear for CMsgClientChangeStatus {
    fn clear(&mut self) {
        self.persona_state = ::std::option::Option::None;
        self.player_name.clear();
        self.is_auto_generated_name = ::std::option::Option::None;
        self.high_priority = ::std::option::Option::None;
        self.persona_set_by_user = ::std::option::Option::None;
        self.persona_state_flags = ::std::option::Option::None;
        self.need_persona_response = ::std::option::Option::None;
        self.is_client_idle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChangeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChangeStatus {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPersonaChangeResponse {
    // message fields
    result: ::std::option::Option<u32>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPersonaChangeResponse {
    fn default() -> &'a CMsgPersonaChangeResponse {
        <CMsgPersonaChangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPersonaChangeResponse {
    pub fn new() -> CMsgPersonaChangeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string player_name = 2;

    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgPersonaChangeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPersonaChangeResponse {
        CMsgPersonaChangeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "result",
                |m: &CMsgPersonaChangeResponse| { &m.result },
                |m: &mut CMsgPersonaChangeResponse| { &mut m.result },
                CMsgPersonaChangeResponse::get_result,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "player_name",
                |m: &CMsgPersonaChangeResponse| { &m.player_name },
                |m: &mut CMsgPersonaChangeResponse| { &mut m.player_name },
                CMsgPersonaChangeResponse::get_player_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgPersonaChangeResponse>(
                "CMsgPersonaChangeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPersonaChangeResponse {
        static instance: ::protobuf::rt::Lazy<CMsgPersonaChangeResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgPersonaChangeResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPersonaChangeResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.player_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPersonaChangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPersonaChangeResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPersonaState {
    // message fields
    status_flags: ::std::option::Option<u32>,
    pub friends: ::protobuf::RepeatedField<cmsg_client_persona_state::Friend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPersonaState {
    fn default() -> &'a CMsgClientPersonaState {
        <CMsgClientPersonaState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPersonaState {
    pub fn new() -> CMsgClientPersonaState {
        ::std::default::Default::default()
    }

    // optional uint32 status_flags = 1;

    pub fn get_status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }

    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPersonaState {
    fn is_initialized(&self) -> bool {
        for v in &self.friends {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.status_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.friends)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status_flags {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status_flags {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPersonaState {
        CMsgClientPersonaState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "status_flags",
                |m: &CMsgClientPersonaState| { &m.status_flags },
                |m: &mut CMsgClientPersonaState| { &mut m.status_flags },
                CMsgClientPersonaState::get_status_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_persona_state::Friend>>(
                "friends",
                |m: &CMsgClientPersonaState| { &m.friends },
                |m: &mut CMsgClientPersonaState| { &mut m.friends },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPersonaState>(
                "CMsgClientPersonaState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPersonaState {
        static instance: ::protobuf::rt::Lazy<CMsgClientPersonaState> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPersonaState::new)
    }
}

impl ::protobuf::Clear for CMsgClientPersonaState {
    fn clear(&mut self) {
        self.status_flags = ::std::option::Option::None;
        self.friends.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPersonaState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPersonaState {
}

/// Nested message and enums of message `CMsgClientPersonaState`
pub mod cmsg_client_persona_state {
    #[derive(PartialEq,Clone,Default)]
    pub struct Friend {
        // message fields
        friendid: ::std::option::Option<u64>,
        persona_state: ::std::option::Option<u32>,
        game_played_app_id: ::std::option::Option<u32>,
        game_server_ip: ::std::option::Option<u32>,
        game_server_port: ::std::option::Option<u32>,
        persona_state_flags: ::std::option::Option<u32>,
        online_session_instances: ::std::option::Option<u32>,
        published_instance_id: ::std::option::Option<u32>,
        persona_set_by_user: ::std::option::Option<bool>,
        player_name: ::protobuf::SingularField<::std::string::String>,
        query_port: ::std::option::Option<u32>,
        steamid_source: ::std::option::Option<u64>,
        avatar_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        last_logoff: ::std::option::Option<u32>,
        last_logon: ::std::option::Option<u32>,
        last_seen_online: ::std::option::Option<u32>,
        clan_rank: ::std::option::Option<u32>,
        game_name: ::protobuf::SingularField<::std::string::String>,
        gameid: ::std::option::Option<u64>,
        game_data_blob: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        pub clan_data: ::protobuf::SingularPtrField<friend::ClanData>,
        clan_tag: ::protobuf::SingularField<::std::string::String>,
        pub rich_presence: ::protobuf::RepeatedField<friend::KV>,
        broadcast_id: ::std::option::Option<u64>,
        game_lobby_id: ::std::option::Option<u64>,
        watching_broadcast_accountid: ::std::option::Option<u32>,
        watching_broadcast_appid: ::std::option::Option<u32>,
        watching_broadcast_viewers: ::std::option::Option<u32>,
        watching_broadcast_title: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Friend {
        fn default() -> &'a Friend {
            <Friend as ::protobuf::Message>::default_instance()
        }
    }

    impl Friend {
        pub fn new() -> Friend {
            ::std::default::Default::default()
        }

        // optional fixed64 friendid = 1;

        pub fn get_friendid(&self) -> u64 {
            self.friendid.unwrap_or(0)
        }

        pub fn clear_friendid(&mut self) {
            self.friendid = ::std::option::Option::None;
        }

        pub fn has_friendid(&self) -> bool {
            self.friendid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friendid(&mut self, v: u64) {
            self.friendid = ::std::option::Option::Some(v);
        }

        // optional uint32 persona_state = 2;

        pub fn get_persona_state(&self) -> u32 {
            self.persona_state.unwrap_or(0)
        }

        pub fn clear_persona_state(&mut self) {
            self.persona_state = ::std::option::Option::None;
        }

        pub fn has_persona_state(&self) -> bool {
            self.persona_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_state(&mut self, v: u32) {
            self.persona_state = ::std::option::Option::Some(v);
        }

        // optional uint32 game_played_app_id = 3;

        pub fn get_game_played_app_id(&self) -> u32 {
            self.game_played_app_id.unwrap_or(0)
        }

        pub fn clear_game_played_app_id(&mut self) {
            self.game_played_app_id = ::std::option::Option::None;
        }

        pub fn has_game_played_app_id(&self) -> bool {
            self.game_played_app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_played_app_id(&mut self, v: u32) {
            self.game_played_app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 game_server_ip = 4;

        pub fn get_game_server_ip(&self) -> u32 {
            self.game_server_ip.unwrap_or(0)
        }

        pub fn clear_game_server_ip(&mut self) {
            self.game_server_ip = ::std::option::Option::None;
        }

        pub fn has_game_server_ip(&self) -> bool {
            self.game_server_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_ip(&mut self, v: u32) {
            self.game_server_ip = ::std::option::Option::Some(v);
        }

        // optional uint32 game_server_port = 5;

        pub fn get_game_server_port(&self) -> u32 {
            self.game_server_port.unwrap_or(0)
        }

        pub fn clear_game_server_port(&mut self) {
            self.game_server_port = ::std::option::Option::None;
        }

        pub fn has_game_server_port(&self) -> bool {
            self.game_server_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_port(&mut self, v: u32) {
            self.game_server_port = ::std::option::Option::Some(v);
        }

        // optional uint32 persona_state_flags = 6;

        pub fn get_persona_state_flags(&self) -> u32 {
            self.persona_state_flags.unwrap_or(0)
        }

        pub fn clear_persona_state_flags(&mut self) {
            self.persona_state_flags = ::std::option::Option::None;
        }

        pub fn has_persona_state_flags(&self) -> bool {
            self.persona_state_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_state_flags(&mut self, v: u32) {
            self.persona_state_flags = ::std::option::Option::Some(v);
        }

        // optional uint32 online_session_instances = 7;

        pub fn get_online_session_instances(&self) -> u32 {
            self.online_session_instances.unwrap_or(0)
        }

        pub fn clear_online_session_instances(&mut self) {
            self.online_session_instances = ::std::option::Option::None;
        }

        pub fn has_online_session_instances(&self) -> bool {
            self.online_session_instances.is_some()
        }

        // Param is passed by value, moved
        pub fn set_online_session_instances(&mut self, v: u32) {
            self.online_session_instances = ::std::option::Option::Some(v);
        }

        // optional uint32 published_instance_id = 8;

        pub fn get_published_instance_id(&self) -> u32 {
            self.published_instance_id.unwrap_or(0)
        }

        pub fn clear_published_instance_id(&mut self) {
            self.published_instance_id = ::std::option::Option::None;
        }

        pub fn has_published_instance_id(&self) -> bool {
            self.published_instance_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_instance_id(&mut self, v: u32) {
            self.published_instance_id = ::std::option::Option::Some(v);
        }

        // optional bool persona_set_by_user = 10;

        pub fn get_persona_set_by_user(&self) -> bool {
            self.persona_set_by_user.unwrap_or(false)
        }

        pub fn clear_persona_set_by_user(&mut self) {
            self.persona_set_by_user = ::std::option::Option::None;
        }

        pub fn has_persona_set_by_user(&self) -> bool {
            self.persona_set_by_user.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_set_by_user(&mut self, v: bool) {
            self.persona_set_by_user = ::std::option::Option::Some(v);
        }

        // optional string player_name = 15;

        pub fn get_player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name.clear();
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name.set_default();
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 query_port = 20;

        pub fn get_query_port(&self) -> u32 {
            self.query_port.unwrap_or(0)
        }

        pub fn clear_query_port(&mut self) {
            self.query_port = ::std::option::Option::None;
        }

        pub fn has_query_port(&self) -> bool {
            self.query_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_query_port(&mut self, v: u32) {
            self.query_port = ::std::option::Option::Some(v);
        }

        // optional fixed64 steamid_source = 25;

        pub fn get_steamid_source(&self) -> u64 {
            self.steamid_source.unwrap_or(0)
        }

        pub fn clear_steamid_source(&mut self) {
            self.steamid_source = ::std::option::Option::None;
        }

        pub fn has_steamid_source(&self) -> bool {
            self.steamid_source.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid_source(&mut self, v: u64) {
            self.steamid_source = ::std::option::Option::Some(v);
        }

        // optional bytes avatar_hash = 31;

        pub fn get_avatar_hash(&self) -> &[u8] {
            match self.avatar_hash.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_avatar_hash(&mut self) {
            self.avatar_hash.clear();
        }

        pub fn has_avatar_hash(&self) -> bool {
            self.avatar_hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avatar_hash(&mut self, v: ::std::vec::Vec<u8>) {
            self.avatar_hash = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_avatar_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.avatar_hash.is_none() {
                self.avatar_hash.set_default();
            }
            self.avatar_hash.as_mut().unwrap()
        }

        // Take field
        pub fn take_avatar_hash(&mut self) -> ::std::vec::Vec<u8> {
            self.avatar_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 last_logoff = 45;

        pub fn get_last_logoff(&self) -> u32 {
            self.last_logoff.unwrap_or(0)
        }

        pub fn clear_last_logoff(&mut self) {
            self.last_logoff = ::std::option::Option::None;
        }

        pub fn has_last_logoff(&self) -> bool {
            self.last_logoff.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_logoff(&mut self, v: u32) {
            self.last_logoff = ::std::option::Option::Some(v);
        }

        // optional uint32 last_logon = 46;

        pub fn get_last_logon(&self) -> u32 {
            self.last_logon.unwrap_or(0)
        }

        pub fn clear_last_logon(&mut self) {
            self.last_logon = ::std::option::Option::None;
        }

        pub fn has_last_logon(&self) -> bool {
            self.last_logon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_logon(&mut self, v: u32) {
            self.last_logon = ::std::option::Option::Some(v);
        }

        // optional uint32 last_seen_online = 47;

        pub fn get_last_seen_online(&self) -> u32 {
            self.last_seen_online.unwrap_or(0)
        }

        pub fn clear_last_seen_online(&mut self) {
            self.last_seen_online = ::std::option::Option::None;
        }

        pub fn has_last_seen_online(&self) -> bool {
            self.last_seen_online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_seen_online(&mut self, v: u32) {
            self.last_seen_online = ::std::option::Option::Some(v);
        }

        // optional uint32 clan_rank = 50;

        pub fn get_clan_rank(&self) -> u32 {
            self.clan_rank.unwrap_or(0)
        }

        pub fn clear_clan_rank(&mut self) {
            self.clan_rank = ::std::option::Option::None;
        }

        pub fn has_clan_rank(&self) -> bool {
            self.clan_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_rank(&mut self, v: u32) {
            self.clan_rank = ::std::option::Option::Some(v);
        }

        // optional string game_name = 55;

        pub fn get_game_name(&self) -> &str {
            match self.game_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_name(&mut self) {
            self.game_name.clear();
        }

        pub fn has_game_name(&self) -> bool {
            self.game_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_name(&mut self, v: ::std::string::String) {
            self.game_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
            if self.game_name.is_none() {
                self.game_name.set_default();
            }
            self.game_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_name(&mut self) -> ::std::string::String {
            self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 gameid = 56;

        pub fn get_gameid(&self) -> u64 {
            self.gameid.unwrap_or(0)
        }

        pub fn clear_gameid(&mut self) {
            self.gameid = ::std::option::Option::None;
        }

        pub fn has_gameid(&self) -> bool {
            self.gameid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gameid(&mut self, v: u64) {
            self.gameid = ::std::option::Option::Some(v);
        }

        // optional bytes game_data_blob = 60;

        pub fn get_game_data_blob(&self) -> &[u8] {
            match self.game_data_blob.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_game_data_blob(&mut self) {
            self.game_data_blob.clear();
        }

        pub fn has_game_data_blob(&self) -> bool {
            self.game_data_blob.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_data_blob(&mut self, v: ::std::vec::Vec<u8>) {
            self.game_data_blob = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_data_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.game_data_blob.is_none() {
                self.game_data_blob.set_default();
            }
            self.game_data_blob.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_data_blob(&mut self) -> ::std::vec::Vec<u8> {
            self.game_data_blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional string clan_tag = 65;

        pub fn get_clan_tag(&self) -> &str {
            match self.clan_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_clan_tag(&mut self) {
            self.clan_tag.clear();
        }

        pub fn has_clan_tag(&self) -> bool {
            self.clan_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_tag(&mut self, v: ::std::string::String) {
            self.clan_tag = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_clan_tag(&mut self) -> &mut ::std::string::String {
            if self.clan_tag.is_none() {
                self.clan_tag.set_default();
            }
            self.clan_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_clan_tag(&mut self) -> ::std::string::String {
            self.clan_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 broadcast_id = 72;

        pub fn get_broadcast_id(&self) -> u64 {
            self.broadcast_id.unwrap_or(0)
        }

        pub fn clear_broadcast_id(&mut self) {
            self.broadcast_id = ::std::option::Option::None;
        }

        pub fn has_broadcast_id(&self) -> bool {
            self.broadcast_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_broadcast_id(&mut self, v: u64) {
            self.broadcast_id = ::std::option::Option::Some(v);
        }

        // optional fixed64 game_lobby_id = 73;

        pub fn get_game_lobby_id(&self) -> u64 {
            self.game_lobby_id.unwrap_or(0)
        }

        pub fn clear_game_lobby_id(&mut self) {
            self.game_lobby_id = ::std::option::Option::None;
        }

        pub fn has_game_lobby_id(&self) -> bool {
            self.game_lobby_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_lobby_id(&mut self, v: u64) {
            self.game_lobby_id = ::std::option::Option::Some(v);
        }

        // optional uint32 watching_broadcast_accountid = 74;

        pub fn get_watching_broadcast_accountid(&self) -> u32 {
            self.watching_broadcast_accountid.unwrap_or(0)
        }

        pub fn clear_watching_broadcast_accountid(&mut self) {
            self.watching_broadcast_accountid = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_accountid(&self) -> bool {
            self.watching_broadcast_accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
            self.watching_broadcast_accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 watching_broadcast_appid = 75;

        pub fn get_watching_broadcast_appid(&self) -> u32 {
            self.watching_broadcast_appid.unwrap_or(0)
        }

        pub fn clear_watching_broadcast_appid(&mut self) {
            self.watching_broadcast_appid = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_appid(&self) -> bool {
            self.watching_broadcast_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_appid(&mut self, v: u32) {
            self.watching_broadcast_appid = ::std::option::Option::Some(v);
        }

        // optional uint32 watching_broadcast_viewers = 76;

        pub fn get_watching_broadcast_viewers(&self) -> u32 {
            self.watching_broadcast_viewers.unwrap_or(0)
        }

        pub fn clear_watching_broadcast_viewers(&mut self) {
            self.watching_broadcast_viewers = ::std::option::Option::None;
        }

        pub fn has_watching_broadcast_viewers(&self) -> bool {
            self.watching_broadcast_viewers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_viewers(&mut self, v: u32) {
            self.watching_broadcast_viewers = ::std::option::Option::Some(v);
        }

        // optional string watching_broadcast_title = 77;

        pub fn get_watching_broadcast_title(&self) -> &str {
            match self.watching_broadcast_title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_watching_broadcast_title(&mut self) {
            self.watching_broadcast_title.clear();
        }

        pub fn has_watching_broadcast_title(&self) -> bool {
            self.watching_broadcast_title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_watching_broadcast_title(&mut self, v: ::std::string::String) {
            self.watching_broadcast_title = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_watching_broadcast_title(&mut self) -> &mut ::std::string::String {
            if self.watching_broadcast_title.is_none() {
                self.watching_broadcast_title.set_default();
            }
            self.watching_broadcast_title.as_mut().unwrap()
        }

        // Take field
        pub fn take_watching_broadcast_title(&mut self) -> ::std::string::String {
            self.watching_broadcast_title.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Friend {
        fn is_initialized(&self) -> bool {
            for v in &self.clan_data {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.rich_presence {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.friendid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.persona_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.game_played_app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.persona_state_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.online_session_instances = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    8 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    10 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.persona_set_by_user = ::std::option::Option::Some(is.read_bool()?);
                    },
                    15 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                    },
                    20 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    25 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steamid_source = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    31 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.avatar_hash)?;
                    },
                    45 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.last_logoff = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    46 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.last_logon = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    47 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.last_seen_online = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.clan_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    55 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_name)?;
                    },
                    56 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    60 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.game_data_blob)?;
                    },
                    64 => {
                        ::protobuf::rt::read_singular_message_into::<friend::ClanData, _>(wire_type, is, &mut self.clan_data)?;
                    },
                    65 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clan_tag)?;
                    },
                    71 => {
                        ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.rich_presence)?;
                    },
                    72 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.broadcast_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    73 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.game_lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    74 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    75 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.watching_broadcast_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    76 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.watching_broadcast_viewers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    77 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.watching_broadcast_title)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.friendid {
                my_size += 9;
            }
            if let Some(v) = self.persona_state {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.game_played_app_id {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.game_server_ip {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.game_server_port {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.persona_state_flags {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.online_session_instances {
                my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.published_instance_id {
                my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.persona_set_by_user {
                my_size += 2;
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::protobuf::rt::string_size(15, &v);
            }
            if let Some(v) = self.query_port {
                my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.steamid_source {
                my_size += 10;
            }
            if let Some(v) = self.avatar_hash.as_ref() {
                my_size += ::protobuf::rt::bytes_size(31, &v);
            }
            if let Some(v) = self.last_logoff {
                my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.last_logon {
                my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.last_seen_online {
                my_size += ::protobuf::rt::value_size(47, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.clan_rank {
                my_size += ::protobuf::rt::value_size(50, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.game_name.as_ref() {
                my_size += ::protobuf::rt::string_size(55, &v);
            }
            if let Some(v) = self.gameid {
                my_size += 10;
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                my_size += ::protobuf::rt::bytes_size(60, &v);
            }
            if let Some(v) = self.clan_data.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            }
            if let Some(v) = self.clan_tag.as_ref() {
                my_size += ::protobuf::rt::string_size(65, &v);
            }
            for value in &self.rich_presence {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            };
            if let Some(v) = self.broadcast_id {
                my_size += 10;
            }
            if let Some(v) = self.game_lobby_id {
                my_size += 10;
            }
            if let Some(v) = self.watching_broadcast_accountid {
                my_size += ::protobuf::rt::value_size(74, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.watching_broadcast_appid {
                my_size += ::protobuf::rt::value_size(75, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.watching_broadcast_viewers {
                my_size += ::protobuf::rt::value_size(76, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.watching_broadcast_title.as_ref() {
                my_size += ::protobuf::rt::string_size(77, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.friendid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_state {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.game_played_app_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_server_ip {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.game_server_port {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.persona_state_flags {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.online_session_instances {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.published_instance_id {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.persona_set_by_user {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(15, v)?;
            }
            if let Some(v) = self.query_port {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.steamid_source {
                os.write_fixed64(25, v)?;
            }
            if let Some(v) = self.avatar_hash.as_ref() {
                os.write_bytes(31, v)?;
            }
            if let Some(v) = self.last_logoff {
                os.write_uint32(45, v)?;
            }
            if let Some(v) = self.last_logon {
                os.write_uint32(46, v)?;
            }
            if let Some(v) = self.last_seen_online {
                os.write_uint32(47, v)?;
            }
            if let Some(v) = self.clan_rank {
                os.write_uint32(50, v)?;
            }
            if let Some(v) = self.game_name.as_ref() {
                os.write_string(55, v)?;
            }
            if let Some(v) = self.gameid {
                os.write_fixed64(56, v)?;
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                os.write_bytes(60, v)?;
            }
            if let Some(v) = self.clan_data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(64, v, os)?;
            }
            if let Some(v) = self.clan_tag.as_ref() {
                os.write_string(65, v)?;
            }
            for v in &self.rich_presence {
                ::protobuf::rt::write_message_field_with_cached_size(71, v, os)?;
            };
            if let Some(v) = self.broadcast_id {
                os.write_fixed64(72, v)?;
            }
            if let Some(v) = self.game_lobby_id {
                os.write_fixed64(73, v)?;
            }
            if let Some(v) = self.watching_broadcast_accountid {
                os.write_uint32(74, v)?;
            }
            if let Some(v) = self.watching_broadcast_appid {
                os.write_uint32(75, v)?;
            }
            if let Some(v) = self.watching_broadcast_viewers {
                os.write_uint32(76, v)?;
            }
            if let Some(v) = self.watching_broadcast_title.as_ref() {
                os.write_string(77, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Friend {
            Friend::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "friendid",
                    |m: &Friend| { &m.friendid },
                    |m: &mut Friend| { &mut m.friendid },
                    Friend::get_friendid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "persona_state",
                    |m: &Friend| { &m.persona_state },
                    |m: &mut Friend| { &mut m.persona_state },
                    Friend::get_persona_state,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "game_played_app_id",
                    |m: &Friend| { &m.game_played_app_id },
                    |m: &mut Friend| { &mut m.game_played_app_id },
                    Friend::get_game_played_app_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "game_server_ip",
                    |m: &Friend| { &m.game_server_ip },
                    |m: &mut Friend| { &mut m.game_server_ip },
                    Friend::get_game_server_ip,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "game_server_port",
                    |m: &Friend| { &m.game_server_port },
                    |m: &mut Friend| { &mut m.game_server_port },
                    Friend::get_game_server_port,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "persona_state_flags",
                    |m: &Friend| { &m.persona_state_flags },
                    |m: &mut Friend| { &mut m.persona_state_flags },
                    Friend::get_persona_state_flags,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "online_session_instances",
                    |m: &Friend| { &m.online_session_instances },
                    |m: &mut Friend| { &mut m.online_session_instances },
                    Friend::get_online_session_instances,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "published_instance_id",
                    |m: &Friend| { &m.published_instance_id },
                    |m: &mut Friend| { &mut m.published_instance_id },
                    Friend::get_published_instance_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "persona_set_by_user",
                    |m: &Friend| { &m.persona_set_by_user },
                    |m: &mut Friend| { &mut m.persona_set_by_user },
                    Friend::get_persona_set_by_user,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "player_name",
                    |m: &Friend| { &m.player_name },
                    |m: &mut Friend| { &mut m.player_name },
                    Friend::get_player_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "query_port",
                    |m: &Friend| { &m.query_port },
                    |m: &mut Friend| { &mut m.query_port },
                    Friend::get_query_port,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steamid_source",
                    |m: &Friend| { &m.steamid_source },
                    |m: &mut Friend| { &mut m.steamid_source },
                    Friend::get_steamid_source,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "avatar_hash",
                    |m: &Friend| { &m.avatar_hash },
                    |m: &mut Friend| { &mut m.avatar_hash },
                    Friend::get_avatar_hash,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "last_logoff",
                    |m: &Friend| { &m.last_logoff },
                    |m: &mut Friend| { &mut m.last_logoff },
                    Friend::get_last_logoff,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "last_logon",
                    |m: &Friend| { &m.last_logon },
                    |m: &mut Friend| { &mut m.last_logon },
                    Friend::get_last_logon,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "last_seen_online",
                    |m: &Friend| { &m.last_seen_online },
                    |m: &mut Friend| { &mut m.last_seen_online },
                    Friend::get_last_seen_online,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "clan_rank",
                    |m: &Friend| { &m.clan_rank },
                    |m: &mut Friend| { &mut m.clan_rank },
                    Friend::get_clan_rank,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "game_name",
                    |m: &Friend| { &m.game_name },
                    |m: &mut Friend| { &mut m.game_name },
                    Friend::get_game_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "gameid",
                    |m: &Friend| { &m.gameid },
                    |m: &mut Friend| { &mut m.gameid },
                    Friend::get_gameid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "game_data_blob",
                    |m: &Friend| { &m.game_data_blob },
                    |m: &mut Friend| { &mut m.game_data_blob },
                    Friend::get_game_data_blob,
                ));
                fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<friend::ClanData>, _>(
                    "clan_data",
                    |m: &Friend| { &m.clan_data },
                    |m: &mut Friend| { &mut m.clan_data },
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "clan_tag",
                    |m: &Friend| { &m.clan_tag },
                    |m: &mut Friend| { &mut m.clan_tag },
                    Friend::get_clan_tag,
                ));
                fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<friend::KV>>(
                    "rich_presence",
                    |m: &Friend| { &m.rich_presence },
                    |m: &mut Friend| { &mut m.rich_presence },
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "broadcast_id",
                    |m: &Friend| { &m.broadcast_id },
                    |m: &mut Friend| { &mut m.broadcast_id },
                    Friend::get_broadcast_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "game_lobby_id",
                    |m: &Friend| { &m.game_lobby_id },
                    |m: &mut Friend| { &mut m.game_lobby_id },
                    Friend::get_game_lobby_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "watching_broadcast_accountid",
                    |m: &Friend| { &m.watching_broadcast_accountid },
                    |m: &mut Friend| { &mut m.watching_broadcast_accountid },
                    Friend::get_watching_broadcast_accountid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "watching_broadcast_appid",
                    |m: &Friend| { &m.watching_broadcast_appid },
                    |m: &mut Friend| { &mut m.watching_broadcast_appid },
                    Friend::get_watching_broadcast_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "watching_broadcast_viewers",
                    |m: &Friend| { &m.watching_broadcast_viewers },
                    |m: &mut Friend| { &mut m.watching_broadcast_viewers },
                    Friend::get_watching_broadcast_viewers,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "watching_broadcast_title",
                    |m: &Friend| { &m.watching_broadcast_title },
                    |m: &mut Friend| { &mut m.watching_broadcast_title },
                    Friend::get_watching_broadcast_title,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Friend>(
                    "CMsgClientPersonaState.Friend",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Friend {
            static instance: ::protobuf::rt::Lazy<Friend> = ::protobuf::rt::Lazy::INIT;
            instance.get(Friend::new)
        }
    }

    impl ::protobuf::Clear for Friend {
        fn clear(&mut self) {
            self.friendid = ::std::option::Option::None;
            self.persona_state = ::std::option::Option::None;
            self.game_played_app_id = ::std::option::Option::None;
            self.game_server_ip = ::std::option::Option::None;
            self.game_server_port = ::std::option::Option::None;
            self.persona_state_flags = ::std::option::Option::None;
            self.online_session_instances = ::std::option::Option::None;
            self.published_instance_id = ::std::option::Option::None;
            self.persona_set_by_user = ::std::option::Option::None;
            self.player_name.clear();
            self.query_port = ::std::option::Option::None;
            self.steamid_source = ::std::option::Option::None;
            self.avatar_hash.clear();
            self.last_logoff = ::std::option::Option::None;
            self.last_logon = ::std::option::Option::None;
            self.last_seen_online = ::std::option::Option::None;
            self.clan_rank = ::std::option::Option::None;
            self.game_name.clear();
            self.gameid = ::std::option::Option::None;
            self.game_data_blob.clear();
            self.clan_data.clear();
            self.clan_tag.clear();
            self.rich_presence.clear();
            self.broadcast_id = ::std::option::Option::None;
            self.game_lobby_id = ::std::option::Option::None;
            self.watching_broadcast_accountid = ::std::option::Option::None;
            self.watching_broadcast_appid = ::std::option::Option::None;
            self.watching_broadcast_viewers = ::std::option::Option::None;
            self.watching_broadcast_title.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Friend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Friend {
    }

    /// Nested message and enums of message `Friend`
    pub mod friend {
        #[derive(PartialEq,Clone,Default)]
        pub struct ClanData {
            // message fields
            ogg_app_id: ::std::option::Option<u32>,
            chat_group_id: ::std::option::Option<u64>,
            // special fields
            pub unknown_fields: ::protobuf::UnknownFields,
            pub cached_size: ::protobuf::rt::CachedSize,
        }

        impl<'a> ::std::default::Default for &'a ClanData {
            fn default() -> &'a ClanData {
                <ClanData as ::protobuf::Message>::default_instance()
            }
        }

        impl ClanData {
            pub fn new() -> ClanData {
                ::std::default::Default::default()
            }

            // optional uint32 ogg_app_id = 1;

            pub fn get_ogg_app_id(&self) -> u32 {
                self.ogg_app_id.unwrap_or(0)
            }

            pub fn clear_ogg_app_id(&mut self) {
                self.ogg_app_id = ::std::option::Option::None;
            }

            pub fn has_ogg_app_id(&self) -> bool {
                self.ogg_app_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ogg_app_id(&mut self, v: u32) {
                self.ogg_app_id = ::std::option::Option::Some(v);
            }

            // optional uint64 chat_group_id = 2;

            pub fn get_chat_group_id(&self) -> u64 {
                self.chat_group_id.unwrap_or(0)
            }

            pub fn clear_chat_group_id(&mut self) {
                self.chat_group_id = ::std::option::Option::None;
            }

            pub fn has_chat_group_id(&self) -> bool {
                self.chat_group_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_chat_group_id(&mut self, v: u64) {
                self.chat_group_id = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for ClanData {
            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                while !is.eof()? {
                    let (field_number, wire_type) = is.read_tag_unpack()?;
                    match field_number {
                        1 => {
                            if wire_type != ::protobuf::wire_format::WireTypeVarint {
                                return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                            }
                            self.ogg_app_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        2 => {
                            if wire_type != ::protobuf::wire_format::WireTypeVarint {
                                return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                            }
                            self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        _ => {
                            ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u32 {
                let mut my_size = 0;
                if let Some(v) = self.ogg_app_id {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                }
                if let Some(v) = self.chat_group_id {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
                self.cached_size.set(my_size);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                if let Some(v) = self.ogg_app_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.chat_group_id {
                    os.write_uint64(2, v)?;
                }
                os.write_unknown_fields(self.get_unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn get_cached_size(&self) -> u32 {
                self.cached_size.get()
            }

            fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
                &self.unknown_fields
            }

            fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
                &mut self.unknown_fields
            }

            fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
                Self::descriptor_static()
            }

            fn new() -> ClanData {
                ClanData::new()
            }

            fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
                descriptor.get(|| {
                    let mut fields = ::std::vec::Vec::new();
                    fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                        "ogg_app_id",
                        |m: &ClanData| { &m.ogg_app_id },
                        |m: &mut ClanData| { &mut m.ogg_app_id },
                        ClanData::get_ogg_app_id,
                    ));
                    fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                        "chat_group_id",
                        |m: &ClanData| { &m.chat_group_id },
                        |m: &mut ClanData| { &mut m.chat_group_id },
                        ClanData::get_chat_group_id,
                    ));
                    ::protobuf::reflect::MessageDescriptor::new::<ClanData>(
                        "CMsgClientPersonaState.Friend.ClanData",
                        fields,
                        super::super::file_descriptor_proto()
                    )
                })
            }

            fn default_instance() -> &'static ClanData {
                static instance: ::protobuf::rt::Lazy<ClanData> = ::protobuf::rt::Lazy::INIT;
                instance.get(ClanData::new)
            }
        }

        impl ::protobuf::Clear for ClanData {
            fn clear(&mut self) {
                self.ogg_app_id = ::std::option::Option::None;
                self.chat_group_id = ::std::option::Option::None;
                self.unknown_fields.clear();
            }
        }

        impl ::std::fmt::Debug for ClanData {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ClanData {
        }

        #[derive(PartialEq,Clone,Default)]
        pub struct KV {
            // message fields
            key: ::protobuf::SingularField<::std::string::String>,
            value: ::protobuf::SingularField<::std::string::String>,
            // special fields
            pub unknown_fields: ::protobuf::UnknownFields,
            pub cached_size: ::protobuf::rt::CachedSize,
        }

        impl<'a> ::std::default::Default for &'a KV {
            fn default() -> &'a KV {
                <KV as ::protobuf::Message>::default_instance()
            }
        }

        impl KV {
            pub fn new() -> KV {
                ::std::default::Default::default()
            }

            // optional string key = 1;

            pub fn get_key(&self) -> &str {
                match self.key.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_key(&mut self) {
                self.key.clear();
            }

            pub fn has_key(&self) -> bool {
                self.key.is_some()
            }

            // Param is passed by value, moved
            pub fn set_key(&mut self, v: ::std::string::String) {
                self.key = ::protobuf::SingularField::some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_key(&mut self) -> &mut ::std::string::String {
                if self.key.is_none() {
                    self.key.set_default();
                }
                self.key.as_mut().unwrap()
            }

            // Take field
            pub fn take_key(&mut self) -> ::std::string::String {
                self.key.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string value = 2;

            pub fn get_value(&self) -> &str {
                match self.value.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_value(&mut self) {
                self.value.clear();
            }

            pub fn has_value(&self) -> bool {
                self.value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: ::std::string::String) {
                self.value = ::protobuf::SingularField::some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_value(&mut self) -> &mut ::std::string::String {
                if self.value.is_none() {
                    self.value.set_default();
                }
                self.value.as_mut().unwrap()
            }

            // Take field
            pub fn take_value(&mut self) -> ::std::string::String {
                self.value.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::protobuf::Message for KV {
            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                while !is.eof()? {
                    let (field_number, wire_type) = is.read_tag_unpack()?;
                    match field_number {
                        1 => {
                            ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                        },
                        2 => {
                            ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                        },
                        _ => {
                            ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u32 {
                let mut my_size = 0;
                if let Some(v) = self.key.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.value.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
                self.cached_size.set(my_size);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                if let Some(v) = self.key.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.value.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.get_unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn get_cached_size(&self) -> u32 {
                self.cached_size.get()
            }

            fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
                &self.unknown_fields
            }

            fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
                &mut self.unknown_fields
            }

            fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
                Self::descriptor_static()
            }

            fn new() -> KV {
                KV::new()
            }

            fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
                descriptor.get(|| {
                    let mut fields = ::std::vec::Vec::new();
                    fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                        "key",
                        |m: &KV| { &m.key },
                        |m: &mut KV| { &mut m.key },
                        KV::get_key,
                    ));
                    fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                        "value",
                        |m: &KV| { &m.value },
                        |m: &mut KV| { &mut m.value },
                        KV::get_value,
                    ));
                    ::protobuf::reflect::MessageDescriptor::new::<KV>(
                        "CMsgClientPersonaState.Friend.KV",
                        fields,
                        super::super::file_descriptor_proto()
                    )
                })
            }

            fn default_instance() -> &'static KV {
                static instance: ::protobuf::rt::Lazy<KV> = ::protobuf::rt::Lazy::INIT;
                instance.get(KV::new)
            }
        }

        impl ::protobuf::Clear for KV {
            fn clear(&mut self) {
                self.key.clear();
                self.value.clear();
                self.unknown_fields.clear();
            }
        }

        impl ::std::fmt::Debug for KV {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for KV {
        }
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFriendProfileInfo {
    // message fields
    steamid_friend: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendProfileInfo {
    fn default() -> &'a CMsgClientFriendProfileInfo {
        <CMsgClientFriendProfileInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendProfileInfo {
    pub fn new() -> CMsgClientFriendProfileInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_friend = 1;

    pub fn get_steamid_friend(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }

    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendProfileInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_friend = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_friend {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_friend {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendProfileInfo {
        CMsgClientFriendProfileInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_friend",
                |m: &CMsgClientFriendProfileInfo| { &m.steamid_friend },
                |m: &mut CMsgClientFriendProfileInfo| { &mut m.steamid_friend },
                CMsgClientFriendProfileInfo::get_steamid_friend,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendProfileInfo>(
                "CMsgClientFriendProfileInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendProfileInfo {
        static instance: ::protobuf::rt::Lazy<CMsgClientFriendProfileInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientFriendProfileInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendProfileInfo {
    fn clear(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendProfileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendProfileInfo {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFriendProfileInfoResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    steamid_friend: ::std::option::Option<u64>,
    time_created: ::std::option::Option<u32>,
    real_name: ::protobuf::SingularField<::std::string::String>,
    city_name: ::protobuf::SingularField<::std::string::String>,
    state_name: ::protobuf::SingularField<::std::string::String>,
    country_name: ::protobuf::SingularField<::std::string::String>,
    headline: ::protobuf::SingularField<::std::string::String>,
    summary: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendProfileInfoResponse {
    fn default() -> &'a CMsgClientFriendProfileInfoResponse {
        <CMsgClientFriendProfileInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendProfileInfoResponse {
    pub fn new() -> CMsgClientFriendProfileInfoResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_friend = 2;

    pub fn get_steamid_friend(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }

    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }

    // optional uint32 time_created = 3;

    pub fn get_time_created(&self) -> u32 {
        self.time_created.unwrap_or(0)
    }

    pub fn clear_time_created(&mut self) {
        self.time_created = ::std::option::Option::None;
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: u32) {
        self.time_created = ::std::option::Option::Some(v);
    }

    // optional string real_name = 4;

    pub fn get_real_name(&self) -> &str {
        match self.real_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_real_name(&mut self) {
        self.real_name.clear();
    }

    pub fn has_real_name(&self) -> bool {
        self.real_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_name(&mut self, v: ::std::string::String) {
        self.real_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_real_name(&mut self) -> &mut ::std::string::String {
        if self.real_name.is_none() {
            self.real_name.set_default();
        }
        self.real_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_real_name(&mut self) -> ::std::string::String {
        self.real_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string city_name = 5;

    pub fn get_city_name(&self) -> &str {
        match self.city_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_city_name(&mut self) {
        self.city_name.clear();
    }

    pub fn has_city_name(&self) -> bool {
        self.city_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city_name(&mut self, v: ::std::string::String) {
        self.city_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city_name(&mut self) -> &mut ::std::string::String {
        if self.city_name.is_none() {
            self.city_name.set_default();
        }
        self.city_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_city_name(&mut self) -> ::std::string::String {
        self.city_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string state_name = 6;

    pub fn get_state_name(&self) -> &str {
        match self.state_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_state_name(&mut self) {
        self.state_name.clear();
    }

    pub fn has_state_name(&self) -> bool {
        self.state_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_name(&mut self, v: ::std::string::String) {
        self.state_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_name(&mut self) -> &mut ::std::string::String {
        if self.state_name.is_none() {
            self.state_name.set_default();
        }
        self.state_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_state_name(&mut self) -> ::std::string::String {
        self.state_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_name = 7;

    pub fn get_country_name(&self) -> &str {
        match self.country_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_name(&mut self) {
        self.country_name.clear();
    }

    pub fn has_country_name(&self) -> bool {
        self.country_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_name(&mut self, v: ::std::string::String) {
        self.country_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_name(&mut self) -> &mut ::std::string::String {
        if self.country_name.is_none() {
            self.country_name.set_default();
        }
        self.country_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_name(&mut self) -> ::std::string::String {
        self.country_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string headline = 8;

    pub fn get_headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline.clear();
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline.set_default();
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string summary = 9;

    pub fn get_summary(&self) -> &str {
        match self.summary.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientFriendProfileInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_friend = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_created = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.real_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state_name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headline)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid_friend {
            my_size += 9;
        }
        if let Some(v) = self.time_created {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.real_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.city_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.state_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.country_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.summary.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid_friend {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.time_created {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.real_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.city_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.state_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.country_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.summary.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendProfileInfoResponse {
        CMsgClientFriendProfileInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.eresult },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.eresult },
                CMsgClientFriendProfileInfoResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_friend",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.steamid_friend },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.steamid_friend },
                CMsgClientFriendProfileInfoResponse::get_steamid_friend,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "time_created",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.time_created },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.time_created },
                CMsgClientFriendProfileInfoResponse::get_time_created,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "real_name",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.real_name },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.real_name },
                CMsgClientFriendProfileInfoResponse::get_real_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "city_name",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.city_name },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.city_name },
                CMsgClientFriendProfileInfoResponse::get_city_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "state_name",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.state_name },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.state_name },
                CMsgClientFriendProfileInfoResponse::get_state_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "country_name",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.country_name },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.country_name },
                CMsgClientFriendProfileInfoResponse::get_country_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "headline",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.headline },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.headline },
                CMsgClientFriendProfileInfoResponse::get_headline,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "summary",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.summary },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.summary },
                CMsgClientFriendProfileInfoResponse::get_summary,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendProfileInfoResponse>(
                "CMsgClientFriendProfileInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendProfileInfoResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientFriendProfileInfoResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientFriendProfileInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendProfileInfoResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steamid_friend = ::std::option::Option::None;
        self.time_created = ::std::option::Option::None;
        self.real_name.clear();
        self.city_name.clear();
        self.state_name.clear();
        self.country_name.clear();
        self.headline.clear();
        self.summary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendProfileInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendProfileInfoResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCreateFriendsGroup {
    // message fields
    steamid: ::std::option::Option<u64>,
    groupname: ::protobuf::SingularField<::std::string::String>,
    pub steamid_friends: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCreateFriendsGroup {
    fn default() -> &'a CMsgClientCreateFriendsGroup {
        <CMsgClientCreateFriendsGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCreateFriendsGroup {
    pub fn new() -> CMsgClientCreateFriendsGroup {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string groupname = 2;

    pub fn get_groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupname(&mut self) {
        self.groupname.clear();
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname.set_default();
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientCreateFriendsGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupname)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_friends)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.groupname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += 9 * self.steamid_friends.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.groupname.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.steamid_friends {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCreateFriendsGroup {
        CMsgClientCreateFriendsGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CMsgClientCreateFriendsGroup| { &m.steamid },
                |m: &mut CMsgClientCreateFriendsGroup| { &mut m.steamid },
                CMsgClientCreateFriendsGroup::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "groupname",
                |m: &CMsgClientCreateFriendsGroup| { &m.groupname },
                |m: &mut CMsgClientCreateFriendsGroup| { &mut m.groupname },
                CMsgClientCreateFriendsGroup::get_groupname,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "steamid_friends",
                |m: &CMsgClientCreateFriendsGroup| { &m.steamid_friends },
                |m: &mut CMsgClientCreateFriendsGroup| { &mut m.steamid_friends },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientCreateFriendsGroup>(
                "CMsgClientCreateFriendsGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCreateFriendsGroup {
        static instance: ::protobuf::rt::Lazy<CMsgClientCreateFriendsGroup> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientCreateFriendsGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientCreateFriendsGroup {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.groupname.clear();
        self.steamid_friends.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCreateFriendsGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCreateFriendsGroup {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCreateFriendsGroupResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    groupid: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCreateFriendsGroupResponse {
    fn default() -> &'a CMsgClientCreateFriendsGroupResponse {
        <CMsgClientCreateFriendsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCreateFriendsGroupResponse {
    pub fn new() -> CMsgClientCreateFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 groupid = 2;

    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCreateFriendsGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.groupid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCreateFriendsGroupResponse {
        CMsgClientCreateFriendsGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientCreateFriendsGroupResponse| { &m.eresult },
                |m: &mut CMsgClientCreateFriendsGroupResponse| { &mut m.eresult },
                CMsgClientCreateFriendsGroupResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "groupid",
                |m: &CMsgClientCreateFriendsGroupResponse| { &m.groupid },
                |m: &mut CMsgClientCreateFriendsGroupResponse| { &mut m.groupid },
                CMsgClientCreateFriendsGroupResponse::get_groupid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientCreateFriendsGroupResponse>(
                "CMsgClientCreateFriendsGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCreateFriendsGroupResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientCreateFriendsGroupResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientCreateFriendsGroupResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientCreateFriendsGroupResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.groupid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCreateFriendsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCreateFriendsGroupResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDeleteFriendsGroup {
    // message fields
    steamid: ::std::option::Option<u64>,
    groupid: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeleteFriendsGroup {
    fn default() -> &'a CMsgClientDeleteFriendsGroup {
        <CMsgClientDeleteFriendsGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeleteFriendsGroup {
    pub fn new() -> CMsgClientDeleteFriendsGroup {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 groupid = 2;

    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeleteFriendsGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.groupid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDeleteFriendsGroup {
        CMsgClientDeleteFriendsGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CMsgClientDeleteFriendsGroup| { &m.steamid },
                |m: &mut CMsgClientDeleteFriendsGroup| { &mut m.steamid },
                CMsgClientDeleteFriendsGroup::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "groupid",
                |m: &CMsgClientDeleteFriendsGroup| { &m.groupid },
                |m: &mut CMsgClientDeleteFriendsGroup| { &mut m.groupid },
                CMsgClientDeleteFriendsGroup::get_groupid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDeleteFriendsGroup>(
                "CMsgClientDeleteFriendsGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDeleteFriendsGroup {
        static instance: ::protobuf::rt::Lazy<CMsgClientDeleteFriendsGroup> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientDeleteFriendsGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientDeleteFriendsGroup {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.groupid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDeleteFriendsGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeleteFriendsGroup {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDeleteFriendsGroupResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeleteFriendsGroupResponse {
    fn default() -> &'a CMsgClientDeleteFriendsGroupResponse {
        <CMsgClientDeleteFriendsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeleteFriendsGroupResponse {
    pub fn new() -> CMsgClientDeleteFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeleteFriendsGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDeleteFriendsGroupResponse {
        CMsgClientDeleteFriendsGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientDeleteFriendsGroupResponse| { &m.eresult },
                |m: &mut CMsgClientDeleteFriendsGroupResponse| { &mut m.eresult },
                CMsgClientDeleteFriendsGroupResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDeleteFriendsGroupResponse>(
                "CMsgClientDeleteFriendsGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDeleteFriendsGroupResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientDeleteFriendsGroupResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientDeleteFriendsGroupResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientDeleteFriendsGroupResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDeleteFriendsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeleteFriendsGroupResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientManageFriendsGroup {
    // message fields
    groupid: ::std::option::Option<i32>,
    groupname: ::protobuf::SingularField<::std::string::String>,
    pub steamid_friends_added: ::std::vec::Vec<u64>,
    pub steamid_friends_removed: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientManageFriendsGroup {
    fn default() -> &'a CMsgClientManageFriendsGroup {
        <CMsgClientManageFriendsGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientManageFriendsGroup {
    pub fn new() -> CMsgClientManageFriendsGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;

    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional string groupname = 2;

    pub fn get_groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupname(&mut self) {
        self.groupname.clear();
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname.set_default();
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientManageFriendsGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupname)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_friends_added)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_friends_removed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.groupname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += 9 * self.steamid_friends_added.len() as u32;
        my_size += 9 * self.steamid_friends_removed.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.groupname.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.steamid_friends_added {
            os.write_fixed64(3, *v)?;
        };
        for v in &self.steamid_friends_removed {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientManageFriendsGroup {
        CMsgClientManageFriendsGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "groupid",
                |m: &CMsgClientManageFriendsGroup| { &m.groupid },
                |m: &mut CMsgClientManageFriendsGroup| { &mut m.groupid },
                CMsgClientManageFriendsGroup::get_groupid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "groupname",
                |m: &CMsgClientManageFriendsGroup| { &m.groupname },
                |m: &mut CMsgClientManageFriendsGroup| { &mut m.groupname },
                CMsgClientManageFriendsGroup::get_groupname,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "steamid_friends_added",
                |m: &CMsgClientManageFriendsGroup| { &m.steamid_friends_added },
                |m: &mut CMsgClientManageFriendsGroup| { &mut m.steamid_friends_added },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "steamid_friends_removed",
                |m: &CMsgClientManageFriendsGroup| { &m.steamid_friends_removed },
                |m: &mut CMsgClientManageFriendsGroup| { &mut m.steamid_friends_removed },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientManageFriendsGroup>(
                "CMsgClientManageFriendsGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientManageFriendsGroup {
        static instance: ::protobuf::rt::Lazy<CMsgClientManageFriendsGroup> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientManageFriendsGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientManageFriendsGroup {
    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.groupname.clear();
        self.steamid_friends_added.clear();
        self.steamid_friends_removed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientManageFriendsGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientManageFriendsGroup {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientManageFriendsGroupResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientManageFriendsGroupResponse {
    fn default() -> &'a CMsgClientManageFriendsGroupResponse {
        <CMsgClientManageFriendsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientManageFriendsGroupResponse {
    pub fn new() -> CMsgClientManageFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientManageFriendsGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientManageFriendsGroupResponse {
        CMsgClientManageFriendsGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientManageFriendsGroupResponse| { &m.eresult },
                |m: &mut CMsgClientManageFriendsGroupResponse| { &mut m.eresult },
                CMsgClientManageFriendsGroupResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientManageFriendsGroupResponse>(
                "CMsgClientManageFriendsGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientManageFriendsGroupResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientManageFriendsGroupResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientManageFriendsGroupResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientManageFriendsGroupResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientManageFriendsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientManageFriendsGroupResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAddFriendToGroup {
    // message fields
    groupid: ::std::option::Option<i32>,
    steamiduser: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendToGroup {
    fn default() -> &'a CMsgClientAddFriendToGroup {
        <CMsgClientAddFriendToGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriendToGroup {
    pub fn new() -> CMsgClientAddFriendToGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;

    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamiduser = 2;

    pub fn get_steamiduser(&self) -> u64 {
        self.steamiduser.unwrap_or(0)
    }

    pub fn clear_steamiduser(&mut self) {
        self.steamiduser = ::std::option::Option::None;
    }

    pub fn has_steamiduser(&self) -> bool {
        self.steamiduser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamiduser(&mut self, v: u64) {
        self.steamiduser = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAddFriendToGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamiduser = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamiduser {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamiduser {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAddFriendToGroup {
        CMsgClientAddFriendToGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "groupid",
                |m: &CMsgClientAddFriendToGroup| { &m.groupid },
                |m: &mut CMsgClientAddFriendToGroup| { &mut m.groupid },
                CMsgClientAddFriendToGroup::get_groupid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamiduser",
                |m: &CMsgClientAddFriendToGroup| { &m.steamiduser },
                |m: &mut CMsgClientAddFriendToGroup| { &mut m.steamiduser },
                CMsgClientAddFriendToGroup::get_steamiduser,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAddFriendToGroup>(
                "CMsgClientAddFriendToGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAddFriendToGroup {
        static instance: ::protobuf::rt::Lazy<CMsgClientAddFriendToGroup> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAddFriendToGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientAddFriendToGroup {
    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.steamiduser = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAddFriendToGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAddFriendToGroup {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAddFriendToGroupResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendToGroupResponse {
    fn default() -> &'a CMsgClientAddFriendToGroupResponse {
        <CMsgClientAddFriendToGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriendToGroupResponse {
    pub fn new() -> CMsgClientAddFriendToGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAddFriendToGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAddFriendToGroupResponse {
        CMsgClientAddFriendToGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientAddFriendToGroupResponse| { &m.eresult },
                |m: &mut CMsgClientAddFriendToGroupResponse| { &mut m.eresult },
                CMsgClientAddFriendToGroupResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAddFriendToGroupResponse>(
                "CMsgClientAddFriendToGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAddFriendToGroupResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientAddFriendToGroupResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAddFriendToGroupResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientAddFriendToGroupResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAddFriendToGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAddFriendToGroupResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRemoveFriendFromGroup {
    // message fields
    groupid: ::std::option::Option<i32>,
    steamiduser: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriendFromGroup {
    fn default() -> &'a CMsgClientRemoveFriendFromGroup {
        <CMsgClientRemoveFriendFromGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriendFromGroup {
    pub fn new() -> CMsgClientRemoveFriendFromGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;

    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamiduser = 2;

    pub fn get_steamiduser(&self) -> u64 {
        self.steamiduser.unwrap_or(0)
    }

    pub fn clear_steamiduser(&mut self) {
        self.steamiduser = ::std::option::Option::None;
    }

    pub fn has_steamiduser(&self) -> bool {
        self.steamiduser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamiduser(&mut self, v: u64) {
        self.steamiduser = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRemoveFriendFromGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.groupid = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamiduser = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamiduser {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamiduser {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRemoveFriendFromGroup {
        CMsgClientRemoveFriendFromGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "groupid",
                |m: &CMsgClientRemoveFriendFromGroup| { &m.groupid },
                |m: &mut CMsgClientRemoveFriendFromGroup| { &mut m.groupid },
                CMsgClientRemoveFriendFromGroup::get_groupid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamiduser",
                |m: &CMsgClientRemoveFriendFromGroup| { &m.steamiduser },
                |m: &mut CMsgClientRemoveFriendFromGroup| { &mut m.steamiduser },
                CMsgClientRemoveFriendFromGroup::get_steamiduser,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRemoveFriendFromGroup>(
                "CMsgClientRemoveFriendFromGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRemoveFriendFromGroup {
        static instance: ::protobuf::rt::Lazy<CMsgClientRemoveFriendFromGroup> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRemoveFriendFromGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientRemoveFriendFromGroup {
    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.steamiduser = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRemoveFriendFromGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRemoveFriendFromGroup {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRemoveFriendFromGroupResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriendFromGroupResponse {
    fn default() -> &'a CMsgClientRemoveFriendFromGroupResponse {
        <CMsgClientRemoveFriendFromGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriendFromGroupResponse {
    pub fn new() -> CMsgClientRemoveFriendFromGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRemoveFriendFromGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRemoveFriendFromGroupResponse {
        CMsgClientRemoveFriendFromGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientRemoveFriendFromGroupResponse| { &m.eresult },
                |m: &mut CMsgClientRemoveFriendFromGroupResponse| { &mut m.eresult },
                CMsgClientRemoveFriendFromGroupResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRemoveFriendFromGroupResponse>(
                "CMsgClientRemoveFriendFromGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRemoveFriendFromGroupResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientRemoveFriendFromGroupResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRemoveFriendFromGroupResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRemoveFriendFromGroupResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRemoveFriendFromGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRemoveFriendFromGroupResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetEmoticonList {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetEmoticonList {
    fn default() -> &'a CMsgClientGetEmoticonList {
        <CMsgClientGetEmoticonList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetEmoticonList {
    pub fn new() -> CMsgClientGetEmoticonList {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetEmoticonList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetEmoticonList {
        CMsgClientGetEmoticonList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetEmoticonList>(
                "CMsgClientGetEmoticonList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetEmoticonList {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetEmoticonList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetEmoticonList::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetEmoticonList {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetEmoticonList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetEmoticonList {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientEmoticonList {
    // message fields
    pub emoticons: ::protobuf::RepeatedField<cmsg_client_emoticon_list::Emoticon>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmoticonList {
    fn default() -> &'a CMsgClientEmoticonList {
        <CMsgClientEmoticonList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEmoticonList {
    pub fn new() -> CMsgClientEmoticonList {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientEmoticonList {
    fn is_initialized(&self) -> bool {
        for v in &self.emoticons {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.emoticons)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.emoticons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.emoticons {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientEmoticonList {
        CMsgClientEmoticonList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_emoticon_list::Emoticon>>(
                "emoticons",
                |m: &CMsgClientEmoticonList| { &m.emoticons },
                |m: &mut CMsgClientEmoticonList| { &mut m.emoticons },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientEmoticonList>(
                "CMsgClientEmoticonList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientEmoticonList {
        static instance: ::protobuf::rt::Lazy<CMsgClientEmoticonList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientEmoticonList::new)
    }
}

impl ::protobuf::Clear for CMsgClientEmoticonList {
    fn clear(&mut self) {
        self.emoticons.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientEmoticonList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientEmoticonList {
}

/// Nested message and enums of message `CMsgClientEmoticonList`
pub mod cmsg_client_emoticon_list {
    #[derive(PartialEq,Clone,Default)]
    pub struct Emoticon {
        // message fields
        name: ::protobuf::SingularField<::std::string::String>,
        count: ::std::option::Option<i32>,
        time_last_used: ::std::option::Option<u32>,
        use_count: ::std::option::Option<u32>,
        time_received: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Emoticon {
        fn default() -> &'a Emoticon {
            <Emoticon as ::protobuf::Message>::default_instance()
        }
    }

    impl Emoticon {
        pub fn new() -> Emoticon {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn get_name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name.clear();
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name.set_default();
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 count = 2;

        pub fn get_count(&self) -> i32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: i32) {
            self.count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_used = 3;

        pub fn get_time_last_used(&self) -> u32 {
            self.time_last_used.unwrap_or(0)
        }

        pub fn clear_time_last_used(&mut self) {
            self.time_last_used = ::std::option::Option::None;
        }

        pub fn has_time_last_used(&self) -> bool {
            self.time_last_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_used(&mut self, v: u32) {
            self.time_last_used = ::std::option::Option::Some(v);
        }

        // optional uint32 use_count = 4;

        pub fn get_use_count(&self) -> u32 {
            self.use_count.unwrap_or(0)
        }

        pub fn clear_use_count(&mut self) {
            self.use_count = ::std::option::Option::None;
        }

        pub fn has_use_count(&self) -> bool {
            self.use_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use_count(&mut self, v: u32) {
            self.use_count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_received = 5;

        pub fn get_time_received(&self) -> u32 {
            self.time_received.unwrap_or(0)
        }

        pub fn clear_time_received(&mut self) {
            self.time_received = ::std::option::Option::None;
        }

        pub fn has_time_received(&self) -> bool {
            self.time_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_received(&mut self, v: u32) {
            self.time_received = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Emoticon {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_last_used = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.use_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_received = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.time_last_used {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.use_count {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.time_received {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.time_last_used {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.use_count {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.time_received {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Emoticon {
            Emoticon::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "name",
                    |m: &Emoticon| { &m.name },
                    |m: &mut Emoticon| { &mut m.name },
                    Emoticon::get_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "count",
                    |m: &Emoticon| { &m.count },
                    |m: &mut Emoticon| { &mut m.count },
                    Emoticon::get_count,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_last_used",
                    |m: &Emoticon| { &m.time_last_used },
                    |m: &mut Emoticon| { &mut m.time_last_used },
                    Emoticon::get_time_last_used,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "use_count",
                    |m: &Emoticon| { &m.use_count },
                    |m: &mut Emoticon| { &mut m.use_count },
                    Emoticon::get_use_count,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_received",
                    |m: &Emoticon| { &m.time_received },
                    |m: &mut Emoticon| { &mut m.time_received },
                    Emoticon::get_time_received,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Emoticon>(
                    "CMsgClientEmoticonList.Emoticon",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Emoticon {
            static instance: ::protobuf::rt::Lazy<Emoticon> = ::protobuf::rt::Lazy::INIT;
            instance.get(Emoticon::new)
        }
    }

    impl ::protobuf::Clear for Emoticon {
        fn clear(&mut self) {
            self.name.clear();
            self.count = ::std::option::Option::None;
            self.time_last_used = ::std::option::Option::None;
            self.use_count = ::std::option::Option::None;
            self.time_received = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Emoticon {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Emoticon {
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n(steammessages_clientserver_friends.proto\x1a\x18steammessages_base.pr\
    oto\"\xd1\x01\n\x13CMsgClientFriendMsg\x12\x18\n\x07steamid\x18\x01\x20\
    \x01(\x06R\x07steamid\x12&\n\x0fchat_entry_type\x18\x02\x20\x01(\x05R\rc\
    hatEntryType\x12\x18\n\x07message\x18\x03\x20\x01(\x0cR\x07message\x128\
    \n\x18rtime32_server_timestamp\x18\x04\x20\x01(\x07R\x16rtime32ServerTim\
    estamp\x12$\n\x0eecho_to_sender\x18\x05\x20\x01(\x08R\x0cechoToSender\"\
    \xee\x01\n\x1bCMsgClientFriendMsgIncoming\x12!\n\x0csteamid_from\x18\x01\
    \x20\x01(\x06R\x0bsteamidFrom\x12&\n\x0fchat_entry_type\x18\x02\x20\x01(\
    \x05R\rchatEntryType\x120\n\x14from_limited_account\x18\x03\x20\x01(\x08\
    R\x12fromLimitedAccount\x12\x18\n\x07message\x18\x04\x20\x01(\x0cR\x07me\
    ssage\x128\n\x18rtime32_server_timestamp\x18\x05\x20\x01(\x07R\x16rtime3\
    2ServerTimestamp\"y\n\x13CMsgClientAddFriend\x12$\n\x0esteamid_to_add\
    \x18\x01\x20\x01(\x06R\x0csteamidToAdd\x12<\n\x1baccountname_or_email_to\
    _add\x18\x02\x20\x01(\tR\x17accountnameOrEmailToAdd\"\x8e\x01\n\x1bCMsgC\
    lientAddFriendResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12$\n\x0esteam_id_added\x18\x02\x20\x01(\x06R\x0csteamIdAdd\
    ed\x12,\n\x12persona_name_added\x18\x03\x20\x01(\tR\x10personaNameAdded\
    \"4\n\x16CMsgClientRemoveFriend\x12\x1a\n\x08friendid\x18\x01\x20\x01(\
    \x06R\x08friendid\"F\n\x14CMsgClientHideFriend\x12\x1a\n\x08friendid\x18\
    \x01\x20\x01(\x06R\x08friendid\x12\x12\n\x04hide\x18\x02\x20\x01(\x08R\
    \x04hide\"\xd6\x02\n\x15CMsgClientFriendsList\x12\"\n\x0cbincremental\
    \x18\x01\x20\x01(\x08R\x0cbincremental\x127\n\x07friends\x18\x02\x20\x03\
    (\x0b2\x1d.CMsgClientFriendsList.FriendR\x07friends\x12(\n\x10max_friend\
    _count\x18\x03\x20\x01(\rR\x0emaxFriendCount\x12.\n\x13active_friend_cou\
    nt\x18\x04\x20\x01(\rR\x11activeFriendCount\x12*\n\x11friends_limit_hit\
    \x18\x05\x20\x01(\x08R\x0ffriendsLimitHit\x1aZ\n\x06Friend\x12\x1e\n\nul\
    friendid\x18\x01\x20\x01(\x06R\nulfriendid\x120\n\x13efriendrelationship\
    \x18\x02\x20\x01(\rR\x13efriendrelationship\"\xa5\x03\n\x1bCMsgClientFri\
    endsGroupsList\x12\x1a\n\x08bremoval\x18\x01\x20\x01(\x08R\x08bremoval\
    \x12\"\n\x0cbincremental\x18\x02\x20\x01(\x08R\x0cbincremental\x12L\n\
    \x0cfriendGroups\x18\x03\x20\x03(\x0b2(.CMsgClientFriendsGroupsList.Frie\
    ndGroupR\x0cfriendGroups\x12U\n\x0bmemberships\x18\x04\x20\x03(\x0b23.CM\
    sgClientFriendsGroupsList.FriendGroupsMembershipR\x0bmemberships\x1aM\n\
    \x0bFriendGroup\x12\x1a\n\x08nGroupID\x18\x01\x20\x01(\x05R\x08nGroupID\
    \x12\"\n\x0cstrGroupName\x18\x02\x20\x01(\tR\x0cstrGroupName\x1aR\n\x16F\
    riendGroupsMembership\x12\x1c\n\tulSteamID\x18\x01\x20\x01(\x06R\tulStea\
    mID\x12\x1a\n\x08nGroupID\x18\x02\x20\x01(\x05R\x08nGroupID\"\xee\x01\n\
    \x1cCMsgClientPlayerNicknameList\x12\x18\n\x07removal\x18\x01\x20\x01(\
    \x08R\x07removal\x12\x20\n\x0bincremental\x18\x02\x20\x01(\x08R\x0bincre\
    mental\x12J\n\tnicknames\x18\x03\x20\x03(\x0b2,.CMsgClientPlayerNickname\
    List.PlayerNicknameR\tnicknames\x1aF\n\x0ePlayerNickname\x12\x18\n\x07st\
    eamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x1a\n\x08nickname\x18\x03\x20\
    \x01(\tR\x08nickname\"S\n\x1bCMsgClientSetPlayerNickname\x12\x18\n\x07st\
    eamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x1a\n\x08nickname\x18\x02\x20\
    \x01(\tR\x08nickname\"?\n#CMsgClientSetPlayerNicknameResponse\x12\x18\n\
    \x07eresult\x18\x01\x20\x01(\rR\x07eresult\"o\n\x1bCMsgClientRequestFrie\
    ndData\x126\n\x17persona_state_requested\x18\x01\x20\x01(\rR\x15personaS\
    tateRequested\x12\x18\n\x07friends\x18\x02\x20\x03(\x06R\x07friends\"\
    \xf4\x02\n\x16CMsgClientChangeStatus\x12#\n\rpersona_state\x18\x01\x20\
    \x01(\rR\x0cpersonaState\x12\x1f\n\x0bplayer_name\x18\x02\x20\x01(\tR\np\
    layerName\x123\n\x16is_auto_generated_name\x18\x03\x20\x01(\x08R\x13isAu\
    toGeneratedName\x12#\n\rhigh_priority\x18\x04\x20\x01(\x08R\x0chighPrior\
    ity\x12-\n\x13persona_set_by_user\x18\x05\x20\x01(\x08R\x10personaSetByU\
    ser\x121\n\x13persona_state_flags\x18\x06\x20\x01(\r:\x010R\x11personaSt\
    ateFlags\x122\n\x15need_persona_response\x18\x07\x20\x01(\x08R\x13needPe\
    rsonaResponse\x12$\n\x0eis_client_idle\x18\x08\x20\x01(\x08R\x0cisClient\
    Idle\"T\n\x19CMsgPersonaChangeResponse\x12\x16\n\x06result\x18\x01\x20\
    \x01(\rR\x06result\x12\x1f\n\x0bplayer_name\x18\x02\x20\x01(\tR\nplayerN\
    ame\"\xd5\x0b\n\x16CMsgClientPersonaState\x12!\n\x0cstatus_flags\x18\x01\
    \x20\x01(\rR\x0bstatusFlags\x128\n\x07friends\x18\x02\x20\x03(\x0b2\x1e.\
    CMsgClientPersonaState.FriendR\x07friends\x1a\xdd\n\n\x06Friend\x12\x1a\
    \n\x08friendid\x18\x01\x20\x01(\x06R\x08friendid\x12#\n\rpersona_state\
    \x18\x02\x20\x01(\rR\x0cpersonaState\x12+\n\x12game_played_app_id\x18\
    \x03\x20\x01(\rR\x0fgamePlayedAppId\x12$\n\x0egame_server_ip\x18\x04\x20\
    \x01(\rR\x0cgameServerIp\x12(\n\x10game_server_port\x18\x05\x20\x01(\rR\
    \x0egameServerPort\x12.\n\x13persona_state_flags\x18\x06\x20\x01(\rR\x11\
    personaStateFlags\x128\n\x18online_session_instances\x18\x07\x20\x01(\rR\
    \x16onlineSessionInstances\x122\n\x15published_instance_id\x18\x08\x20\
    \x01(\rR\x13publishedInstanceId\x12-\n\x13persona_set_by_user\x18\n\x20\
    \x01(\x08R\x10personaSetByUser\x12\x1f\n\x0bplayer_name\x18\x0f\x20\x01(\
    \tR\nplayerName\x12\x1d\n\nquery_port\x18\x14\x20\x01(\rR\tqueryPort\x12\
    %\n\x0esteamid_source\x18\x19\x20\x01(\x06R\rsteamidSource\x12\x1f\n\x0b\
    avatar_hash\x18\x1f\x20\x01(\x0cR\navatarHash\x12\x1f\n\x0blast_logoff\
    \x18-\x20\x01(\rR\nlastLogoff\x12\x1d\n\nlast_logon\x18.\x20\x01(\rR\tla\
    stLogon\x12(\n\x10last_seen_online\x18/\x20\x01(\rR\x0elastSeenOnline\
    \x12\x1b\n\tclan_rank\x182\x20\x01(\rR\x08clanRank\x12\x1b\n\tgame_name\
    \x187\x20\x01(\tR\x08gameName\x12\x16\n\x06gameid\x188\x20\x01(\x06R\x06\
    gameid\x12$\n\x0egame_data_blob\x18<\x20\x01(\x0cR\x0cgameDataBlob\x12D\
    \n\tclan_data\x18@\x20\x01(\x0b2'.CMsgClientPersonaState.Friend.ClanData\
    R\x08clanData\x12\x19\n\x08clan_tag\x18A\x20\x01(\tR\x07clanTag\x12F\n\r\
    rich_presence\x18G\x20\x03(\x0b2!.CMsgClientPersonaState.Friend.KVR\x0cr\
    ichPresence\x12!\n\x0cbroadcast_id\x18H\x20\x01(\x06R\x0bbroadcastId\x12\
    \"\n\rgame_lobby_id\x18I\x20\x01(\x06R\x0bgameLobbyId\x12@\n\x1cwatching\
    _broadcast_accountid\x18J\x20\x01(\rR\x1awatchingBroadcastAccountid\x128\
    \n\x18watching_broadcast_appid\x18K\x20\x01(\rR\x16watchingBroadcastAppi\
    d\x12<\n\x1awatching_broadcast_viewers\x18L\x20\x01(\rR\x18watchingBroad\
    castViewers\x128\n\x18watching_broadcast_title\x18M\x20\x01(\tR\x16watch\
    ingBroadcastTitle\x1aL\n\x08ClanData\x12\x1c\n\nogg_app_id\x18\x01\x20\
    \x01(\rR\x08oggAppId\x12\"\n\rchat_group_id\x18\x02\x20\x01(\x04R\x0bcha\
    tGroupId\x1a,\n\x02KV\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"D\n\x1bCMsgClientFriendPro\
    fileInfo\x12%\n\x0esteamid_friend\x18\x01\x20\x01(\x06R\rsteamidFriend\"\
    \xbe\x02\n#CMsgClientFriendProfileInfoResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x12%\n\x0esteamid_friend\x18\x02\x20\
    \x01(\x06R\rsteamidFriend\x12!\n\x0ctime_created\x18\x03\x20\x01(\rR\x0b\
    timeCreated\x12\x1b\n\treal_name\x18\x04\x20\x01(\tR\x08realName\x12\x1b\
    \n\tcity_name\x18\x05\x20\x01(\tR\x08cityName\x12\x1d\n\nstate_name\x18\
    \x06\x20\x01(\tR\tstateName\x12!\n\x0ccountry_name\x18\x07\x20\x01(\tR\
    \x0bcountryName\x12\x1a\n\x08headline\x18\x08\x20\x01(\tR\x08headline\
    \x12\x18\n\x07summary\x18\t\x20\x01(\tR\x07summary\"\x7f\n\x1cCMsgClient\
    CreateFriendsGroup\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\
    \x12\x1c\n\tgroupname\x18\x02\x20\x01(\tR\tgroupname\x12'\n\x0fsteamid_f\
    riends\x18\x03\x20\x03(\x06R\x0esteamidFriends\"Z\n$CMsgClientCreateFrie\
    ndsGroupResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\x12\
    \x18\n\x07groupid\x18\x02\x20\x01(\x05R\x07groupid\"R\n\x1cCMsgClientDel\
    eteFriendsGroup\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\
    \x12\x18\n\x07groupid\x18\x02\x20\x01(\x05R\x07groupid\"@\n$CMsgClientDe\
    leteFriendsGroupResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07ere\
    sult\"\xc2\x01\n\x1cCMsgClientManageFriendsGroup\x12\x18\n\x07groupid\
    \x18\x01\x20\x01(\x05R\x07groupid\x12\x1c\n\tgroupname\x18\x02\x20\x01(\
    \tR\tgroupname\x122\n\x15steamid_friends_added\x18\x03\x20\x03(\x06R\x13\
    steamidFriendsAdded\x126\n\x17steamid_friends_removed\x18\x04\x20\x03(\
    \x06R\x15steamidFriendsRemoved\"@\n$CMsgClientManageFriendsGroupResponse\
    \x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\"X\n\x1aCMsgClientA\
    ddFriendToGroup\x12\x18\n\x07groupid\x18\x01\x20\x01(\x05R\x07groupid\
    \x12\x20\n\x0bsteamiduser\x18\x02\x20\x01(\x06R\x0bsteamiduser\">\n\"CMs\
    gClientAddFriendToGroupResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\
    \x07eresult\"]\n\x1fCMsgClientRemoveFriendFromGroup\x12\x18\n\x07groupid\
    \x18\x01\x20\x01(\x05R\x07groupid\x12\x20\n\x0bsteamiduser\x18\x02\x20\
    \x01(\x06R\x0bsteamiduser\"C\n'CMsgClientRemoveFriendFromGroupResponse\
    \x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\"\x1b\n\x19CMsgClie\
    ntGetEmoticonList\"\xf7\x01\n\x16CMsgClientEmoticonList\x12>\n\temoticon\
    s\x18\x01\x20\x03(\x0b2\x20.CMsgClientEmoticonList.EmoticonR\temoticons\
    \x1a\x9c\x01\n\x08Emoticon\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05count\x12$\n\x0etime_last_u\
    sed\x18\x03\x20\x01(\rR\x0ctimeLastUsed\x12\x1b\n\tuse_count\x18\x04\x20\
    \x01(\rR\x08useCount\x12#\n\rtime_received\x18\x05\x20\x01(\rR\x0ctimeRe\
    ceivedB\x05H\x01\x80\x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
