// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_clientmetrics.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_AppInterfaceCreation {
    // message fields
    raw_version: ::protobuf::SingularField<::std::string::String>,
    requested_interface_type: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceCreation {
    fn default() -> &'a CClientMetrics_AppInterfaceCreation {
        <CClientMetrics_AppInterfaceCreation as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceCreation {
    pub fn new() -> CClientMetrics_AppInterfaceCreation {
        ::std::default::Default::default()
    }

    // optional string raw_version = 1;


    pub fn get_raw_version(&self) -> &str {
        match self.raw_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_raw_version(&mut self) {
        self.raw_version.clear();
    }

    pub fn has_raw_version(&self) -> bool {
        self.raw_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_version(&mut self, v: ::std::string::String) {
        self.raw_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_version(&mut self) -> &mut ::std::string::String {
        if self.raw_version.is_none() {
            self.raw_version.set_default();
        }
        self.raw_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_version(&mut self) -> ::std::string::String {
        self.raw_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string requested_interface_type = 2;


    pub fn get_requested_interface_type(&self) -> &str {
        match self.requested_interface_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_requested_interface_type(&mut self) {
        self.requested_interface_type.clear();
    }

    pub fn has_requested_interface_type(&self) -> bool {
        self.requested_interface_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_interface_type(&mut self, v: ::std::string::String) {
        self.requested_interface_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requested_interface_type(&mut self) -> &mut ::std::string::String {
        if self.requested_interface_type.is_none() {
            self.requested_interface_type.set_default();
        }
        self.requested_interface_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_requested_interface_type(&mut self) -> ::std::string::String {
        self.requested_interface_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceCreation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.raw_version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.requested_interface_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.raw_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.requested_interface_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.raw_version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.requested_interface_type.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_AppInterfaceCreation {
        CClientMetrics_AppInterfaceCreation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "raw_version",
                |m: &CClientMetrics_AppInterfaceCreation| { &m.raw_version },
                |m: &mut CClientMetrics_AppInterfaceCreation| { &mut m.raw_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "requested_interface_type",
                |m: &CClientMetrics_AppInterfaceCreation| { &m.requested_interface_type },
                |m: &mut CClientMetrics_AppInterfaceCreation| { &mut m.requested_interface_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientMetrics_AppInterfaceCreation>(
                "CClientMetrics_AppInterfaceCreation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceCreation {
        static instance: ::protobuf::rt::LazyV2<CClientMetrics_AppInterfaceCreation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientMetrics_AppInterfaceCreation::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_AppInterfaceCreation {
    fn clear(&mut self) {
        self.raw_version.clear();
        self.requested_interface_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_AppInterfaceCreation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceCreation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_AppInterfaceMethodCounts {
    // message fields
    interface_name: ::protobuf::SingularField<::std::string::String>,
    method_name: ::protobuf::SingularField<::std::string::String>,
    call_count: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceMethodCounts {
    fn default() -> &'a CClientMetrics_AppInterfaceMethodCounts {
        <CClientMetrics_AppInterfaceMethodCounts as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceMethodCounts {
    pub fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        ::std::default::Default::default()
    }

    // optional string interface_name = 1;


    pub fn get_interface_name(&self) -> &str {
        match self.interface_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_interface_name(&mut self) {
        self.interface_name.clear();
    }

    pub fn has_interface_name(&self) -> bool {
        self.interface_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface_name(&mut self, v: ::std::string::String) {
        self.interface_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface_name(&mut self) -> &mut ::std::string::String {
        if self.interface_name.is_none() {
            self.interface_name.set_default();
        }
        self.interface_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_interface_name(&mut self) -> ::std::string::String {
        self.interface_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string method_name = 2;


    pub fn get_method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_method_name(&mut self) {
        self.method_name.clear();
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name.set_default();
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 call_count = 3;


    pub fn get_call_count(&self) -> u32 {
        self.call_count.unwrap_or(0)
    }
    pub fn clear_call_count(&mut self) {
        self.call_count = ::std::option::Option::None;
    }

    pub fn has_call_count(&self) -> bool {
        self.call_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_count(&mut self, v: u32) {
        self.call_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceMethodCounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.interface_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.method_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.call_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.interface_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.call_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.interface_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.method_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.call_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        CClientMetrics_AppInterfaceMethodCounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "interface_name",
                |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.interface_name },
                |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.interface_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "method_name",
                |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.method_name },
                |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.method_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "call_count",
                |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.call_count },
                |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.call_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientMetrics_AppInterfaceMethodCounts>(
                "CClientMetrics_AppInterfaceMethodCounts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceMethodCounts {
        static instance: ::protobuf::rt::LazyV2<CClientMetrics_AppInterfaceMethodCounts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientMetrics_AppInterfaceMethodCounts::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_AppInterfaceMethodCounts {
    fn clear(&mut self) {
        self.interface_name.clear();
        self.method_name.clear();
        self.call_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_AppInterfaceMethodCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceMethodCounts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_AppInterfaceStats_Notification {
    // message fields
    game_id: ::std::option::Option<u64>,
    pub interfaces_created: ::protobuf::RepeatedField<CClientMetrics_AppInterfaceCreation>,
    pub methods_called: ::protobuf::RepeatedField<CClientMetrics_AppInterfaceMethodCounts>,
    session_length_seconds: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceStats_Notification {
    fn default() -> &'a CClientMetrics_AppInterfaceStats_Notification {
        <CClientMetrics_AppInterfaceStats_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceStats_Notification {
    pub fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // repeated .CClientMetrics_AppInterfaceCreation interfaces_created = 2;


    pub fn get_interfaces_created(&self) -> &[CClientMetrics_AppInterfaceCreation] {
        &self.interfaces_created
    }
    pub fn clear_interfaces_created(&mut self) {
        self.interfaces_created.clear();
    }

    // Param is passed by value, moved
    pub fn set_interfaces_created(&mut self, v: ::protobuf::RepeatedField<CClientMetrics_AppInterfaceCreation>) {
        self.interfaces_created = v;
    }

    // Mutable pointer to the field.
    pub fn mut_interfaces_created(&mut self) -> &mut ::protobuf::RepeatedField<CClientMetrics_AppInterfaceCreation> {
        &mut self.interfaces_created
    }

    // Take field
    pub fn take_interfaces_created(&mut self) -> ::protobuf::RepeatedField<CClientMetrics_AppInterfaceCreation> {
        ::std::mem::replace(&mut self.interfaces_created, ::protobuf::RepeatedField::new())
    }

    // repeated .CClientMetrics_AppInterfaceMethodCounts methods_called = 3;


    pub fn get_methods_called(&self) -> &[CClientMetrics_AppInterfaceMethodCounts] {
        &self.methods_called
    }
    pub fn clear_methods_called(&mut self) {
        self.methods_called.clear();
    }

    // Param is passed by value, moved
    pub fn set_methods_called(&mut self, v: ::protobuf::RepeatedField<CClientMetrics_AppInterfaceMethodCounts>) {
        self.methods_called = v;
    }

    // Mutable pointer to the field.
    pub fn mut_methods_called(&mut self) -> &mut ::protobuf::RepeatedField<CClientMetrics_AppInterfaceMethodCounts> {
        &mut self.methods_called
    }

    // Take field
    pub fn take_methods_called(&mut self) -> ::protobuf::RepeatedField<CClientMetrics_AppInterfaceMethodCounts> {
        ::std::mem::replace(&mut self.methods_called, ::protobuf::RepeatedField::new())
    }

    // optional uint32 session_length_seconds = 4;


    pub fn get_session_length_seconds(&self) -> u32 {
        self.session_length_seconds.unwrap_or(0)
    }
    pub fn clear_session_length_seconds(&mut self) {
        self.session_length_seconds = ::std::option::Option::None;
    }

    pub fn has_session_length_seconds(&self) -> bool {
        self.session_length_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_seconds(&mut self, v: u32) {
        self.session_length_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceStats_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.interfaces_created {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.methods_called {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.interfaces_created)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.methods_called)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session_length_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.interfaces_created {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.methods_called {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.session_length_seconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.interfaces_created {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.methods_called {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.session_length_seconds {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        CClientMetrics_AppInterfaceStats_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "game_id",
                |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.game_id },
                |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CClientMetrics_AppInterfaceCreation>>(
                "interfaces_created",
                |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.interfaces_created },
                |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.interfaces_created },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CClientMetrics_AppInterfaceMethodCounts>>(
                "methods_called",
                |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.methods_called },
                |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.methods_called },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session_length_seconds",
                |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.session_length_seconds },
                |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.session_length_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientMetrics_AppInterfaceStats_Notification>(
                "CClientMetrics_AppInterfaceStats_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceStats_Notification {
        static instance: ::protobuf::rt::LazyV2<CClientMetrics_AppInterfaceStats_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientMetrics_AppInterfaceStats_Notification::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_AppInterfaceStats_Notification {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.interfaces_created.clear();
        self.methods_called.clear();
        self.session_length_seconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_AppInterfaceStats_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceStats_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_IPv6Connectivity_Result {
    // message fields
    protocol_tested: ::std::option::Option<u32>,
    connectivity_state: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Result {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Result {
        <CClientMetrics_IPv6Connectivity_Result as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Result {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Result {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_tested = 1;


    pub fn get_protocol_tested(&self) -> u32 {
        self.protocol_tested.unwrap_or(0)
    }
    pub fn clear_protocol_tested(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
    }

    pub fn has_protocol_tested(&self) -> bool {
        self.protocol_tested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_tested(&mut self, v: u32) {
        self.protocol_tested = ::std::option::Option::Some(v);
    }

    // optional uint32 connectivity_state = 2;


    pub fn get_connectivity_state(&self) -> u32 {
        self.connectivity_state.unwrap_or(0)
    }
    pub fn clear_connectivity_state(&mut self) {
        self.connectivity_state = ::std::option::Option::None;
    }

    pub fn has_connectivity_state(&self) -> bool {
        self.connectivity_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectivity_state(&mut self, v: u32) {
        self.connectivity_state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_IPv6Connectivity_Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_tested = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.connectivity_state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_tested {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connectivity_state {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_tested {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connectivity_state {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Result {
        CClientMetrics_IPv6Connectivity_Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_tested",
                |m: &CClientMetrics_IPv6Connectivity_Result| { &m.protocol_tested },
                |m: &mut CClientMetrics_IPv6Connectivity_Result| { &mut m.protocol_tested },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "connectivity_state",
                |m: &CClientMetrics_IPv6Connectivity_Result| { &m.connectivity_state },
                |m: &mut CClientMetrics_IPv6Connectivity_Result| { &mut m.connectivity_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientMetrics_IPv6Connectivity_Result>(
                "CClientMetrics_IPv6Connectivity_Result",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Result {
        static instance: ::protobuf::rt::LazyV2<CClientMetrics_IPv6Connectivity_Result> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientMetrics_IPv6Connectivity_Result::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_IPv6Connectivity_Result {
    fn clear(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
        self.connectivity_state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_IPv6Connectivity_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_IPv6Connectivity_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_IPv6Connectivity_Notification {
    // message fields
    cell_id: ::std::option::Option<u32>,
    pub results: ::protobuf::RepeatedField<CClientMetrics_IPv6Connectivity_Result>,
    private_ip_is_rfc6598: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Notification {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Notification {
        <CClientMetrics_IPv6Connectivity_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Notification {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;


    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }
    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // repeated .CClientMetrics_IPv6Connectivity_Result results = 2;


    pub fn get_results(&self) -> &[CClientMetrics_IPv6Connectivity_Result] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<CClientMetrics_IPv6Connectivity_Result>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<CClientMetrics_IPv6Connectivity_Result> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<CClientMetrics_IPv6Connectivity_Result> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    // optional bool private_ip_is_rfc6598 = 3;


    pub fn get_private_ip_is_rfc6598(&self) -> bool {
        self.private_ip_is_rfc6598.unwrap_or(false)
    }
    pub fn clear_private_ip_is_rfc6598(&mut self) {
        self.private_ip_is_rfc6598 = ::std::option::Option::None;
    }

    pub fn has_private_ip_is_rfc6598(&self) -> bool {
        self.private_ip_is_rfc6598.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_ip_is_rfc6598(&mut self, v: bool) {
        self.private_ip_is_rfc6598 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_IPv6Connectivity_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private_ip_is_rfc6598 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.private_ip_is_rfc6598 {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.private_ip_is_rfc6598 {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        CClientMetrics_IPv6Connectivity_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cell_id",
                |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.cell_id },
                |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.cell_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CClientMetrics_IPv6Connectivity_Result>>(
                "results",
                |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.results },
                |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.results },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "private_ip_is_rfc6598",
                |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.private_ip_is_rfc6598 },
                |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.private_ip_is_rfc6598 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientMetrics_IPv6Connectivity_Notification>(
                "CClientMetrics_IPv6Connectivity_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Notification {
        static instance: ::protobuf::rt::LazyV2<CClientMetrics_IPv6Connectivity_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientMetrics_IPv6Connectivity_Notification::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_IPv6Connectivity_Notification {
    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.results.clear();
        self.private_ip_is_rfc6598 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_IPv6Connectivity_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_IPv6Connectivity_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_SteamPipeWorkStats_Operation {
    // message fields
    field_type: ::std::option::Option<ESteamPipeOperationType>,
    num_ops: ::std::option::Option<u32>,
    num_bytes: ::std::option::Option<u64>,
    busy_time_ms: ::std::option::Option<u64>,
    idle_time_ms: ::std::option::Option<u64>,
    sum_run_time_ms: ::std::option::Option<u64>,
    sum_wait_time_ms: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_SteamPipeWorkStats_Operation {
    fn default() -> &'a CClientMetrics_SteamPipeWorkStats_Operation {
        <CClientMetrics_SteamPipeWorkStats_Operation as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_SteamPipeWorkStats_Operation {
    pub fn new() -> CClientMetrics_SteamPipeWorkStats_Operation {
        ::std::default::Default::default()
    }

    // optional .ESteamPipeOperationType type = 1;


    pub fn get_field_type(&self) -> ESteamPipeOperationType {
        self.field_type.unwrap_or(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ESteamPipeOperationType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint32 num_ops = 2;


    pub fn get_num_ops(&self) -> u32 {
        self.num_ops.unwrap_or(0)
    }
    pub fn clear_num_ops(&mut self) {
        self.num_ops = ::std::option::Option::None;
    }

    pub fn has_num_ops(&self) -> bool {
        self.num_ops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_ops(&mut self, v: u32) {
        self.num_ops = ::std::option::Option::Some(v);
    }

    // optional uint64 num_bytes = 3;


    pub fn get_num_bytes(&self) -> u64 {
        self.num_bytes.unwrap_or(0)
    }
    pub fn clear_num_bytes(&mut self) {
        self.num_bytes = ::std::option::Option::None;
    }

    pub fn has_num_bytes(&self) -> bool {
        self.num_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_bytes(&mut self, v: u64) {
        self.num_bytes = ::std::option::Option::Some(v);
    }

    // optional uint64 busy_time_ms = 4;


    pub fn get_busy_time_ms(&self) -> u64 {
        self.busy_time_ms.unwrap_or(0)
    }
    pub fn clear_busy_time_ms(&mut self) {
        self.busy_time_ms = ::std::option::Option::None;
    }

    pub fn has_busy_time_ms(&self) -> bool {
        self.busy_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_busy_time_ms(&mut self, v: u64) {
        self.busy_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 idle_time_ms = 5;


    pub fn get_idle_time_ms(&self) -> u64 {
        self.idle_time_ms.unwrap_or(0)
    }
    pub fn clear_idle_time_ms(&mut self) {
        self.idle_time_ms = ::std::option::Option::None;
    }

    pub fn has_idle_time_ms(&self) -> bool {
        self.idle_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_time_ms(&mut self, v: u64) {
        self.idle_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 sum_run_time_ms = 6;


    pub fn get_sum_run_time_ms(&self) -> u64 {
        self.sum_run_time_ms.unwrap_or(0)
    }
    pub fn clear_sum_run_time_ms(&mut self) {
        self.sum_run_time_ms = ::std::option::Option::None;
    }

    pub fn has_sum_run_time_ms(&self) -> bool {
        self.sum_run_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum_run_time_ms(&mut self, v: u64) {
        self.sum_run_time_ms = ::std::option::Option::Some(v);
    }

    // optional uint64 sum_wait_time_ms = 7;


    pub fn get_sum_wait_time_ms(&self) -> u64 {
        self.sum_wait_time_ms.unwrap_or(0)
    }
    pub fn clear_sum_wait_time_ms(&mut self) {
        self.sum_wait_time_ms = ::std::option::Option::None;
    }

    pub fn has_sum_wait_time_ms(&self) -> bool {
        self.sum_wait_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sum_wait_time_ms(&mut self, v: u64) {
        self.sum_wait_time_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_SteamPipeWorkStats_Operation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_ops = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_bytes = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.busy_time_ms = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.idle_time_ms = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sum_run_time_ms = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sum_wait_time_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.num_ops {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_bytes {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.busy_time_ms {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.idle_time_ms {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sum_run_time_ms {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sum_wait_time_ms {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.num_ops {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_bytes {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.busy_time_ms {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.idle_time_ms {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.sum_run_time_ms {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.sum_wait_time_ms {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_SteamPipeWorkStats_Operation {
        CClientMetrics_SteamPipeWorkStats_Operation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ESteamPipeOperationType>>(
                "type",
                |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.field_type },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_ops",
                |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.num_ops },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.num_ops },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_bytes",
                |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.num_bytes },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.num_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "busy_time_ms",
                |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.busy_time_ms },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.busy_time_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "idle_time_ms",
                |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.idle_time_ms },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.idle_time_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sum_run_time_ms",
                |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.sum_run_time_ms },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.sum_run_time_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sum_wait_time_ms",
                |m: &CClientMetrics_SteamPipeWorkStats_Operation| { &m.sum_wait_time_ms },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Operation| { &mut m.sum_wait_time_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientMetrics_SteamPipeWorkStats_Operation>(
                "CClientMetrics_SteamPipeWorkStats_Operation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_SteamPipeWorkStats_Operation {
        static instance: ::protobuf::rt::LazyV2<CClientMetrics_SteamPipeWorkStats_Operation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientMetrics_SteamPipeWorkStats_Operation::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_SteamPipeWorkStats_Operation {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.num_ops = ::std::option::Option::None;
        self.num_bytes = ::std::option::Option::None;
        self.busy_time_ms = ::std::option::Option::None;
        self.idle_time_ms = ::std::option::Option::None;
        self.sum_run_time_ms = ::std::option::Option::None;
        self.sum_wait_time_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_SteamPipeWorkStats_Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_SteamPipeWorkStats_Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_SteamPipeWorkStats_Notification {
    // message fields
    appid: ::std::option::Option<u32>,
    depotid: ::std::option::Option<u32>,
    work_type: ::std::option::Option<ESteamPipeWorkType>,
    pub operations: ::protobuf::RepeatedField<CClientMetrics_SteamPipeWorkStats_Operation>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_SteamPipeWorkStats_Notification {
    fn default() -> &'a CClientMetrics_SteamPipeWorkStats_Notification {
        <CClientMetrics_SteamPipeWorkStats_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_SteamPipeWorkStats_Notification {
    pub fn new() -> CClientMetrics_SteamPipeWorkStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 depotid = 2;


    pub fn get_depotid(&self) -> u32 {
        self.depotid.unwrap_or(0)
    }
    pub fn clear_depotid(&mut self) {
        self.depotid = ::std::option::Option::None;
    }

    pub fn has_depotid(&self) -> bool {
        self.depotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depotid(&mut self, v: u32) {
        self.depotid = ::std::option::Option::Some(v);
    }

    // optional .ESteamPipeWorkType work_type = 3;


    pub fn get_work_type(&self) -> ESteamPipeWorkType {
        self.work_type.unwrap_or(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid)
    }
    pub fn clear_work_type(&mut self) {
        self.work_type = ::std::option::Option::None;
    }

    pub fn has_work_type(&self) -> bool {
        self.work_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_work_type(&mut self, v: ESteamPipeWorkType) {
        self.work_type = ::std::option::Option::Some(v);
    }

    // repeated .CClientMetrics_SteamPipeWorkStats_Operation operations = 4;


    pub fn get_operations(&self) -> &[CClientMetrics_SteamPipeWorkStats_Operation] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<CClientMetrics_SteamPipeWorkStats_Operation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::protobuf::RepeatedField<CClientMetrics_SteamPipeWorkStats_Operation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<CClientMetrics_SteamPipeWorkStats_Operation> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CClientMetrics_SteamPipeWorkStats_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.depotid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.work_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.depotid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.work_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.depotid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.work_type {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.operations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_SteamPipeWorkStats_Notification {
        CClientMetrics_SteamPipeWorkStats_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.appid },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "depotid",
                |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.depotid },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.depotid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ESteamPipeWorkType>>(
                "work_type",
                |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.work_type },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.work_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CClientMetrics_SteamPipeWorkStats_Operation>>(
                "operations",
                |m: &CClientMetrics_SteamPipeWorkStats_Notification| { &m.operations },
                |m: &mut CClientMetrics_SteamPipeWorkStats_Notification| { &mut m.operations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientMetrics_SteamPipeWorkStats_Notification>(
                "CClientMetrics_SteamPipeWorkStats_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_SteamPipeWorkStats_Notification {
        static instance: ::protobuf::rt::LazyV2<CClientMetrics_SteamPipeWorkStats_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientMetrics_SteamPipeWorkStats_Notification::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_SteamPipeWorkStats_Notification {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.depotid = ::std::option::Option::None;
        self.work_type = ::std::option::Option::None;
        self.operations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_SteamPipeWorkStats_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_SteamPipeWorkStats_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_ReportClientError_Notification {
    // message fields
    product: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    pub errors: ::protobuf::RepeatedField<CClientMetrics_ReportClientError_Notification_Error>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ReportClientError_Notification {
    fn default() -> &'a CClientMetrics_ReportClientError_Notification {
        <CClientMetrics_ReportClientError_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ReportClientError_Notification {
    pub fn new() -> CClientMetrics_ReportClientError_Notification {
        ::std::default::Default::default()
    }

    // optional string product = 1;


    pub fn get_product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product.set_default();
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CClientMetrics_ReportClientError_Notification.Error errors = 3;


    pub fn get_errors(&self) -> &[CClientMetrics_ReportClientError_Notification_Error] {
        &self.errors
    }
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ::protobuf::RepeatedField<CClientMetrics_ReportClientError_Notification_Error>) {
        self.errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errors(&mut self) -> &mut ::protobuf::RepeatedField<CClientMetrics_ReportClientError_Notification_Error> {
        &mut self.errors
    }

    // Take field
    pub fn take_errors(&mut self) -> ::protobuf::RepeatedField<CClientMetrics_ReportClientError_Notification_Error> {
        ::std::mem::replace(&mut self.errors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CClientMetrics_ReportClientError_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.errors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.product)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.errors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.product.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.errors {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_ReportClientError_Notification {
        CClientMetrics_ReportClientError_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product",
                |m: &CClientMetrics_ReportClientError_Notification| { &m.product },
                |m: &mut CClientMetrics_ReportClientError_Notification| { &mut m.product },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &CClientMetrics_ReportClientError_Notification| { &m.version },
                |m: &mut CClientMetrics_ReportClientError_Notification| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CClientMetrics_ReportClientError_Notification_Error>>(
                "errors",
                |m: &CClientMetrics_ReportClientError_Notification| { &m.errors },
                |m: &mut CClientMetrics_ReportClientError_Notification| { &mut m.errors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientMetrics_ReportClientError_Notification>(
                "CClientMetrics_ReportClientError_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_ReportClientError_Notification {
        static instance: ::protobuf::rt::LazyV2<CClientMetrics_ReportClientError_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientMetrics_ReportClientError_Notification::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_ReportClientError_Notification {
    fn clear(&mut self) {
        self.product.clear();
        self.version.clear();
        self.errors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_ReportClientError_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_ReportClientError_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_ReportClientError_Notification_Error {
    // message fields
    identifier: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    count: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ReportClientError_Notification_Error {
    fn default() -> &'a CClientMetrics_ReportClientError_Notification_Error {
        <CClientMetrics_ReportClientError_Notification_Error as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ReportClientError_Notification_Error {
    pub fn new() -> CClientMetrics_ReportClientError_Notification_Error {
        ::std::default::Default::default()
    }

    // optional string identifier = 1;


    pub fn get_identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        if self.identifier.is_none() {
            self.identifier.set_default();
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 count = 3;


    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_ReportClientError_Notification_Error {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.identifier)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifier.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_ReportClientError_Notification_Error {
        CClientMetrics_ReportClientError_Notification_Error::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identifier",
                |m: &CClientMetrics_ReportClientError_Notification_Error| { &m.identifier },
                |m: &mut CClientMetrics_ReportClientError_Notification_Error| { &mut m.identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CClientMetrics_ReportClientError_Notification_Error| { &m.message },
                |m: &mut CClientMetrics_ReportClientError_Notification_Error| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &CClientMetrics_ReportClientError_Notification_Error| { &m.count },
                |m: &mut CClientMetrics_ReportClientError_Notification_Error| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientMetrics_ReportClientError_Notification_Error>(
                "CClientMetrics_ReportClientError_Notification.Error",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_ReportClientError_Notification_Error {
        static instance: ::protobuf::rt::LazyV2<CClientMetrics_ReportClientError_Notification_Error> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientMetrics_ReportClientError_Notification_Error::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_ReportClientError_Notification_Error {
    fn clear(&mut self) {
        self.identifier.clear();
        self.message.clear();
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_ReportClientError_Notification_Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_ReportClientError_Notification_Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_ClientBootstrap_Notification {
    // message fields
    pub summary: ::protobuf::SingularPtrField<super::clientmetrics::CClientMetrics_ClientBootstrap_Summary>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_ClientBootstrap_Notification {
    fn default() -> &'a CClientMetrics_ClientBootstrap_Notification {
        <CClientMetrics_ClientBootstrap_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_ClientBootstrap_Notification {
    pub fn new() -> CClientMetrics_ClientBootstrap_Notification {
        ::std::default::Default::default()
    }

    // optional .CClientMetrics_ClientBootstrap_Summary summary = 1;


    pub fn get_summary(&self) -> &super::clientmetrics::CClientMetrics_ClientBootstrap_Summary {
        self.summary.as_ref().unwrap_or_else(|| <super::clientmetrics::CClientMetrics_ClientBootstrap_Summary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: super::clientmetrics::CClientMetrics_ClientBootstrap_Summary) {
        self.summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut super::clientmetrics::CClientMetrics_ClientBootstrap_Summary {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> super::clientmetrics::CClientMetrics_ClientBootstrap_Summary {
        self.summary.take().unwrap_or_else(|| super::clientmetrics::CClientMetrics_ClientBootstrap_Summary::new())
    }
}

impl ::protobuf::Message for CClientMetrics_ClientBootstrap_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.summary.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_ClientBootstrap_Notification {
        CClientMetrics_ClientBootstrap_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::clientmetrics::CClientMetrics_ClientBootstrap_Summary>>(
                "summary",
                |m: &CClientMetrics_ClientBootstrap_Notification| { &m.summary },
                |m: &mut CClientMetrics_ClientBootstrap_Notification| { &mut m.summary },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientMetrics_ClientBootstrap_Notification>(
                "CClientMetrics_ClientBootstrap_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_ClientBootstrap_Notification {
        static instance: ::protobuf::rt::LazyV2<CClientMetrics_ClientBootstrap_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientMetrics_ClientBootstrap_Notification::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_ClientBootstrap_Notification {
    fn clear(&mut self) {
        self.summary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_ClientBootstrap_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_ClientBootstrap_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum ESteamPipeWorkType {
    k_ESteamPipeClientWorkType_Invalid = 0,
    k_ESteamPipeClientWorkType_StageFromChunkStores = 1,
}

impl ::protobuf::ProtobufEnum for ESteamPipeWorkType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamPipeWorkType> {
        match value {
            0 => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid),
            1 => ::std::option::Option::Some(ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ESteamPipeWorkType] = &[
            ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid,
            ESteamPipeWorkType::k_ESteamPipeClientWorkType_StageFromChunkStores,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ESteamPipeWorkType>("ESteamPipeWorkType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ESteamPipeWorkType {
}

impl ::std::default::Default for ESteamPipeWorkType {
    fn default() -> Self {
        ESteamPipeWorkType::k_ESteamPipeClientWorkType_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for ESteamPipeWorkType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum ESteamPipeOperationType {
    k_ESteamPipeOperationType_Invalid = 0,
    k_ESteamPipeOperationType_DecryptCPU = 1,
    k_ESteamPipeOperationType_DiskRead = 2,
    k_ESteamPipeOperationType_DiskWrite = 3,
}

impl ::protobuf::ProtobufEnum for ESteamPipeOperationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamPipeOperationType> {
        match value {
            0 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid),
            1 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU),
            2 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead),
            3 => ::std::option::Option::Some(ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ESteamPipeOperationType] = &[
            ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid,
            ESteamPipeOperationType::k_ESteamPipeOperationType_DecryptCPU,
            ESteamPipeOperationType::k_ESteamPipeOperationType_DiskRead,
            ESteamPipeOperationType::k_ESteamPipeOperationType_DiskWrite,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ESteamPipeOperationType>("ESteamPipeOperationType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ESteamPipeOperationType {
}

impl ::std::default::Default for ESteamPipeOperationType {
    fn default() -> Self {
        ESteamPipeOperationType::k_ESteamPipeOperationType_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for ESteamPipeOperationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-steammessages_clientmetrics.steamclient.proto\x1a,steammessages_unifi\
    ed_base.steamclient.proto\x1a\x13clientmetrics.proto\"\x80\x01\n#CClient\
    Metrics_AppInterfaceCreation\x12\x1f\n\x0braw_version\x18\x01\x20\x01(\t\
    R\nrawVersion\x128\n\x18requested_interface_type\x18\x02\x20\x01(\tR\x16\
    requestedInterfaceType\"\x90\x01\n'CClientMetrics_AppInterfaceMethodCoun\
    ts\x12%\n\x0einterface_name\x18\x01\x20\x01(\tR\rinterfaceName\x12\x1f\n\
    \x0bmethod_name\x18\x02\x20\x01(\tR\nmethodName\x12\x1d\n\ncall_count\
    \x18\x03\x20\x01(\rR\tcallCount\"\xa4\x02\n-CClientMetrics_AppInterfaceS\
    tats_Notification\x12\x17\n\x07game_id\x18\x01\x20\x01(\x04R\x06gameId\
    \x12S\n\x12interfaces_created\x18\x02\x20\x03(\x0b2$.CClientMetrics_AppI\
    nterfaceCreationR\x11interfacesCreated\x12O\n\x0emethods_called\x18\x03\
    \x20\x03(\x0b2(.CClientMetrics_AppInterfaceMethodCountsR\rmethodsCalled\
    \x124\n\x16session_length_seconds\x18\x04\x20\x01(\rR\x14sessionLengthSe\
    conds\"\x80\x01\n&CClientMetrics_IPv6Connectivity_Result\x12'\n\x0fproto\
    col_tested\x18\x01\x20\x01(\rR\x0eprotocolTested\x12-\n\x12connectivity_\
    state\x18\x02\x20\x01(\rR\x11connectivityState\"\xbd\x01\n,CClientMetric\
    s_IPv6Connectivity_Notification\x12\x17\n\x07cell_id\x18\x01\x20\x01(\rR\
    \x06cellId\x12A\n\x07results\x18\x02\x20\x03(\x0b2'.CClientMetrics_IPv6C\
    onnectivity_ResultR\x07results\x121\n\x15private_ip_is_rfc6598\x18\x03\
    \x20\x01(\x08R\x12privateIpIsRfc6598\"\xc8\x02\n+CClientMetrics_SteamPip\
    eWorkStats_Operation\x12O\n\x04type\x18\x01\x20\x01(\x0e2\x18.ESteamPipe\
    OperationType:!k_ESteamPipeOperationType_InvalidR\x04type\x12\x17\n\x07n\
    um_ops\x18\x02\x20\x01(\rR\x06numOps\x12\x1b\n\tnum_bytes\x18\x03\x20\
    \x01(\x04R\x08numBytes\x12\x20\n\x0cbusy_time_ms\x18\x04\x20\x01(\x04R\n\
    busyTimeMs\x12\x20\n\x0cidle_time_ms\x18\x05\x20\x01(\x04R\nidleTimeMs\
    \x12%\n\x0fsum_run_time_ms\x18\x06\x20\x01(\x04R\x0csumRunTimeMs\x12'\n\
    \x10sum_wait_time_ms\x18\x07\x20\x01(\x04R\rsumWaitTimeMs\"\x84\x02\n.CC\
    lientMetrics_SteamPipeWorkStats_Notification\x12\x14\n\x05appid\x18\x01\
    \x20\x01(\rR\x05appid\x12\x18\n\x07depotid\x18\x02\x20\x01(\rR\x07depoti\
    d\x12T\n\twork_type\x18\x03\x20\x01(\x0e2\x13.ESteamPipeWorkType:\"k_ESt\
    eamPipeClientWorkType_InvalidR\x08workType\x12L\n\noperations\x18\x04\
    \x20\x03(\x0b2,.CClientMetrics_SteamPipeWorkStats_OperationR\noperations\
    \"\x8a\x02\n-CClientMetrics_ReportClientError_Notification\x12\x18\n\x07\
    product\x18\x01\x20\x01(\tR\x07product\x12\x18\n\x07version\x18\x02\x20\
    \x01(\tR\x07version\x12L\n\x06errors\x18\x03\x20\x03(\x0b24.CClientMetri\
    cs_ReportClientError_Notification.ErrorR\x06errors\x1aW\n\x05Error\x12\
    \x1e\n\nidentifier\x18\x01\x20\x01(\tR\nidentifier\x12\x18\n\x07message\
    \x18\x02\x20\x01(\tR\x07message\x12\x14\n\x05count\x18\x03\x20\x01(\rR\
    \x05count\"p\n+CClientMetrics_ClientBootstrap_Notification\x12A\n\x07sum\
    mary\x18\x01\x20\x01(\x0b2'.CClientMetrics_ClientBootstrap_SummaryR\x07s\
    ummary*q\n\x12ESteamPipeWorkType\x12&\n\"k_ESteamPipeClientWorkType_Inva\
    lid\x10\0\x123\n/k_ESteamPipeClientWorkType_StageFromChunkStores\x10\x01\
    *\xbb\x01\n\x17ESteamPipeOperationType\x12%\n!k_ESteamPipeOperationType_\
    Invalid\x10\0\x12(\n$k_ESteamPipeOperationType_DecryptCPU\x10\x01\x12&\n\
    \"k_ESteamPipeOperationType_DiskRead\x10\x02\x12'\n#k_ESteamPipeOperatio\
    nType_DiskWrite\x10\x032\xf4\x03\n\rClientMetrics\x12\\\n\x1dClientAppIn\
    terfaceStatsReport\x12..CClientMetrics_AppInterfaceStats_Notification\
    \x1a\x0b.NoResponse\x12Z\n\x1cClientIPv6ConnectivityReport\x12-.CClientM\
    etrics_IPv6Connectivity_Notification\x1a\x0b.NoResponse\x12X\n\x18SteamP\
    ipeWorkStatsReport\x12/.CClientMetrics_SteamPipeWorkStats_Notification\
    \x1a\x0b.NoResponse\x12P\n\x11ReportClientError\x12..CClientMetrics_Repo\
    rtClientError_Notification\x1a\x0b.NoResponse\x12R\n\x15ClientBootstrapR\
    eport\x12,.CClientMetrics_ClientBootstrap_Notification\x1a\x0b.NoRespons\
    e\x1a)\x82\xb5\x18%A\x20service\x20for\x20client-reported\x20metricsB\
    \x03\x80\x01\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
