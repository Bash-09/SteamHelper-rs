// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_clientserver.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUDSP2PSessionStarted {
    // message fields
    steamid_remote: ::std::option::Option<u64>,
    appid: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUDSP2PSessionStarted {
    fn default() -> &'a CMsgClientUDSP2PSessionStarted {
        <CMsgClientUDSP2PSessionStarted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUDSP2PSessionStarted {
    pub fn new() -> CMsgClientUDSP2PSessionStarted {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_remote = 1;


    pub fn get_steamid_remote(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }
    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 2;


    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUDSP2PSessionStarted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_remote = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_remote {
            my_size += 9;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_remote {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUDSP2PSessionStarted {
        CMsgClientUDSP2PSessionStarted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_remote",
                |m: &CMsgClientUDSP2PSessionStarted| { &m.steamid_remote },
                |m: &mut CMsgClientUDSP2PSessionStarted| { &mut m.steamid_remote },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "appid",
                |m: &CMsgClientUDSP2PSessionStarted| { &m.appid },
                |m: &mut CMsgClientUDSP2PSessionStarted| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUDSP2PSessionStarted>(
                "CMsgClientUDSP2PSessionStarted",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUDSP2PSessionStarted {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUDSP2PSessionStarted> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUDSP2PSessionStarted::new)
    }
}

impl ::protobuf::Clear for CMsgClientUDSP2PSessionStarted {
    fn clear(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUDSP2PSessionStarted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUDSP2PSessionStarted {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUDSP2PSessionEnded {
    // message fields
    steamid_remote: ::std::option::Option<u64>,
    appid: ::std::option::Option<i32>,
    session_length_sec: ::std::option::Option<i32>,
    session_error: ::std::option::Option<i32>,
    nattype: ::std::option::Option<i32>,
    bytes_recv: ::std::option::Option<i32>,
    bytes_sent: ::std::option::Option<i32>,
    bytes_sent_relay: ::std::option::Option<i32>,
    bytes_recv_relay: ::std::option::Option<i32>,
    time_to_connect_ms: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUDSP2PSessionEnded {
    fn default() -> &'a CMsgClientUDSP2PSessionEnded {
        <CMsgClientUDSP2PSessionEnded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUDSP2PSessionEnded {
    pub fn new() -> CMsgClientUDSP2PSessionEnded {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_remote = 1;


    pub fn get_steamid_remote(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }
    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 2;


    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 session_length_sec = 3;


    pub fn get_session_length_sec(&self) -> i32 {
        self.session_length_sec.unwrap_or(0)
    }
    pub fn clear_session_length_sec(&mut self) {
        self.session_length_sec = ::std::option::Option::None;
    }

    pub fn has_session_length_sec(&self) -> bool {
        self.session_length_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_sec(&mut self, v: i32) {
        self.session_length_sec = ::std::option::Option::Some(v);
    }

    // optional int32 session_error = 4;


    pub fn get_session_error(&self) -> i32 {
        self.session_error.unwrap_or(0)
    }
    pub fn clear_session_error(&mut self) {
        self.session_error = ::std::option::Option::None;
    }

    pub fn has_session_error(&self) -> bool {
        self.session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_error(&mut self, v: i32) {
        self.session_error = ::std::option::Option::Some(v);
    }

    // optional int32 nattype = 5;


    pub fn get_nattype(&self) -> i32 {
        self.nattype.unwrap_or(0)
    }
    pub fn clear_nattype(&mut self) {
        self.nattype = ::std::option::Option::None;
    }

    pub fn has_nattype(&self) -> bool {
        self.nattype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nattype(&mut self, v: i32) {
        self.nattype = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_recv = 6;


    pub fn get_bytes_recv(&self) -> i32 {
        self.bytes_recv.unwrap_or(0)
    }
    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = ::std::option::Option::None;
    }

    pub fn has_bytes_recv(&self) -> bool {
        self.bytes_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: i32) {
        self.bytes_recv = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_sent = 7;


    pub fn get_bytes_sent(&self) -> i32 {
        self.bytes_sent.unwrap_or(0)
    }
    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = ::std::option::Option::None;
    }

    pub fn has_bytes_sent(&self) -> bool {
        self.bytes_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: i32) {
        self.bytes_sent = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_sent_relay = 8;


    pub fn get_bytes_sent_relay(&self) -> i32 {
        self.bytes_sent_relay.unwrap_or(0)
    }
    pub fn clear_bytes_sent_relay(&mut self) {
        self.bytes_sent_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_sent_relay(&self) -> bool {
        self.bytes_sent_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent_relay(&mut self, v: i32) {
        self.bytes_sent_relay = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_recv_relay = 9;


    pub fn get_bytes_recv_relay(&self) -> i32 {
        self.bytes_recv_relay.unwrap_or(0)
    }
    pub fn clear_bytes_recv_relay(&mut self) {
        self.bytes_recv_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_recv_relay(&self) -> bool {
        self.bytes_recv_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv_relay(&mut self, v: i32) {
        self.bytes_recv_relay = ::std::option::Option::Some(v);
    }

    // optional int32 time_to_connect_ms = 10;


    pub fn get_time_to_connect_ms(&self) -> i32 {
        self.time_to_connect_ms.unwrap_or(0)
    }
    pub fn clear_time_to_connect_ms(&mut self) {
        self.time_to_connect_ms = ::std::option::Option::None;
    }

    pub fn has_time_to_connect_ms(&self) -> bool {
        self.time_to_connect_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_connect_ms(&mut self, v: i32) {
        self.time_to_connect_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUDSP2PSessionEnded {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_remote = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.session_length_sec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.session_error = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nattype = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bytes_recv = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bytes_sent = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bytes_sent_relay = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bytes_recv_relay = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.time_to_connect_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_remote {
            my_size += 9;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session_length_sec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session_error {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nattype {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_recv {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_sent {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_sent_relay {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_recv_relay {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_to_connect_ms {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_remote {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.session_length_sec {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.session_error {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.nattype {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.bytes_recv {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.bytes_sent {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.bytes_sent_relay {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.bytes_recv_relay {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.time_to_connect_ms {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUDSP2PSessionEnded {
        CMsgClientUDSP2PSessionEnded::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_remote",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.steamid_remote },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.steamid_remote },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "appid",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.appid },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "session_length_sec",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.session_length_sec },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.session_length_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "session_error",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.session_error },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.session_error },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "nattype",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.nattype },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.nattype },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bytes_recv",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_recv },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bytes_sent",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_sent },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bytes_sent_relay",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_sent_relay },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_sent_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bytes_recv_relay",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_recv_relay },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_recv_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "time_to_connect_ms",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.time_to_connect_ms },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.time_to_connect_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUDSP2PSessionEnded>(
                "CMsgClientUDSP2PSessionEnded",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUDSP2PSessionEnded {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUDSP2PSessionEnded> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUDSP2PSessionEnded::new)
    }
}

impl ::protobuf::Clear for CMsgClientUDSP2PSessionEnded {
    fn clear(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.session_length_sec = ::std::option::Option::None;
        self.session_error = ::std::option::Option::None;
        self.nattype = ::std::option::Option::None;
        self.bytes_recv = ::std::option::Option::None;
        self.bytes_sent = ::std::option::Option::None;
        self.bytes_sent_relay = ::std::option::Option::None;
        self.bytes_recv_relay = ::std::option::Option::None;
        self.time_to_connect_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUDSP2PSessionEnded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUDSP2PSessionEnded {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRegisterAuthTicketWithCM {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    client_instance_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterAuthTicketWithCM {
    fn default() -> &'a CMsgClientRegisterAuthTicketWithCM {
        <CMsgClientRegisterAuthTicketWithCM as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterAuthTicketWithCM {
    pub fn new() -> CMsgClientRegisterAuthTicketWithCM {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 3;


    pub fn get_ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket.set_default();
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 client_instance_id = 4;


    pub fn get_client_instance_id(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }
    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRegisterAuthTicketWithCM {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ticket)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.client_instance_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.client_instance_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.ticket.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.client_instance_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRegisterAuthTicketWithCM {
        CMsgClientRegisterAuthTicketWithCM::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgClientRegisterAuthTicketWithCM| { &m.protocol_version },
                |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.protocol_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ticket",
                |m: &CMsgClientRegisterAuthTicketWithCM| { &m.ticket },
                |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.ticket },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "client_instance_id",
                |m: &CMsgClientRegisterAuthTicketWithCM| { &m.client_instance_id },
                |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.client_instance_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRegisterAuthTicketWithCM>(
                "CMsgClientRegisterAuthTicketWithCM",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRegisterAuthTicketWithCM {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRegisterAuthTicketWithCM> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRegisterAuthTicketWithCM::new)
    }
}

impl ::protobuf::Clear for CMsgClientRegisterAuthTicketWithCM {
    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.ticket.clear();
        self.client_instance_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRegisterAuthTicketWithCM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterAuthTicketWithCM {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientTicketAuthComplete {
    // message fields
    steam_id: ::std::option::Option<u64>,
    game_id: ::std::option::Option<u64>,
    estate: ::std::option::Option<u32>,
    eauth_session_response: ::std::option::Option<u32>,
    DEPRECATED_ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ticket_crc: ::std::option::Option<u32>,
    ticket_sequence: ::std::option::Option<u32>,
    owner_steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientTicketAuthComplete {
    fn default() -> &'a CMsgClientTicketAuthComplete {
        <CMsgClientTicketAuthComplete as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientTicketAuthComplete {
    pub fn new() -> CMsgClientTicketAuthComplete {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_id = 2;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 estate = 3;


    pub fn get_estate(&self) -> u32 {
        self.estate.unwrap_or(0)
    }
    pub fn clear_estate(&mut self) {
        self.estate = ::std::option::Option::None;
    }

    pub fn has_estate(&self) -> bool {
        self.estate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estate(&mut self, v: u32) {
        self.estate = ::std::option::Option::Some(v);
    }

    // optional uint32 eauth_session_response = 4;


    pub fn get_eauth_session_response(&self) -> u32 {
        self.eauth_session_response.unwrap_or(0)
    }
    pub fn clear_eauth_session_response(&mut self) {
        self.eauth_session_response = ::std::option::Option::None;
    }

    pub fn has_eauth_session_response(&self) -> bool {
        self.eauth_session_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eauth_session_response(&mut self, v: u32) {
        self.eauth_session_response = ::std::option::Option::Some(v);
    }

    // optional bytes DEPRECATED_ticket = 5;


    pub fn get_DEPRECATED_ticket(&self) -> &[u8] {
        match self.DEPRECATED_ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_DEPRECATED_ticket(&mut self) {
        self.DEPRECATED_ticket.clear();
    }

    pub fn has_DEPRECATED_ticket(&self) -> bool {
        self.DEPRECATED_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DEPRECATED_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.DEPRECATED_ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DEPRECATED_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.DEPRECATED_ticket.is_none() {
            self.DEPRECATED_ticket.set_default();
        }
        self.DEPRECATED_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_DEPRECATED_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.DEPRECATED_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ticket_crc = 6;


    pub fn get_ticket_crc(&self) -> u32 {
        self.ticket_crc.unwrap_or(0)
    }
    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc = ::std::option::Option::None;
    }

    pub fn has_ticket_crc(&self) -> bool {
        self.ticket_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: u32) {
        self.ticket_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 ticket_sequence = 7;


    pub fn get_ticket_sequence(&self) -> u32 {
        self.ticket_sequence.unwrap_or(0)
    }
    pub fn clear_ticket_sequence(&mut self) {
        self.ticket_sequence = ::std::option::Option::None;
    }

    pub fn has_ticket_sequence(&self) -> bool {
        self.ticket_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_sequence(&mut self, v: u32) {
        self.ticket_sequence = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steam_id = 8;


    pub fn get_owner_steam_id(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }
    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientTicketAuthComplete {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.estate = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eauth_session_response = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.DEPRECATED_ticket)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ticket_crc = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ticket_sequence = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.owner_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.estate {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eauth_session_response {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.DEPRECATED_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.ticket_crc {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ticket_sequence {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.estate {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.eauth_session_response {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.DEPRECATED_ticket.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.ticket_crc {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ticket_sequence {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.owner_steam_id {
            os.write_fixed64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientTicketAuthComplete {
        CMsgClientTicketAuthComplete::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgClientTicketAuthComplete| { &m.steam_id },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_id",
                |m: &CMsgClientTicketAuthComplete| { &m.game_id },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "estate",
                |m: &CMsgClientTicketAuthComplete| { &m.estate },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.estate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eauth_session_response",
                |m: &CMsgClientTicketAuthComplete| { &m.eauth_session_response },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.eauth_session_response },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "DEPRECATED_ticket",
                |m: &CMsgClientTicketAuthComplete| { &m.DEPRECATED_ticket },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.DEPRECATED_ticket },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ticket_crc",
                |m: &CMsgClientTicketAuthComplete| { &m.ticket_crc },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.ticket_crc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ticket_sequence",
                |m: &CMsgClientTicketAuthComplete| { &m.ticket_sequence },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.ticket_sequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "owner_steam_id",
                |m: &CMsgClientTicketAuthComplete| { &m.owner_steam_id },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.owner_steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientTicketAuthComplete>(
                "CMsgClientTicketAuthComplete",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientTicketAuthComplete {
        static instance: ::protobuf::rt::LazyV2<CMsgClientTicketAuthComplete> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientTicketAuthComplete::new)
    }
}

impl ::protobuf::Clear for CMsgClientTicketAuthComplete {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.estate = ::std::option::Option::None;
        self.eauth_session_response = ::std::option::Option::None;
        self.DEPRECATED_ticket.clear();
        self.ticket_crc = ::std::option::Option::None;
        self.ticket_sequence = ::std::option::Option::None;
        self.owner_steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientTicketAuthComplete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientTicketAuthComplete {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCMList {
    // message fields
    pub cm_addresses: ::std::vec::Vec<u32>,
    pub cm_ports: ::std::vec::Vec<u32>,
    pub cm_websocket_addresses: ::protobuf::RepeatedField<::std::string::String>,
    percent_default_to_websocket: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCMList {
    fn default() -> &'a CMsgClientCMList {
        <CMsgClientCMList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCMList {
    pub fn new() -> CMsgClientCMList {
        ::std::default::Default::default()
    }

    // repeated uint32 cm_addresses = 1;


    pub fn get_cm_addresses(&self) -> &[u32] {
        &self.cm_addresses
    }
    pub fn clear_cm_addresses(&mut self) {
        self.cm_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_cm_addresses(&mut self, v: ::std::vec::Vec<u32>) {
        self.cm_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cm_addresses(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.cm_addresses
    }

    // Take field
    pub fn take_cm_addresses(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.cm_addresses, ::std::vec::Vec::new())
    }

    // repeated uint32 cm_ports = 2;


    pub fn get_cm_ports(&self) -> &[u32] {
        &self.cm_ports
    }
    pub fn clear_cm_ports(&mut self) {
        self.cm_ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_cm_ports(&mut self, v: ::std::vec::Vec<u32>) {
        self.cm_ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cm_ports(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.cm_ports
    }

    // Take field
    pub fn take_cm_ports(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.cm_ports, ::std::vec::Vec::new())
    }

    // repeated string cm_websocket_addresses = 3;


    pub fn get_cm_websocket_addresses(&self) -> &[::std::string::String] {
        &self.cm_websocket_addresses
    }
    pub fn clear_cm_websocket_addresses(&mut self) {
        self.cm_websocket_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_cm_websocket_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cm_websocket_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cm_websocket_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cm_websocket_addresses
    }

    // Take field
    pub fn take_cm_websocket_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cm_websocket_addresses, ::protobuf::RepeatedField::new())
    }

    // optional uint32 percent_default_to_websocket = 4;


    pub fn get_percent_default_to_websocket(&self) -> u32 {
        self.percent_default_to_websocket.unwrap_or(0)
    }
    pub fn clear_percent_default_to_websocket(&mut self) {
        self.percent_default_to_websocket = ::std::option::Option::None;
    }

    pub fn has_percent_default_to_websocket(&self) -> bool {
        self.percent_default_to_websocket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percent_default_to_websocket(&mut self, v: u32) {
        self.percent_default_to_websocket = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCMList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.cm_addresses)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.cm_ports)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cm_websocket_addresses)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.percent_default_to_websocket = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cm_addresses {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.cm_ports {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.cm_websocket_addresses {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.percent_default_to_websocket {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cm_addresses {
            os.write_uint32(1, *v)?;
        };
        for v in &self.cm_ports {
            os.write_uint32(2, *v)?;
        };
        for v in &self.cm_websocket_addresses {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.percent_default_to_websocket {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCMList {
        CMsgClientCMList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cm_addresses",
                |m: &CMsgClientCMList| { &m.cm_addresses },
                |m: &mut CMsgClientCMList| { &mut m.cm_addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cm_ports",
                |m: &CMsgClientCMList| { &m.cm_ports },
                |m: &mut CMsgClientCMList| { &mut m.cm_ports },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cm_websocket_addresses",
                |m: &CMsgClientCMList| { &m.cm_websocket_addresses },
                |m: &mut CMsgClientCMList| { &mut m.cm_websocket_addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "percent_default_to_websocket",
                |m: &CMsgClientCMList| { &m.percent_default_to_websocket },
                |m: &mut CMsgClientCMList| { &mut m.percent_default_to_websocket },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientCMList>(
                "CMsgClientCMList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCMList {
        static instance: ::protobuf::rt::LazyV2<CMsgClientCMList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientCMList::new)
    }
}

impl ::protobuf::Clear for CMsgClientCMList {
    fn clear(&mut self) {
        self.cm_addresses.clear();
        self.cm_ports.clear();
        self.cm_websocket_addresses.clear();
        self.percent_default_to_websocket = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCMList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCMList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientP2PConnectionInfo {
    // message fields
    steam_id_dest: ::std::option::Option<u64>,
    steam_id_src: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    candidate: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    connection_id_src: ::std::option::Option<u64>,
    rendezvous: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientP2PConnectionInfo {
    fn default() -> &'a CMsgClientP2PConnectionInfo {
        <CMsgClientP2PConnectionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientP2PConnectionInfo {
    pub fn new() -> CMsgClientP2PConnectionInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;


    pub fn get_steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }
    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;


    pub fn get_steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }
    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes candidate = 4;


    pub fn get_candidate(&self) -> &[u8] {
        match self.candidate.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::vec::Vec<u8>) {
        self.candidate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.candidate.is_none() {
            self.candidate.set_default();
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::vec::Vec<u8> {
        self.candidate.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 connection_id_src = 5;


    pub fn get_connection_id_src(&self) -> u64 {
        self.connection_id_src.unwrap_or(0)
    }
    pub fn clear_connection_id_src(&mut self) {
        self.connection_id_src = ::std::option::Option::None;
    }

    pub fn has_connection_id_src(&self) -> bool {
        self.connection_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id_src(&mut self, v: u64) {
        self.connection_id_src = ::std::option::Option::Some(v);
    }

    // optional bytes rendezvous = 6;


    pub fn get_rendezvous(&self) -> &[u8] {
        match self.rendezvous.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_rendezvous(&mut self) {
        self.rendezvous.clear();
    }

    pub fn has_rendezvous(&self) -> bool {
        self.rendezvous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rendezvous(&mut self, v: ::std::vec::Vec<u8>) {
        self.rendezvous = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rendezvous(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rendezvous.is_none() {
            self.rendezvous.set_default();
        }
        self.rendezvous.as_mut().unwrap()
    }

    // Take field
    pub fn take_rendezvous(&mut self) -> ::std::vec::Vec<u8> {
        self.rendezvous.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientP2PConnectionInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_dest = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_src = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.candidate)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.connection_id_src = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rendezvous)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.candidate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.connection_id_src {
            my_size += 9;
        }
        if let Some(ref v) = self.rendezvous.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.candidate.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.connection_id_src {
            os.write_fixed64(5, v)?;
        }
        if let Some(ref v) = self.rendezvous.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientP2PConnectionInfo {
        CMsgClientP2PConnectionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_dest",
                |m: &CMsgClientP2PConnectionInfo| { &m.steam_id_dest },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.steam_id_dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_src",
                |m: &CMsgClientP2PConnectionInfo| { &m.steam_id_src },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.steam_id_src },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientP2PConnectionInfo| { &m.app_id },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "candidate",
                |m: &CMsgClientP2PConnectionInfo| { &m.candidate },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.candidate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "connection_id_src",
                |m: &CMsgClientP2PConnectionInfo| { &m.connection_id_src },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.connection_id_src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rendezvous",
                |m: &CMsgClientP2PConnectionInfo| { &m.rendezvous },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.rendezvous },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientP2PConnectionInfo>(
                "CMsgClientP2PConnectionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientP2PConnectionInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientP2PConnectionInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientP2PConnectionInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientP2PConnectionInfo {
    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.candidate.clear();
        self.connection_id_src = ::std::option::Option::None;
        self.rendezvous.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientP2PConnectionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientP2PConnectionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientP2PConnectionFailInfo {
    // message fields
    steam_id_dest: ::std::option::Option<u64>,
    steam_id_src: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    ep2p_session_error: ::std::option::Option<u32>,
    connection_id_dest: ::std::option::Option<u64>,
    close_reason: ::std::option::Option<u32>,
    close_message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientP2PConnectionFailInfo {
    fn default() -> &'a CMsgClientP2PConnectionFailInfo {
        <CMsgClientP2PConnectionFailInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientP2PConnectionFailInfo {
    pub fn new() -> CMsgClientP2PConnectionFailInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;


    pub fn get_steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }
    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;


    pub fn get_steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }
    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ep2p_session_error = 4;


    pub fn get_ep2p_session_error(&self) -> u32 {
        self.ep2p_session_error.unwrap_or(0)
    }
    pub fn clear_ep2p_session_error(&mut self) {
        self.ep2p_session_error = ::std::option::Option::None;
    }

    pub fn has_ep2p_session_error(&self) -> bool {
        self.ep2p_session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ep2p_session_error(&mut self, v: u32) {
        self.ep2p_session_error = ::std::option::Option::Some(v);
    }

    // optional fixed64 connection_id_dest = 5;


    pub fn get_connection_id_dest(&self) -> u64 {
        self.connection_id_dest.unwrap_or(0)
    }
    pub fn clear_connection_id_dest(&mut self) {
        self.connection_id_dest = ::std::option::Option::None;
    }

    pub fn has_connection_id_dest(&self) -> bool {
        self.connection_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id_dest(&mut self, v: u64) {
        self.connection_id_dest = ::std::option::Option::Some(v);
    }

    // optional uint32 close_reason = 7;


    pub fn get_close_reason(&self) -> u32 {
        self.close_reason.unwrap_or(0)
    }
    pub fn clear_close_reason(&mut self) {
        self.close_reason = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        self.close_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: u32) {
        self.close_reason = ::std::option::Option::Some(v);
    }

    // optional string close_message = 8;


    pub fn get_close_message(&self) -> &str {
        match self.close_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_close_message(&mut self) {
        self.close_message.clear();
    }

    pub fn has_close_message(&self) -> bool {
        self.close_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_message(&mut self, v: ::std::string::String) {
        self.close_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_message(&mut self) -> &mut ::std::string::String {
        if self.close_message.is_none() {
            self.close_message.set_default();
        }
        self.close_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_message(&mut self) -> ::std::string::String {
        self.close_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientP2PConnectionFailInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_dest = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_src = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ep2p_session_error = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.connection_id_dest = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.close_reason = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.close_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ep2p_session_error {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connection_id_dest {
            my_size += 9;
        }
        if let Some(v) = self.close_reason {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.close_message.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ep2p_session_error {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.connection_id_dest {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.close_reason {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.close_message.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientP2PConnectionFailInfo {
        CMsgClientP2PConnectionFailInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_dest",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.steam_id_dest },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.steam_id_dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_src",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.steam_id_src },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.steam_id_src },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.app_id },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ep2p_session_error",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.ep2p_session_error },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.ep2p_session_error },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "connection_id_dest",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.connection_id_dest },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.connection_id_dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "close_reason",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.close_reason },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.close_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "close_message",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.close_message },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.close_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientP2PConnectionFailInfo>(
                "CMsgClientP2PConnectionFailInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientP2PConnectionFailInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientP2PConnectionFailInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientP2PConnectionFailInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientP2PConnectionFailInfo {
    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.ep2p_session_error = ::std::option::Option::None;
        self.connection_id_dest = ::std::option::Option::None;
        self.close_reason = ::std::option::Option::None;
        self.close_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientP2PConnectionFailInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientP2PConnectionFailInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientNetworkingCertRequest {
    // message fields
    key_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingCertRequest {
    fn default() -> &'a CMsgClientNetworkingCertRequest {
        <CMsgClientNetworkingCertRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingCertRequest {
    pub fn new() -> CMsgClientNetworkingCertRequest {
        ::std::default::Default::default()
    }

    // optional bytes key_data = 2;


    pub fn get_key_data(&self) -> &[u8] {
        match self.key_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key_data(&mut self) {
        self.key_data.clear();
    }

    pub fn has_key_data(&self) -> bool {
        self.key_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_data.is_none() {
            self.key_data.set_default();
        }
        self.key_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::std::vec::Vec<u8> {
        self.key_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 app_id = 3;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientNetworkingCertRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key_data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientNetworkingCertRequest {
        CMsgClientNetworkingCertRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key_data",
                |m: &CMsgClientNetworkingCertRequest| { &m.key_data },
                |m: &mut CMsgClientNetworkingCertRequest| { &mut m.key_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientNetworkingCertRequest| { &m.app_id },
                |m: &mut CMsgClientNetworkingCertRequest| { &mut m.app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientNetworkingCertRequest>(
                "CMsgClientNetworkingCertRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientNetworkingCertRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientNetworkingCertRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientNetworkingCertRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientNetworkingCertRequest {
    fn clear(&mut self) {
        self.key_data.clear();
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientNetworkingCertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingCertRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientNetworkingCertReply {
    // message fields
    cert: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ca_key_id: ::std::option::Option<u64>,
    ca_signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingCertReply {
    fn default() -> &'a CMsgClientNetworkingCertReply {
        <CMsgClientNetworkingCertReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingCertReply {
    pub fn new() -> CMsgClientNetworkingCertReply {
        ::std::default::Default::default()
    }

    // optional bytes cert = 4;


    pub fn get_cert(&self) -> &[u8] {
        match self.cert.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::std::vec::Vec<u8>) {
        self.cert = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> ::std::vec::Vec<u8> {
        self.cert.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 ca_key_id = 5;


    pub fn get_ca_key_id(&self) -> u64 {
        self.ca_key_id.unwrap_or(0)
    }
    pub fn clear_ca_key_id(&mut self) {
        self.ca_key_id = ::std::option::Option::None;
    }

    pub fn has_ca_key_id(&self) -> bool {
        self.ca_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ca_key_id(&mut self, v: u64) {
        self.ca_key_id = ::std::option::Option::Some(v);
    }

    // optional bytes ca_signature = 6;


    pub fn get_ca_signature(&self) -> &[u8] {
        match self.ca_signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ca_signature(&mut self) {
        self.ca_signature.clear();
    }

    pub fn has_ca_signature(&self) -> bool {
        self.ca_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ca_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.ca_signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ca_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ca_signature.is_none() {
            self.ca_signature.set_default();
        }
        self.ca_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_ca_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.ca_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientNetworkingCertReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.cert)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.ca_key_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ca_signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cert.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ca_key_id {
            my_size += 9;
        }
        if let Some(ref v) = self.ca_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cert.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.ca_key_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(ref v) = self.ca_signature.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientNetworkingCertReply {
        CMsgClientNetworkingCertReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "cert",
                |m: &CMsgClientNetworkingCertReply| { &m.cert },
                |m: &mut CMsgClientNetworkingCertReply| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "ca_key_id",
                |m: &CMsgClientNetworkingCertReply| { &m.ca_key_id },
                |m: &mut CMsgClientNetworkingCertReply| { &mut m.ca_key_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ca_signature",
                |m: &CMsgClientNetworkingCertReply| { &m.ca_signature },
                |m: &mut CMsgClientNetworkingCertReply| { &mut m.ca_signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientNetworkingCertReply>(
                "CMsgClientNetworkingCertReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientNetworkingCertReply {
        static instance: ::protobuf::rt::LazyV2<CMsgClientNetworkingCertReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientNetworkingCertReply::new)
    }
}

impl ::protobuf::Clear for CMsgClientNetworkingCertReply {
    fn clear(&mut self) {
        self.cert.clear();
        self.ca_key_id = ::std::option::Option::None;
        self.ca_signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientNetworkingCertReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingCertReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientNetworkingMobileCertRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingMobileCertRequest {
    fn default() -> &'a CMsgClientNetworkingMobileCertRequest {
        <CMsgClientNetworkingMobileCertRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingMobileCertRequest {
    pub fn new() -> CMsgClientNetworkingMobileCertRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientNetworkingMobileCertRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientNetworkingMobileCertRequest {
        CMsgClientNetworkingMobileCertRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientNetworkingMobileCertRequest| { &m.app_id },
                |m: &mut CMsgClientNetworkingMobileCertRequest| { &mut m.app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientNetworkingMobileCertRequest>(
                "CMsgClientNetworkingMobileCertRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientNetworkingMobileCertRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientNetworkingMobileCertRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientNetworkingMobileCertRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientNetworkingMobileCertRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientNetworkingMobileCertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingMobileCertRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientNetworkingMobileCertReply {
    // message fields
    encoded_cert: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingMobileCertReply {
    fn default() -> &'a CMsgClientNetworkingMobileCertReply {
        <CMsgClientNetworkingMobileCertReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingMobileCertReply {
    pub fn new() -> CMsgClientNetworkingMobileCertReply {
        ::std::default::Default::default()
    }

    // optional string encoded_cert = 1;


    pub fn get_encoded_cert(&self) -> &str {
        match self.encoded_cert.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_encoded_cert(&mut self) {
        self.encoded_cert.clear();
    }

    pub fn has_encoded_cert(&self) -> bool {
        self.encoded_cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoded_cert(&mut self, v: ::std::string::String) {
        self.encoded_cert = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoded_cert(&mut self) -> &mut ::std::string::String {
        if self.encoded_cert.is_none() {
            self.encoded_cert.set_default();
        }
        self.encoded_cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_encoded_cert(&mut self) -> ::std::string::String {
        self.encoded_cert.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientNetworkingMobileCertReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encoded_cert)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.encoded_cert.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.encoded_cert.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientNetworkingMobileCertReply {
        CMsgClientNetworkingMobileCertReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encoded_cert",
                |m: &CMsgClientNetworkingMobileCertReply| { &m.encoded_cert },
                |m: &mut CMsgClientNetworkingMobileCertReply| { &mut m.encoded_cert },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientNetworkingMobileCertReply>(
                "CMsgClientNetworkingMobileCertReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientNetworkingMobileCertReply {
        static instance: ::protobuf::rt::LazyV2<CMsgClientNetworkingMobileCertReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientNetworkingMobileCertReply::new)
    }
}

impl ::protobuf::Clear for CMsgClientNetworkingMobileCertReply {
    fn clear(&mut self) {
        self.encoded_cert.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientNetworkingMobileCertReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingMobileCertReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetAppOwnershipTicket {
    // message fields
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAppOwnershipTicket {
    fn default() -> &'a CMsgClientGetAppOwnershipTicket {
        <CMsgClientGetAppOwnershipTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAppOwnershipTicket {
    pub fn new() -> CMsgClientGetAppOwnershipTicket {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetAppOwnershipTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetAppOwnershipTicket {
        CMsgClientGetAppOwnershipTicket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientGetAppOwnershipTicket| { &m.app_id },
                |m: &mut CMsgClientGetAppOwnershipTicket| { &mut m.app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetAppOwnershipTicket>(
                "CMsgClientGetAppOwnershipTicket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetAppOwnershipTicket {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetAppOwnershipTicket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetAppOwnershipTicket::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetAppOwnershipTicket {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetAppOwnershipTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAppOwnershipTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetAppOwnershipTicketResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAppOwnershipTicketResponse {
    fn default() -> &'a CMsgClientGetAppOwnershipTicketResponse {
        <CMsgClientGetAppOwnershipTicketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAppOwnershipTicketResponse {
    pub fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 3;


    pub fn get_ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket.set_default();
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientGetAppOwnershipTicketResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ticket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.ticket.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        CMsgClientGetAppOwnershipTicketResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.eresult },
                |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.app_id },
                |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ticket",
                |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.ticket },
                |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.ticket },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetAppOwnershipTicketResponse>(
                "CMsgClientGetAppOwnershipTicketResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetAppOwnershipTicketResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetAppOwnershipTicketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetAppOwnershipTicketResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetAppOwnershipTicketResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.ticket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetAppOwnershipTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAppOwnershipTicketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSessionToken {
    // message fields
    token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSessionToken {
    fn default() -> &'a CMsgClientSessionToken {
        <CMsgClientSessionToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSessionToken {
    pub fn new() -> CMsgClientSessionToken {
        ::std::default::Default::default()
    }

    // optional uint64 token = 1;


    pub fn get_token(&self) -> u64 {
        self.token.unwrap_or(0)
    }
    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u64) {
        self.token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSessionToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.token {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSessionToken {
        CMsgClientSessionToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "token",
                |m: &CMsgClientSessionToken| { &m.token },
                |m: &mut CMsgClientSessionToken| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientSessionToken>(
                "CMsgClientSessionToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSessionToken {
        static instance: ::protobuf::rt::LazyV2<CMsgClientSessionToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientSessionToken::new)
    }
}

impl ::protobuf::Clear for CMsgClientSessionToken {
    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSessionToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSessionToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGameConnectTokens {
    // message fields
    max_tokens_to_keep: ::std::option::Option<u32>,
    pub tokens: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGameConnectTokens {
    fn default() -> &'a CMsgClientGameConnectTokens {
        <CMsgClientGameConnectTokens as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGameConnectTokens {
    pub fn new() -> CMsgClientGameConnectTokens {
        ::std::default::Default::default()
    }

    // optional uint32 max_tokens_to_keep = 1;


    pub fn get_max_tokens_to_keep(&self) -> u32 {
        self.max_tokens_to_keep.unwrap_or(10u32)
    }
    pub fn clear_max_tokens_to_keep(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
    }

    pub fn has_max_tokens_to_keep(&self) -> bool {
        self.max_tokens_to_keep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_tokens_to_keep(&mut self, v: u32) {
        self.max_tokens_to_keep = ::std::option::Option::Some(v);
    }

    // repeated bytes tokens = 2;


    pub fn get_tokens(&self) -> &[::std::vec::Vec<u8>] {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientGameConnectTokens {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_tokens_to_keep = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.max_tokens_to_keep {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tokens {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.max_tokens_to_keep {
            os.write_uint32(1, v)?;
        }
        for v in &self.tokens {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGameConnectTokens {
        CMsgClientGameConnectTokens::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_tokens_to_keep",
                |m: &CMsgClientGameConnectTokens| { &m.max_tokens_to_keep },
                |m: &mut CMsgClientGameConnectTokens| { &mut m.max_tokens_to_keep },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tokens",
                |m: &CMsgClientGameConnectTokens| { &m.tokens },
                |m: &mut CMsgClientGameConnectTokens| { &mut m.tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGameConnectTokens>(
                "CMsgClientGameConnectTokens",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGameConnectTokens {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGameConnectTokens> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGameConnectTokens::new)
    }
}

impl ::protobuf::Clear for CMsgClientGameConnectTokens {
    fn clear(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
        self.tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGameConnectTokens {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGameConnectTokens {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSServerType {
    // message fields
    app_id_served: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    deprecated_game_ip_address: ::std::option::Option<u32>,
    game_port: ::std::option::Option<u32>,
    game_dir: ::protobuf::SingularField<::std::string::String>,
    game_version: ::protobuf::SingularField<::std::string::String>,
    game_query_port: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSServerType {
    fn default() -> &'a CMsgGSServerType {
        <CMsgGSServerType as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSServerType {
    pub fn new() -> CMsgGSServerType {
        ::std::default::Default::default()
    }

    // optional uint32 app_id_served = 1;


    pub fn get_app_id_served(&self) -> u32 {
        self.app_id_served.unwrap_or(0)
    }
    pub fn clear_app_id_served(&mut self) {
        self.app_id_served = ::std::option::Option::None;
    }

    pub fn has_app_id_served(&self) -> bool {
        self.app_id_served.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id_served(&mut self, v: u32) {
        self.app_id_served = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 2;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_ip_address = 3;


    pub fn get_deprecated_game_ip_address(&self) -> u32 {
        self.deprecated_game_ip_address.unwrap_or(0)
    }
    pub fn clear_deprecated_game_ip_address(&mut self) {
        self.deprecated_game_ip_address = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_ip_address(&self) -> bool {
        self.deprecated_game_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_ip_address(&mut self, v: u32) {
        self.deprecated_game_ip_address = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;


    pub fn get_game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }
    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional string game_dir = 5;


    pub fn get_game_dir(&self) -> &str {
        match self.game_dir.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_dir(&mut self) {
        self.game_dir.clear();
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: ::std::string::String) {
        self.game_dir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir(&mut self) -> &mut ::std::string::String {
        if self.game_dir.is_none() {
            self.game_dir.set_default();
        }
        self.game_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_dir(&mut self) -> ::std::string::String {
        self.game_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_version = 6;


    pub fn get_game_version(&self) -> &str {
        match self.game_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_version(&mut self) {
        self.game_version.clear();
    }

    pub fn has_game_version(&self) -> bool {
        self.game_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_version(&mut self, v: ::std::string::String) {
        self.game_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_version(&mut self) -> &mut ::std::string::String {
        if self.game_version.is_none() {
            self.game_version.set_default();
        }
        self.game_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_version(&mut self) -> ::std::string::String {
        self.game_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 game_query_port = 7;


    pub fn get_game_query_port(&self) -> u32 {
        self.game_query_port.unwrap_or(0)
    }
    pub fn clear_game_query_port(&mut self) {
        self.game_query_port = ::std::option::Option::None;
    }

    pub fn has_game_query_port(&self) -> bool {
        self.game_query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_query_port(&mut self, v: u32) {
        self.game_query_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSServerType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id_served = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_game_ip_address = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_dir)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_version)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_query_port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id_served {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deprecated_game_ip_address {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_dir.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.game_version.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.game_query_port {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id_served {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deprecated_game_ip_address {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.game_dir.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.game_version.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.game_query_port {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSServerType {
        CMsgGSServerType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id_served",
                |m: &CMsgGSServerType| { &m.app_id_served },
                |m: &mut CMsgGSServerType| { &mut m.app_id_served },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgGSServerType| { &m.flags },
                |m: &mut CMsgGSServerType| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_game_ip_address",
                |m: &CMsgGSServerType| { &m.deprecated_game_ip_address },
                |m: &mut CMsgGSServerType| { &mut m.deprecated_game_ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_port",
                |m: &CMsgGSServerType| { &m.game_port },
                |m: &mut CMsgGSServerType| { &mut m.game_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_dir",
                |m: &CMsgGSServerType| { &m.game_dir },
                |m: &mut CMsgGSServerType| { &mut m.game_dir },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_version",
                |m: &CMsgGSServerType| { &m.game_version },
                |m: &mut CMsgGSServerType| { &mut m.game_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_query_port",
                |m: &CMsgGSServerType| { &m.game_query_port },
                |m: &mut CMsgGSServerType| { &mut m.game_query_port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSServerType>(
                "CMsgGSServerType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSServerType {
        static instance: ::protobuf::rt::LazyV2<CMsgGSServerType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSServerType::new)
    }
}

impl ::protobuf::Clear for CMsgGSServerType {
    fn clear(&mut self) {
        self.app_id_served = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.deprecated_game_ip_address = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.game_dir.clear();
        self.game_version.clear();
        self.game_query_port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSServerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSServerType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSStatusReply {
    // message fields
    is_secure: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSStatusReply {
    fn default() -> &'a CMsgGSStatusReply {
        <CMsgGSStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSStatusReply {
    pub fn new() -> CMsgGSStatusReply {
        ::std::default::Default::default()
    }

    // optional bool is_secure = 1;


    pub fn get_is_secure(&self) -> bool {
        self.is_secure.unwrap_or(false)
    }
    pub fn clear_is_secure(&mut self) {
        self.is_secure = ::std::option::Option::None;
    }

    pub fn has_is_secure(&self) -> bool {
        self.is_secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_secure(&mut self, v: bool) {
        self.is_secure = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSStatusReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_secure = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_secure {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_secure {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSStatusReply {
        CMsgGSStatusReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_secure",
                |m: &CMsgGSStatusReply| { &m.is_secure },
                |m: &mut CMsgGSStatusReply| { &mut m.is_secure },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSStatusReply>(
                "CMsgGSStatusReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSStatusReply {
        static instance: ::protobuf::rt::LazyV2<CMsgGSStatusReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSStatusReply::new)
    }
}

impl ::protobuf::Clear for CMsgGSStatusReply {
    fn clear(&mut self) {
        self.is_secure = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSStatusReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSStatusReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSPlayerList {
    // message fields
    pub players: ::protobuf::RepeatedField<CMsgGSPlayerList_Player>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSPlayerList {
    fn default() -> &'a CMsgGSPlayerList {
        <CMsgGSPlayerList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSPlayerList {
    pub fn new() -> CMsgGSPlayerList {
        ::std::default::Default::default()
    }

    // repeated .CMsgGSPlayerList.Player players = 1;


    pub fn get_players(&self) -> &[CMsgGSPlayerList_Player] {
        &self.players
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgGSPlayerList_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGSPlayerList_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgGSPlayerList_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGSPlayerList {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSPlayerList {
        CMsgGSPlayerList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGSPlayerList_Player>>(
                "players",
                |m: &CMsgGSPlayerList| { &m.players },
                |m: &mut CMsgGSPlayerList| { &mut m.players },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSPlayerList>(
                "CMsgGSPlayerList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSPlayerList {
        static instance: ::protobuf::rt::LazyV2<CMsgGSPlayerList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSPlayerList::new)
    }
}

impl ::protobuf::Clear for CMsgGSPlayerList {
    fn clear(&mut self) {
        self.players.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSPlayerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSPlayerList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSPlayerList_Player {
    // message fields
    steam_id: ::std::option::Option<u64>,
    deprecated_public_ip: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub public_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSPlayerList_Player {
    fn default() -> &'a CMsgGSPlayerList_Player {
        <CMsgGSPlayerList_Player as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSPlayerList_Player {
    pub fn new() -> CMsgGSPlayerList_Player {
        ::std::default::Default::default()
    }

    // optional uint64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 2;


    pub fn get_deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }
    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes token = 3;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .CMsgIPAddress public_ip = 4;


    pub fn get_public_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.public_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_public_ip(&mut self) {
        self.public_ip.clear();
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.public_ip = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        if self.public_ip.is_none() {
            self.public_ip.set_default();
        }
        self.public_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.public_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }
}

impl ::protobuf::Message for CMsgGSPlayerList_Player {
    fn is_initialized(&self) -> bool {
        for v in &self.public_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_public_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.public_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.public_ip.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSPlayerList_Player {
        CMsgGSPlayerList_Player::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "steam_id",
                |m: &CMsgGSPlayerList_Player| { &m.steam_id },
                |m: &mut CMsgGSPlayerList_Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_public_ip",
                |m: &CMsgGSPlayerList_Player| { &m.deprecated_public_ip },
                |m: &mut CMsgGSPlayerList_Player| { &mut m.deprecated_public_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &CMsgGSPlayerList_Player| { &m.token },
                |m: &mut CMsgGSPlayerList_Player| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>>(
                "public_ip",
                |m: &CMsgGSPlayerList_Player| { &m.public_ip },
                |m: &mut CMsgGSPlayerList_Player| { &mut m.public_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSPlayerList_Player>(
                "CMsgGSPlayerList.Player",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSPlayerList_Player {
        static instance: ::protobuf::rt::LazyV2<CMsgGSPlayerList_Player> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSPlayerList_Player::new)
    }
}

impl ::protobuf::Clear for CMsgGSPlayerList_Player {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.token.clear();
        self.public_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSPlayerList_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSPlayerList_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSUserPlaying {
    // message fields
    steam_id: ::std::option::Option<u64>,
    deprecated_public_ip: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub public_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSUserPlaying {
    fn default() -> &'a CMsgGSUserPlaying {
        <CMsgGSUserPlaying as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSUserPlaying {
    pub fn new() -> CMsgGSUserPlaying {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 2;


    pub fn get_deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }
    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes token = 3;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .CMsgIPAddress public_ip = 4;


    pub fn get_public_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.public_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_public_ip(&mut self) {
        self.public_ip.clear();
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.public_ip = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        if self.public_ip.is_none() {
            self.public_ip.set_default();
        }
        self.public_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.public_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }
}

impl ::protobuf::Message for CMsgGSUserPlaying {
    fn is_initialized(&self) -> bool {
        for v in &self.public_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_public_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.public_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.public_ip.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSUserPlaying {
        CMsgGSUserPlaying::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGSUserPlaying| { &m.steam_id },
                |m: &mut CMsgGSUserPlaying| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_public_ip",
                |m: &CMsgGSUserPlaying| { &m.deprecated_public_ip },
                |m: &mut CMsgGSUserPlaying| { &mut m.deprecated_public_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &CMsgGSUserPlaying| { &m.token },
                |m: &mut CMsgGSUserPlaying| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>>(
                "public_ip",
                |m: &CMsgGSUserPlaying| { &m.public_ip },
                |m: &mut CMsgGSUserPlaying| { &mut m.public_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSUserPlaying>(
                "CMsgGSUserPlaying",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSUserPlaying {
        static instance: ::protobuf::rt::LazyV2<CMsgGSUserPlaying> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSUserPlaying::new)
    }
}

impl ::protobuf::Clear for CMsgGSUserPlaying {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.token.clear();
        self.public_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSUserPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSUserPlaying {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSDisconnectNotice {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSDisconnectNotice {
    fn default() -> &'a CMsgGSDisconnectNotice {
        <CMsgGSDisconnectNotice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSDisconnectNotice {
    pub fn new() -> CMsgGSDisconnectNotice {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSDisconnectNotice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSDisconnectNotice {
        CMsgGSDisconnectNotice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGSDisconnectNotice| { &m.steam_id },
                |m: &mut CMsgGSDisconnectNotice| { &mut m.steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSDisconnectNotice>(
                "CMsgGSDisconnectNotice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSDisconnectNotice {
        static instance: ::protobuf::rt::LazyV2<CMsgGSDisconnectNotice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSDisconnectNotice::new)
    }
}

impl ::protobuf::Clear for CMsgGSDisconnectNotice {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSDisconnectNotice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSDisconnectNotice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGamesPlayed {
    // message fields
    pub games_played: ::protobuf::RepeatedField<CMsgClientGamesPlayed_GamePlayed>,
    client_os_type: ::std::option::Option<u32>,
    cloud_gaming_platform: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGamesPlayed {
    fn default() -> &'a CMsgClientGamesPlayed {
        <CMsgClientGamesPlayed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGamesPlayed {
    pub fn new() -> CMsgClientGamesPlayed {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientGamesPlayed.GamePlayed games_played = 1;


    pub fn get_games_played(&self) -> &[CMsgClientGamesPlayed_GamePlayed] {
        &self.games_played
    }
    pub fn clear_games_played(&mut self) {
        self.games_played.clear();
    }

    // Param is passed by value, moved
    pub fn set_games_played(&mut self, v: ::protobuf::RepeatedField<CMsgClientGamesPlayed_GamePlayed>) {
        self.games_played = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games_played(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientGamesPlayed_GamePlayed> {
        &mut self.games_played
    }

    // Take field
    pub fn take_games_played(&mut self) -> ::protobuf::RepeatedField<CMsgClientGamesPlayed_GamePlayed> {
        ::std::mem::replace(&mut self.games_played, ::protobuf::RepeatedField::new())
    }

    // optional uint32 client_os_type = 2;


    pub fn get_client_os_type(&self) -> u32 {
        self.client_os_type.unwrap_or(0)
    }
    pub fn clear_client_os_type(&mut self) {
        self.client_os_type = ::std::option::Option::None;
    }

    pub fn has_client_os_type(&self) -> bool {
        self.client_os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_os_type(&mut self, v: u32) {
        self.client_os_type = ::std::option::Option::Some(v);
    }

    // optional uint32 cloud_gaming_platform = 3;


    pub fn get_cloud_gaming_platform(&self) -> u32 {
        self.cloud_gaming_platform.unwrap_or(0)
    }
    pub fn clear_cloud_gaming_platform(&mut self) {
        self.cloud_gaming_platform = ::std::option::Option::None;
    }

    pub fn has_cloud_gaming_platform(&self) -> bool {
        self.cloud_gaming_platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_gaming_platform(&mut self, v: u32) {
        self.cloud_gaming_platform = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGamesPlayed {
    fn is_initialized(&self) -> bool {
        for v in &self.games_played {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games_played)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_os_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cloud_gaming_platform = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.games_played {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.client_os_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cloud_gaming_platform {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.games_played {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.client_os_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cloud_gaming_platform {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGamesPlayed {
        CMsgClientGamesPlayed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientGamesPlayed_GamePlayed>>(
                "games_played",
                |m: &CMsgClientGamesPlayed| { &m.games_played },
                |m: &mut CMsgClientGamesPlayed| { &mut m.games_played },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_os_type",
                |m: &CMsgClientGamesPlayed| { &m.client_os_type },
                |m: &mut CMsgClientGamesPlayed| { &mut m.client_os_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cloud_gaming_platform",
                |m: &CMsgClientGamesPlayed| { &m.cloud_gaming_platform },
                |m: &mut CMsgClientGamesPlayed| { &mut m.cloud_gaming_platform },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGamesPlayed>(
                "CMsgClientGamesPlayed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGamesPlayed {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGamesPlayed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGamesPlayed::new)
    }
}

impl ::protobuf::Clear for CMsgClientGamesPlayed {
    fn clear(&mut self) {
        self.games_played.clear();
        self.client_os_type = ::std::option::Option::None;
        self.cloud_gaming_platform = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGamesPlayed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGamesPlayed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGamesPlayed_GamePlayed {
    // message fields
    steam_id_gs: ::std::option::Option<u64>,
    game_id: ::std::option::Option<u64>,
    deprecated_game_ip_address: ::std::option::Option<u32>,
    game_port: ::std::option::Option<u32>,
    is_secure: ::std::option::Option<bool>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    game_extra_info: ::protobuf::SingularField<::std::string::String>,
    game_data_blob: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    process_id: ::std::option::Option<u32>,
    streaming_provider_id: ::std::option::Option<u32>,
    game_flags: ::std::option::Option<u32>,
    owner_id: ::std::option::Option<u32>,
    vr_hmd_vendor: ::protobuf::SingularField<::std::string::String>,
    vr_hmd_model: ::protobuf::SingularField<::std::string::String>,
    launch_option_type: ::std::option::Option<u32>,
    primary_controller_type: ::std::option::Option<i32>,
    primary_steam_controller_serial: ::protobuf::SingularField<::std::string::String>,
    total_steam_controller_count: ::std::option::Option<u32>,
    total_non_steam_controller_count: ::std::option::Option<u32>,
    controller_workshop_file_id: ::std::option::Option<u64>,
    launch_source: ::std::option::Option<u32>,
    vr_hmd_runtime: ::std::option::Option<u32>,
    pub game_ip_address: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    controller_connection_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGamesPlayed_GamePlayed {
    fn default() -> &'a CMsgClientGamesPlayed_GamePlayed {
        <CMsgClientGamesPlayed_GamePlayed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGamesPlayed_GamePlayed {
    pub fn new() -> CMsgClientGamesPlayed_GamePlayed {
        ::std::default::Default::default()
    }

    // optional uint64 steam_id_gs = 1;


    pub fn get_steam_id_gs(&self) -> u64 {
        self.steam_id_gs.unwrap_or(0)
    }
    pub fn clear_steam_id_gs(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_steam_id_gs(&self) -> bool {
        self.steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_gs(&mut self, v: u64) {
        self.steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_id = 2;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_ip_address = 3;


    pub fn get_deprecated_game_ip_address(&self) -> u32 {
        self.deprecated_game_ip_address.unwrap_or(0)
    }
    pub fn clear_deprecated_game_ip_address(&mut self) {
        self.deprecated_game_ip_address = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_ip_address(&self) -> bool {
        self.deprecated_game_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_ip_address(&mut self, v: u32) {
        self.deprecated_game_ip_address = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;


    pub fn get_game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }
    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional bool is_secure = 5;


    pub fn get_is_secure(&self) -> bool {
        self.is_secure.unwrap_or(false)
    }
    pub fn clear_is_secure(&mut self) {
        self.is_secure = ::std::option::Option::None;
    }

    pub fn has_is_secure(&self) -> bool {
        self.is_secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_secure(&mut self, v: bool) {
        self.is_secure = ::std::option::Option::Some(v);
    }

    // optional bytes token = 6;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string game_extra_info = 7;


    pub fn get_game_extra_info(&self) -> &str {
        match self.game_extra_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_extra_info(&mut self) {
        self.game_extra_info.clear();
    }

    pub fn has_game_extra_info(&self) -> bool {
        self.game_extra_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_extra_info(&mut self, v: ::std::string::String) {
        self.game_extra_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_extra_info(&mut self) -> &mut ::std::string::String {
        if self.game_extra_info.is_none() {
            self.game_extra_info.set_default();
        }
        self.game_extra_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_extra_info(&mut self) -> ::std::string::String {
        self.game_extra_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes game_data_blob = 8;


    pub fn get_game_data_blob(&self) -> &[u8] {
        match self.game_data_blob.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_game_data_blob(&mut self) {
        self.game_data_blob.clear();
    }

    pub fn has_game_data_blob(&self) -> bool {
        self.game_data_blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data_blob = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data_blob.is_none() {
            self.game_data_blob.set_default();
        }
        self.game_data_blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data_blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 process_id = 9;


    pub fn get_process_id(&self) -> u32 {
        self.process_id.unwrap_or(0)
    }
    pub fn clear_process_id(&mut self) {
        self.process_id = ::std::option::Option::None;
    }

    pub fn has_process_id(&self) -> bool {
        self.process_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_id(&mut self, v: u32) {
        self.process_id = ::std::option::Option::Some(v);
    }

    // optional uint32 streaming_provider_id = 10;


    pub fn get_streaming_provider_id(&self) -> u32 {
        self.streaming_provider_id.unwrap_or(0)
    }
    pub fn clear_streaming_provider_id(&mut self) {
        self.streaming_provider_id = ::std::option::Option::None;
    }

    pub fn has_streaming_provider_id(&self) -> bool {
        self.streaming_provider_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streaming_provider_id(&mut self, v: u32) {
        self.streaming_provider_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_flags = 11;


    pub fn get_game_flags(&self) -> u32 {
        self.game_flags.unwrap_or(0)
    }
    pub fn clear_game_flags(&mut self) {
        self.game_flags = ::std::option::Option::None;
    }

    pub fn has_game_flags(&self) -> bool {
        self.game_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_flags(&mut self, v: u32) {
        self.game_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_id = 12;


    pub fn get_owner_id(&self) -> u32 {
        self.owner_id.unwrap_or(0)
    }
    pub fn clear_owner_id(&mut self) {
        self.owner_id = ::std::option::Option::None;
    }

    pub fn has_owner_id(&self) -> bool {
        self.owner_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: u32) {
        self.owner_id = ::std::option::Option::Some(v);
    }

    // optional string vr_hmd_vendor = 13;


    pub fn get_vr_hmd_vendor(&self) -> &str {
        match self.vr_hmd_vendor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_vr_hmd_vendor(&mut self) {
        self.vr_hmd_vendor.clear();
    }

    pub fn has_vr_hmd_vendor(&self) -> bool {
        self.vr_hmd_vendor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_hmd_vendor(&mut self, v: ::std::string::String) {
        self.vr_hmd_vendor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_hmd_vendor(&mut self) -> &mut ::std::string::String {
        if self.vr_hmd_vendor.is_none() {
            self.vr_hmd_vendor.set_default();
        }
        self.vr_hmd_vendor.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_hmd_vendor(&mut self) -> ::std::string::String {
        self.vr_hmd_vendor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string vr_hmd_model = 14;


    pub fn get_vr_hmd_model(&self) -> &str {
        match self.vr_hmd_model.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_vr_hmd_model(&mut self) {
        self.vr_hmd_model.clear();
    }

    pub fn has_vr_hmd_model(&self) -> bool {
        self.vr_hmd_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_hmd_model(&mut self, v: ::std::string::String) {
        self.vr_hmd_model = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_hmd_model(&mut self) -> &mut ::std::string::String {
        if self.vr_hmd_model.is_none() {
            self.vr_hmd_model.set_default();
        }
        self.vr_hmd_model.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_hmd_model(&mut self) -> ::std::string::String {
        self.vr_hmd_model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 launch_option_type = 15;


    pub fn get_launch_option_type(&self) -> u32 {
        self.launch_option_type.unwrap_or(0u32)
    }
    pub fn clear_launch_option_type(&mut self) {
        self.launch_option_type = ::std::option::Option::None;
    }

    pub fn has_launch_option_type(&self) -> bool {
        self.launch_option_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch_option_type(&mut self, v: u32) {
        self.launch_option_type = ::std::option::Option::Some(v);
    }

    // optional int32 primary_controller_type = 16;


    pub fn get_primary_controller_type(&self) -> i32 {
        self.primary_controller_type.unwrap_or(-1i32)
    }
    pub fn clear_primary_controller_type(&mut self) {
        self.primary_controller_type = ::std::option::Option::None;
    }

    pub fn has_primary_controller_type(&self) -> bool {
        self.primary_controller_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_controller_type(&mut self, v: i32) {
        self.primary_controller_type = ::std::option::Option::Some(v);
    }

    // optional string primary_steam_controller_serial = 17;


    pub fn get_primary_steam_controller_serial(&self) -> &str {
        match self.primary_steam_controller_serial.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_primary_steam_controller_serial(&mut self) {
        self.primary_steam_controller_serial.clear();
    }

    pub fn has_primary_steam_controller_serial(&self) -> bool {
        self.primary_steam_controller_serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_steam_controller_serial(&mut self, v: ::std::string::String) {
        self.primary_steam_controller_serial = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_steam_controller_serial(&mut self) -> &mut ::std::string::String {
        if self.primary_steam_controller_serial.is_none() {
            self.primary_steam_controller_serial.set_default();
        }
        self.primary_steam_controller_serial.as_mut().unwrap()
    }

    // Take field
    pub fn take_primary_steam_controller_serial(&mut self) -> ::std::string::String {
        self.primary_steam_controller_serial.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 total_steam_controller_count = 18;


    pub fn get_total_steam_controller_count(&self) -> u32 {
        self.total_steam_controller_count.unwrap_or(0u32)
    }
    pub fn clear_total_steam_controller_count(&mut self) {
        self.total_steam_controller_count = ::std::option::Option::None;
    }

    pub fn has_total_steam_controller_count(&self) -> bool {
        self.total_steam_controller_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_steam_controller_count(&mut self, v: u32) {
        self.total_steam_controller_count = ::std::option::Option::Some(v);
    }

    // optional uint32 total_non_steam_controller_count = 19;


    pub fn get_total_non_steam_controller_count(&self) -> u32 {
        self.total_non_steam_controller_count.unwrap_or(0u32)
    }
    pub fn clear_total_non_steam_controller_count(&mut self) {
        self.total_non_steam_controller_count = ::std::option::Option::None;
    }

    pub fn has_total_non_steam_controller_count(&self) -> bool {
        self.total_non_steam_controller_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_non_steam_controller_count(&mut self, v: u32) {
        self.total_non_steam_controller_count = ::std::option::Option::Some(v);
    }

    // optional uint64 controller_workshop_file_id = 20;


    pub fn get_controller_workshop_file_id(&self) -> u64 {
        self.controller_workshop_file_id.unwrap_or(0u64)
    }
    pub fn clear_controller_workshop_file_id(&mut self) {
        self.controller_workshop_file_id = ::std::option::Option::None;
    }

    pub fn has_controller_workshop_file_id(&self) -> bool {
        self.controller_workshop_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_workshop_file_id(&mut self, v: u64) {
        self.controller_workshop_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 launch_source = 21;


    pub fn get_launch_source(&self) -> u32 {
        self.launch_source.unwrap_or(0u32)
    }
    pub fn clear_launch_source(&mut self) {
        self.launch_source = ::std::option::Option::None;
    }

    pub fn has_launch_source(&self) -> bool {
        self.launch_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch_source(&mut self, v: u32) {
        self.launch_source = ::std::option::Option::Some(v);
    }

    // optional uint32 vr_hmd_runtime = 22;


    pub fn get_vr_hmd_runtime(&self) -> u32 {
        self.vr_hmd_runtime.unwrap_or(0)
    }
    pub fn clear_vr_hmd_runtime(&mut self) {
        self.vr_hmd_runtime = ::std::option::Option::None;
    }

    pub fn has_vr_hmd_runtime(&self) -> bool {
        self.vr_hmd_runtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_hmd_runtime(&mut self, v: u32) {
        self.vr_hmd_runtime = ::std::option::Option::Some(v);
    }

    // optional .CMsgIPAddress game_ip_address = 23;


    pub fn get_game_ip_address(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.game_ip_address.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_game_ip_address(&mut self) {
        self.game_ip_address.clear();
    }

    pub fn has_game_ip_address(&self) -> bool {
        self.game_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_ip_address(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.game_ip_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_ip_address(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        if self.game_ip_address.is_none() {
            self.game_ip_address.set_default();
        }
        self.game_ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_ip_address(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.game_ip_address.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }

    // optional uint32 controller_connection_type = 24;


    pub fn get_controller_connection_type(&self) -> u32 {
        self.controller_connection_type.unwrap_or(0u32)
    }
    pub fn clear_controller_connection_type(&mut self) {
        self.controller_connection_type = ::std::option::Option::None;
    }

    pub fn has_controller_connection_type(&self) -> bool {
        self.controller_connection_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_connection_type(&mut self, v: u32) {
        self.controller_connection_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGamesPlayed_GamePlayed {
    fn is_initialized(&self) -> bool {
        for v in &self.game_ip_address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steam_id_gs = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_game_ip_address = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_secure = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_extra_info)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.game_data_blob)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.process_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.streaming_provider_id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_flags = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vr_hmd_vendor)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vr_hmd_model)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.launch_option_type = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.primary_controller_type = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.primary_steam_controller_serial)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_steam_controller_count = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_non_steam_controller_count = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.controller_workshop_file_id = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.launch_source = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vr_hmd_runtime = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.game_ip_address)?;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.controller_connection_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_gs {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_game_ip_address {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_secure {
            my_size += 2;
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.game_extra_info.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.game_data_blob.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.process_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.streaming_provider_id {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_flags {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_id {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.vr_hmd_vendor.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.vr_hmd_model.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.launch_option_type {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.primary_controller_type {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.primary_steam_controller_serial.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.total_steam_controller_count {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_non_steam_controller_count {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.controller_workshop_file_id {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.launch_source {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vr_hmd_runtime {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_ip_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.controller_connection_type {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_gs {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_ip_address {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.is_secure {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.game_extra_info.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.game_data_blob.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(v) = self.process_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.streaming_provider_id {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.game_flags {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.owner_id {
            os.write_uint32(12, v)?;
        }
        if let Some(ref v) = self.vr_hmd_vendor.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.vr_hmd_model.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.launch_option_type {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.primary_controller_type {
            os.write_int32(16, v)?;
        }
        if let Some(ref v) = self.primary_steam_controller_serial.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(v) = self.total_steam_controller_count {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.total_non_steam_controller_count {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.controller_workshop_file_id {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.launch_source {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.vr_hmd_runtime {
            os.write_uint32(22, v)?;
        }
        if let Some(ref v) = self.game_ip_address.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.controller_connection_type {
            os.write_uint32(24, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGamesPlayed_GamePlayed {
        CMsgClientGamesPlayed_GamePlayed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "steam_id_gs",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.steam_id_gs },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.steam_id_gs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_id",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.game_id },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_game_ip_address",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.deprecated_game_ip_address },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.deprecated_game_ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_port",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.game_port },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.game_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_secure",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.is_secure },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.is_secure },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.token },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_extra_info",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.game_extra_info },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.game_extra_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "game_data_blob",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.game_data_blob },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.game_data_blob },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "process_id",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.process_id },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.process_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "streaming_provider_id",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.streaming_provider_id },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.streaming_provider_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_flags",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.game_flags },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.game_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "owner_id",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.owner_id },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.owner_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "vr_hmd_vendor",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.vr_hmd_vendor },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.vr_hmd_vendor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "vr_hmd_model",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.vr_hmd_model },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.vr_hmd_model },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "launch_option_type",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.launch_option_type },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.launch_option_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "primary_controller_type",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.primary_controller_type },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.primary_controller_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "primary_steam_controller_serial",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.primary_steam_controller_serial },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.primary_steam_controller_serial },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_steam_controller_count",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.total_steam_controller_count },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.total_steam_controller_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_non_steam_controller_count",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.total_non_steam_controller_count },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.total_non_steam_controller_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "controller_workshop_file_id",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.controller_workshop_file_id },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.controller_workshop_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "launch_source",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.launch_source },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.launch_source },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "vr_hmd_runtime",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.vr_hmd_runtime },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.vr_hmd_runtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>>(
                "game_ip_address",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.game_ip_address },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.game_ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "controller_connection_type",
                |m: &CMsgClientGamesPlayed_GamePlayed| { &m.controller_connection_type },
                |m: &mut CMsgClientGamesPlayed_GamePlayed| { &mut m.controller_connection_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGamesPlayed_GamePlayed>(
                "CMsgClientGamesPlayed.GamePlayed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGamesPlayed_GamePlayed {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGamesPlayed_GamePlayed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGamesPlayed_GamePlayed::new)
    }
}

impl ::protobuf::Clear for CMsgClientGamesPlayed_GamePlayed {
    fn clear(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.deprecated_game_ip_address = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.is_secure = ::std::option::Option::None;
        self.token.clear();
        self.game_extra_info.clear();
        self.game_data_blob.clear();
        self.process_id = ::std::option::Option::None;
        self.streaming_provider_id = ::std::option::Option::None;
        self.game_flags = ::std::option::Option::None;
        self.owner_id = ::std::option::Option::None;
        self.vr_hmd_vendor.clear();
        self.vr_hmd_model.clear();
        self.launch_option_type = ::std::option::Option::None;
        self.primary_controller_type = ::std::option::Option::None;
        self.primary_steam_controller_serial.clear();
        self.total_steam_controller_count = ::std::option::Option::None;
        self.total_non_steam_controller_count = ::std::option::Option::None;
        self.controller_workshop_file_id = ::std::option::Option::None;
        self.launch_source = ::std::option::Option::None;
        self.vr_hmd_runtime = ::std::option::Option::None;
        self.game_ip_address.clear();
        self.controller_connection_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGamesPlayed_GamePlayed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGamesPlayed_GamePlayed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSApprove {
    // message fields
    steam_id: ::std::option::Option<u64>,
    owner_steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSApprove {
    fn default() -> &'a CMsgGSApprove {
        <CMsgGSApprove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSApprove {
    pub fn new() -> CMsgGSApprove {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steam_id = 2;


    pub fn get_owner_steam_id(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }
    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSApprove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.owner_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.owner_steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.owner_steam_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSApprove {
        CMsgGSApprove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGSApprove| { &m.steam_id },
                |m: &mut CMsgGSApprove| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "owner_steam_id",
                |m: &CMsgGSApprove| { &m.owner_steam_id },
                |m: &mut CMsgGSApprove| { &mut m.owner_steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSApprove>(
                "CMsgGSApprove",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSApprove {
        static instance: ::protobuf::rt::LazyV2<CMsgGSApprove> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSApprove::new)
    }
}

impl ::protobuf::Clear for CMsgGSApprove {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.owner_steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSApprove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSApprove {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSDeny {
    // message fields
    steam_id: ::std::option::Option<u64>,
    edeny_reason: ::std::option::Option<i32>,
    deny_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSDeny {
    fn default() -> &'a CMsgGSDeny {
        <CMsgGSDeny as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSDeny {
    pub fn new() -> CMsgGSDeny {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 edeny_reason = 2;


    pub fn get_edeny_reason(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }
    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }

    // optional string deny_string = 3;


    pub fn get_deny_string(&self) -> &str {
        match self.deny_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_deny_string(&mut self) {
        self.deny_string.clear();
    }

    pub fn has_deny_string(&self) -> bool {
        self.deny_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny_string(&mut self, v: ::std::string::String) {
        self.deny_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deny_string(&mut self) -> &mut ::std::string::String {
        if self.deny_string.is_none() {
            self.deny_string.set_default();
        }
        self.deny_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_deny_string(&mut self) -> ::std::string::String {
        self.deny_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGSDeny {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.edeny_reason = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deny_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.edeny_reason {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.deny_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.edeny_reason {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.deny_string.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSDeny {
        CMsgGSDeny::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGSDeny| { &m.steam_id },
                |m: &mut CMsgGSDeny| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "edeny_reason",
                |m: &CMsgGSDeny| { &m.edeny_reason },
                |m: &mut CMsgGSDeny| { &mut m.edeny_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deny_string",
                |m: &CMsgGSDeny| { &m.deny_string },
                |m: &mut CMsgGSDeny| { &mut m.deny_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSDeny>(
                "CMsgGSDeny",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSDeny {
        static instance: ::protobuf::rt::LazyV2<CMsgGSDeny> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSDeny::new)
    }
}

impl ::protobuf::Clear for CMsgGSDeny {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.edeny_reason = ::std::option::Option::None;
        self.deny_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSDeny {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSDeny {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSKick {
    // message fields
    steam_id: ::std::option::Option<u64>,
    edeny_reason: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSKick {
    fn default() -> &'a CMsgGSKick {
        <CMsgGSKick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSKick {
    pub fn new() -> CMsgGSKick {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 edeny_reason = 2;


    pub fn get_edeny_reason(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }
    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSKick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.edeny_reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.edeny_reason {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.edeny_reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSKick {
        CMsgGSKick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGSKick| { &m.steam_id },
                |m: &mut CMsgGSKick| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "edeny_reason",
                |m: &CMsgGSKick| { &m.edeny_reason },
                |m: &mut CMsgGSKick| { &mut m.edeny_reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSKick>(
                "CMsgGSKick",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSKick {
        static instance: ::protobuf::rt::LazyV2<CMsgGSKick> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSKick::new)
    }
}

impl ::protobuf::Clear for CMsgGSKick {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.edeny_reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSKick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAuthList {
    // message fields
    tokens_left: ::std::option::Option<u32>,
    last_request_seq: ::std::option::Option<u32>,
    last_request_seq_from_server: ::std::option::Option<u32>,
    pub tickets: ::protobuf::RepeatedField<super::steammessages_base::CMsgAuthTicket>,
    pub app_ids: ::std::vec::Vec<u32>,
    message_sequence: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthList {
    fn default() -> &'a CMsgClientAuthList {
        <CMsgClientAuthList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthList {
    pub fn new() -> CMsgClientAuthList {
        ::std::default::Default::default()
    }

    // optional uint32 tokens_left = 1;


    pub fn get_tokens_left(&self) -> u32 {
        self.tokens_left.unwrap_or(0)
    }
    pub fn clear_tokens_left(&mut self) {
        self.tokens_left = ::std::option::Option::None;
    }

    pub fn has_tokens_left(&self) -> bool {
        self.tokens_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens_left(&mut self, v: u32) {
        self.tokens_left = ::std::option::Option::Some(v);
    }

    // optional uint32 last_request_seq = 2;


    pub fn get_last_request_seq(&self) -> u32 {
        self.last_request_seq.unwrap_or(0)
    }
    pub fn clear_last_request_seq(&mut self) {
        self.last_request_seq = ::std::option::Option::None;
    }

    pub fn has_last_request_seq(&self) -> bool {
        self.last_request_seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq(&mut self, v: u32) {
        self.last_request_seq = ::std::option::Option::Some(v);
    }

    // optional uint32 last_request_seq_from_server = 3;


    pub fn get_last_request_seq_from_server(&self) -> u32 {
        self.last_request_seq_from_server.unwrap_or(0)
    }
    pub fn clear_last_request_seq_from_server(&mut self) {
        self.last_request_seq_from_server = ::std::option::Option::None;
    }

    pub fn has_last_request_seq_from_server(&self) -> bool {
        self.last_request_seq_from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq_from_server(&mut self, v: u32) {
        self.last_request_seq_from_server = ::std::option::Option::Some(v);
    }

    // repeated .CMsgAuthTicket tickets = 4;


    pub fn get_tickets(&self) -> &[super::steammessages_base::CMsgAuthTicket] {
        &self.tickets
    }
    pub fn clear_tickets(&mut self) {
        self.tickets.clear();
    }

    // Param is passed by value, moved
    pub fn set_tickets(&mut self, v: ::protobuf::RepeatedField<super::steammessages_base::CMsgAuthTicket>) {
        self.tickets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tickets(&mut self) -> &mut ::protobuf::RepeatedField<super::steammessages_base::CMsgAuthTicket> {
        &mut self.tickets
    }

    // Take field
    pub fn take_tickets(&mut self) -> ::protobuf::RepeatedField<super::steammessages_base::CMsgAuthTicket> {
        ::std::mem::replace(&mut self.tickets, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 app_ids = 5;


    pub fn get_app_ids(&self) -> &[u32] {
        &self.app_ids
    }
    pub fn clear_app_ids(&mut self) {
        self.app_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.app_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.app_ids
    }

    // Take field
    pub fn take_app_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.app_ids, ::std::vec::Vec::new())
    }

    // optional uint32 message_sequence = 6;


    pub fn get_message_sequence(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }
    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthList {
    fn is_initialized(&self) -> bool {
        for v in &self.tickets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tokens_left = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_request_seq = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_request_seq_from_server = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tickets)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.app_ids)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.message_sequence = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tokens_left {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_request_seq {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_request_seq_from_server {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tickets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.app_ids {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.message_sequence {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tokens_left {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_request_seq {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.last_request_seq_from_server {
            os.write_uint32(3, v)?;
        }
        for v in &self.tickets {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.app_ids {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.message_sequence {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAuthList {
        CMsgClientAuthList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "tokens_left",
                |m: &CMsgClientAuthList| { &m.tokens_left },
                |m: &mut CMsgClientAuthList| { &mut m.tokens_left },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_request_seq",
                |m: &CMsgClientAuthList| { &m.last_request_seq },
                |m: &mut CMsgClientAuthList| { &mut m.last_request_seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_request_seq_from_server",
                |m: &CMsgClientAuthList| { &m.last_request_seq_from_server },
                |m: &mut CMsgClientAuthList| { &mut m.last_request_seq_from_server },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgAuthTicket>>(
                "tickets",
                |m: &CMsgClientAuthList| { &m.tickets },
                |m: &mut CMsgClientAuthList| { &mut m.tickets },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_ids",
                |m: &CMsgClientAuthList| { &m.app_ids },
                |m: &mut CMsgClientAuthList| { &mut m.app_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "message_sequence",
                |m: &CMsgClientAuthList| { &m.message_sequence },
                |m: &mut CMsgClientAuthList| { &mut m.message_sequence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAuthList>(
                "CMsgClientAuthList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAuthList {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAuthList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAuthList::new)
    }
}

impl ::protobuf::Clear for CMsgClientAuthList {
    fn clear(&mut self) {
        self.tokens_left = ::std::option::Option::None;
        self.last_request_seq = ::std::option::Option::None;
        self.last_request_seq_from_server = ::std::option::Option::None;
        self.tickets.clear();
        self.app_ids.clear();
        self.message_sequence = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAuthList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAuthListAck {
    // message fields
    pub ticket_crc: ::std::vec::Vec<u32>,
    pub app_ids: ::std::vec::Vec<u32>,
    message_sequence: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthListAck {
    fn default() -> &'a CMsgClientAuthListAck {
        <CMsgClientAuthListAck as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthListAck {
    pub fn new() -> CMsgClientAuthListAck {
        ::std::default::Default::default()
    }

    // repeated uint32 ticket_crc = 1;


    pub fn get_ticket_crc(&self) -> &[u32] {
        &self.ticket_crc
    }
    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: ::std::vec::Vec<u32>) {
        self.ticket_crc = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ticket_crc(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ticket_crc
    }

    // Take field
    pub fn take_ticket_crc(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ticket_crc, ::std::vec::Vec::new())
    }

    // repeated uint32 app_ids = 2;


    pub fn get_app_ids(&self) -> &[u32] {
        &self.app_ids
    }
    pub fn clear_app_ids(&mut self) {
        self.app_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.app_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.app_ids
    }

    // Take field
    pub fn take_app_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.app_ids, ::std::vec::Vec::new())
    }

    // optional uint32 message_sequence = 3;


    pub fn get_message_sequence(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }
    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthListAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.ticket_crc)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.app_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.message_sequence = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ticket_crc {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.app_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.message_sequence {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ticket_crc {
            os.write_uint32(1, *v)?;
        };
        for v in &self.app_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.message_sequence {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAuthListAck {
        CMsgClientAuthListAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ticket_crc",
                |m: &CMsgClientAuthListAck| { &m.ticket_crc },
                |m: &mut CMsgClientAuthListAck| { &mut m.ticket_crc },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_ids",
                |m: &CMsgClientAuthListAck| { &m.app_ids },
                |m: &mut CMsgClientAuthListAck| { &mut m.app_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "message_sequence",
                |m: &CMsgClientAuthListAck| { &m.message_sequence },
                |m: &mut CMsgClientAuthListAck| { &mut m.message_sequence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAuthListAck>(
                "CMsgClientAuthListAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAuthListAck {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAuthListAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAuthListAck::new)
    }
}

impl ::protobuf::Clear for CMsgClientAuthListAck {
    fn clear(&mut self) {
        self.ticket_crc.clear();
        self.app_ids.clear();
        self.message_sequence = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAuthListAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthListAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLicenseList {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub licenses: ::protobuf::RepeatedField<CMsgClientLicenseList_License>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLicenseList {
    fn default() -> &'a CMsgClientLicenseList {
        <CMsgClientLicenseList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLicenseList {
    pub fn new() -> CMsgClientLicenseList {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientLicenseList.License licenses = 2;


    pub fn get_licenses(&self) -> &[CMsgClientLicenseList_License] {
        &self.licenses
    }
    pub fn clear_licenses(&mut self) {
        self.licenses.clear();
    }

    // Param is passed by value, moved
    pub fn set_licenses(&mut self, v: ::protobuf::RepeatedField<CMsgClientLicenseList_License>) {
        self.licenses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_licenses(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientLicenseList_License> {
        &mut self.licenses
    }

    // Take field
    pub fn take_licenses(&mut self) -> ::protobuf::RepeatedField<CMsgClientLicenseList_License> {
        ::std::mem::replace(&mut self.licenses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientLicenseList {
    fn is_initialized(&self) -> bool {
        for v in &self.licenses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.licenses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.licenses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.licenses {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLicenseList {
        CMsgClientLicenseList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientLicenseList| { &m.eresult },
                |m: &mut CMsgClientLicenseList| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientLicenseList_License>>(
                "licenses",
                |m: &CMsgClientLicenseList| { &m.licenses },
                |m: &mut CMsgClientLicenseList| { &mut m.licenses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLicenseList>(
                "CMsgClientLicenseList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLicenseList {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLicenseList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLicenseList::new)
    }
}

impl ::protobuf::Clear for CMsgClientLicenseList {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.licenses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLicenseList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLicenseList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLicenseList_License {
    // message fields
    package_id: ::std::option::Option<u32>,
    time_created: ::std::option::Option<u32>,
    time_next_process: ::std::option::Option<u32>,
    minute_limit: ::std::option::Option<i32>,
    minutes_used: ::std::option::Option<i32>,
    payment_method: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    purchase_country_code: ::protobuf::SingularField<::std::string::String>,
    license_type: ::std::option::Option<u32>,
    territory_code: ::std::option::Option<i32>,
    change_number: ::std::option::Option<i32>,
    owner_id: ::std::option::Option<u32>,
    initial_period: ::std::option::Option<u32>,
    initial_time_unit: ::std::option::Option<u32>,
    renewal_period: ::std::option::Option<u32>,
    renewal_time_unit: ::std::option::Option<u32>,
    access_token: ::std::option::Option<u64>,
    master_package_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLicenseList_License {
    fn default() -> &'a CMsgClientLicenseList_License {
        <CMsgClientLicenseList_License as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLicenseList_License {
    pub fn new() -> CMsgClientLicenseList_License {
        ::std::default::Default::default()
    }

    // optional uint32 package_id = 1;


    pub fn get_package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }
    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_created = 2;


    pub fn get_time_created(&self) -> u32 {
        self.time_created.unwrap_or(0)
    }
    pub fn clear_time_created(&mut self) {
        self.time_created = ::std::option::Option::None;
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: u32) {
        self.time_created = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_next_process = 3;


    pub fn get_time_next_process(&self) -> u32 {
        self.time_next_process.unwrap_or(0)
    }
    pub fn clear_time_next_process(&mut self) {
        self.time_next_process = ::std::option::Option::None;
    }

    pub fn has_time_next_process(&self) -> bool {
        self.time_next_process.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_next_process(&mut self, v: u32) {
        self.time_next_process = ::std::option::Option::Some(v);
    }

    // optional int32 minute_limit = 4;


    pub fn get_minute_limit(&self) -> i32 {
        self.minute_limit.unwrap_or(0)
    }
    pub fn clear_minute_limit(&mut self) {
        self.minute_limit = ::std::option::Option::None;
    }

    pub fn has_minute_limit(&self) -> bool {
        self.minute_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minute_limit(&mut self, v: i32) {
        self.minute_limit = ::std::option::Option::Some(v);
    }

    // optional int32 minutes_used = 5;


    pub fn get_minutes_used(&self) -> i32 {
        self.minutes_used.unwrap_or(0)
    }
    pub fn clear_minutes_used(&mut self) {
        self.minutes_used = ::std::option::Option::None;
    }

    pub fn has_minutes_used(&self) -> bool {
        self.minutes_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_used(&mut self, v: i32) {
        self.minutes_used = ::std::option::Option::Some(v);
    }

    // optional uint32 payment_method = 6;


    pub fn get_payment_method(&self) -> u32 {
        self.payment_method.unwrap_or(0)
    }
    pub fn clear_payment_method(&mut self) {
        self.payment_method = ::std::option::Option::None;
    }

    pub fn has_payment_method(&self) -> bool {
        self.payment_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_method(&mut self, v: u32) {
        self.payment_method = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 7;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional string purchase_country_code = 8;


    pub fn get_purchase_country_code(&self) -> &str {
        match self.purchase_country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_purchase_country_code(&mut self) {
        self.purchase_country_code.clear();
    }

    pub fn has_purchase_country_code(&self) -> bool {
        self.purchase_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_country_code(&mut self, v: ::std::string::String) {
        self.purchase_country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_purchase_country_code(&mut self) -> &mut ::std::string::String {
        if self.purchase_country_code.is_none() {
            self.purchase_country_code.set_default();
        }
        self.purchase_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_purchase_country_code(&mut self) -> ::std::string::String {
        self.purchase_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 license_type = 9;


    pub fn get_license_type(&self) -> u32 {
        self.license_type.unwrap_or(0)
    }
    pub fn clear_license_type(&mut self) {
        self.license_type = ::std::option::Option::None;
    }

    pub fn has_license_type(&self) -> bool {
        self.license_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_license_type(&mut self, v: u32) {
        self.license_type = ::std::option::Option::Some(v);
    }

    // optional int32 territory_code = 10;


    pub fn get_territory_code(&self) -> i32 {
        self.territory_code.unwrap_or(0)
    }
    pub fn clear_territory_code(&mut self) {
        self.territory_code = ::std::option::Option::None;
    }

    pub fn has_territory_code(&self) -> bool {
        self.territory_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_territory_code(&mut self, v: i32) {
        self.territory_code = ::std::option::Option::Some(v);
    }

    // optional int32 change_number = 11;


    pub fn get_change_number(&self) -> i32 {
        self.change_number.unwrap_or(0)
    }
    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: i32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_id = 12;


    pub fn get_owner_id(&self) -> u32 {
        self.owner_id.unwrap_or(0)
    }
    pub fn clear_owner_id(&mut self) {
        self.owner_id = ::std::option::Option::None;
    }

    pub fn has_owner_id(&self) -> bool {
        self.owner_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: u32) {
        self.owner_id = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_period = 13;


    pub fn get_initial_period(&self) -> u32 {
        self.initial_period.unwrap_or(0)
    }
    pub fn clear_initial_period(&mut self) {
        self.initial_period = ::std::option::Option::None;
    }

    pub fn has_initial_period(&self) -> bool {
        self.initial_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_period(&mut self, v: u32) {
        self.initial_period = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_time_unit = 14;


    pub fn get_initial_time_unit(&self) -> u32 {
        self.initial_time_unit.unwrap_or(0)
    }
    pub fn clear_initial_time_unit(&mut self) {
        self.initial_time_unit = ::std::option::Option::None;
    }

    pub fn has_initial_time_unit(&self) -> bool {
        self.initial_time_unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_time_unit(&mut self, v: u32) {
        self.initial_time_unit = ::std::option::Option::Some(v);
    }

    // optional uint32 renewal_period = 15;


    pub fn get_renewal_period(&self) -> u32 {
        self.renewal_period.unwrap_or(0)
    }
    pub fn clear_renewal_period(&mut self) {
        self.renewal_period = ::std::option::Option::None;
    }

    pub fn has_renewal_period(&self) -> bool {
        self.renewal_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_renewal_period(&mut self, v: u32) {
        self.renewal_period = ::std::option::Option::Some(v);
    }

    // optional uint32 renewal_time_unit = 16;


    pub fn get_renewal_time_unit(&self) -> u32 {
        self.renewal_time_unit.unwrap_or(0)
    }
    pub fn clear_renewal_time_unit(&mut self) {
        self.renewal_time_unit = ::std::option::Option::None;
    }

    pub fn has_renewal_time_unit(&self) -> bool {
        self.renewal_time_unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_renewal_time_unit(&mut self, v: u32) {
        self.renewal_time_unit = ::std::option::Option::Some(v);
    }

    // optional uint64 access_token = 17;


    pub fn get_access_token(&self) -> u64 {
        self.access_token.unwrap_or(0)
    }
    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: u64) {
        self.access_token = ::std::option::Option::Some(v);
    }

    // optional uint32 master_package_id = 18;


    pub fn get_master_package_id(&self) -> u32 {
        self.master_package_id.unwrap_or(0)
    }
    pub fn clear_master_package_id(&mut self) {
        self.master_package_id = ::std::option::Option::None;
    }

    pub fn has_master_package_id(&self) -> bool {
        self.master_package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_master_package_id(&mut self, v: u32) {
        self.master_package_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLicenseList_License {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.package_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.time_created = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.time_next_process = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minute_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minutes_used = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.payment_method = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchase_country_code)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.license_type = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.territory_code = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_period = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_time_unit = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.renewal_period = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.renewal_time_unit = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.access_token = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.master_package_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.package_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_created {
            my_size += 5;
        }
        if let Some(v) = self.time_next_process {
            my_size += 5;
        }
        if let Some(v) = self.minute_limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minutes_used {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.payment_method {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.purchase_country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.license_type {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.territory_code {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.change_number {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_id {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_period {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_time_unit {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.renewal_period {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.renewal_time_unit {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.access_token {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.master_package_id {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.package_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_created {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.time_next_process {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.minute_limit {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.minutes_used {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.payment_method {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.purchase_country_code.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.license_type {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.territory_code {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.change_number {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.owner_id {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.initial_period {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.initial_time_unit {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.renewal_period {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.renewal_time_unit {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.access_token {
            os.write_uint64(17, v)?;
        }
        if let Some(v) = self.master_package_id {
            os.write_uint32(18, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLicenseList_License {
        CMsgClientLicenseList_License::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "package_id",
                |m: &CMsgClientLicenseList_License| { &m.package_id },
                |m: &mut CMsgClientLicenseList_License| { &mut m.package_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "time_created",
                |m: &CMsgClientLicenseList_License| { &m.time_created },
                |m: &mut CMsgClientLicenseList_License| { &mut m.time_created },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "time_next_process",
                |m: &CMsgClientLicenseList_License| { &m.time_next_process },
                |m: &mut CMsgClientLicenseList_License| { &mut m.time_next_process },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "minute_limit",
                |m: &CMsgClientLicenseList_License| { &m.minute_limit },
                |m: &mut CMsgClientLicenseList_License| { &mut m.minute_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "minutes_used",
                |m: &CMsgClientLicenseList_License| { &m.minutes_used },
                |m: &mut CMsgClientLicenseList_License| { &mut m.minutes_used },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "payment_method",
                |m: &CMsgClientLicenseList_License| { &m.payment_method },
                |m: &mut CMsgClientLicenseList_License| { &mut m.payment_method },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgClientLicenseList_License| { &m.flags },
                |m: &mut CMsgClientLicenseList_License| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchase_country_code",
                |m: &CMsgClientLicenseList_License| { &m.purchase_country_code },
                |m: &mut CMsgClientLicenseList_License| { &mut m.purchase_country_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "license_type",
                |m: &CMsgClientLicenseList_License| { &m.license_type },
                |m: &mut CMsgClientLicenseList_License| { &mut m.license_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "territory_code",
                |m: &CMsgClientLicenseList_License| { &m.territory_code },
                |m: &mut CMsgClientLicenseList_License| { &mut m.territory_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "change_number",
                |m: &CMsgClientLicenseList_License| { &m.change_number },
                |m: &mut CMsgClientLicenseList_License| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "owner_id",
                |m: &CMsgClientLicenseList_License| { &m.owner_id },
                |m: &mut CMsgClientLicenseList_License| { &mut m.owner_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_period",
                |m: &CMsgClientLicenseList_License| { &m.initial_period },
                |m: &mut CMsgClientLicenseList_License| { &mut m.initial_period },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_time_unit",
                |m: &CMsgClientLicenseList_License| { &m.initial_time_unit },
                |m: &mut CMsgClientLicenseList_License| { &mut m.initial_time_unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "renewal_period",
                |m: &CMsgClientLicenseList_License| { &m.renewal_period },
                |m: &mut CMsgClientLicenseList_License| { &mut m.renewal_period },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "renewal_time_unit",
                |m: &CMsgClientLicenseList_License| { &m.renewal_time_unit },
                |m: &mut CMsgClientLicenseList_License| { &mut m.renewal_time_unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "access_token",
                |m: &CMsgClientLicenseList_License| { &m.access_token },
                |m: &mut CMsgClientLicenseList_License| { &mut m.access_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "master_package_id",
                |m: &CMsgClientLicenseList_License| { &m.master_package_id },
                |m: &mut CMsgClientLicenseList_License| { &mut m.master_package_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLicenseList_License>(
                "CMsgClientLicenseList.License",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLicenseList_License {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLicenseList_License> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLicenseList_License::new)
    }
}

impl ::protobuf::Clear for CMsgClientLicenseList_License {
    fn clear(&mut self) {
        self.package_id = ::std::option::Option::None;
        self.time_created = ::std::option::Option::None;
        self.time_next_process = ::std::option::Option::None;
        self.minute_limit = ::std::option::Option::None;
        self.minutes_used = ::std::option::Option::None;
        self.payment_method = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.purchase_country_code.clear();
        self.license_type = ::std::option::Option::None;
        self.territory_code = ::std::option::Option::None;
        self.change_number = ::std::option::Option::None;
        self.owner_id = ::std::option::Option::None;
        self.initial_period = ::std::option::Option::None;
        self.initial_time_unit = ::std::option::Option::None;
        self.renewal_period = ::std::option::Option::None;
        self.renewal_time_unit = ::std::option::Option::None;
        self.access_token = ::std::option::Option::None;
        self.master_package_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLicenseList_License {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLicenseList_License {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSSetScore {
    // message fields
    app_id: ::std::option::Option<u32>,
    leaderboard_id: ::std::option::Option<i32>,
    score: ::std::option::Option<i32>,
    details: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    upload_score_method: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetScore {
    fn default() -> &'a CMsgClientLBSSetScore {
        <CMsgClientLBSSetScore as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetScore {
    pub fn new() -> CMsgClientLBSSetScore {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;


    pub fn get_leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }
    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional int32 score = 3;


    pub fn get_score(&self) -> i32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional bytes details = 4;


    pub fn get_details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details.set_default();
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 upload_score_method = 5;


    pub fn get_upload_score_method(&self) -> i32 {
        self.upload_score_method.unwrap_or(0)
    }
    pub fn clear_upload_score_method(&mut self) {
        self.upload_score_method = ::std::option::Option::None;
    }

    pub fn has_upload_score_method(&self) -> bool {
        self.upload_score_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_score_method(&mut self, v: i32) {
        self.upload_score_method = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSSetScore {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.details)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.upload_score_method = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.upload_score_method {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.score {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.upload_score_method {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSSetScore {
        CMsgClientLBSSetScore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientLBSSetScore| { &m.app_id },
                |m: &mut CMsgClientLBSSetScore| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_id",
                |m: &CMsgClientLBSSetScore| { &m.leaderboard_id },
                |m: &mut CMsgClientLBSSetScore| { &mut m.leaderboard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "score",
                |m: &CMsgClientLBSSetScore| { &m.score },
                |m: &mut CMsgClientLBSSetScore| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "details",
                |m: &CMsgClientLBSSetScore| { &m.details },
                |m: &mut CMsgClientLBSSetScore| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "upload_score_method",
                |m: &CMsgClientLBSSetScore| { &m.upload_score_method },
                |m: &mut CMsgClientLBSSetScore| { &mut m.upload_score_method },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLBSSetScore>(
                "CMsgClientLBSSetScore",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSSetScore {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLBSSetScore> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLBSSetScore::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetScore {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.details.clear();
        self.upload_score_method = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetScore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetScore {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSSetScoreResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    leaderboard_entry_count: ::std::option::Option<i32>,
    score_changed: ::std::option::Option<bool>,
    global_rank_previous: ::std::option::Option<i32>,
    global_rank_new: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetScoreResponse {
    fn default() -> &'a CMsgClientLBSSetScoreResponse {
        <CMsgClientLBSSetScoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetScoreResponse {
    pub fn new() -> CMsgClientLBSSetScoreResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_entry_count = 2;


    pub fn get_leaderboard_entry_count(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }
    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    // optional bool score_changed = 3;


    pub fn get_score_changed(&self) -> bool {
        self.score_changed.unwrap_or(false)
    }
    pub fn clear_score_changed(&mut self) {
        self.score_changed = ::std::option::Option::None;
    }

    pub fn has_score_changed(&self) -> bool {
        self.score_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_changed(&mut self, v: bool) {
        self.score_changed = ::std::option::Option::Some(v);
    }

    // optional int32 global_rank_previous = 4;


    pub fn get_global_rank_previous(&self) -> i32 {
        self.global_rank_previous.unwrap_or(0)
    }
    pub fn clear_global_rank_previous(&mut self) {
        self.global_rank_previous = ::std::option::Option::None;
    }

    pub fn has_global_rank_previous(&self) -> bool {
        self.global_rank_previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_rank_previous(&mut self, v: i32) {
        self.global_rank_previous = ::std::option::Option::Some(v);
    }

    // optional int32 global_rank_new = 5;


    pub fn get_global_rank_new(&self) -> i32 {
        self.global_rank_new.unwrap_or(0)
    }
    pub fn clear_global_rank_new(&mut self) {
        self.global_rank_new = ::std::option::Option::None;
    }

    pub fn has_global_rank_new(&self) -> bool {
        self.global_rank_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_rank_new(&mut self, v: i32) {
        self.global_rank_new = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSSetScoreResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_entry_count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.score_changed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.global_rank_previous = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.global_rank_new = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_entry_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_changed {
            my_size += 2;
        }
        if let Some(v) = self.global_rank_previous {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.global_rank_new {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_entry_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.score_changed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.global_rank_previous {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.global_rank_new {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSSetScoreResponse {
        CMsgClientLBSSetScoreResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientLBSSetScoreResponse| { &m.eresult },
                |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_entry_count",
                |m: &CMsgClientLBSSetScoreResponse| { &m.leaderboard_entry_count },
                |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.leaderboard_entry_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "score_changed",
                |m: &CMsgClientLBSSetScoreResponse| { &m.score_changed },
                |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.score_changed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "global_rank_previous",
                |m: &CMsgClientLBSSetScoreResponse| { &m.global_rank_previous },
                |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.global_rank_previous },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "global_rank_new",
                |m: &CMsgClientLBSSetScoreResponse| { &m.global_rank_new },
                |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.global_rank_new },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLBSSetScoreResponse>(
                "CMsgClientLBSSetScoreResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSSetScoreResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLBSSetScoreResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLBSSetScoreResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetScoreResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.leaderboard_entry_count = ::std::option::Option::None;
        self.score_changed = ::std::option::Option::None;
        self.global_rank_previous = ::std::option::Option::None;
        self.global_rank_new = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetScoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetScoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSSetUGC {
    // message fields
    app_id: ::std::option::Option<u32>,
    leaderboard_id: ::std::option::Option<i32>,
    ugc_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetUGC {
    fn default() -> &'a CMsgClientLBSSetUGC {
        <CMsgClientLBSSetUGC as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetUGC {
    pub fn new() -> CMsgClientLBSSetUGC {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;


    pub fn get_leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }
    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 ugc_id = 3;


    pub fn get_ugc_id(&self) -> u64 {
        self.ugc_id.unwrap_or(0)
    }
    pub fn clear_ugc_id(&mut self) {
        self.ugc_id = ::std::option::Option::None;
    }

    pub fn has_ugc_id(&self) -> bool {
        self.ugc_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ugc_id(&mut self, v: u64) {
        self.ugc_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSSetUGC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.ugc_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ugc_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ugc_id {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSSetUGC {
        CMsgClientLBSSetUGC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientLBSSetUGC| { &m.app_id },
                |m: &mut CMsgClientLBSSetUGC| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_id",
                |m: &CMsgClientLBSSetUGC| { &m.leaderboard_id },
                |m: &mut CMsgClientLBSSetUGC| { &mut m.leaderboard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "ugc_id",
                |m: &CMsgClientLBSSetUGC| { &m.ugc_id },
                |m: &mut CMsgClientLBSSetUGC| { &mut m.ugc_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLBSSetUGC>(
                "CMsgClientLBSSetUGC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSSetUGC {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLBSSetUGC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLBSSetUGC::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetUGC {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.ugc_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetUGC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetUGC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSSetUGCResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetUGCResponse {
    fn default() -> &'a CMsgClientLBSSetUGCResponse {
        <CMsgClientLBSSetUGCResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetUGCResponse {
    pub fn new() -> CMsgClientLBSSetUGCResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSSetUGCResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSSetUGCResponse {
        CMsgClientLBSSetUGCResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientLBSSetUGCResponse| { &m.eresult },
                |m: &mut CMsgClientLBSSetUGCResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLBSSetUGCResponse>(
                "CMsgClientLBSSetUGCResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSSetUGCResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLBSSetUGCResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLBSSetUGCResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetUGCResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetUGCResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetUGCResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSFindOrCreateLB {
    // message fields
    app_id: ::std::option::Option<u32>,
    leaderboard_sort_method: ::std::option::Option<i32>,
    leaderboard_display_type: ::std::option::Option<i32>,
    create_if_not_found: ::std::option::Option<bool>,
    leaderboard_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSFindOrCreateLB {
    fn default() -> &'a CMsgClientLBSFindOrCreateLB {
        <CMsgClientLBSFindOrCreateLB as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSFindOrCreateLB {
    pub fn new() -> CMsgClientLBSFindOrCreateLB {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_sort_method = 2;


    pub fn get_leaderboard_sort_method(&self) -> i32 {
        self.leaderboard_sort_method.unwrap_or(0)
    }
    pub fn clear_leaderboard_sort_method(&mut self) {
        self.leaderboard_sort_method = ::std::option::Option::None;
    }

    pub fn has_leaderboard_sort_method(&self) -> bool {
        self.leaderboard_sort_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_sort_method(&mut self, v: i32) {
        self.leaderboard_sort_method = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_display_type = 3;


    pub fn get_leaderboard_display_type(&self) -> i32 {
        self.leaderboard_display_type.unwrap_or(0)
    }
    pub fn clear_leaderboard_display_type(&mut self) {
        self.leaderboard_display_type = ::std::option::Option::None;
    }

    pub fn has_leaderboard_display_type(&self) -> bool {
        self.leaderboard_display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_display_type(&mut self, v: i32) {
        self.leaderboard_display_type = ::std::option::Option::Some(v);
    }

    // optional bool create_if_not_found = 4;


    pub fn get_create_if_not_found(&self) -> bool {
        self.create_if_not_found.unwrap_or(false)
    }
    pub fn clear_create_if_not_found(&mut self) {
        self.create_if_not_found = ::std::option::Option::None;
    }

    pub fn has_create_if_not_found(&self) -> bool {
        self.create_if_not_found.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_if_not_found(&mut self, v: bool) {
        self.create_if_not_found = ::std::option::Option::Some(v);
    }

    // optional string leaderboard_name = 5;


    pub fn get_leaderboard_name(&self) -> &str {
        match self.leaderboard_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_leaderboard_name(&mut self) {
        self.leaderboard_name.clear();
    }

    pub fn has_leaderboard_name(&self) -> bool {
        self.leaderboard_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name(&mut self, v: ::std::string::String) {
        self.leaderboard_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_name(&mut self) -> &mut ::std::string::String {
        if self.leaderboard_name.is_none() {
            self.leaderboard_name.set_default();
        }
        self.leaderboard_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_name(&mut self) -> ::std::string::String {
        self.leaderboard_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientLBSFindOrCreateLB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_sort_method = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_display_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.create_if_not_found = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.leaderboard_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_sort_method {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_display_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.create_if_not_found {
            my_size += 2;
        }
        if let Some(ref v) = self.leaderboard_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leaderboard_sort_method {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.leaderboard_display_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.create_if_not_found {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.leaderboard_name.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSFindOrCreateLB {
        CMsgClientLBSFindOrCreateLB::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientLBSFindOrCreateLB| { &m.app_id },
                |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_sort_method",
                |m: &CMsgClientLBSFindOrCreateLB| { &m.leaderboard_sort_method },
                |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.leaderboard_sort_method },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_display_type",
                |m: &CMsgClientLBSFindOrCreateLB| { &m.leaderboard_display_type },
                |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.leaderboard_display_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "create_if_not_found",
                |m: &CMsgClientLBSFindOrCreateLB| { &m.create_if_not_found },
                |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.create_if_not_found },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "leaderboard_name",
                |m: &CMsgClientLBSFindOrCreateLB| { &m.leaderboard_name },
                |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.leaderboard_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLBSFindOrCreateLB>(
                "CMsgClientLBSFindOrCreateLB",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSFindOrCreateLB {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLBSFindOrCreateLB> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLBSFindOrCreateLB::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSFindOrCreateLB {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_sort_method = ::std::option::Option::None;
        self.leaderboard_display_type = ::std::option::Option::None;
        self.create_if_not_found = ::std::option::Option::None;
        self.leaderboard_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSFindOrCreateLB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSFindOrCreateLB {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSFindOrCreateLBResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    leaderboard_id: ::std::option::Option<i32>,
    leaderboard_entry_count: ::std::option::Option<i32>,
    leaderboard_sort_method: ::std::option::Option<i32>,
    leaderboard_display_type: ::std::option::Option<i32>,
    leaderboard_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSFindOrCreateLBResponse {
    fn default() -> &'a CMsgClientLBSFindOrCreateLBResponse {
        <CMsgClientLBSFindOrCreateLBResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSFindOrCreateLBResponse {
    pub fn new() -> CMsgClientLBSFindOrCreateLBResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;


    pub fn get_leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }
    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_entry_count = 3;


    pub fn get_leaderboard_entry_count(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }
    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_sort_method = 4;


    pub fn get_leaderboard_sort_method(&self) -> i32 {
        self.leaderboard_sort_method.unwrap_or(0i32)
    }
    pub fn clear_leaderboard_sort_method(&mut self) {
        self.leaderboard_sort_method = ::std::option::Option::None;
    }

    pub fn has_leaderboard_sort_method(&self) -> bool {
        self.leaderboard_sort_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_sort_method(&mut self, v: i32) {
        self.leaderboard_sort_method = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_display_type = 5;


    pub fn get_leaderboard_display_type(&self) -> i32 {
        self.leaderboard_display_type.unwrap_or(0i32)
    }
    pub fn clear_leaderboard_display_type(&mut self) {
        self.leaderboard_display_type = ::std::option::Option::None;
    }

    pub fn has_leaderboard_display_type(&self) -> bool {
        self.leaderboard_display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_display_type(&mut self, v: i32) {
        self.leaderboard_display_type = ::std::option::Option::Some(v);
    }

    // optional string leaderboard_name = 6;


    pub fn get_leaderboard_name(&self) -> &str {
        match self.leaderboard_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_leaderboard_name(&mut self) {
        self.leaderboard_name.clear();
    }

    pub fn has_leaderboard_name(&self) -> bool {
        self.leaderboard_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name(&mut self, v: ::std::string::String) {
        self.leaderboard_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_name(&mut self) -> &mut ::std::string::String {
        if self.leaderboard_name.is_none() {
            self.leaderboard_name.set_default();
        }
        self.leaderboard_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_name(&mut self) -> ::std::string::String {
        self.leaderboard_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientLBSFindOrCreateLBResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_entry_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_sort_method = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_display_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.leaderboard_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_entry_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_sort_method {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_display_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.leaderboard_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.leaderboard_entry_count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.leaderboard_sort_method {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.leaderboard_display_type {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.leaderboard_name.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSFindOrCreateLBResponse {
        CMsgClientLBSFindOrCreateLBResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.eresult },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_id",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_id },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_entry_count",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_entry_count },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_entry_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_sort_method",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_sort_method },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_sort_method },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_display_type",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_display_type },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_display_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "leaderboard_name",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_name },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLBSFindOrCreateLBResponse>(
                "CMsgClientLBSFindOrCreateLBResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSFindOrCreateLBResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLBSFindOrCreateLBResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLBSFindOrCreateLBResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSFindOrCreateLBResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.leaderboard_entry_count = ::std::option::Option::None;
        self.leaderboard_sort_method = ::std::option::Option::None;
        self.leaderboard_display_type = ::std::option::Option::None;
        self.leaderboard_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSFindOrCreateLBResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSFindOrCreateLBResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSGetLBEntries {
    // message fields
    app_id: ::std::option::Option<i32>,
    leaderboard_id: ::std::option::Option<i32>,
    range_start: ::std::option::Option<i32>,
    range_end: ::std::option::Option<i32>,
    leaderboard_data_request: ::std::option::Option<i32>,
    pub steamids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSGetLBEntries {
    fn default() -> &'a CMsgClientLBSGetLBEntries {
        <CMsgClientLBSGetLBEntries as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSGetLBEntries {
    pub fn new() -> CMsgClientLBSGetLBEntries {
        ::std::default::Default::default()
    }

    // optional int32 app_id = 1;


    pub fn get_app_id(&self) -> i32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: i32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;


    pub fn get_leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }
    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional int32 range_start = 3;


    pub fn get_range_start(&self) -> i32 {
        self.range_start.unwrap_or(0)
    }
    pub fn clear_range_start(&mut self) {
        self.range_start = ::std::option::Option::None;
    }

    pub fn has_range_start(&self) -> bool {
        self.range_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_start(&mut self, v: i32) {
        self.range_start = ::std::option::Option::Some(v);
    }

    // optional int32 range_end = 4;


    pub fn get_range_end(&self) -> i32 {
        self.range_end.unwrap_or(0)
    }
    pub fn clear_range_end(&mut self) {
        self.range_end = ::std::option::Option::None;
    }

    pub fn has_range_end(&self) -> bool {
        self.range_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: i32) {
        self.range_end = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_data_request = 5;


    pub fn get_leaderboard_data_request(&self) -> i32 {
        self.leaderboard_data_request.unwrap_or(0)
    }
    pub fn clear_leaderboard_data_request(&mut self) {
        self.leaderboard_data_request = ::std::option::Option::None;
    }

    pub fn has_leaderboard_data_request(&self) -> bool {
        self.leaderboard_data_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_data_request(&mut self, v: i32) {
        self.leaderboard_data_request = ::std::option::Option::Some(v);
    }

    // repeated fixed64 steamids = 6;


    pub fn get_steamids(&self) -> &[u64] {
        &self.steamids
    }
    pub fn clear_steamids(&mut self) {
        self.steamids.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamids(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamids
    }

    // Take field
    pub fn take_steamids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientLBSGetLBEntries {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.range_start = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.range_end = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_data_request = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.range_start {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.range_end {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_data_request {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 9 * self.steamids.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.range_start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.range_end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.leaderboard_data_request {
            os.write_int32(5, v)?;
        }
        for v in &self.steamids {
            os.write_fixed64(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSGetLBEntries {
        CMsgClientLBSGetLBEntries::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "app_id",
                |m: &CMsgClientLBSGetLBEntries| { &m.app_id },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_id",
                |m: &CMsgClientLBSGetLBEntries| { &m.leaderboard_id },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.leaderboard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "range_start",
                |m: &CMsgClientLBSGetLBEntries| { &m.range_start },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.range_start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "range_end",
                |m: &CMsgClientLBSGetLBEntries| { &m.range_end },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.range_end },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_data_request",
                |m: &CMsgClientLBSGetLBEntries| { &m.leaderboard_data_request },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.leaderboard_data_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamids",
                |m: &CMsgClientLBSGetLBEntries| { &m.steamids },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.steamids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLBSGetLBEntries>(
                "CMsgClientLBSGetLBEntries",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSGetLBEntries {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLBSGetLBEntries> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLBSGetLBEntries::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSGetLBEntries {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.range_start = ::std::option::Option::None;
        self.range_end = ::std::option::Option::None;
        self.leaderboard_data_request = ::std::option::Option::None;
        self.steamids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSGetLBEntries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSGetLBEntries {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSGetLBEntriesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    leaderboard_entry_count: ::std::option::Option<i32>,
    pub entries: ::protobuf::RepeatedField<CMsgClientLBSGetLBEntriesResponse_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSGetLBEntriesResponse {
    fn default() -> &'a CMsgClientLBSGetLBEntriesResponse {
        <CMsgClientLBSGetLBEntriesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSGetLBEntriesResponse {
    pub fn new() -> CMsgClientLBSGetLBEntriesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_entry_count = 2;


    pub fn get_leaderboard_entry_count(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }
    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientLBSGetLBEntriesResponse.Entry entries = 3;


    pub fn get_entries(&self) -> &[CMsgClientLBSGetLBEntriesResponse_Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CMsgClientLBSGetLBEntriesResponse_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientLBSGetLBEntriesResponse_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CMsgClientLBSGetLBEntriesResponse_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientLBSGetLBEntriesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leaderboard_entry_count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_entry_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_entry_count {
            os.write_int32(2, v)?;
        }
        for v in &self.entries {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSGetLBEntriesResponse {
        CMsgClientLBSGetLBEntriesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientLBSGetLBEntriesResponse| { &m.eresult },
                |m: &mut CMsgClientLBSGetLBEntriesResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "leaderboard_entry_count",
                |m: &CMsgClientLBSGetLBEntriesResponse| { &m.leaderboard_entry_count },
                |m: &mut CMsgClientLBSGetLBEntriesResponse| { &mut m.leaderboard_entry_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientLBSGetLBEntriesResponse_Entry>>(
                "entries",
                |m: &CMsgClientLBSGetLBEntriesResponse| { &m.entries },
                |m: &mut CMsgClientLBSGetLBEntriesResponse| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLBSGetLBEntriesResponse>(
                "CMsgClientLBSGetLBEntriesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSGetLBEntriesResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLBSGetLBEntriesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLBSGetLBEntriesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSGetLBEntriesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.leaderboard_entry_count = ::std::option::Option::None;
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSGetLBEntriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSGetLBEntriesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSGetLBEntriesResponse_Entry {
    // message fields
    steam_id_user: ::std::option::Option<u64>,
    global_rank: ::std::option::Option<i32>,
    score: ::std::option::Option<i32>,
    details: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ugc_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSGetLBEntriesResponse_Entry {
    fn default() -> &'a CMsgClientLBSGetLBEntriesResponse_Entry {
        <CMsgClientLBSGetLBEntriesResponse_Entry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSGetLBEntriesResponse_Entry {
    pub fn new() -> CMsgClientLBSGetLBEntriesResponse_Entry {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_user = 1;


    pub fn get_steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }
    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional int32 global_rank = 2;


    pub fn get_global_rank(&self) -> i32 {
        self.global_rank.unwrap_or(0)
    }
    pub fn clear_global_rank(&mut self) {
        self.global_rank = ::std::option::Option::None;
    }

    pub fn has_global_rank(&self) -> bool {
        self.global_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_rank(&mut self, v: i32) {
        self.global_rank = ::std::option::Option::Some(v);
    }

    // optional int32 score = 3;


    pub fn get_score(&self) -> i32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional bytes details = 4;


    pub fn get_details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details.set_default();
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 ugc_id = 5;


    pub fn get_ugc_id(&self) -> u64 {
        self.ugc_id.unwrap_or(0)
    }
    pub fn clear_ugc_id(&mut self) {
        self.ugc_id = ::std::option::Option::None;
    }

    pub fn has_ugc_id(&self) -> bool {
        self.ugc_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ugc_id(&mut self, v: u64) {
        self.ugc_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSGetLBEntriesResponse_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_user = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.global_rank = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.details)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.ugc_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_user {
            my_size += 9;
        }
        if let Some(v) = self.global_rank {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ugc_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.global_rank {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.score {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.ugc_id {
            os.write_fixed64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSGetLBEntriesResponse_Entry {
        CMsgClientLBSGetLBEntriesResponse_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_user",
                |m: &CMsgClientLBSGetLBEntriesResponse_Entry| { &m.steam_id_user },
                |m: &mut CMsgClientLBSGetLBEntriesResponse_Entry| { &mut m.steam_id_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "global_rank",
                |m: &CMsgClientLBSGetLBEntriesResponse_Entry| { &m.global_rank },
                |m: &mut CMsgClientLBSGetLBEntriesResponse_Entry| { &mut m.global_rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "score",
                |m: &CMsgClientLBSGetLBEntriesResponse_Entry| { &m.score },
                |m: &mut CMsgClientLBSGetLBEntriesResponse_Entry| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "details",
                |m: &CMsgClientLBSGetLBEntriesResponse_Entry| { &m.details },
                |m: &mut CMsgClientLBSGetLBEntriesResponse_Entry| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "ugc_id",
                |m: &CMsgClientLBSGetLBEntriesResponse_Entry| { &m.ugc_id },
                |m: &mut CMsgClientLBSGetLBEntriesResponse_Entry| { &mut m.ugc_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientLBSGetLBEntriesResponse_Entry>(
                "CMsgClientLBSGetLBEntriesResponse.Entry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSGetLBEntriesResponse_Entry {
        static instance: ::protobuf::rt::LazyV2<CMsgClientLBSGetLBEntriesResponse_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientLBSGetLBEntriesResponse_Entry::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSGetLBEntriesResponse_Entry {
    fn clear(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
        self.global_rank = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.details.clear();
        self.ugc_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSGetLBEntriesResponse_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSGetLBEntriesResponse_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientIsLimitedAccount {
    // message fields
    bis_limited_account: ::std::option::Option<bool>,
    bis_community_banned: ::std::option::Option<bool>,
    bis_locked_account: ::std::option::Option<bool>,
    bis_limited_account_allowed_to_invite_friends: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientIsLimitedAccount {
    fn default() -> &'a CMsgClientIsLimitedAccount {
        <CMsgClientIsLimitedAccount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientIsLimitedAccount {
    pub fn new() -> CMsgClientIsLimitedAccount {
        ::std::default::Default::default()
    }

    // optional bool bis_limited_account = 1;


    pub fn get_bis_limited_account(&self) -> bool {
        self.bis_limited_account.unwrap_or(false)
    }
    pub fn clear_bis_limited_account(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account(&self) -> bool {
        self.bis_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account(&mut self, v: bool) {
        self.bis_limited_account = ::std::option::Option::Some(v);
    }

    // optional bool bis_community_banned = 2;


    pub fn get_bis_community_banned(&self) -> bool {
        self.bis_community_banned.unwrap_or(false)
    }
    pub fn clear_bis_community_banned(&mut self) {
        self.bis_community_banned = ::std::option::Option::None;
    }

    pub fn has_bis_community_banned(&self) -> bool {
        self.bis_community_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_community_banned(&mut self, v: bool) {
        self.bis_community_banned = ::std::option::Option::Some(v);
    }

    // optional bool bis_locked_account = 3;


    pub fn get_bis_locked_account(&self) -> bool {
        self.bis_locked_account.unwrap_or(false)
    }
    pub fn clear_bis_locked_account(&mut self) {
        self.bis_locked_account = ::std::option::Option::None;
    }

    pub fn has_bis_locked_account(&self) -> bool {
        self.bis_locked_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_locked_account(&mut self, v: bool) {
        self.bis_locked_account = ::std::option::Option::Some(v);
    }

    // optional bool bis_limited_account_allowed_to_invite_friends = 4;


    pub fn get_bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.unwrap_or(false)
    }
    pub fn clear_bis_limited_account_allowed_to_invite_friends(&mut self) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account_allowed_to_invite_friends(&mut self, v: bool) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientIsLimitedAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bis_limited_account = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bis_community_banned = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bis_locked_account = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bis_limited_account {
            my_size += 2;
        }
        if let Some(v) = self.bis_community_banned {
            my_size += 2;
        }
        if let Some(v) = self.bis_locked_account {
            my_size += 2;
        }
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bis_limited_account {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bis_community_banned {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bis_locked_account {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientIsLimitedAccount {
        CMsgClientIsLimitedAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bis_limited_account",
                |m: &CMsgClientIsLimitedAccount| { &m.bis_limited_account },
                |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_limited_account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bis_community_banned",
                |m: &CMsgClientIsLimitedAccount| { &m.bis_community_banned },
                |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_community_banned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bis_locked_account",
                |m: &CMsgClientIsLimitedAccount| { &m.bis_locked_account },
                |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_locked_account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bis_limited_account_allowed_to_invite_friends",
                |m: &CMsgClientIsLimitedAccount| { &m.bis_limited_account_allowed_to_invite_friends },
                |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_limited_account_allowed_to_invite_friends },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientIsLimitedAccount>(
                "CMsgClientIsLimitedAccount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientIsLimitedAccount {
        static instance: ::protobuf::rt::LazyV2<CMsgClientIsLimitedAccount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientIsLimitedAccount::new)
    }
}

impl ::protobuf::Clear for CMsgClientIsLimitedAccount {
    fn clear(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
        self.bis_community_banned = ::std::option::Option::None;
        self.bis_locked_account = ::std::option::Option::None;
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientIsLimitedAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientIsLimitedAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestedClientStats {
    // message fields
    pub stats_to_send: ::protobuf::RepeatedField<CMsgClientRequestedClientStats_StatsToSend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestedClientStats {
    fn default() -> &'a CMsgClientRequestedClientStats {
        <CMsgClientRequestedClientStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestedClientStats {
    pub fn new() -> CMsgClientRequestedClientStats {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientRequestedClientStats.StatsToSend stats_to_send = 1;


    pub fn get_stats_to_send(&self) -> &[CMsgClientRequestedClientStats_StatsToSend] {
        &self.stats_to_send
    }
    pub fn clear_stats_to_send(&mut self) {
        self.stats_to_send.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats_to_send(&mut self, v: ::protobuf::RepeatedField<CMsgClientRequestedClientStats_StatsToSend>) {
        self.stats_to_send = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats_to_send(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientRequestedClientStats_StatsToSend> {
        &mut self.stats_to_send
    }

    // Take field
    pub fn take_stats_to_send(&mut self) -> ::protobuf::RepeatedField<CMsgClientRequestedClientStats_StatsToSend> {
        ::std::mem::replace(&mut self.stats_to_send, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestedClientStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats_to_send {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats_to_send)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stats_to_send {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stats_to_send {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestedClientStats {
        CMsgClientRequestedClientStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientRequestedClientStats_StatsToSend>>(
                "stats_to_send",
                |m: &CMsgClientRequestedClientStats| { &m.stats_to_send },
                |m: &mut CMsgClientRequestedClientStats| { &mut m.stats_to_send },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestedClientStats>(
                "CMsgClientRequestedClientStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestedClientStats {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestedClientStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestedClientStats::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestedClientStats {
    fn clear(&mut self) {
        self.stats_to_send.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestedClientStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestedClientStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestedClientStats_StatsToSend {
    // message fields
    client_stat: ::std::option::Option<u32>,
    stat_aggregate_method: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestedClientStats_StatsToSend {
    fn default() -> &'a CMsgClientRequestedClientStats_StatsToSend {
        <CMsgClientRequestedClientStats_StatsToSend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestedClientStats_StatsToSend {
    pub fn new() -> CMsgClientRequestedClientStats_StatsToSend {
        ::std::default::Default::default()
    }

    // optional uint32 client_stat = 1;


    pub fn get_client_stat(&self) -> u32 {
        self.client_stat.unwrap_or(0)
    }
    pub fn clear_client_stat(&mut self) {
        self.client_stat = ::std::option::Option::None;
    }

    pub fn has_client_stat(&self) -> bool {
        self.client_stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_stat(&mut self, v: u32) {
        self.client_stat = ::std::option::Option::Some(v);
    }

    // optional uint32 stat_aggregate_method = 2;


    pub fn get_stat_aggregate_method(&self) -> u32 {
        self.stat_aggregate_method.unwrap_or(0)
    }
    pub fn clear_stat_aggregate_method(&mut self) {
        self.stat_aggregate_method = ::std::option::Option::None;
    }

    pub fn has_stat_aggregate_method(&self) -> bool {
        self.stat_aggregate_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_aggregate_method(&mut self, v: u32) {
        self.stat_aggregate_method = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestedClientStats_StatsToSend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_stat = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_aggregate_method = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_stat {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stat_aggregate_method {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_stat {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stat_aggregate_method {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestedClientStats_StatsToSend {
        CMsgClientRequestedClientStats_StatsToSend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_stat",
                |m: &CMsgClientRequestedClientStats_StatsToSend| { &m.client_stat },
                |m: &mut CMsgClientRequestedClientStats_StatsToSend| { &mut m.client_stat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stat_aggregate_method",
                |m: &CMsgClientRequestedClientStats_StatsToSend| { &m.stat_aggregate_method },
                |m: &mut CMsgClientRequestedClientStats_StatsToSend| { &mut m.stat_aggregate_method },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestedClientStats_StatsToSend>(
                "CMsgClientRequestedClientStats.StatsToSend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestedClientStats_StatsToSend {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestedClientStats_StatsToSend> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestedClientStats_StatsToSend::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestedClientStats_StatsToSend {
    fn clear(&mut self) {
        self.client_stat = ::std::option::Option::None;
        self.stat_aggregate_method = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestedClientStats_StatsToSend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestedClientStats_StatsToSend {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStat2 {
    // message fields
    pub stat_detail: ::protobuf::RepeatedField<CMsgClientStat2_StatDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStat2 {
    fn default() -> &'a CMsgClientStat2 {
        <CMsgClientStat2 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStat2 {
    pub fn new() -> CMsgClientStat2 {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientStat2.StatDetail stat_detail = 1;


    pub fn get_stat_detail(&self) -> &[CMsgClientStat2_StatDetail] {
        &self.stat_detail
    }
    pub fn clear_stat_detail(&mut self) {
        self.stat_detail.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_detail(&mut self, v: ::protobuf::RepeatedField<CMsgClientStat2_StatDetail>) {
        self.stat_detail = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_detail(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientStat2_StatDetail> {
        &mut self.stat_detail
    }

    // Take field
    pub fn take_stat_detail(&mut self) -> ::protobuf::RepeatedField<CMsgClientStat2_StatDetail> {
        ::std::mem::replace(&mut self.stat_detail, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientStat2 {
    fn is_initialized(&self) -> bool {
        for v in &self.stat_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_detail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stat_detail {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stat_detail {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStat2 {
        CMsgClientStat2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientStat2_StatDetail>>(
                "stat_detail",
                |m: &CMsgClientStat2| { &m.stat_detail },
                |m: &mut CMsgClientStat2| { &mut m.stat_detail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientStat2>(
                "CMsgClientStat2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStat2 {
        static instance: ::protobuf::rt::LazyV2<CMsgClientStat2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientStat2::new)
    }
}

impl ::protobuf::Clear for CMsgClientStat2 {
    fn clear(&mut self) {
        self.stat_detail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStat2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStat2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStat2_StatDetail {
    // message fields
    client_stat: ::std::option::Option<u32>,
    ll_value: ::std::option::Option<i64>,
    time_of_day: ::std::option::Option<u32>,
    cell_id: ::std::option::Option<u32>,
    depot_id: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStat2_StatDetail {
    fn default() -> &'a CMsgClientStat2_StatDetail {
        <CMsgClientStat2_StatDetail as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStat2_StatDetail {
    pub fn new() -> CMsgClientStat2_StatDetail {
        ::std::default::Default::default()
    }

    // optional uint32 client_stat = 1;


    pub fn get_client_stat(&self) -> u32 {
        self.client_stat.unwrap_or(0)
    }
    pub fn clear_client_stat(&mut self) {
        self.client_stat = ::std::option::Option::None;
    }

    pub fn has_client_stat(&self) -> bool {
        self.client_stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_stat(&mut self, v: u32) {
        self.client_stat = ::std::option::Option::Some(v);
    }

    // optional int64 ll_value = 2;


    pub fn get_ll_value(&self) -> i64 {
        self.ll_value.unwrap_or(0)
    }
    pub fn clear_ll_value(&mut self) {
        self.ll_value = ::std::option::Option::None;
    }

    pub fn has_ll_value(&self) -> bool {
        self.ll_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ll_value(&mut self, v: i64) {
        self.ll_value = ::std::option::Option::Some(v);
    }

    // optional uint32 time_of_day = 3;


    pub fn get_time_of_day(&self) -> u32 {
        self.time_of_day.unwrap_or(0)
    }
    pub fn clear_time_of_day(&mut self) {
        self.time_of_day = ::std::option::Option::None;
    }

    pub fn has_time_of_day(&self) -> bool {
        self.time_of_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_of_day(&mut self, v: u32) {
        self.time_of_day = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 4;


    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }
    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 depot_id = 5;


    pub fn get_depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }
    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 6;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStat2_StatDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_stat = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ll_value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_of_day = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.depot_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_stat {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ll_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_of_day {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_stat {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ll_value {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.time_of_day {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.depot_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStat2_StatDetail {
        CMsgClientStat2_StatDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_stat",
                |m: &CMsgClientStat2_StatDetail| { &m.client_stat },
                |m: &mut CMsgClientStat2_StatDetail| { &mut m.client_stat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ll_value",
                |m: &CMsgClientStat2_StatDetail| { &m.ll_value },
                |m: &mut CMsgClientStat2_StatDetail| { &mut m.ll_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_of_day",
                |m: &CMsgClientStat2_StatDetail| { &m.time_of_day },
                |m: &mut CMsgClientStat2_StatDetail| { &mut m.time_of_day },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cell_id",
                |m: &CMsgClientStat2_StatDetail| { &m.cell_id },
                |m: &mut CMsgClientStat2_StatDetail| { &mut m.cell_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "depot_id",
                |m: &CMsgClientStat2_StatDetail| { &m.depot_id },
                |m: &mut CMsgClientStat2_StatDetail| { &mut m.depot_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientStat2_StatDetail| { &m.app_id },
                |m: &mut CMsgClientStat2_StatDetail| { &mut m.app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientStat2_StatDetail>(
                "CMsgClientStat2.StatDetail",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStat2_StatDetail {
        static instance: ::protobuf::rt::LazyV2<CMsgClientStat2_StatDetail> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientStat2_StatDetail::new)
    }
}

impl ::protobuf::Clear for CMsgClientStat2_StatDetail {
    fn clear(&mut self) {
        self.client_stat = ::std::option::Option::None;
        self.ll_value = ::std::option::Option::None;
        self.time_of_day = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.depot_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStat2_StatDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStat2_StatDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetRatelimitPolicyOnClient {
    // message fields
    app_id: ::std::option::Option<u32>,
    enable_rate_limits: ::std::option::Option<bool>,
    seconds_per_message: ::std::option::Option<i32>,
    milliseconds_per_data_update: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetRatelimitPolicyOnClient {
    fn default() -> &'a CMsgClientMMSSetRatelimitPolicyOnClient {
        <CMsgClientMMSSetRatelimitPolicyOnClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetRatelimitPolicyOnClient {
    pub fn new() -> CMsgClientMMSSetRatelimitPolicyOnClient {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bool enable_rate_limits = 2;


    pub fn get_enable_rate_limits(&self) -> bool {
        self.enable_rate_limits.unwrap_or(false)
    }
    pub fn clear_enable_rate_limits(&mut self) {
        self.enable_rate_limits = ::std::option::Option::None;
    }

    pub fn has_enable_rate_limits(&self) -> bool {
        self.enable_rate_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_rate_limits(&mut self, v: bool) {
        self.enable_rate_limits = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_per_message = 3;


    pub fn get_seconds_per_message(&self) -> i32 {
        self.seconds_per_message.unwrap_or(0)
    }
    pub fn clear_seconds_per_message(&mut self) {
        self.seconds_per_message = ::std::option::Option::None;
    }

    pub fn has_seconds_per_message(&self) -> bool {
        self.seconds_per_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_per_message(&mut self, v: i32) {
        self.seconds_per_message = ::std::option::Option::Some(v);
    }

    // optional int32 milliseconds_per_data_update = 4;


    pub fn get_milliseconds_per_data_update(&self) -> i32 {
        self.milliseconds_per_data_update.unwrap_or(0)
    }
    pub fn clear_milliseconds_per_data_update(&mut self) {
        self.milliseconds_per_data_update = ::std::option::Option::None;
    }

    pub fn has_milliseconds_per_data_update(&self) -> bool {
        self.milliseconds_per_data_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_milliseconds_per_data_update(&mut self, v: i32) {
        self.milliseconds_per_data_update = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_rate_limits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seconds_per_message = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.milliseconds_per_data_update = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.enable_rate_limits {
            my_size += 2;
        }
        if let Some(v) = self.seconds_per_message {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.milliseconds_per_data_update {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.enable_rate_limits {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.seconds_per_message {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.milliseconds_per_data_update {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetRatelimitPolicyOnClient {
        CMsgClientMMSSetRatelimitPolicyOnClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.app_id },
                |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_rate_limits",
                |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.enable_rate_limits },
                |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.enable_rate_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seconds_per_message",
                |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.seconds_per_message },
                |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.seconds_per_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "milliseconds_per_data_update",
                |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.milliseconds_per_data_update },
                |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.milliseconds_per_data_update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSSetRatelimitPolicyOnClient>(
                "CMsgClientMMSSetRatelimitPolicyOnClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetRatelimitPolicyOnClient {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSSetRatelimitPolicyOnClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSSetRatelimitPolicyOnClient::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.enable_rate_limits = ::std::option::Option::None;
        self.seconds_per_message = ::std::option::Option::None;
        self.milliseconds_per_data_update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSCreateLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    cell_id: ::std::option::Option<u32>,
    deprecated_public_ip: ::std::option::Option<u32>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    persona_name_owner: ::protobuf::SingularField<::std::string::String>,
    pub public_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSCreateLobby {
    fn default() -> &'a CMsgClientMMSCreateLobby {
        <CMsgClientMMSCreateLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSCreateLobby {
    pub fn new() -> CMsgClientMMSCreateLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 2;


    pub fn get_max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }
    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 3;


    pub fn get_lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }
    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 4;


    pub fn get_lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }
    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 5;


    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }
    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 6;


    pub fn get_deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }
    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 7;


    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string persona_name_owner = 8;


    pub fn get_persona_name_owner(&self) -> &str {
        match self.persona_name_owner.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persona_name_owner(&mut self) {
        self.persona_name_owner.clear();
    }

    pub fn has_persona_name_owner(&self) -> bool {
        self.persona_name_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_owner(&mut self, v: ::std::string::String) {
        self.persona_name_owner = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_owner(&mut self) -> &mut ::std::string::String {
        if self.persona_name_owner.is_none() {
            self.persona_name_owner.set_default();
        }
        self.persona_name_owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_owner(&mut self) -> ::std::string::String {
        self.persona_name_owner.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgIPAddress public_ip = 9;


    pub fn get_public_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.public_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_public_ip(&mut self) {
        self.public_ip.clear();
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.public_ip = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        if self.public_ip.is_none() {
            self.public_ip.set_default();
        }
        self.public_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.public_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSCreateLobby {
    fn is_initialized(&self) -> bool {
        for v in &self.public_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_members = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lobby_flags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_public_ip = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name_owner)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.public_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(ref v) = self.persona_name_owner.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(ref v) = self.persona_name_owner.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.public_ip.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSCreateLobby {
        CMsgClientMMSCreateLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSCreateLobby| { &m.app_id },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_members",
                |m: &CMsgClientMMSCreateLobby| { &m.max_members },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.max_members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lobby_type",
                |m: &CMsgClientMMSCreateLobby| { &m.lobby_type },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.lobby_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lobby_flags",
                |m: &CMsgClientMMSCreateLobby| { &m.lobby_flags },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.lobby_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cell_id",
                |m: &CMsgClientMMSCreateLobby| { &m.cell_id },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.cell_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_public_ip",
                |m: &CMsgClientMMSCreateLobby| { &m.deprecated_public_ip },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.deprecated_public_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "metadata",
                |m: &CMsgClientMMSCreateLobby| { &m.metadata },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persona_name_owner",
                |m: &CMsgClientMMSCreateLobby| { &m.persona_name_owner },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.persona_name_owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>>(
                "public_ip",
                |m: &CMsgClientMMSCreateLobby| { &m.public_ip },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.public_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSCreateLobby>(
                "CMsgClientMMSCreateLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSCreateLobby {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSCreateLobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSCreateLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSCreateLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.metadata.clear();
        self.persona_name_owner.clear();
        self.public_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSCreateLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSCreateLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSCreateLobbyResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSCreateLobbyResponse {
    fn default() -> &'a CMsgClientMMSCreateLobbyResponse {
        <CMsgClientMMSCreateLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSCreateLobbyResponse {
    pub fn new() -> CMsgClientMMSCreateLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSCreateLobbyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSCreateLobbyResponse {
        CMsgClientMMSCreateLobbyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSCreateLobbyResponse| { &m.app_id },
                |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSCreateLobbyResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientMMSCreateLobbyResponse| { &m.eresult },
                |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSCreateLobbyResponse>(
                "CMsgClientMMSCreateLobbyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSCreateLobbyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSCreateLobbyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSCreateLobbyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSCreateLobbyResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSCreateLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSCreateLobbyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSJoinLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobby {
    fn default() -> &'a CMsgClientMMSJoinLobby {
        <CMsgClientMMSJoinLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobby {
    pub fn new() -> CMsgClientMMSJoinLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 3;


    pub fn get_persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSJoinLobby {
        CMsgClientMMSJoinLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSJoinLobby| { &m.app_id },
                |m: &mut CMsgClientMMSJoinLobby| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSJoinLobby| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSJoinLobby| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persona_name",
                |m: &CMsgClientMMSJoinLobby| { &m.persona_name },
                |m: &mut CMsgClientMMSJoinLobby| { &mut m.persona_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSJoinLobby>(
                "CMsgClientMMSJoinLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobby {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSJoinLobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSJoinLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSJoinLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.persona_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSJoinLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSJoinLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSJoinLobbyResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    chat_room_enter_response: ::std::option::Option<i32>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    steam_id_owner: ::std::option::Option<u64>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub members: ::protobuf::RepeatedField<CMsgClientMMSJoinLobbyResponse_Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobbyResponse {
    fn default() -> &'a CMsgClientMMSJoinLobbyResponse {
        <CMsgClientMMSJoinLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobbyResponse {
    pub fn new() -> CMsgClientMMSJoinLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 chat_room_enter_response = 3;


    pub fn get_chat_room_enter_response(&self) -> i32 {
        self.chat_room_enter_response.unwrap_or(0)
    }
    pub fn clear_chat_room_enter_response(&mut self) {
        self.chat_room_enter_response = ::std::option::Option::None;
    }

    pub fn has_chat_room_enter_response(&self) -> bool {
        self.chat_room_enter_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_enter_response(&mut self, v: i32) {
        self.chat_room_enter_response = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;


    pub fn get_max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }
    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;


    pub fn get_lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }
    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;


    pub fn get_lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }
    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_owner = 7;


    pub fn get_steam_id_owner(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }
    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 8;


    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .CMsgClientMMSJoinLobbyResponse.Member members = 9;


    pub fn get_members(&self) -> &[CMsgClientMMSJoinLobbyResponse_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CMsgClientMMSJoinLobbyResponse_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientMMSJoinLobbyResponse_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CMsgClientMMSJoinLobbyResponse_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobbyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_room_enter_response = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_members = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lobby_flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_owner = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.chat_room_enter_response {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_owner {
            my_size += 9;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.chat_room_enter_response {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_id_owner {
            os.write_fixed64(7, v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_bytes(8, &v)?;
        }
        for v in &self.members {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSJoinLobbyResponse {
        CMsgClientMMSJoinLobbyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.app_id },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chat_room_enter_response",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.chat_room_enter_response },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.chat_room_enter_response },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_members",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.max_members },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.max_members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lobby_type",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.lobby_type },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.lobby_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lobby_flags",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.lobby_flags },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.lobby_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_owner",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.steam_id_owner },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.steam_id_owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "metadata",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.metadata },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientMMSJoinLobbyResponse_Member>>(
                "members",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.members },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSJoinLobbyResponse>(
                "CMsgClientMMSJoinLobbyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobbyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSJoinLobbyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSJoinLobbyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSJoinLobbyResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.chat_room_enter_response = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.steam_id_owner = ::std::option::Option::None;
        self.metadata.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSJoinLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSJoinLobbyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSJoinLobbyResponse_Member {
    // message fields
    steam_id: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobbyResponse_Member {
    fn default() -> &'a CMsgClientMMSJoinLobbyResponse_Member {
        <CMsgClientMMSJoinLobbyResponse_Member as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobbyResponse_Member {
    pub fn new() -> CMsgClientMMSJoinLobbyResponse_Member {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 2;


    pub fn get_persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes metadata = 3;


    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobbyResponse_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSJoinLobbyResponse_Member {
        CMsgClientMMSJoinLobbyResponse_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgClientMMSJoinLobbyResponse_Member| { &m.steam_id },
                |m: &mut CMsgClientMMSJoinLobbyResponse_Member| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persona_name",
                |m: &CMsgClientMMSJoinLobbyResponse_Member| { &m.persona_name },
                |m: &mut CMsgClientMMSJoinLobbyResponse_Member| { &mut m.persona_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "metadata",
                |m: &CMsgClientMMSJoinLobbyResponse_Member| { &m.metadata },
                |m: &mut CMsgClientMMSJoinLobbyResponse_Member| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSJoinLobbyResponse_Member>(
                "CMsgClientMMSJoinLobbyResponse.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobbyResponse_Member {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSJoinLobbyResponse_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSJoinLobbyResponse_Member::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSJoinLobbyResponse_Member {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.persona_name.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSJoinLobbyResponse_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSJoinLobbyResponse_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLeaveLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLeaveLobby {
    fn default() -> &'a CMsgClientMMSLeaveLobby {
        <CMsgClientMMSLeaveLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLeaveLobby {
    pub fn new() -> CMsgClientMMSLeaveLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLeaveLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLeaveLobby {
        CMsgClientMMSLeaveLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSLeaveLobby| { &m.app_id },
                |m: &mut CMsgClientMMSLeaveLobby| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSLeaveLobby| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSLeaveLobby| { &mut m.steam_id_lobby },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSLeaveLobby>(
                "CMsgClientMMSLeaveLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLeaveLobby {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSLeaveLobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSLeaveLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLeaveLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLeaveLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLeaveLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLeaveLobbyResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLeaveLobbyResponse {
    fn default() -> &'a CMsgClientMMSLeaveLobbyResponse {
        <CMsgClientMMSLeaveLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLeaveLobbyResponse {
    pub fn new() -> CMsgClientMMSLeaveLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLeaveLobbyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLeaveLobbyResponse {
        CMsgClientMMSLeaveLobbyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSLeaveLobbyResponse| { &m.app_id },
                |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSLeaveLobbyResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientMMSLeaveLobbyResponse| { &m.eresult },
                |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSLeaveLobbyResponse>(
                "CMsgClientMMSLeaveLobbyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLeaveLobbyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSLeaveLobbyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSLeaveLobbyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLeaveLobbyResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLeaveLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLeaveLobbyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyList {
    // message fields
    app_id: ::std::option::Option<u32>,
    num_lobbies_requested: ::std::option::Option<i32>,
    cell_id: ::std::option::Option<u32>,
    deprecated_public_ip: ::std::option::Option<u32>,
    pub filters: ::protobuf::RepeatedField<CMsgClientMMSGetLobbyList_Filter>,
    pub public_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyList {
    fn default() -> &'a CMsgClientMMSGetLobbyList {
        <CMsgClientMMSGetLobbyList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyList {
    pub fn new() -> CMsgClientMMSGetLobbyList {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_lobbies_requested = 3;


    pub fn get_num_lobbies_requested(&self) -> i32 {
        self.num_lobbies_requested.unwrap_or(0)
    }
    pub fn clear_num_lobbies_requested(&mut self) {
        self.num_lobbies_requested = ::std::option::Option::None;
    }

    pub fn has_num_lobbies_requested(&self) -> bool {
        self.num_lobbies_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_lobbies_requested(&mut self, v: i32) {
        self.num_lobbies_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 4;


    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }
    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 5;


    pub fn get_deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }
    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientMMSGetLobbyList.Filter filters = 6;


    pub fn get_filters(&self) -> &[CMsgClientMMSGetLobbyList_Filter] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<CMsgClientMMSGetLobbyList_Filter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientMMSGetLobbyList_Filter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<CMsgClientMMSGetLobbyList_Filter> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }

    // optional .CMsgIPAddress public_ip = 7;


    pub fn get_public_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.public_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_public_ip(&mut self) {
        self.public_ip.clear();
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.public_ip = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        if self.public_ip.is_none() {
            self.public_ip.set_default();
        }
        self.public_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.public_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyList {
    fn is_initialized(&self) -> bool {
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.public_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_lobbies_requested = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_public_ip = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.public_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_lobbies_requested {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_lobbies_requested {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(5, v)?;
        }
        for v in &self.filters {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.public_ip.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyList {
        CMsgClientMMSGetLobbyList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSGetLobbyList| { &m.app_id },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_lobbies_requested",
                |m: &CMsgClientMMSGetLobbyList| { &m.num_lobbies_requested },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.num_lobbies_requested },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cell_id",
                |m: &CMsgClientMMSGetLobbyList| { &m.cell_id },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.cell_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_public_ip",
                |m: &CMsgClientMMSGetLobbyList| { &m.deprecated_public_ip },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.deprecated_public_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientMMSGetLobbyList_Filter>>(
                "filters",
                |m: &CMsgClientMMSGetLobbyList| { &m.filters },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.filters },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>>(
                "public_ip",
                |m: &CMsgClientMMSGetLobbyList| { &m.public_ip },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.public_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSGetLobbyList>(
                "CMsgClientMMSGetLobbyList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyList {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSGetLobbyList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSGetLobbyList::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyList {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.num_lobbies_requested = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.filters.clear();
        self.public_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyList_Filter {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    comparision: ::std::option::Option<i32>,
    filter_type: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyList_Filter {
    fn default() -> &'a CMsgClientMMSGetLobbyList_Filter {
        <CMsgClientMMSGetLobbyList_Filter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyList_Filter {
    pub fn new() -> CMsgClientMMSGetLobbyList_Filter {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 comparision = 3;


    pub fn get_comparision(&self) -> i32 {
        self.comparision.unwrap_or(0)
    }
    pub fn clear_comparision(&mut self) {
        self.comparision = ::std::option::Option::None;
    }

    pub fn has_comparision(&self) -> bool {
        self.comparision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comparision(&mut self, v: i32) {
        self.comparision = ::std::option::Option::Some(v);
    }

    // optional int32 filter_type = 4;


    pub fn get_filter_type(&self) -> i32 {
        self.filter_type.unwrap_or(0)
    }
    pub fn clear_filter_type(&mut self) {
        self.filter_type = ::std::option::Option::None;
    }

    pub fn has_filter_type(&self) -> bool {
        self.filter_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_type(&mut self, v: i32) {
        self.filter_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyList_Filter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.comparision = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.filter_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.comparision {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.comparision {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.filter_type {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyList_Filter {
        CMsgClientMMSGetLobbyList_Filter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &CMsgClientMMSGetLobbyList_Filter| { &m.key },
                |m: &mut CMsgClientMMSGetLobbyList_Filter| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CMsgClientMMSGetLobbyList_Filter| { &m.value },
                |m: &mut CMsgClientMMSGetLobbyList_Filter| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "comparision",
                |m: &CMsgClientMMSGetLobbyList_Filter| { &m.comparision },
                |m: &mut CMsgClientMMSGetLobbyList_Filter| { &mut m.comparision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "filter_type",
                |m: &CMsgClientMMSGetLobbyList_Filter| { &m.filter_type },
                |m: &mut CMsgClientMMSGetLobbyList_Filter| { &mut m.filter_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSGetLobbyList_Filter>(
                "CMsgClientMMSGetLobbyList.Filter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyList_Filter {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSGetLobbyList_Filter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSGetLobbyList_Filter::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyList_Filter {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.comparision = ::std::option::Option::None;
        self.filter_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyList_Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyList_Filter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyListResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    eresult: ::std::option::Option<i32>,
    pub lobbies: ::protobuf::RepeatedField<CMsgClientMMSGetLobbyListResponse_Lobby>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyListResponse {
    fn default() -> &'a CMsgClientMMSGetLobbyListResponse {
        <CMsgClientMMSGetLobbyListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyListResponse {
    pub fn new() -> CMsgClientMMSGetLobbyListResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientMMSGetLobbyListResponse.Lobby lobbies = 4;


    pub fn get_lobbies(&self) -> &[CMsgClientMMSGetLobbyListResponse_Lobby] {
        &self.lobbies
    }
    pub fn clear_lobbies(&mut self) {
        self.lobbies.clear();
    }

    // Param is passed by value, moved
    pub fn set_lobbies(&mut self, v: ::protobuf::RepeatedField<CMsgClientMMSGetLobbyListResponse_Lobby>) {
        self.lobbies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lobbies(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientMMSGetLobbyListResponse_Lobby> {
        &mut self.lobbies
    }

    // Take field
    pub fn take_lobbies(&mut self) -> ::protobuf::RepeatedField<CMsgClientMMSGetLobbyListResponse_Lobby> {
        ::std::mem::replace(&mut self.lobbies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.lobbies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.lobbies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        for v in &self.lobbies {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyListResponse {
        CMsgClientMMSGetLobbyListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSGetLobbyListResponse| { &m.app_id },
                |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientMMSGetLobbyListResponse| { &m.eresult },
                |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientMMSGetLobbyListResponse_Lobby>>(
                "lobbies",
                |m: &CMsgClientMMSGetLobbyListResponse| { &m.lobbies },
                |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.lobbies },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSGetLobbyListResponse>(
                "CMsgClientMMSGetLobbyListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyListResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSGetLobbyListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSGetLobbyListResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyListResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.lobbies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyListResponse_Lobby {
    // message fields
    steam_id: ::std::option::Option<u64>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    num_members: ::std::option::Option<i32>,
    distance: ::std::option::Option<f32>,
    weight: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyListResponse_Lobby {
    fn default() -> &'a CMsgClientMMSGetLobbyListResponse_Lobby {
        <CMsgClientMMSGetLobbyListResponse_Lobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyListResponse_Lobby {
    pub fn new() -> CMsgClientMMSGetLobbyListResponse_Lobby {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 2;


    pub fn get_max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }
    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 3;


    pub fn get_lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }
    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 4;


    pub fn get_lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }
    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 5;


    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 num_members = 6;


    pub fn get_num_members(&self) -> i32 {
        self.num_members.unwrap_or(0)
    }
    pub fn clear_num_members(&mut self) {
        self.num_members = ::std::option::Option::None;
    }

    pub fn has_num_members(&self) -> bool {
        self.num_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_members(&mut self, v: i32) {
        self.num_members = ::std::option::Option::Some(v);
    }

    // optional float distance = 7;


    pub fn get_distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }
    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    // optional int64 weight = 8;


    pub fn get_weight(&self) -> i64 {
        self.weight.unwrap_or(0)
    }
    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i64) {
        self.weight = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyListResponse_Lobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_members = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lobby_flags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_members = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.distance = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.num_members {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.distance {
            my_size += 5;
        }
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.num_members {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.distance {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.weight {
            os.write_int64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyListResponse_Lobby {
        CMsgClientMMSGetLobbyListResponse_Lobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgClientMMSGetLobbyListResponse_Lobby| { &m.steam_id },
                |m: &mut CMsgClientMMSGetLobbyListResponse_Lobby| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_members",
                |m: &CMsgClientMMSGetLobbyListResponse_Lobby| { &m.max_members },
                |m: &mut CMsgClientMMSGetLobbyListResponse_Lobby| { &mut m.max_members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lobby_type",
                |m: &CMsgClientMMSGetLobbyListResponse_Lobby| { &m.lobby_type },
                |m: &mut CMsgClientMMSGetLobbyListResponse_Lobby| { &mut m.lobby_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lobby_flags",
                |m: &CMsgClientMMSGetLobbyListResponse_Lobby| { &m.lobby_flags },
                |m: &mut CMsgClientMMSGetLobbyListResponse_Lobby| { &mut m.lobby_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "metadata",
                |m: &CMsgClientMMSGetLobbyListResponse_Lobby| { &m.metadata },
                |m: &mut CMsgClientMMSGetLobbyListResponse_Lobby| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_members",
                |m: &CMsgClientMMSGetLobbyListResponse_Lobby| { &m.num_members },
                |m: &mut CMsgClientMMSGetLobbyListResponse_Lobby| { &mut m.num_members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "distance",
                |m: &CMsgClientMMSGetLobbyListResponse_Lobby| { &m.distance },
                |m: &mut CMsgClientMMSGetLobbyListResponse_Lobby| { &mut m.distance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "weight",
                |m: &CMsgClientMMSGetLobbyListResponse_Lobby| { &m.weight },
                |m: &mut CMsgClientMMSGetLobbyListResponse_Lobby| { &mut m.weight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSGetLobbyListResponse_Lobby>(
                "CMsgClientMMSGetLobbyListResponse.Lobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyListResponse_Lobby {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSGetLobbyListResponse_Lobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSGetLobbyListResponse_Lobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyListResponse_Lobby {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.metadata.clear();
        self.num_members = ::std::option::Option::None;
        self.distance = ::std::option::Option::None;
        self.weight = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyListResponse_Lobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyListResponse_Lobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyData {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_member: ::std::option::Option<u64>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyData {
    fn default() -> &'a CMsgClientMMSSetLobbyData {
        <CMsgClientMMSSetLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyData {
    pub fn new() -> CMsgClientMMSSetLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_member = 3;


    pub fn get_steam_id_member(&self) -> u64 {
        self.steam_id_member.unwrap_or(0)
    }
    pub fn clear_steam_id_member(&mut self) {
        self.steam_id_member = ::std::option::Option::None;
    }

    pub fn has_steam_id_member(&self) -> bool {
        self.steam_id_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_member(&mut self, v: u64) {
        self.steam_id_member = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;


    pub fn get_max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }
    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;


    pub fn get_lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }
    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;


    pub fn get_lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }
    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 7;


    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_member = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_members = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lobby_flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_member {
            my_size += 9;
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_member {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_bytes(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyData {
        CMsgClientMMSSetLobbyData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyData| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyData| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_member",
                |m: &CMsgClientMMSSetLobbyData| { &m.steam_id_member },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.steam_id_member },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_members",
                |m: &CMsgClientMMSSetLobbyData| { &m.max_members },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.max_members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lobby_type",
                |m: &CMsgClientMMSSetLobbyData| { &m.lobby_type },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.lobby_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lobby_flags",
                |m: &CMsgClientMMSSetLobbyData| { &m.lobby_flags },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.lobby_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "metadata",
                |m: &CMsgClientMMSSetLobbyData| { &m.metadata },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSSetLobbyData>(
                "CMsgClientMMSSetLobbyData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyData {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSSetLobbyData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSSetLobbyData::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyData {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_member = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyDataResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyDataResponse {
    fn default() -> &'a CMsgClientMMSSetLobbyDataResponse {
        <CMsgClientMMSSetLobbyDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyDataResponse {
    pub fn new() -> CMsgClientMMSSetLobbyDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyDataResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyDataResponse {
        CMsgClientMMSSetLobbyDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyDataResponse| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyDataResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientMMSSetLobbyDataResponse| { &m.eresult },
                |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSSetLobbyDataResponse>(
                "CMsgClientMMSSetLobbyDataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyDataResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSSetLobbyDataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSSetLobbyDataResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyDataResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyData {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyData {
    fn default() -> &'a CMsgClientMMSGetLobbyData {
        <CMsgClientMMSGetLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyData {
    pub fn new() -> CMsgClientMMSGetLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyData {
        CMsgClientMMSGetLobbyData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSGetLobbyData| { &m.app_id },
                |m: &mut CMsgClientMMSGetLobbyData| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSGetLobbyData| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSGetLobbyData| { &mut m.steam_id_lobby },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSGetLobbyData>(
                "CMsgClientMMSGetLobbyData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyData {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSGetLobbyData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSGetLobbyData::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyData {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLobbyData {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    num_members: ::std::option::Option<i32>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    steam_id_owner: ::std::option::Option<u64>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub members: ::protobuf::RepeatedField<CMsgClientMMSLobbyData_Member>,
    lobby_cellid: ::std::option::Option<u32>,
    owner_should_accept_changes: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyData {
    fn default() -> &'a CMsgClientMMSLobbyData {
        <CMsgClientMMSLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyData {
    pub fn new() -> CMsgClientMMSLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 num_members = 3;


    pub fn get_num_members(&self) -> i32 {
        self.num_members.unwrap_or(0)
    }
    pub fn clear_num_members(&mut self) {
        self.num_members = ::std::option::Option::None;
    }

    pub fn has_num_members(&self) -> bool {
        self.num_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_members(&mut self, v: i32) {
        self.num_members = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;


    pub fn get_max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }
    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;


    pub fn get_lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }
    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;


    pub fn get_lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }
    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_owner = 7;


    pub fn get_steam_id_owner(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }
    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 8;


    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .CMsgClientMMSLobbyData.Member members = 9;


    pub fn get_members(&self) -> &[CMsgClientMMSLobbyData_Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CMsgClientMMSLobbyData_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientMMSLobbyData_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CMsgClientMMSLobbyData_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional uint32 lobby_cellid = 10;


    pub fn get_lobby_cellid(&self) -> u32 {
        self.lobby_cellid.unwrap_or(0)
    }
    pub fn clear_lobby_cellid(&mut self) {
        self.lobby_cellid = ::std::option::Option::None;
    }

    pub fn has_lobby_cellid(&self) -> bool {
        self.lobby_cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_cellid(&mut self, v: u32) {
        self.lobby_cellid = ::std::option::Option::Some(v);
    }

    // optional bool owner_should_accept_changes = 11;


    pub fn get_owner_should_accept_changes(&self) -> bool {
        self.owner_should_accept_changes.unwrap_or(false)
    }
    pub fn clear_owner_should_accept_changes(&mut self) {
        self.owner_should_accept_changes = ::std::option::Option::None;
    }

    pub fn has_owner_should_accept_changes(&self) -> bool {
        self.owner_should_accept_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_should_accept_changes(&mut self, v: bool) {
        self.owner_should_accept_changes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyData {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_members = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_members = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lobby_flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_owner = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lobby_cellid = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.owner_should_accept_changes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.num_members {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_owner {
            my_size += 9;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.lobby_cellid {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_should_accept_changes {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.num_members {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_id_owner {
            os.write_fixed64(7, v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_bytes(8, &v)?;
        }
        for v in &self.members {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.lobby_cellid {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.owner_should_accept_changes {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLobbyData {
        CMsgClientMMSLobbyData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSLobbyData| { &m.app_id },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSLobbyData| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_members",
                |m: &CMsgClientMMSLobbyData| { &m.num_members },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.num_members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_members",
                |m: &CMsgClientMMSLobbyData| { &m.max_members },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.max_members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lobby_type",
                |m: &CMsgClientMMSLobbyData| { &m.lobby_type },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lobby_flags",
                |m: &CMsgClientMMSLobbyData| { &m.lobby_flags },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_owner",
                |m: &CMsgClientMMSLobbyData| { &m.steam_id_owner },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.steam_id_owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "metadata",
                |m: &CMsgClientMMSLobbyData| { &m.metadata },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientMMSLobbyData_Member>>(
                "members",
                |m: &CMsgClientMMSLobbyData| { &m.members },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lobby_cellid",
                |m: &CMsgClientMMSLobbyData| { &m.lobby_cellid },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_cellid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "owner_should_accept_changes",
                |m: &CMsgClientMMSLobbyData| { &m.owner_should_accept_changes },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.owner_should_accept_changes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSLobbyData>(
                "CMsgClientMMSLobbyData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyData {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSLobbyData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSLobbyData::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyData {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.num_members = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.steam_id_owner = ::std::option::Option::None;
        self.metadata.clear();
        self.members.clear();
        self.lobby_cellid = ::std::option::Option::None;
        self.owner_should_accept_changes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLobbyData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLobbyData_Member {
    // message fields
    steam_id: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyData_Member {
    fn default() -> &'a CMsgClientMMSLobbyData_Member {
        <CMsgClientMMSLobbyData_Member as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyData_Member {
    pub fn new() -> CMsgClientMMSLobbyData_Member {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 2;


    pub fn get_persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes metadata = 3;


    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyData_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLobbyData_Member {
        CMsgClientMMSLobbyData_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgClientMMSLobbyData_Member| { &m.steam_id },
                |m: &mut CMsgClientMMSLobbyData_Member| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persona_name",
                |m: &CMsgClientMMSLobbyData_Member| { &m.persona_name },
                |m: &mut CMsgClientMMSLobbyData_Member| { &mut m.persona_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "metadata",
                |m: &CMsgClientMMSLobbyData_Member| { &m.metadata },
                |m: &mut CMsgClientMMSLobbyData_Member| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSLobbyData_Member>(
                "CMsgClientMMSLobbyData.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyData_Member {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSLobbyData_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSLobbyData_Member::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyData_Member {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.persona_name.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyData_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLobbyData_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSendLobbyChatMsg {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_target: ::std::option::Option<u64>,
    lobby_message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSendLobbyChatMsg {
    fn default() -> &'a CMsgClientMMSSendLobbyChatMsg {
        <CMsgClientMMSSendLobbyChatMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSendLobbyChatMsg {
    pub fn new() -> CMsgClientMMSSendLobbyChatMsg {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_target = 3;


    pub fn get_steam_id_target(&self) -> u64 {
        self.steam_id_target.unwrap_or(0)
    }
    pub fn clear_steam_id_target(&mut self) {
        self.steam_id_target = ::std::option::Option::None;
    }

    pub fn has_steam_id_target(&self) -> bool {
        self.steam_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_target(&mut self, v: u64) {
        self.steam_id_target = ::std::option::Option::Some(v);
    }

    // optional bytes lobby_message = 4;


    pub fn get_lobby_message(&self) -> &[u8] {
        match self.lobby_message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_lobby_message(&mut self) {
        self.lobby_message.clear();
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.lobby_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lobby_message.is_none() {
            self.lobby_message.set_default();
        }
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::std::vec::Vec<u8> {
        self.lobby_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSSendLobbyChatMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_target = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.lobby_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_target {
            my_size += 9;
        }
        if let Some(ref v) = self.lobby_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_target {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.lobby_message.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSendLobbyChatMsg {
        CMsgClientMMSSendLobbyChatMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSSendLobbyChatMsg| { &m.app_id },
                |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSendLobbyChatMsg| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_target",
                |m: &CMsgClientMMSSendLobbyChatMsg| { &m.steam_id_target },
                |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.steam_id_target },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "lobby_message",
                |m: &CMsgClientMMSSendLobbyChatMsg| { &m.lobby_message },
                |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.lobby_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSSendLobbyChatMsg>(
                "CMsgClientMMSSendLobbyChatMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSendLobbyChatMsg {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSSendLobbyChatMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSSendLobbyChatMsg::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSendLobbyChatMsg {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_target = ::std::option::Option::None;
        self.lobby_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSendLobbyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSendLobbyChatMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLobbyChatMsg {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_sender: ::std::option::Option<u64>,
    lobby_message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyChatMsg {
    fn default() -> &'a CMsgClientMMSLobbyChatMsg {
        <CMsgClientMMSLobbyChatMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyChatMsg {
    pub fn new() -> CMsgClientMMSLobbyChatMsg {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_sender = 3;


    pub fn get_steam_id_sender(&self) -> u64 {
        self.steam_id_sender.unwrap_or(0)
    }
    pub fn clear_steam_id_sender(&mut self) {
        self.steam_id_sender = ::std::option::Option::None;
    }

    pub fn has_steam_id_sender(&self) -> bool {
        self.steam_id_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_sender(&mut self, v: u64) {
        self.steam_id_sender = ::std::option::Option::Some(v);
    }

    // optional bytes lobby_message = 4;


    pub fn get_lobby_message(&self) -> &[u8] {
        match self.lobby_message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_lobby_message(&mut self) {
        self.lobby_message.clear();
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.lobby_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lobby_message.is_none() {
            self.lobby_message.set_default();
        }
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::std::vec::Vec<u8> {
        self.lobby_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyChatMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_sender = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.lobby_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_sender {
            my_size += 9;
        }
        if let Some(ref v) = self.lobby_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.lobby_message.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLobbyChatMsg {
        CMsgClientMMSLobbyChatMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSLobbyChatMsg| { &m.app_id },
                |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSLobbyChatMsg| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_sender",
                |m: &CMsgClientMMSLobbyChatMsg| { &m.steam_id_sender },
                |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.steam_id_sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "lobby_message",
                |m: &CMsgClientMMSLobbyChatMsg| { &m.lobby_message },
                |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.lobby_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSLobbyChatMsg>(
                "CMsgClientMMSLobbyChatMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyChatMsg {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSLobbyChatMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSLobbyChatMsg::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyChatMsg {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_sender = ::std::option::Option::None;
        self.lobby_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLobbyChatMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyOwner {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_new_owner: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyOwner {
    fn default() -> &'a CMsgClientMMSSetLobbyOwner {
        <CMsgClientMMSSetLobbyOwner as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyOwner {
    pub fn new() -> CMsgClientMMSSetLobbyOwner {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_new_owner = 3;


    pub fn get_steam_id_new_owner(&self) -> u64 {
        self.steam_id_new_owner.unwrap_or(0)
    }
    pub fn clear_steam_id_new_owner(&mut self) {
        self.steam_id_new_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_new_owner(&self) -> bool {
        self.steam_id_new_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_new_owner(&mut self, v: u64) {
        self.steam_id_new_owner = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyOwner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_new_owner = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_new_owner {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_new_owner {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyOwner {
        CMsgClientMMSSetLobbyOwner::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyOwner| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyOwner| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_new_owner",
                |m: &CMsgClientMMSSetLobbyOwner| { &m.steam_id_new_owner },
                |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.steam_id_new_owner },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSSetLobbyOwner>(
                "CMsgClientMMSSetLobbyOwner",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyOwner {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSSetLobbyOwner> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSSetLobbyOwner::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyOwner {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_new_owner = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyOwner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyOwner {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyOwnerResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyOwnerResponse {
    fn default() -> &'a CMsgClientMMSSetLobbyOwnerResponse {
        <CMsgClientMMSSetLobbyOwnerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyOwnerResponse {
    pub fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyOwnerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        CMsgClientMMSSetLobbyOwnerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.eresult },
                |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSSetLobbyOwnerResponse>(
                "CMsgClientMMSSetLobbyOwnerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyOwnerResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSSetLobbyOwnerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSSetLobbyOwnerResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyOwnerResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyOwnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyOwnerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyLinked {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_lobby2: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyLinked {
    fn default() -> &'a CMsgClientMMSSetLobbyLinked {
        <CMsgClientMMSSetLobbyLinked as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyLinked {
    pub fn new() -> CMsgClientMMSSetLobbyLinked {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby2 = 3;


    pub fn get_steam_id_lobby2(&self) -> u64 {
        self.steam_id_lobby2.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby2(&mut self) {
        self.steam_id_lobby2 = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby2(&self) -> bool {
        self.steam_id_lobby2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby2(&mut self, v: u64) {
        self.steam_id_lobby2 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyLinked {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby2 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_lobby2 {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_lobby2 {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyLinked {
        CMsgClientMMSSetLobbyLinked::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyLinked| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyLinked| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby2",
                |m: &CMsgClientMMSSetLobbyLinked| { &m.steam_id_lobby2 },
                |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.steam_id_lobby2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSSetLobbyLinked>(
                "CMsgClientMMSSetLobbyLinked",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyLinked {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSSetLobbyLinked> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSSetLobbyLinked::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyLinked {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_lobby2 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyLinked {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyLinked {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyGameServer {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    deprecated_game_server_ip: ::std::option::Option<u32>,
    game_server_port: ::std::option::Option<u32>,
    game_server_steam_id: ::std::option::Option<u64>,
    pub game_server_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyGameServer {
    fn default() -> &'a CMsgClientMMSSetLobbyGameServer {
        <CMsgClientMMSSetLobbyGameServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyGameServer {
    pub fn new() -> CMsgClientMMSSetLobbyGameServer {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_server_ip = 3;


    pub fn get_deprecated_game_server_ip(&self) -> u32 {
        self.deprecated_game_server_ip.unwrap_or(0)
    }
    pub fn clear_deprecated_game_server_ip(&mut self) {
        self.deprecated_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_server_ip(&self) -> bool {
        self.deprecated_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_server_ip(&mut self, v: u32) {
        self.deprecated_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 4;


    pub fn get_game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }
    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_server_steam_id = 5;


    pub fn get_game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }
    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgIPAddress game_server_ip = 6;


    pub fn get_game_server_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.game_server_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_game_server_ip(&mut self) {
        self.game_server_ip.clear();
    }

    pub fn has_game_server_ip(&self) -> bool {
        self.game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.game_server_ip = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        if self.game_server_ip.is_none() {
            self.game_server_ip.set_default();
        }
        self.game_server_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_server_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.game_server_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyGameServer {
    fn is_initialized(&self) -> bool {
        for v in &self.game_server_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_game_server_ip = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_server_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_server_steam_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.game_server_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += 9;
        }
        if let Some(ref v) = self.game_server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(ref v) = self.game_server_ip.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyGameServer {
        CMsgClientMMSSetLobbyGameServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_game_server_ip",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.deprecated_game_server_ip },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.deprecated_game_server_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_server_port",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_port },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_server_steam_id",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_steam_id },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>>(
                "game_server_ip",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_ip },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSSetLobbyGameServer>(
                "CMsgClientMMSSetLobbyGameServer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyGameServer {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSSetLobbyGameServer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSSetLobbyGameServer::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyGameServer {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.deprecated_game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.game_server_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyGameServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyGameServer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLobbyGameServerSet {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    deprecated_game_server_ip: ::std::option::Option<u32>,
    game_server_port: ::std::option::Option<u32>,
    game_server_steam_id: ::std::option::Option<u64>,
    pub game_server_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyGameServerSet {
    fn default() -> &'a CMsgClientMMSLobbyGameServerSet {
        <CMsgClientMMSLobbyGameServerSet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyGameServerSet {
    pub fn new() -> CMsgClientMMSLobbyGameServerSet {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_server_ip = 3;


    pub fn get_deprecated_game_server_ip(&self) -> u32 {
        self.deprecated_game_server_ip.unwrap_or(0)
    }
    pub fn clear_deprecated_game_server_ip(&mut self) {
        self.deprecated_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_server_ip(&self) -> bool {
        self.deprecated_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_server_ip(&mut self, v: u32) {
        self.deprecated_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 4;


    pub fn get_game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }
    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_server_steam_id = 5;


    pub fn get_game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }
    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgIPAddress game_server_ip = 6;


    pub fn get_game_server_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.game_server_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_game_server_ip(&mut self) {
        self.game_server_ip.clear();
    }

    pub fn has_game_server_ip(&self) -> bool {
        self.game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.game_server_ip = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        if self.game_server_ip.is_none() {
            self.game_server_ip.set_default();
        }
        self.game_server_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_server_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.game_server_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyGameServerSet {
    fn is_initialized(&self) -> bool {
        for v in &self.game_server_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_game_server_ip = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_server_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_server_steam_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.game_server_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += 9;
        }
        if let Some(ref v) = self.game_server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(ref v) = self.game_server_ip.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLobbyGameServerSet {
        CMsgClientMMSLobbyGameServerSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.app_id },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_game_server_ip",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.deprecated_game_server_ip },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.deprecated_game_server_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_server_port",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_port },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_server_steam_id",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_steam_id },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>>(
                "game_server_ip",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_ip },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSLobbyGameServerSet>(
                "CMsgClientMMSLobbyGameServerSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyGameServerSet {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSLobbyGameServerSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSLobbyGameServerSet::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyGameServerSet {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.deprecated_game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.game_server_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyGameServerSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLobbyGameServerSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSUserJoinedLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_user: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSUserJoinedLobby {
    fn default() -> &'a CMsgClientMMSUserJoinedLobby {
        <CMsgClientMMSUserJoinedLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSUserJoinedLobby {
    pub fn new() -> CMsgClientMMSUserJoinedLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user = 3;


    pub fn get_steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }
    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 4;


    pub fn get_persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSUserJoinedLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_user = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_user {
            my_size += 9;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSUserJoinedLobby {
        CMsgClientMMSUserJoinedLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSUserJoinedLobby| { &m.app_id },
                |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSUserJoinedLobby| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_user",
                |m: &CMsgClientMMSUserJoinedLobby| { &m.steam_id_user },
                |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.steam_id_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persona_name",
                |m: &CMsgClientMMSUserJoinedLobby| { &m.persona_name },
                |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.persona_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSUserJoinedLobby>(
                "CMsgClientMMSUserJoinedLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSUserJoinedLobby {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSUserJoinedLobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSUserJoinedLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSUserJoinedLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user = ::std::option::Option::None;
        self.persona_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSUserJoinedLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSUserJoinedLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSUserLeftLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_user: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSUserLeftLobby {
    fn default() -> &'a CMsgClientMMSUserLeftLobby {
        <CMsgClientMMSUserLeftLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSUserLeftLobby {
    pub fn new() -> CMsgClientMMSUserLeftLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user = 3;


    pub fn get_steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }
    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 4;


    pub fn get_persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSUserLeftLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_user = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_user {
            my_size += 9;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSUserLeftLobby {
        CMsgClientMMSUserLeftLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSUserLeftLobby| { &m.app_id },
                |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSUserLeftLobby| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_user",
                |m: &CMsgClientMMSUserLeftLobby| { &m.steam_id_user },
                |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.steam_id_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persona_name",
                |m: &CMsgClientMMSUserLeftLobby| { &m.persona_name },
                |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.persona_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSUserLeftLobby>(
                "CMsgClientMMSUserLeftLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSUserLeftLobby {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSUserLeftLobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSUserLeftLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSUserLeftLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user = ::std::option::Option::None;
        self.persona_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSUserLeftLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSUserLeftLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSInviteToLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_user_invited: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSInviteToLobby {
    fn default() -> &'a CMsgClientMMSInviteToLobby {
        <CMsgClientMMSInviteToLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSInviteToLobby {
    pub fn new() -> CMsgClientMMSInviteToLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user_invited = 3;


    pub fn get_steam_id_user_invited(&self) -> u64 {
        self.steam_id_user_invited.unwrap_or(0)
    }
    pub fn clear_steam_id_user_invited(&mut self) {
        self.steam_id_user_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_user_invited(&self) -> bool {
        self.steam_id_user_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user_invited(&mut self, v: u64) {
        self.steam_id_user_invited = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSInviteToLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_user_invited = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_user_invited {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user_invited {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSInviteToLobby {
        CMsgClientMMSInviteToLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSInviteToLobby| { &m.app_id },
                |m: &mut CMsgClientMMSInviteToLobby| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSInviteToLobby| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSInviteToLobby| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_user_invited",
                |m: &CMsgClientMMSInviteToLobby| { &m.steam_id_user_invited },
                |m: &mut CMsgClientMMSInviteToLobby| { &mut m.steam_id_user_invited },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSInviteToLobby>(
                "CMsgClientMMSInviteToLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSInviteToLobby {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSInviteToLobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSInviteToLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSInviteToLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user_invited = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSInviteToLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSInviteToLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyStatus {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    claim_membership: ::std::option::Option<bool>,
    claim_ownership: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyStatus {
    fn default() -> &'a CMsgClientMMSGetLobbyStatus {
        <CMsgClientMMSGetLobbyStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyStatus {
    pub fn new() -> CMsgClientMMSGetLobbyStatus {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional bool claim_membership = 3;


    pub fn get_claim_membership(&self) -> bool {
        self.claim_membership.unwrap_or(false)
    }
    pub fn clear_claim_membership(&mut self) {
        self.claim_membership = ::std::option::Option::None;
    }

    pub fn has_claim_membership(&self) -> bool {
        self.claim_membership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_membership(&mut self, v: bool) {
        self.claim_membership = ::std::option::Option::Some(v);
    }

    // optional bool claim_ownership = 4;


    pub fn get_claim_ownership(&self) -> bool {
        self.claim_ownership.unwrap_or(false)
    }
    pub fn clear_claim_ownership(&mut self) {
        self.claim_ownership = ::std::option::Option::None;
    }

    pub fn has_claim_ownership(&self) -> bool {
        self.claim_ownership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_ownership(&mut self, v: bool) {
        self.claim_ownership = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.claim_membership = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.claim_ownership = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.claim_membership {
            my_size += 2;
        }
        if let Some(v) = self.claim_ownership {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.claim_membership {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.claim_ownership {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyStatus {
        CMsgClientMMSGetLobbyStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSGetLobbyStatus| { &m.app_id },
                |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSGetLobbyStatus| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "claim_membership",
                |m: &CMsgClientMMSGetLobbyStatus| { &m.claim_membership },
                |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.claim_membership },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "claim_ownership",
                |m: &CMsgClientMMSGetLobbyStatus| { &m.claim_ownership },
                |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.claim_ownership },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSGetLobbyStatus>(
                "CMsgClientMMSGetLobbyStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyStatus {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSGetLobbyStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSGetLobbyStatus::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyStatus {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.claim_membership = ::std::option::Option::None;
        self.claim_ownership = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyStatusResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    lobby_status: ::std::option::Option<EMMSLobbyStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyStatusResponse {
    fn default() -> &'a CMsgClientMMSGetLobbyStatusResponse {
        <CMsgClientMMSGetLobbyStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyStatusResponse {
    pub fn new() -> CMsgClientMMSGetLobbyStatusResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;


    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional .EMMSLobbyStatus lobby_status = 3;


    pub fn get_lobby_status(&self) -> EMMSLobbyStatus {
        self.lobby_status.unwrap_or(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid)
    }
    pub fn clear_lobby_status(&mut self) {
        self.lobby_status = ::std::option::Option::None;
    }

    pub fn has_lobby_status(&self) -> bool {
        self.lobby_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_status(&mut self, v: EMMSLobbyStatus) {
        self.lobby_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.lobby_status, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.lobby_status {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.lobby_status {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyStatusResponse {
        CMsgClientMMSGetLobbyStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.app_id },
                |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_lobby",
                |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.steam_id_lobby },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EMMSLobbyStatus>>(
                "lobby_status",
                |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.lobby_status },
                |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.lobby_status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientMMSGetLobbyStatusResponse>(
                "CMsgClientMMSGetLobbyStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyStatusResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientMMSGetLobbyStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientMMSGetLobbyStatusResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyStatusResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.lobby_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientInviteToGame {
    // message fields
    steam_id_dest: ::std::option::Option<u64>,
    steam_id_src: ::std::option::Option<u64>,
    connect_string: ::protobuf::SingularField<::std::string::String>,
    remote_play: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientInviteToGame {
    fn default() -> &'a CMsgClientInviteToGame {
        <CMsgClientInviteToGame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInviteToGame {
    pub fn new() -> CMsgClientInviteToGame {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;


    pub fn get_steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }
    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;


    pub fn get_steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }
    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional string connect_string = 3;


    pub fn get_connect_string(&self) -> &str {
        match self.connect_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_connect_string(&mut self) {
        self.connect_string.clear();
    }

    pub fn has_connect_string(&self) -> bool {
        self.connect_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_string(&mut self, v: ::std::string::String) {
        self.connect_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_string(&mut self) -> &mut ::std::string::String {
        if self.connect_string.is_none() {
            self.connect_string.set_default();
        }
        self.connect_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_string(&mut self) -> ::std::string::String {
        self.connect_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string remote_play = 4;


    pub fn get_remote_play(&self) -> &str {
        match self.remote_play.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_remote_play(&mut self) {
        self.remote_play.clear();
    }

    pub fn has_remote_play(&self) -> bool {
        self.remote_play.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_play(&mut self, v: ::std::string::String) {
        self.remote_play = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_play(&mut self) -> &mut ::std::string::String {
        if self.remote_play.is_none() {
            self.remote_play.set_default();
        }
        self.remote_play.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_play(&mut self) -> ::std::string::String {
        self.remote_play.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientInviteToGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_dest = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_src = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.connect_string)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.remote_play)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 9;
        }
        if let Some(ref v) = self.connect_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.remote_play.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.connect_string.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.remote_play.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientInviteToGame {
        CMsgClientInviteToGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_dest",
                |m: &CMsgClientInviteToGame| { &m.steam_id_dest },
                |m: &mut CMsgClientInviteToGame| { &mut m.steam_id_dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_src",
                |m: &CMsgClientInviteToGame| { &m.steam_id_src },
                |m: &mut CMsgClientInviteToGame| { &mut m.steam_id_src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "connect_string",
                |m: &CMsgClientInviteToGame| { &m.connect_string },
                |m: &mut CMsgClientInviteToGame| { &mut m.connect_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remote_play",
                |m: &CMsgClientInviteToGame| { &m.remote_play },
                |m: &mut CMsgClientInviteToGame| { &mut m.remote_play },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientInviteToGame>(
                "CMsgClientInviteToGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientInviteToGame {
        static instance: ::protobuf::rt::LazyV2<CMsgClientInviteToGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientInviteToGame::new)
    }
}

impl ::protobuf::Clear for CMsgClientInviteToGame {
    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.connect_string.clear();
        self.remote_play.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientInviteToGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientInviteToGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientChatInvite {
    // message fields
    steam_id_invited: ::std::option::Option<u64>,
    steam_id_chat: ::std::option::Option<u64>,
    steam_id_patron: ::std::option::Option<u64>,
    chatroom_type: ::std::option::Option<i32>,
    steam_id_friend_chat: ::std::option::Option<u64>,
    chat_name: ::protobuf::SingularField<::std::string::String>,
    game_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatInvite {
    fn default() -> &'a CMsgClientChatInvite {
        <CMsgClientChatInvite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatInvite {
    pub fn new() -> CMsgClientChatInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_invited = 1;


    pub fn get_steam_id_invited(&self) -> u64 {
        self.steam_id_invited.unwrap_or(0)
    }
    pub fn clear_steam_id_invited(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_invited(&self) -> bool {
        self.steam_id_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_invited(&mut self, v: u64) {
        self.steam_id_invited = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_chat = 2;


    pub fn get_steam_id_chat(&self) -> u64 {
        self.steam_id_chat.unwrap_or(0)
    }
    pub fn clear_steam_id_chat(&mut self) {
        self.steam_id_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_chat(&self) -> bool {
        self.steam_id_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_chat(&mut self, v: u64) {
        self.steam_id_chat = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_patron = 3;


    pub fn get_steam_id_patron(&self) -> u64 {
        self.steam_id_patron.unwrap_or(0)
    }
    pub fn clear_steam_id_patron(&mut self) {
        self.steam_id_patron = ::std::option::Option::None;
    }

    pub fn has_steam_id_patron(&self) -> bool {
        self.steam_id_patron.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_patron(&mut self, v: u64) {
        self.steam_id_patron = ::std::option::Option::Some(v);
    }

    // optional int32 chatroom_type = 4;


    pub fn get_chatroom_type(&self) -> i32 {
        self.chatroom_type.unwrap_or(0)
    }
    pub fn clear_chatroom_type(&mut self) {
        self.chatroom_type = ::std::option::Option::None;
    }

    pub fn has_chatroom_type(&self) -> bool {
        self.chatroom_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatroom_type(&mut self, v: i32) {
        self.chatroom_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_friend_chat = 5;


    pub fn get_steam_id_friend_chat(&self) -> u64 {
        self.steam_id_friend_chat.unwrap_or(0)
    }
    pub fn clear_steam_id_friend_chat(&mut self) {
        self.steam_id_friend_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_friend_chat(&self) -> bool {
        self.steam_id_friend_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_friend_chat(&mut self, v: u64) {
        self.steam_id_friend_chat = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 6;


    pub fn get_chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_name(&mut self) {
        self.chat_name.clear();
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name.set_default();
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 game_id = 7;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChatInvite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_invited = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_chat = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_patron = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chatroom_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_friend_chat = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_invited {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_chat {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_patron {
            my_size += 9;
        }
        if let Some(v) = self.chatroom_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_friend_chat {
            my_size += 9;
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_invited {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_chat {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_patron {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.chatroom_type {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.steam_id_friend_chat {
            os.write_fixed64(5, v)?;
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChatInvite {
        CMsgClientChatInvite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_invited",
                |m: &CMsgClientChatInvite| { &m.steam_id_invited },
                |m: &mut CMsgClientChatInvite| { &mut m.steam_id_invited },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_chat",
                |m: &CMsgClientChatInvite| { &m.steam_id_chat },
                |m: &mut CMsgClientChatInvite| { &mut m.steam_id_chat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_patron",
                |m: &CMsgClientChatInvite| { &m.steam_id_patron },
                |m: &mut CMsgClientChatInvite| { &mut m.steam_id_patron },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chatroom_type",
                |m: &CMsgClientChatInvite| { &m.chatroom_type },
                |m: &mut CMsgClientChatInvite| { &mut m.chatroom_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_friend_chat",
                |m: &CMsgClientChatInvite| { &m.steam_id_friend_chat },
                |m: &mut CMsgClientChatInvite| { &mut m.steam_id_friend_chat },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "chat_name",
                |m: &CMsgClientChatInvite| { &m.chat_name },
                |m: &mut CMsgClientChatInvite| { &mut m.chat_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_id",
                |m: &CMsgClientChatInvite| { &m.game_id },
                |m: &mut CMsgClientChatInvite| { &mut m.game_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientChatInvite>(
                "CMsgClientChatInvite",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChatInvite {
        static instance: ::protobuf::rt::LazyV2<CMsgClientChatInvite> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientChatInvite::new)
    }
}

impl ::protobuf::Clear for CMsgClientChatInvite {
    fn clear(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
        self.steam_id_chat = ::std::option::Option::None;
        self.steam_id_patron = ::std::option::Option::None;
        self.chatroom_type = ::std::option::Option::None;
        self.steam_id_friend_chat = ::std::option::Option::None;
        self.chat_name.clear();
        self.game_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChatInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatInvite {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientConnectionStats {
    // message fields
    pub stats_logon: ::protobuf::SingularPtrField<CMsgClientConnectionStats_Stats_Logon>,
    pub stats_vconn: ::protobuf::SingularPtrField<CMsgClientConnectionStats_Stats_VConn>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientConnectionStats {
    fn default() -> &'a CMsgClientConnectionStats {
        <CMsgClientConnectionStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientConnectionStats {
    pub fn new() -> CMsgClientConnectionStats {
        ::std::default::Default::default()
    }

    // optional .CMsgClientConnectionStats.Stats_Logon stats_logon = 1;


    pub fn get_stats_logon(&self) -> &CMsgClientConnectionStats_Stats_Logon {
        self.stats_logon.as_ref().unwrap_or_else(|| <CMsgClientConnectionStats_Stats_Logon as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats_logon(&mut self) {
        self.stats_logon.clear();
    }

    pub fn has_stats_logon(&self) -> bool {
        self.stats_logon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_logon(&mut self, v: CMsgClientConnectionStats_Stats_Logon) {
        self.stats_logon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_logon(&mut self) -> &mut CMsgClientConnectionStats_Stats_Logon {
        if self.stats_logon.is_none() {
            self.stats_logon.set_default();
        }
        self.stats_logon.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_logon(&mut self) -> CMsgClientConnectionStats_Stats_Logon {
        self.stats_logon.take().unwrap_or_else(|| CMsgClientConnectionStats_Stats_Logon::new())
    }

    // optional .CMsgClientConnectionStats.Stats_VConn stats_vconn = 2;


    pub fn get_stats_vconn(&self) -> &CMsgClientConnectionStats_Stats_VConn {
        self.stats_vconn.as_ref().unwrap_or_else(|| <CMsgClientConnectionStats_Stats_VConn as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats_vconn(&mut self) {
        self.stats_vconn.clear();
    }

    pub fn has_stats_vconn(&self) -> bool {
        self.stats_vconn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_vconn(&mut self, v: CMsgClientConnectionStats_Stats_VConn) {
        self.stats_vconn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_vconn(&mut self) -> &mut CMsgClientConnectionStats_Stats_VConn {
        if self.stats_vconn.is_none() {
            self.stats_vconn.set_default();
        }
        self.stats_vconn.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_vconn(&mut self) -> CMsgClientConnectionStats_Stats_VConn {
        self.stats_vconn.take().unwrap_or_else(|| CMsgClientConnectionStats_Stats_VConn::new())
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats_logon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_vconn {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_logon)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_vconn)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats_logon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats_vconn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats_logon.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats_vconn.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientConnectionStats {
        CMsgClientConnectionStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientConnectionStats_Stats_Logon>>(
                "stats_logon",
                |m: &CMsgClientConnectionStats| { &m.stats_logon },
                |m: &mut CMsgClientConnectionStats| { &mut m.stats_logon },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientConnectionStats_Stats_VConn>>(
                "stats_vconn",
                |m: &CMsgClientConnectionStats| { &m.stats_vconn },
                |m: &mut CMsgClientConnectionStats| { &mut m.stats_vconn },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientConnectionStats>(
                "CMsgClientConnectionStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientConnectionStats {
        static instance: ::protobuf::rt::LazyV2<CMsgClientConnectionStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientConnectionStats::new)
    }
}

impl ::protobuf::Clear for CMsgClientConnectionStats {
    fn clear(&mut self) {
        self.stats_logon.clear();
        self.stats_vconn.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientConnectionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientConnectionStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientConnectionStats_Stats_Logon {
    // message fields
    connect_attempts: ::std::option::Option<i32>,
    connect_successes: ::std::option::Option<i32>,
    connect_failures: ::std::option::Option<i32>,
    connections_dropped: ::std::option::Option<i32>,
    seconds_running: ::std::option::Option<u32>,
    msec_tologonthistime: ::std::option::Option<u32>,
    count_bad_cms: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientConnectionStats_Stats_Logon {
    fn default() -> &'a CMsgClientConnectionStats_Stats_Logon {
        <CMsgClientConnectionStats_Stats_Logon as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientConnectionStats_Stats_Logon {
    pub fn new() -> CMsgClientConnectionStats_Stats_Logon {
        ::std::default::Default::default()
    }

    // optional int32 connect_attempts = 1;


    pub fn get_connect_attempts(&self) -> i32 {
        self.connect_attempts.unwrap_or(0)
    }
    pub fn clear_connect_attempts(&mut self) {
        self.connect_attempts = ::std::option::Option::None;
    }

    pub fn has_connect_attempts(&self) -> bool {
        self.connect_attempts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_attempts(&mut self, v: i32) {
        self.connect_attempts = ::std::option::Option::Some(v);
    }

    // optional int32 connect_successes = 2;


    pub fn get_connect_successes(&self) -> i32 {
        self.connect_successes.unwrap_or(0)
    }
    pub fn clear_connect_successes(&mut self) {
        self.connect_successes = ::std::option::Option::None;
    }

    pub fn has_connect_successes(&self) -> bool {
        self.connect_successes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_successes(&mut self, v: i32) {
        self.connect_successes = ::std::option::Option::Some(v);
    }

    // optional int32 connect_failures = 3;


    pub fn get_connect_failures(&self) -> i32 {
        self.connect_failures.unwrap_or(0)
    }
    pub fn clear_connect_failures(&mut self) {
        self.connect_failures = ::std::option::Option::None;
    }

    pub fn has_connect_failures(&self) -> bool {
        self.connect_failures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_failures(&mut self, v: i32) {
        self.connect_failures = ::std::option::Option::Some(v);
    }

    // optional int32 connections_dropped = 4;


    pub fn get_connections_dropped(&self) -> i32 {
        self.connections_dropped.unwrap_or(0)
    }
    pub fn clear_connections_dropped(&mut self) {
        self.connections_dropped = ::std::option::Option::None;
    }

    pub fn has_connections_dropped(&self) -> bool {
        self.connections_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connections_dropped(&mut self, v: i32) {
        self.connections_dropped = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_running = 5;


    pub fn get_seconds_running(&self) -> u32 {
        self.seconds_running.unwrap_or(0)
    }
    pub fn clear_seconds_running(&mut self) {
        self.seconds_running = ::std::option::Option::None;
    }

    pub fn has_seconds_running(&self) -> bool {
        self.seconds_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_running(&mut self, v: u32) {
        self.seconds_running = ::std::option::Option::Some(v);
    }

    // optional uint32 msec_tologonthistime = 6;


    pub fn get_msec_tologonthistime(&self) -> u32 {
        self.msec_tologonthistime.unwrap_or(0)
    }
    pub fn clear_msec_tologonthistime(&mut self) {
        self.msec_tologonthistime = ::std::option::Option::None;
    }

    pub fn has_msec_tologonthistime(&self) -> bool {
        self.msec_tologonthistime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msec_tologonthistime(&mut self, v: u32) {
        self.msec_tologonthistime = ::std::option::Option::Some(v);
    }

    // optional uint32 count_bad_cms = 7;


    pub fn get_count_bad_cms(&self) -> u32 {
        self.count_bad_cms.unwrap_or(0)
    }
    pub fn clear_count_bad_cms(&mut self) {
        self.count_bad_cms = ::std::option::Option::None;
    }

    pub fn has_count_bad_cms(&self) -> bool {
        self.count_bad_cms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_bad_cms(&mut self, v: u32) {
        self.count_bad_cms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats_Stats_Logon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.connect_attempts = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.connect_successes = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.connect_failures = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.connections_dropped = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_running = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msec_tologonthistime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count_bad_cms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connect_attempts {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connect_successes {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connect_failures {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connections_dropped {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_running {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msec_tologonthistime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count_bad_cms {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connect_attempts {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.connect_successes {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.connect_failures {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.connections_dropped {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.seconds_running {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.msec_tologonthistime {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.count_bad_cms {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientConnectionStats_Stats_Logon {
        CMsgClientConnectionStats_Stats_Logon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "connect_attempts",
                |m: &CMsgClientConnectionStats_Stats_Logon| { &m.connect_attempts },
                |m: &mut CMsgClientConnectionStats_Stats_Logon| { &mut m.connect_attempts },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "connect_successes",
                |m: &CMsgClientConnectionStats_Stats_Logon| { &m.connect_successes },
                |m: &mut CMsgClientConnectionStats_Stats_Logon| { &mut m.connect_successes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "connect_failures",
                |m: &CMsgClientConnectionStats_Stats_Logon| { &m.connect_failures },
                |m: &mut CMsgClientConnectionStats_Stats_Logon| { &mut m.connect_failures },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "connections_dropped",
                |m: &CMsgClientConnectionStats_Stats_Logon| { &m.connections_dropped },
                |m: &mut CMsgClientConnectionStats_Stats_Logon| { &mut m.connections_dropped },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_running",
                |m: &CMsgClientConnectionStats_Stats_Logon| { &m.seconds_running },
                |m: &mut CMsgClientConnectionStats_Stats_Logon| { &mut m.seconds_running },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "msec_tologonthistime",
                |m: &CMsgClientConnectionStats_Stats_Logon| { &m.msec_tologonthistime },
                |m: &mut CMsgClientConnectionStats_Stats_Logon| { &mut m.msec_tologonthistime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count_bad_cms",
                |m: &CMsgClientConnectionStats_Stats_Logon| { &m.count_bad_cms },
                |m: &mut CMsgClientConnectionStats_Stats_Logon| { &mut m.count_bad_cms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientConnectionStats_Stats_Logon>(
                "CMsgClientConnectionStats.Stats_Logon",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientConnectionStats_Stats_Logon {
        static instance: ::protobuf::rt::LazyV2<CMsgClientConnectionStats_Stats_Logon> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientConnectionStats_Stats_Logon::new)
    }
}

impl ::protobuf::Clear for CMsgClientConnectionStats_Stats_Logon {
    fn clear(&mut self) {
        self.connect_attempts = ::std::option::Option::None;
        self.connect_successes = ::std::option::Option::None;
        self.connect_failures = ::std::option::Option::None;
        self.connections_dropped = ::std::option::Option::None;
        self.seconds_running = ::std::option::Option::None;
        self.msec_tologonthistime = ::std::option::Option::None;
        self.count_bad_cms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientConnectionStats_Stats_Logon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientConnectionStats_Stats_Logon {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientConnectionStats_Stats_UDP {
    // message fields
    pkts_sent: ::std::option::Option<u64>,
    bytes_sent: ::std::option::Option<u64>,
    pkts_recv: ::std::option::Option<u64>,
    pkts_processed: ::std::option::Option<u64>,
    bytes_recv: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientConnectionStats_Stats_UDP {
    fn default() -> &'a CMsgClientConnectionStats_Stats_UDP {
        <CMsgClientConnectionStats_Stats_UDP as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientConnectionStats_Stats_UDP {
    pub fn new() -> CMsgClientConnectionStats_Stats_UDP {
        ::std::default::Default::default()
    }

    // optional uint64 pkts_sent = 1;


    pub fn get_pkts_sent(&self) -> u64 {
        self.pkts_sent.unwrap_or(0)
    }
    pub fn clear_pkts_sent(&mut self) {
        self.pkts_sent = ::std::option::Option::None;
    }

    pub fn has_pkts_sent(&self) -> bool {
        self.pkts_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkts_sent(&mut self, v: u64) {
        self.pkts_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_sent = 2;


    pub fn get_bytes_sent(&self) -> u64 {
        self.bytes_sent.unwrap_or(0)
    }
    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = ::std::option::Option::None;
    }

    pub fn has_bytes_sent(&self) -> bool {
        self.bytes_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: u64) {
        self.bytes_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 pkts_recv = 3;


    pub fn get_pkts_recv(&self) -> u64 {
        self.pkts_recv.unwrap_or(0)
    }
    pub fn clear_pkts_recv(&mut self) {
        self.pkts_recv = ::std::option::Option::None;
    }

    pub fn has_pkts_recv(&self) -> bool {
        self.pkts_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkts_recv(&mut self, v: u64) {
        self.pkts_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 pkts_processed = 4;


    pub fn get_pkts_processed(&self) -> u64 {
        self.pkts_processed.unwrap_or(0)
    }
    pub fn clear_pkts_processed(&mut self) {
        self.pkts_processed = ::std::option::Option::None;
    }

    pub fn has_pkts_processed(&self) -> bool {
        self.pkts_processed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkts_processed(&mut self, v: u64) {
        self.pkts_processed = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_recv = 5;


    pub fn get_bytes_recv(&self) -> u64 {
        self.bytes_recv.unwrap_or(0)
    }
    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = ::std::option::Option::None;
    }

    pub fn has_bytes_recv(&self) -> bool {
        self.bytes_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: u64) {
        self.bytes_recv = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats_Stats_UDP {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pkts_sent = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_sent = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pkts_recv = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pkts_processed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_recv = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pkts_sent {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_sent {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pkts_recv {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pkts_processed {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_recv {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pkts_sent {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.bytes_sent {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.pkts_recv {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.pkts_processed {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.bytes_recv {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientConnectionStats_Stats_UDP {
        CMsgClientConnectionStats_Stats_UDP::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pkts_sent",
                |m: &CMsgClientConnectionStats_Stats_UDP| { &m.pkts_sent },
                |m: &mut CMsgClientConnectionStats_Stats_UDP| { &mut m.pkts_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_sent",
                |m: &CMsgClientConnectionStats_Stats_UDP| { &m.bytes_sent },
                |m: &mut CMsgClientConnectionStats_Stats_UDP| { &mut m.bytes_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pkts_recv",
                |m: &CMsgClientConnectionStats_Stats_UDP| { &m.pkts_recv },
                |m: &mut CMsgClientConnectionStats_Stats_UDP| { &mut m.pkts_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pkts_processed",
                |m: &CMsgClientConnectionStats_Stats_UDP| { &m.pkts_processed },
                |m: &mut CMsgClientConnectionStats_Stats_UDP| { &mut m.pkts_processed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_recv",
                |m: &CMsgClientConnectionStats_Stats_UDP| { &m.bytes_recv },
                |m: &mut CMsgClientConnectionStats_Stats_UDP| { &mut m.bytes_recv },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientConnectionStats_Stats_UDP>(
                "CMsgClientConnectionStats.Stats_UDP",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientConnectionStats_Stats_UDP {
        static instance: ::protobuf::rt::LazyV2<CMsgClientConnectionStats_Stats_UDP> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientConnectionStats_Stats_UDP::new)
    }
}

impl ::protobuf::Clear for CMsgClientConnectionStats_Stats_UDP {
    fn clear(&mut self) {
        self.pkts_sent = ::std::option::Option::None;
        self.bytes_sent = ::std::option::Option::None;
        self.pkts_recv = ::std::option::Option::None;
        self.pkts_processed = ::std::option::Option::None;
        self.bytes_recv = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientConnectionStats_Stats_UDP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientConnectionStats_Stats_UDP {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientConnectionStats_Stats_VConn {
    // message fields
    connections_udp: ::std::option::Option<u32>,
    connections_tcp: ::std::option::Option<u32>,
    pub stats_udp: ::protobuf::SingularPtrField<CMsgClientConnectionStats_Stats_UDP>,
    pkts_abandoned: ::std::option::Option<u64>,
    conn_req_received: ::std::option::Option<u64>,
    pkts_resent: ::std::option::Option<u64>,
    msgs_sent: ::std::option::Option<u64>,
    msgs_sent_failed: ::std::option::Option<u64>,
    msgs_recv: ::std::option::Option<u64>,
    datagrams_sent: ::std::option::Option<u64>,
    datagrams_recv: ::std::option::Option<u64>,
    bad_pkts_recv: ::std::option::Option<u64>,
    unknown_conn_pkts_recv: ::std::option::Option<u64>,
    missed_pkts_recv: ::std::option::Option<u64>,
    dup_pkts_recv: ::std::option::Option<u64>,
    failed_connect_challenges: ::std::option::Option<u64>,
    micro_sec_avg_latency: ::std::option::Option<u32>,
    micro_sec_min_latency: ::std::option::Option<u32>,
    micro_sec_max_latency: ::std::option::Option<u32>,
    mem_pool_msg_in_use: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientConnectionStats_Stats_VConn {
    fn default() -> &'a CMsgClientConnectionStats_Stats_VConn {
        <CMsgClientConnectionStats_Stats_VConn as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientConnectionStats_Stats_VConn {
    pub fn new() -> CMsgClientConnectionStats_Stats_VConn {
        ::std::default::Default::default()
    }

    // optional uint32 connections_udp = 1;


    pub fn get_connections_udp(&self) -> u32 {
        self.connections_udp.unwrap_or(0)
    }
    pub fn clear_connections_udp(&mut self) {
        self.connections_udp = ::std::option::Option::None;
    }

    pub fn has_connections_udp(&self) -> bool {
        self.connections_udp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connections_udp(&mut self, v: u32) {
        self.connections_udp = ::std::option::Option::Some(v);
    }

    // optional uint32 connections_tcp = 2;


    pub fn get_connections_tcp(&self) -> u32 {
        self.connections_tcp.unwrap_or(0)
    }
    pub fn clear_connections_tcp(&mut self) {
        self.connections_tcp = ::std::option::Option::None;
    }

    pub fn has_connections_tcp(&self) -> bool {
        self.connections_tcp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connections_tcp(&mut self, v: u32) {
        self.connections_tcp = ::std::option::Option::Some(v);
    }

    // optional .CMsgClientConnectionStats.Stats_UDP stats_udp = 3;


    pub fn get_stats_udp(&self) -> &CMsgClientConnectionStats_Stats_UDP {
        self.stats_udp.as_ref().unwrap_or_else(|| <CMsgClientConnectionStats_Stats_UDP as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats_udp(&mut self) {
        self.stats_udp.clear();
    }

    pub fn has_stats_udp(&self) -> bool {
        self.stats_udp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_udp(&mut self, v: CMsgClientConnectionStats_Stats_UDP) {
        self.stats_udp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_udp(&mut self) -> &mut CMsgClientConnectionStats_Stats_UDP {
        if self.stats_udp.is_none() {
            self.stats_udp.set_default();
        }
        self.stats_udp.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_udp(&mut self) -> CMsgClientConnectionStats_Stats_UDP {
        self.stats_udp.take().unwrap_or_else(|| CMsgClientConnectionStats_Stats_UDP::new())
    }

    // optional uint64 pkts_abandoned = 4;


    pub fn get_pkts_abandoned(&self) -> u64 {
        self.pkts_abandoned.unwrap_or(0)
    }
    pub fn clear_pkts_abandoned(&mut self) {
        self.pkts_abandoned = ::std::option::Option::None;
    }

    pub fn has_pkts_abandoned(&self) -> bool {
        self.pkts_abandoned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkts_abandoned(&mut self, v: u64) {
        self.pkts_abandoned = ::std::option::Option::Some(v);
    }

    // optional uint64 conn_req_received = 5;


    pub fn get_conn_req_received(&self) -> u64 {
        self.conn_req_received.unwrap_or(0)
    }
    pub fn clear_conn_req_received(&mut self) {
        self.conn_req_received = ::std::option::Option::None;
    }

    pub fn has_conn_req_received(&self) -> bool {
        self.conn_req_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conn_req_received(&mut self, v: u64) {
        self.conn_req_received = ::std::option::Option::Some(v);
    }

    // optional uint64 pkts_resent = 6;


    pub fn get_pkts_resent(&self) -> u64 {
        self.pkts_resent.unwrap_or(0)
    }
    pub fn clear_pkts_resent(&mut self) {
        self.pkts_resent = ::std::option::Option::None;
    }

    pub fn has_pkts_resent(&self) -> bool {
        self.pkts_resent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkts_resent(&mut self, v: u64) {
        self.pkts_resent = ::std::option::Option::Some(v);
    }

    // optional uint64 msgs_sent = 7;


    pub fn get_msgs_sent(&self) -> u64 {
        self.msgs_sent.unwrap_or(0)
    }
    pub fn clear_msgs_sent(&mut self) {
        self.msgs_sent = ::std::option::Option::None;
    }

    pub fn has_msgs_sent(&self) -> bool {
        self.msgs_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgs_sent(&mut self, v: u64) {
        self.msgs_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 msgs_sent_failed = 8;


    pub fn get_msgs_sent_failed(&self) -> u64 {
        self.msgs_sent_failed.unwrap_or(0)
    }
    pub fn clear_msgs_sent_failed(&mut self) {
        self.msgs_sent_failed = ::std::option::Option::None;
    }

    pub fn has_msgs_sent_failed(&self) -> bool {
        self.msgs_sent_failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgs_sent_failed(&mut self, v: u64) {
        self.msgs_sent_failed = ::std::option::Option::Some(v);
    }

    // optional uint64 msgs_recv = 9;


    pub fn get_msgs_recv(&self) -> u64 {
        self.msgs_recv.unwrap_or(0)
    }
    pub fn clear_msgs_recv(&mut self) {
        self.msgs_recv = ::std::option::Option::None;
    }

    pub fn has_msgs_recv(&self) -> bool {
        self.msgs_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgs_recv(&mut self, v: u64) {
        self.msgs_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 datagrams_sent = 10;


    pub fn get_datagrams_sent(&self) -> u64 {
        self.datagrams_sent.unwrap_or(0)
    }
    pub fn clear_datagrams_sent(&mut self) {
        self.datagrams_sent = ::std::option::Option::None;
    }

    pub fn has_datagrams_sent(&self) -> bool {
        self.datagrams_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datagrams_sent(&mut self, v: u64) {
        self.datagrams_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 datagrams_recv = 11;


    pub fn get_datagrams_recv(&self) -> u64 {
        self.datagrams_recv.unwrap_or(0)
    }
    pub fn clear_datagrams_recv(&mut self) {
        self.datagrams_recv = ::std::option::Option::None;
    }

    pub fn has_datagrams_recv(&self) -> bool {
        self.datagrams_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datagrams_recv(&mut self, v: u64) {
        self.datagrams_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 bad_pkts_recv = 12;


    pub fn get_bad_pkts_recv(&self) -> u64 {
        self.bad_pkts_recv.unwrap_or(0)
    }
    pub fn clear_bad_pkts_recv(&mut self) {
        self.bad_pkts_recv = ::std::option::Option::None;
    }

    pub fn has_bad_pkts_recv(&self) -> bool {
        self.bad_pkts_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bad_pkts_recv(&mut self, v: u64) {
        self.bad_pkts_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 unknown_conn_pkts_recv = 13;


    pub fn get_unknown_conn_pkts_recv(&self) -> u64 {
        self.unknown_conn_pkts_recv.unwrap_or(0)
    }
    pub fn clear_unknown_conn_pkts_recv(&mut self) {
        self.unknown_conn_pkts_recv = ::std::option::Option::None;
    }

    pub fn has_unknown_conn_pkts_recv(&self) -> bool {
        self.unknown_conn_pkts_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unknown_conn_pkts_recv(&mut self, v: u64) {
        self.unknown_conn_pkts_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 missed_pkts_recv = 14;


    pub fn get_missed_pkts_recv(&self) -> u64 {
        self.missed_pkts_recv.unwrap_or(0)
    }
    pub fn clear_missed_pkts_recv(&mut self) {
        self.missed_pkts_recv = ::std::option::Option::None;
    }

    pub fn has_missed_pkts_recv(&self) -> bool {
        self.missed_pkts_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missed_pkts_recv(&mut self, v: u64) {
        self.missed_pkts_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 dup_pkts_recv = 15;


    pub fn get_dup_pkts_recv(&self) -> u64 {
        self.dup_pkts_recv.unwrap_or(0)
    }
    pub fn clear_dup_pkts_recv(&mut self) {
        self.dup_pkts_recv = ::std::option::Option::None;
    }

    pub fn has_dup_pkts_recv(&self) -> bool {
        self.dup_pkts_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dup_pkts_recv(&mut self, v: u64) {
        self.dup_pkts_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 failed_connect_challenges = 16;


    pub fn get_failed_connect_challenges(&self) -> u64 {
        self.failed_connect_challenges.unwrap_or(0)
    }
    pub fn clear_failed_connect_challenges(&mut self) {
        self.failed_connect_challenges = ::std::option::Option::None;
    }

    pub fn has_failed_connect_challenges(&self) -> bool {
        self.failed_connect_challenges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed_connect_challenges(&mut self, v: u64) {
        self.failed_connect_challenges = ::std::option::Option::Some(v);
    }

    // optional uint32 micro_sec_avg_latency = 17;


    pub fn get_micro_sec_avg_latency(&self) -> u32 {
        self.micro_sec_avg_latency.unwrap_or(0)
    }
    pub fn clear_micro_sec_avg_latency(&mut self) {
        self.micro_sec_avg_latency = ::std::option::Option::None;
    }

    pub fn has_micro_sec_avg_latency(&self) -> bool {
        self.micro_sec_avg_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_micro_sec_avg_latency(&mut self, v: u32) {
        self.micro_sec_avg_latency = ::std::option::Option::Some(v);
    }

    // optional uint32 micro_sec_min_latency = 18;


    pub fn get_micro_sec_min_latency(&self) -> u32 {
        self.micro_sec_min_latency.unwrap_or(0)
    }
    pub fn clear_micro_sec_min_latency(&mut self) {
        self.micro_sec_min_latency = ::std::option::Option::None;
    }

    pub fn has_micro_sec_min_latency(&self) -> bool {
        self.micro_sec_min_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_micro_sec_min_latency(&mut self, v: u32) {
        self.micro_sec_min_latency = ::std::option::Option::Some(v);
    }

    // optional uint32 micro_sec_max_latency = 19;


    pub fn get_micro_sec_max_latency(&self) -> u32 {
        self.micro_sec_max_latency.unwrap_or(0)
    }
    pub fn clear_micro_sec_max_latency(&mut self) {
        self.micro_sec_max_latency = ::std::option::Option::None;
    }

    pub fn has_micro_sec_max_latency(&self) -> bool {
        self.micro_sec_max_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_micro_sec_max_latency(&mut self, v: u32) {
        self.micro_sec_max_latency = ::std::option::Option::Some(v);
    }

    // optional uint32 mem_pool_msg_in_use = 20;


    pub fn get_mem_pool_msg_in_use(&self) -> u32 {
        self.mem_pool_msg_in_use.unwrap_or(0)
    }
    pub fn clear_mem_pool_msg_in_use(&mut self) {
        self.mem_pool_msg_in_use = ::std::option::Option::None;
    }

    pub fn has_mem_pool_msg_in_use(&self) -> bool {
        self.mem_pool_msg_in_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_pool_msg_in_use(&mut self, v: u32) {
        self.mem_pool_msg_in_use = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats_Stats_VConn {
    fn is_initialized(&self) -> bool {
        for v in &self.stats_udp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.connections_udp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.connections_tcp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_udp)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pkts_abandoned = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.conn_req_received = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pkts_resent = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.msgs_sent = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.msgs_sent_failed = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.msgs_recv = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.datagrams_sent = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.datagrams_recv = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bad_pkts_recv = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.unknown_conn_pkts_recv = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missed_pkts_recv = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dup_pkts_recv = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.failed_connect_challenges = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.micro_sec_avg_latency = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.micro_sec_min_latency = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.micro_sec_max_latency = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mem_pool_msg_in_use = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connections_udp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connections_tcp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.stats_udp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.pkts_abandoned {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.conn_req_received {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pkts_resent {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msgs_sent {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msgs_sent_failed {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msgs_recv {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.datagrams_sent {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.datagrams_recv {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bad_pkts_recv {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unknown_conn_pkts_recv {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missed_pkts_recv {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dup_pkts_recv {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.failed_connect_challenges {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.micro_sec_avg_latency {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.micro_sec_min_latency {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.micro_sec_max_latency {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mem_pool_msg_in_use {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connections_udp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connections_tcp {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.stats_udp.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.pkts_abandoned {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.conn_req_received {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.pkts_resent {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.msgs_sent {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.msgs_sent_failed {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.msgs_recv {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.datagrams_sent {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.datagrams_recv {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.bad_pkts_recv {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.unknown_conn_pkts_recv {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.missed_pkts_recv {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.dup_pkts_recv {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.failed_connect_challenges {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.micro_sec_avg_latency {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.micro_sec_min_latency {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.micro_sec_max_latency {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.mem_pool_msg_in_use {
            os.write_uint32(20, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientConnectionStats_Stats_VConn {
        CMsgClientConnectionStats_Stats_VConn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "connections_udp",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.connections_udp },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.connections_udp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "connections_tcp",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.connections_tcp },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.connections_tcp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientConnectionStats_Stats_UDP>>(
                "stats_udp",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.stats_udp },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.stats_udp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pkts_abandoned",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.pkts_abandoned },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.pkts_abandoned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "conn_req_received",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.conn_req_received },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.conn_req_received },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pkts_resent",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.pkts_resent },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.pkts_resent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "msgs_sent",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.msgs_sent },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.msgs_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "msgs_sent_failed",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.msgs_sent_failed },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.msgs_sent_failed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "msgs_recv",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.msgs_recv },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.msgs_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "datagrams_sent",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.datagrams_sent },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.datagrams_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "datagrams_recv",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.datagrams_recv },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.datagrams_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bad_pkts_recv",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.bad_pkts_recv },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.bad_pkts_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "unknown_conn_pkts_recv",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.unknown_conn_pkts_recv },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.unknown_conn_pkts_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "missed_pkts_recv",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.missed_pkts_recv },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.missed_pkts_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dup_pkts_recv",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.dup_pkts_recv },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.dup_pkts_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "failed_connect_challenges",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.failed_connect_challenges },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.failed_connect_challenges },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "micro_sec_avg_latency",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.micro_sec_avg_latency },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.micro_sec_avg_latency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "micro_sec_min_latency",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.micro_sec_min_latency },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.micro_sec_min_latency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "micro_sec_max_latency",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.micro_sec_max_latency },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.micro_sec_max_latency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mem_pool_msg_in_use",
                |m: &CMsgClientConnectionStats_Stats_VConn| { &m.mem_pool_msg_in_use },
                |m: &mut CMsgClientConnectionStats_Stats_VConn| { &mut m.mem_pool_msg_in_use },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientConnectionStats_Stats_VConn>(
                "CMsgClientConnectionStats.Stats_VConn",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientConnectionStats_Stats_VConn {
        static instance: ::protobuf::rt::LazyV2<CMsgClientConnectionStats_Stats_VConn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientConnectionStats_Stats_VConn::new)
    }
}

impl ::protobuf::Clear for CMsgClientConnectionStats_Stats_VConn {
    fn clear(&mut self) {
        self.connections_udp = ::std::option::Option::None;
        self.connections_tcp = ::std::option::Option::None;
        self.stats_udp.clear();
        self.pkts_abandoned = ::std::option::Option::None;
        self.conn_req_received = ::std::option::Option::None;
        self.pkts_resent = ::std::option::Option::None;
        self.msgs_sent = ::std::option::Option::None;
        self.msgs_sent_failed = ::std::option::Option::None;
        self.msgs_recv = ::std::option::Option::None;
        self.datagrams_sent = ::std::option::Option::None;
        self.datagrams_recv = ::std::option::Option::None;
        self.bad_pkts_recv = ::std::option::Option::None;
        self.unknown_conn_pkts_recv = ::std::option::Option::None;
        self.missed_pkts_recv = ::std::option::Option::None;
        self.dup_pkts_recv = ::std::option::Option::None;
        self.failed_connect_challenges = ::std::option::Option::None;
        self.micro_sec_avg_latency = ::std::option::Option::None;
        self.micro_sec_min_latency = ::std::option::Option::None;
        self.micro_sec_max_latency = ::std::option::Option::None;
        self.mem_pool_msg_in_use = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientConnectionStats_Stats_VConn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientConnectionStats_Stats_VConn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServersAvailable {
    // message fields
    pub server_types_available: ::protobuf::RepeatedField<CMsgClientServersAvailable_Server_Types_Available>,
    server_type_for_auth_services: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServersAvailable {
    fn default() -> &'a CMsgClientServersAvailable {
        <CMsgClientServersAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServersAvailable {
    pub fn new() -> CMsgClientServersAvailable {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientServersAvailable.Server_Types_Available server_types_available = 1;


    pub fn get_server_types_available(&self) -> &[CMsgClientServersAvailable_Server_Types_Available] {
        &self.server_types_available
    }
    pub fn clear_server_types_available(&mut self) {
        self.server_types_available.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_types_available(&mut self, v: ::protobuf::RepeatedField<CMsgClientServersAvailable_Server_Types_Available>) {
        self.server_types_available = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_types_available(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientServersAvailable_Server_Types_Available> {
        &mut self.server_types_available
    }

    // Take field
    pub fn take_server_types_available(&mut self) -> ::protobuf::RepeatedField<CMsgClientServersAvailable_Server_Types_Available> {
        ::std::mem::replace(&mut self.server_types_available, ::protobuf::RepeatedField::new())
    }

    // optional uint32 server_type_for_auth_services = 2;


    pub fn get_server_type_for_auth_services(&self) -> u32 {
        self.server_type_for_auth_services.unwrap_or(0)
    }
    pub fn clear_server_type_for_auth_services(&mut self) {
        self.server_type_for_auth_services = ::std::option::Option::None;
    }

    pub fn has_server_type_for_auth_services(&self) -> bool {
        self.server_type_for_auth_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type_for_auth_services(&mut self, v: u32) {
        self.server_type_for_auth_services = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServersAvailable {
    fn is_initialized(&self) -> bool {
        for v in &self.server_types_available {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.server_types_available)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_type_for_auth_services = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.server_types_available {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.server_type_for_auth_services {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.server_types_available {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.server_type_for_auth_services {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServersAvailable {
        CMsgClientServersAvailable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientServersAvailable_Server_Types_Available>>(
                "server_types_available",
                |m: &CMsgClientServersAvailable| { &m.server_types_available },
                |m: &mut CMsgClientServersAvailable| { &mut m.server_types_available },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_type_for_auth_services",
                |m: &CMsgClientServersAvailable| { &m.server_type_for_auth_services },
                |m: &mut CMsgClientServersAvailable| { &mut m.server_type_for_auth_services },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientServersAvailable>(
                "CMsgClientServersAvailable",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServersAvailable {
        static instance: ::protobuf::rt::LazyV2<CMsgClientServersAvailable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientServersAvailable::new)
    }
}

impl ::protobuf::Clear for CMsgClientServersAvailable {
    fn clear(&mut self) {
        self.server_types_available.clear();
        self.server_type_for_auth_services = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServersAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServersAvailable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServersAvailable_Server_Types_Available {
    // message fields
    server: ::std::option::Option<u32>,
    changed: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServersAvailable_Server_Types_Available {
    fn default() -> &'a CMsgClientServersAvailable_Server_Types_Available {
        <CMsgClientServersAvailable_Server_Types_Available as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServersAvailable_Server_Types_Available {
    pub fn new() -> CMsgClientServersAvailable_Server_Types_Available {
        ::std::default::Default::default()
    }

    // optional uint32 server = 1;


    pub fn get_server(&self) -> u32 {
        self.server.unwrap_or(0)
    }
    pub fn clear_server(&mut self) {
        self.server = ::std::option::Option::None;
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: u32) {
        self.server = ::std::option::Option::Some(v);
    }

    // optional bool changed = 2;


    pub fn get_changed(&self) -> bool {
        self.changed.unwrap_or(false)
    }
    pub fn clear_changed(&mut self) {
        self.changed = ::std::option::Option::None;
    }

    pub fn has_changed(&self) -> bool {
        self.changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changed(&mut self, v: bool) {
        self.changed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServersAvailable_Server_Types_Available {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.changed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.changed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.changed {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServersAvailable_Server_Types_Available {
        CMsgClientServersAvailable_Server_Types_Available::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server",
                |m: &CMsgClientServersAvailable_Server_Types_Available| { &m.server },
                |m: &mut CMsgClientServersAvailable_Server_Types_Available| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "changed",
                |m: &CMsgClientServersAvailable_Server_Types_Available| { &m.changed },
                |m: &mut CMsgClientServersAvailable_Server_Types_Available| { &mut m.changed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientServersAvailable_Server_Types_Available>(
                "CMsgClientServersAvailable.Server_Types_Available",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServersAvailable_Server_Types_Available {
        static instance: ::protobuf::rt::LazyV2<CMsgClientServersAvailable_Server_Types_Available> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientServersAvailable_Server_Types_Available::new)
    }
}

impl ::protobuf::Clear for CMsgClientServersAvailable_Server_Types_Available {
    fn clear(&mut self) {
        self.server = ::std::option::Option::None;
        self.changed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServersAvailable_Server_Types_Available {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServersAvailable_Server_Types_Available {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetUserStats {
    // message fields
    game_id: ::std::option::Option<u64>,
    crc_stats: ::std::option::Option<u32>,
    schema_local_version: ::std::option::Option<i32>,
    steam_id_for_user: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetUserStats {
    fn default() -> &'a CMsgClientGetUserStats {
        <CMsgClientGetUserStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetUserStats {
    pub fn new() -> CMsgClientGetUserStats {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 2;


    pub fn get_crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }
    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional int32 schema_local_version = 3;


    pub fn get_schema_local_version(&self) -> i32 {
        self.schema_local_version.unwrap_or(0)
    }
    pub fn clear_schema_local_version(&mut self) {
        self.schema_local_version = ::std::option::Option::None;
    }

    pub fn has_schema_local_version(&self) -> bool {
        self.schema_local_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_local_version(&mut self, v: i32) {
        self.schema_local_version = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_for_user = 4;


    pub fn get_steam_id_for_user(&self) -> u64 {
        self.steam_id_for_user.unwrap_or(0)
    }
    pub fn clear_steam_id_for_user(&mut self) {
        self.steam_id_for_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_for_user(&self) -> bool {
        self.steam_id_for_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_for_user(&mut self, v: u64) {
        self.steam_id_for_user = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetUserStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.crc_stats = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.schema_local_version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_for_user = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.schema_local_version {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_for_user {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.schema_local_version {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.steam_id_for_user {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetUserStats {
        CMsgClientGetUserStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_id",
                |m: &CMsgClientGetUserStats| { &m.game_id },
                |m: &mut CMsgClientGetUserStats| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "crc_stats",
                |m: &CMsgClientGetUserStats| { &m.crc_stats },
                |m: &mut CMsgClientGetUserStats| { &mut m.crc_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "schema_local_version",
                |m: &CMsgClientGetUserStats| { &m.schema_local_version },
                |m: &mut CMsgClientGetUserStats| { &mut m.schema_local_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_for_user",
                |m: &CMsgClientGetUserStats| { &m.steam_id_for_user },
                |m: &mut CMsgClientGetUserStats| { &mut m.steam_id_for_user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetUserStats>(
                "CMsgClientGetUserStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetUserStats {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetUserStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetUserStats::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetUserStats {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.schema_local_version = ::std::option::Option::None;
        self.steam_id_for_user = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetUserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetUserStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetUserStatsResponse {
    // message fields
    game_id: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    crc_stats: ::std::option::Option<u32>,
    schema: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub stats: ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Stats>,
    pub achievement_blocks: ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Achievement_Blocks>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetUserStatsResponse {
    fn default() -> &'a CMsgClientGetUserStatsResponse {
        <CMsgClientGetUserStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetUserStatsResponse {
    pub fn new() -> CMsgClientGetUserStatsResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 3;


    pub fn get_crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }
    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional bytes schema = 4;


    pub fn get_schema(&self) -> &[u8] {
        match self.schema.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> ::std::vec::Vec<u8> {
        self.schema.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .CMsgClientGetUserStatsResponse.Stats stats = 5;


    pub fn get_stats(&self) -> &[CMsgClientGetUserStatsResponse_Stats] {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Stats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Stats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Stats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgClientGetUserStatsResponse.Achievement_Blocks achievement_blocks = 6;


    pub fn get_achievement_blocks(&self) -> &[CMsgClientGetUserStatsResponse_Achievement_Blocks] {
        &self.achievement_blocks
    }
    pub fn clear_achievement_blocks(&mut self) {
        self.achievement_blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_achievement_blocks(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Achievement_Blocks>) {
        self.achievement_blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_achievement_blocks(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Achievement_Blocks> {
        &mut self.achievement_blocks
    }

    // Take field
    pub fn take_achievement_blocks(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Achievement_Blocks> {
        ::std::mem::replace(&mut self.achievement_blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientGetUserStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.achievement_blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.crc_stats = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.achievement_blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.schema.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.achievement_blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.schema.as_ref() {
            os.write_bytes(4, &v)?;
        }
        for v in &self.stats {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.achievement_blocks {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetUserStatsResponse {
        CMsgClientGetUserStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_id",
                |m: &CMsgClientGetUserStatsResponse| { &m.game_id },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientGetUserStatsResponse| { &m.eresult },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "crc_stats",
                |m: &CMsgClientGetUserStatsResponse| { &m.crc_stats },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.crc_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "schema",
                |m: &CMsgClientGetUserStatsResponse| { &m.schema },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.schema },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientGetUserStatsResponse_Stats>>(
                "stats",
                |m: &CMsgClientGetUserStatsResponse| { &m.stats },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientGetUserStatsResponse_Achievement_Blocks>>(
                "achievement_blocks",
                |m: &CMsgClientGetUserStatsResponse| { &m.achievement_blocks },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.achievement_blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetUserStatsResponse>(
                "CMsgClientGetUserStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetUserStatsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetUserStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetUserStatsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetUserStatsResponse {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.schema.clear();
        self.stats.clear();
        self.achievement_blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetUserStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetUserStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetUserStatsResponse_Stats {
    // message fields
    stat_id: ::std::option::Option<u32>,
    stat_value: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetUserStatsResponse_Stats {
    fn default() -> &'a CMsgClientGetUserStatsResponse_Stats {
        <CMsgClientGetUserStatsResponse_Stats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetUserStatsResponse_Stats {
    pub fn new() -> CMsgClientGetUserStatsResponse_Stats {
        ::std::default::Default::default()
    }

    // optional uint32 stat_id = 1;


    pub fn get_stat_id(&self) -> u32 {
        self.stat_id.unwrap_or(0)
    }
    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: u32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 stat_value = 2;


    pub fn get_stat_value(&self) -> u32 {
        self.stat_value.unwrap_or(0)
    }
    pub fn clear_stat_value(&mut self) {
        self.stat_value = ::std::option::Option::None;
    }

    pub fn has_stat_value(&self) -> bool {
        self.stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_value(&mut self, v: u32) {
        self.stat_value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetUserStatsResponse_Stats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stat_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stat_value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetUserStatsResponse_Stats {
        CMsgClientGetUserStatsResponse_Stats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stat_id",
                |m: &CMsgClientGetUserStatsResponse_Stats| { &m.stat_id },
                |m: &mut CMsgClientGetUserStatsResponse_Stats| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stat_value",
                |m: &CMsgClientGetUserStatsResponse_Stats| { &m.stat_value },
                |m: &mut CMsgClientGetUserStatsResponse_Stats| { &mut m.stat_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetUserStatsResponse_Stats>(
                "CMsgClientGetUserStatsResponse.Stats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetUserStatsResponse_Stats {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetUserStatsResponse_Stats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetUserStatsResponse_Stats::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetUserStatsResponse_Stats {
    fn clear(&mut self) {
        self.stat_id = ::std::option::Option::None;
        self.stat_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetUserStatsResponse_Stats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetUserStatsResponse_Stats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetUserStatsResponse_Achievement_Blocks {
    // message fields
    achievement_id: ::std::option::Option<u32>,
    pub unlock_time: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetUserStatsResponse_Achievement_Blocks {
    fn default() -> &'a CMsgClientGetUserStatsResponse_Achievement_Blocks {
        <CMsgClientGetUserStatsResponse_Achievement_Blocks as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetUserStatsResponse_Achievement_Blocks {
    pub fn new() -> CMsgClientGetUserStatsResponse_Achievement_Blocks {
        ::std::default::Default::default()
    }

    // optional uint32 achievement_id = 1;


    pub fn get_achievement_id(&self) -> u32 {
        self.achievement_id.unwrap_or(0)
    }
    pub fn clear_achievement_id(&mut self) {
        self.achievement_id = ::std::option::Option::None;
    }

    pub fn has_achievement_id(&self) -> bool {
        self.achievement_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement_id(&mut self, v: u32) {
        self.achievement_id = ::std::option::Option::Some(v);
    }

    // repeated fixed32 unlock_time = 2;


    pub fn get_unlock_time(&self) -> &[u32] {
        &self.unlock_time
    }
    pub fn clear_unlock_time(&mut self) {
        self.unlock_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlock_time(&mut self, v: ::std::vec::Vec<u32>) {
        self.unlock_time = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlock_time(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.unlock_time
    }

    // Take field
    pub fn take_unlock_time(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.unlock_time, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientGetUserStatsResponse_Achievement_Blocks {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.achievement_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.unlock_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.achievement_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.unlock_time.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.achievement_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.unlock_time {
            os.write_fixed32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetUserStatsResponse_Achievement_Blocks {
        CMsgClientGetUserStatsResponse_Achievement_Blocks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "achievement_id",
                |m: &CMsgClientGetUserStatsResponse_Achievement_Blocks| { &m.achievement_id },
                |m: &mut CMsgClientGetUserStatsResponse_Achievement_Blocks| { &mut m.achievement_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "unlock_time",
                |m: &CMsgClientGetUserStatsResponse_Achievement_Blocks| { &m.unlock_time },
                |m: &mut CMsgClientGetUserStatsResponse_Achievement_Blocks| { &mut m.unlock_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetUserStatsResponse_Achievement_Blocks>(
                "CMsgClientGetUserStatsResponse.Achievement_Blocks",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetUserStatsResponse_Achievement_Blocks {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetUserStatsResponse_Achievement_Blocks> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetUserStatsResponse_Achievement_Blocks::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetUserStatsResponse_Achievement_Blocks {
    fn clear(&mut self) {
        self.achievement_id = ::std::option::Option::None;
        self.unlock_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetUserStatsResponse_Achievement_Blocks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetUserStatsResponse_Achievement_Blocks {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStoreUserStatsResponse {
    // message fields
    game_id: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    crc_stats: ::std::option::Option<u32>,
    pub stats_failed_validation: ::protobuf::RepeatedField<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>,
    stats_out_of_date: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStatsResponse {
    fn default() -> &'a CMsgClientStoreUserStatsResponse {
        <CMsgClientStoreUserStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStatsResponse {
    pub fn new() -> CMsgClientStoreUserStatsResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 3;


    pub fn get_crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }
    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientStoreUserStatsResponse.Stats_Failed_Validation stats_failed_validation = 4;


    pub fn get_stats_failed_validation(&self) -> &[CMsgClientStoreUserStatsResponse_Stats_Failed_Validation] {
        &self.stats_failed_validation
    }
    pub fn clear_stats_failed_validation(&mut self) {
        self.stats_failed_validation.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats_failed_validation(&mut self, v: ::protobuf::RepeatedField<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>) {
        self.stats_failed_validation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats_failed_validation(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation> {
        &mut self.stats_failed_validation
    }

    // Take field
    pub fn take_stats_failed_validation(&mut self) -> ::protobuf::RepeatedField<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation> {
        ::std::mem::replace(&mut self.stats_failed_validation, ::protobuf::RepeatedField::new())
    }

    // optional bool stats_out_of_date = 5;


    pub fn get_stats_out_of_date(&self) -> bool {
        self.stats_out_of_date.unwrap_or(false)
    }
    pub fn clear_stats_out_of_date(&mut self) {
        self.stats_out_of_date = ::std::option::Option::None;
    }

    pub fn has_stats_out_of_date(&self) -> bool {
        self.stats_out_of_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_out_of_date(&mut self, v: bool) {
        self.stats_out_of_date = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.stats_failed_validation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.crc_stats = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats_failed_validation)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stats_out_of_date = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stats_failed_validation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.stats_out_of_date {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(3, v)?;
        }
        for v in &self.stats_failed_validation {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.stats_out_of_date {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStoreUserStatsResponse {
        CMsgClientStoreUserStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_id",
                |m: &CMsgClientStoreUserStatsResponse| { &m.game_id },
                |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientStoreUserStatsResponse| { &m.eresult },
                |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "crc_stats",
                |m: &CMsgClientStoreUserStatsResponse| { &m.crc_stats },
                |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.crc_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>>(
                "stats_failed_validation",
                |m: &CMsgClientStoreUserStatsResponse| { &m.stats_failed_validation },
                |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.stats_failed_validation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stats_out_of_date",
                |m: &CMsgClientStoreUserStatsResponse| { &m.stats_out_of_date },
                |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.stats_out_of_date },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientStoreUserStatsResponse>(
                "CMsgClientStoreUserStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStoreUserStatsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientStoreUserStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientStoreUserStatsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStatsResponse {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.stats_failed_validation.clear();
        self.stats_out_of_date = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    // message fields
    stat_id: ::std::option::Option<u32>,
    reverted_stat_value: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    fn default() -> &'a CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
        <CMsgClientStoreUserStatsResponse_Stats_Failed_Validation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    pub fn new() -> CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
        ::std::default::Default::default()
    }

    // optional uint32 stat_id = 1;


    pub fn get_stat_id(&self) -> u32 {
        self.stat_id.unwrap_or(0)
    }
    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: u32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reverted_stat_value = 2;


    pub fn get_reverted_stat_value(&self) -> u32 {
        self.reverted_stat_value.unwrap_or(0)
    }
    pub fn clear_reverted_stat_value(&mut self) {
        self.reverted_stat_value = ::std::option::Option::None;
    }

    pub fn has_reverted_stat_value(&self) -> bool {
        self.reverted_stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverted_stat_value(&mut self, v: u32) {
        self.reverted_stat_value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reverted_stat_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reverted_stat_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reverted_stat_value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
        CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stat_id",
                |m: &CMsgClientStoreUserStatsResponse_Stats_Failed_Validation| { &m.stat_id },
                |m: &mut CMsgClientStoreUserStatsResponse_Stats_Failed_Validation| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reverted_stat_value",
                |m: &CMsgClientStoreUserStatsResponse_Stats_Failed_Validation| { &m.reverted_stat_value },
                |m: &mut CMsgClientStoreUserStatsResponse_Stats_Failed_Validation| { &mut m.reverted_stat_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>(
                "CMsgClientStoreUserStatsResponse.Stats_Failed_Validation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
        static instance: ::protobuf::rt::LazyV2<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::new)
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    fn clear(&mut self) {
        self.stat_id = ::std::option::Option::None;
        self.reverted_stat_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStoreUserStats2 {
    // message fields
    game_id: ::std::option::Option<u64>,
    settor_steam_id: ::std::option::Option<u64>,
    settee_steam_id: ::std::option::Option<u64>,
    crc_stats: ::std::option::Option<u32>,
    explicit_reset: ::std::option::Option<bool>,
    pub stats: ::protobuf::RepeatedField<CMsgClientStoreUserStats2_Stats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStats2 {
    fn default() -> &'a CMsgClientStoreUserStats2 {
        <CMsgClientStoreUserStats2 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStats2 {
    pub fn new() -> CMsgClientStoreUserStats2 {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 settor_steam_id = 2;


    pub fn get_settor_steam_id(&self) -> u64 {
        self.settor_steam_id.unwrap_or(0)
    }
    pub fn clear_settor_steam_id(&mut self) {
        self.settor_steam_id = ::std::option::Option::None;
    }

    pub fn has_settor_steam_id(&self) -> bool {
        self.settor_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settor_steam_id(&mut self, v: u64) {
        self.settor_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 settee_steam_id = 3;


    pub fn get_settee_steam_id(&self) -> u64 {
        self.settee_steam_id.unwrap_or(0)
    }
    pub fn clear_settee_steam_id(&mut self) {
        self.settee_steam_id = ::std::option::Option::None;
    }

    pub fn has_settee_steam_id(&self) -> bool {
        self.settee_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settee_steam_id(&mut self, v: u64) {
        self.settee_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 4;


    pub fn get_crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }
    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional bool explicit_reset = 5;


    pub fn get_explicit_reset(&self) -> bool {
        self.explicit_reset.unwrap_or(false)
    }
    pub fn clear_explicit_reset(&mut self) {
        self.explicit_reset = ::std::option::Option::None;
    }

    pub fn has_explicit_reset(&self) -> bool {
        self.explicit_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_reset(&mut self, v: bool) {
        self.explicit_reset = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientStoreUserStats2.Stats stats = 6;


    pub fn get_stats(&self) -> &[CMsgClientStoreUserStats2_Stats] {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CMsgClientStoreUserStats2_Stats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientStoreUserStats2_Stats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CMsgClientStoreUserStats2_Stats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats2 {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.settor_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.settee_steam_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.crc_stats = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.explicit_reset = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.settor_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.settee_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.explicit_reset {
            my_size += 2;
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.settor_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.settee_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.explicit_reset {
            os.write_bool(5, v)?;
        }
        for v in &self.stats {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStoreUserStats2 {
        CMsgClientStoreUserStats2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_id",
                |m: &CMsgClientStoreUserStats2| { &m.game_id },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "settor_steam_id",
                |m: &CMsgClientStoreUserStats2| { &m.settor_steam_id },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.settor_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "settee_steam_id",
                |m: &CMsgClientStoreUserStats2| { &m.settee_steam_id },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.settee_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "crc_stats",
                |m: &CMsgClientStoreUserStats2| { &m.crc_stats },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.crc_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "explicit_reset",
                |m: &CMsgClientStoreUserStats2| { &m.explicit_reset },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.explicit_reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientStoreUserStats2_Stats>>(
                "stats",
                |m: &CMsgClientStoreUserStats2| { &m.stats },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientStoreUserStats2>(
                "CMsgClientStoreUserStats2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStoreUserStats2 {
        static instance: ::protobuf::rt::LazyV2<CMsgClientStoreUserStats2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientStoreUserStats2::new)
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStats2 {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.settor_steam_id = ::std::option::Option::None;
        self.settee_steam_id = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.explicit_reset = ::std::option::Option::None;
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStats2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStats2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStoreUserStats2_Stats {
    // message fields
    stat_id: ::std::option::Option<u32>,
    stat_value: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStats2_Stats {
    fn default() -> &'a CMsgClientStoreUserStats2_Stats {
        <CMsgClientStoreUserStats2_Stats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStats2_Stats {
    pub fn new() -> CMsgClientStoreUserStats2_Stats {
        ::std::default::Default::default()
    }

    // optional uint32 stat_id = 1;


    pub fn get_stat_id(&self) -> u32 {
        self.stat_id.unwrap_or(0)
    }
    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: u32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 stat_value = 2;


    pub fn get_stat_value(&self) -> u32 {
        self.stat_value.unwrap_or(0)
    }
    pub fn clear_stat_value(&mut self) {
        self.stat_value = ::std::option::Option::None;
    }

    pub fn has_stat_value(&self) -> bool {
        self.stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_value(&mut self, v: u32) {
        self.stat_value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats2_Stats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stat_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stat_value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStoreUserStats2_Stats {
        CMsgClientStoreUserStats2_Stats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stat_id",
                |m: &CMsgClientStoreUserStats2_Stats| { &m.stat_id },
                |m: &mut CMsgClientStoreUserStats2_Stats| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stat_value",
                |m: &CMsgClientStoreUserStats2_Stats| { &m.stat_value },
                |m: &mut CMsgClientStoreUserStats2_Stats| { &mut m.stat_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientStoreUserStats2_Stats>(
                "CMsgClientStoreUserStats2.Stats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStoreUserStats2_Stats {
        static instance: ::protobuf::rt::LazyV2<CMsgClientStoreUserStats2_Stats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientStoreUserStats2_Stats::new)
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStats2_Stats {
    fn clear(&mut self) {
        self.stat_id = ::std::option::Option::None;
        self.stat_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStats2_Stats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStats2_Stats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStatsUpdated {
    // message fields
    steam_id: ::std::option::Option<u64>,
    game_id: ::std::option::Option<u64>,
    crc_stats: ::std::option::Option<u32>,
    pub updated_stats: ::protobuf::RepeatedField<CMsgClientStatsUpdated_Updated_Stats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStatsUpdated {
    fn default() -> &'a CMsgClientStatsUpdated {
        <CMsgClientStatsUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStatsUpdated {
    pub fn new() -> CMsgClientStatsUpdated {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_id = 2;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 3;


    pub fn get_crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }
    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientStatsUpdated.Updated_Stats updated_stats = 4;


    pub fn get_updated_stats(&self) -> &[CMsgClientStatsUpdated_Updated_Stats] {
        &self.updated_stats
    }
    pub fn clear_updated_stats(&mut self) {
        self.updated_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_updated_stats(&mut self, v: ::protobuf::RepeatedField<CMsgClientStatsUpdated_Updated_Stats>) {
        self.updated_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_updated_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientStatsUpdated_Updated_Stats> {
        &mut self.updated_stats
    }

    // Take field
    pub fn take_updated_stats(&mut self) -> ::protobuf::RepeatedField<CMsgClientStatsUpdated_Updated_Stats> {
        ::std::mem::replace(&mut self.updated_stats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientStatsUpdated {
    fn is_initialized(&self) -> bool {
        for v in &self.updated_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.crc_stats = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.updated_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.updated_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(3, v)?;
        }
        for v in &self.updated_stats {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStatsUpdated {
        CMsgClientStatsUpdated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgClientStatsUpdated| { &m.steam_id },
                |m: &mut CMsgClientStatsUpdated| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_id",
                |m: &CMsgClientStatsUpdated| { &m.game_id },
                |m: &mut CMsgClientStatsUpdated| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "crc_stats",
                |m: &CMsgClientStatsUpdated| { &m.crc_stats },
                |m: &mut CMsgClientStatsUpdated| { &mut m.crc_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientStatsUpdated_Updated_Stats>>(
                "updated_stats",
                |m: &CMsgClientStatsUpdated| { &m.updated_stats },
                |m: &mut CMsgClientStatsUpdated| { &mut m.updated_stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientStatsUpdated>(
                "CMsgClientStatsUpdated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStatsUpdated {
        static instance: ::protobuf::rt::LazyV2<CMsgClientStatsUpdated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientStatsUpdated::new)
    }
}

impl ::protobuf::Clear for CMsgClientStatsUpdated {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.updated_stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStatsUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStatsUpdated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStatsUpdated_Updated_Stats {
    // message fields
    stat_id: ::std::option::Option<u32>,
    stat_value: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStatsUpdated_Updated_Stats {
    fn default() -> &'a CMsgClientStatsUpdated_Updated_Stats {
        <CMsgClientStatsUpdated_Updated_Stats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStatsUpdated_Updated_Stats {
    pub fn new() -> CMsgClientStatsUpdated_Updated_Stats {
        ::std::default::Default::default()
    }

    // optional uint32 stat_id = 1;


    pub fn get_stat_id(&self) -> u32 {
        self.stat_id.unwrap_or(0)
    }
    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: u32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 stat_value = 2;


    pub fn get_stat_value(&self) -> u32 {
        self.stat_value.unwrap_or(0)
    }
    pub fn clear_stat_value(&mut self) {
        self.stat_value = ::std::option::Option::None;
    }

    pub fn has_stat_value(&self) -> bool {
        self.stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_value(&mut self, v: u32) {
        self.stat_value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStatsUpdated_Updated_Stats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stat_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stat_value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStatsUpdated_Updated_Stats {
        CMsgClientStatsUpdated_Updated_Stats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stat_id",
                |m: &CMsgClientStatsUpdated_Updated_Stats| { &m.stat_id },
                |m: &mut CMsgClientStatsUpdated_Updated_Stats| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stat_value",
                |m: &CMsgClientStatsUpdated_Updated_Stats| { &m.stat_value },
                |m: &mut CMsgClientStatsUpdated_Updated_Stats| { &mut m.stat_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientStatsUpdated_Updated_Stats>(
                "CMsgClientStatsUpdated.Updated_Stats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStatsUpdated_Updated_Stats {
        static instance: ::protobuf::rt::LazyV2<CMsgClientStatsUpdated_Updated_Stats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientStatsUpdated_Updated_Stats::new)
    }
}

impl ::protobuf::Clear for CMsgClientStatsUpdated_Updated_Stats {
    fn clear(&mut self) {
        self.stat_id = ::std::option::Option::None;
        self.stat_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStatsUpdated_Updated_Stats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStatsUpdated_Updated_Stats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStoreUserStats {
    // message fields
    game_id: ::std::option::Option<u64>,
    explicit_reset: ::std::option::Option<bool>,
    pub stats_to_store: ::protobuf::RepeatedField<CMsgClientStoreUserStats_Stats_To_Store>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStats {
    fn default() -> &'a CMsgClientStoreUserStats {
        <CMsgClientStoreUserStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStats {
    pub fn new() -> CMsgClientStoreUserStats {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional bool explicit_reset = 2;


    pub fn get_explicit_reset(&self) -> bool {
        self.explicit_reset.unwrap_or(false)
    }
    pub fn clear_explicit_reset(&mut self) {
        self.explicit_reset = ::std::option::Option::None;
    }

    pub fn has_explicit_reset(&self) -> bool {
        self.explicit_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_reset(&mut self, v: bool) {
        self.explicit_reset = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientStoreUserStats.Stats_To_Store stats_to_store = 3;


    pub fn get_stats_to_store(&self) -> &[CMsgClientStoreUserStats_Stats_To_Store] {
        &self.stats_to_store
    }
    pub fn clear_stats_to_store(&mut self) {
        self.stats_to_store.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats_to_store(&mut self, v: ::protobuf::RepeatedField<CMsgClientStoreUserStats_Stats_To_Store>) {
        self.stats_to_store = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats_to_store(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientStoreUserStats_Stats_To_Store> {
        &mut self.stats_to_store
    }

    // Take field
    pub fn take_stats_to_store(&mut self) -> ::protobuf::RepeatedField<CMsgClientStoreUserStats_Stats_To_Store> {
        ::std::mem::replace(&mut self.stats_to_store, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats_to_store {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.explicit_reset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats_to_store)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.explicit_reset {
            my_size += 2;
        }
        for value in &self.stats_to_store {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.explicit_reset {
            os.write_bool(2, v)?;
        }
        for v in &self.stats_to_store {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStoreUserStats {
        CMsgClientStoreUserStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_id",
                |m: &CMsgClientStoreUserStats| { &m.game_id },
                |m: &mut CMsgClientStoreUserStats| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "explicit_reset",
                |m: &CMsgClientStoreUserStats| { &m.explicit_reset },
                |m: &mut CMsgClientStoreUserStats| { &mut m.explicit_reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientStoreUserStats_Stats_To_Store>>(
                "stats_to_store",
                |m: &CMsgClientStoreUserStats| { &m.stats_to_store },
                |m: &mut CMsgClientStoreUserStats| { &mut m.stats_to_store },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientStoreUserStats>(
                "CMsgClientStoreUserStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStoreUserStats {
        static instance: ::protobuf::rt::LazyV2<CMsgClientStoreUserStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientStoreUserStats::new)
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStats {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.explicit_reset = ::std::option::Option::None;
        self.stats_to_store.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStoreUserStats_Stats_To_Store {
    // message fields
    stat_id: ::std::option::Option<u32>,
    stat_value: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStats_Stats_To_Store {
    fn default() -> &'a CMsgClientStoreUserStats_Stats_To_Store {
        <CMsgClientStoreUserStats_Stats_To_Store as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStats_Stats_To_Store {
    pub fn new() -> CMsgClientStoreUserStats_Stats_To_Store {
        ::std::default::Default::default()
    }

    // optional uint32 stat_id = 1;


    pub fn get_stat_id(&self) -> u32 {
        self.stat_id.unwrap_or(0)
    }
    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: u32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 stat_value = 2;


    pub fn get_stat_value(&self) -> u32 {
        self.stat_value.unwrap_or(0)
    }
    pub fn clear_stat_value(&mut self) {
        self.stat_value = ::std::option::Option::None;
    }

    pub fn has_stat_value(&self) -> bool {
        self.stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_value(&mut self, v: u32) {
        self.stat_value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats_Stats_To_Store {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stat_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stat_value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStoreUserStats_Stats_To_Store {
        CMsgClientStoreUserStats_Stats_To_Store::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stat_id",
                |m: &CMsgClientStoreUserStats_Stats_To_Store| { &m.stat_id },
                |m: &mut CMsgClientStoreUserStats_Stats_To_Store| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stat_value",
                |m: &CMsgClientStoreUserStats_Stats_To_Store| { &m.stat_value },
                |m: &mut CMsgClientStoreUserStats_Stats_To_Store| { &mut m.stat_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientStoreUserStats_Stats_To_Store>(
                "CMsgClientStoreUserStats.Stats_To_Store",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStoreUserStats_Stats_To_Store {
        static instance: ::protobuf::rt::LazyV2<CMsgClientStoreUserStats_Stats_To_Store> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientStoreUserStats_Stats_To_Store::new)
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStats_Stats_To_Store {
    fn clear(&mut self) {
        self.stat_id = ::std::option::Option::None;
        self.stat_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStats_Stats_To_Store {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStats_Stats_To_Store {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientDetails {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetails {
    fn default() -> &'a CMsgClientGetClientDetails {
        <CMsgClientGetClientDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetails {
    pub fn new() -> CMsgClientGetClientDetails {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientDetails {
        CMsgClientGetClientDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetClientDetails>(
                "CMsgClientGetClientDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientDetails {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetClientDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetClientDetails::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientDetails {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientReportOverlayDetourFailure {
    // message fields
    pub failure_strings: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientReportOverlayDetourFailure {
    fn default() -> &'a CMsgClientReportOverlayDetourFailure {
        <CMsgClientReportOverlayDetourFailure as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReportOverlayDetourFailure {
    pub fn new() -> CMsgClientReportOverlayDetourFailure {
        ::std::default::Default::default()
    }

    // repeated string failure_strings = 1;


    pub fn get_failure_strings(&self) -> &[::std::string::String] {
        &self.failure_strings
    }
    pub fn clear_failure_strings(&mut self) {
        self.failure_strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_failure_strings(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.failure_strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failure_strings(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.failure_strings
    }

    // Take field
    pub fn take_failure_strings(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.failure_strings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientReportOverlayDetourFailure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.failure_strings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.failure_strings {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.failure_strings {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientReportOverlayDetourFailure {
        CMsgClientReportOverlayDetourFailure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "failure_strings",
                |m: &CMsgClientReportOverlayDetourFailure| { &m.failure_strings },
                |m: &mut CMsgClientReportOverlayDetourFailure| { &mut m.failure_strings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientReportOverlayDetourFailure>(
                "CMsgClientReportOverlayDetourFailure",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientReportOverlayDetourFailure {
        static instance: ::protobuf::rt::LazyV2<CMsgClientReportOverlayDetourFailure> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientReportOverlayDetourFailure::new)
    }
}

impl ::protobuf::Clear for CMsgClientReportOverlayDetourFailure {
    fn clear(&mut self) {
        self.failure_strings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientReportOverlayDetourFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientReportOverlayDetourFailure {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientDetailsResponse {
    // message fields
    package_version: ::std::option::Option<u32>,
    protocol_version: ::std::option::Option<u32>,
    os: ::protobuf::SingularField<::std::string::String>,
    machine_name: ::protobuf::SingularField<::std::string::String>,
    ip_public: ::protobuf::SingularField<::std::string::String>,
    ip_private: ::protobuf::SingularField<::std::string::String>,
    bytes_available: ::std::option::Option<u64>,
    pub games_running: ::protobuf::RepeatedField<CMsgClientGetClientDetailsResponse_Game>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetailsResponse {
    fn default() -> &'a CMsgClientGetClientDetailsResponse {
        <CMsgClientGetClientDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetailsResponse {
    pub fn new() -> CMsgClientGetClientDetailsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 package_version = 1;


    pub fn get_package_version(&self) -> u32 {
        self.package_version.unwrap_or(0)
    }
    pub fn clear_package_version(&mut self) {
        self.package_version = ::std::option::Option::None;
    }

    pub fn has_package_version(&self) -> bool {
        self.package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_version(&mut self, v: u32) {
        self.package_version = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional string os = 2;


    pub fn get_os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os.set_default();
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_name = 3;


    pub fn get_machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_machine_name(&mut self) {
        self.machine_name.clear();
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name.set_default();
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ip_public = 4;


    pub fn get_ip_public(&self) -> &str {
        match self.ip_public.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ip_public(&mut self) {
        self.ip_public.clear();
    }

    pub fn has_ip_public(&self) -> bool {
        self.ip_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_public(&mut self, v: ::std::string::String) {
        self.ip_public = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_public(&mut self) -> &mut ::std::string::String {
        if self.ip_public.is_none() {
            self.ip_public.set_default();
        }
        self.ip_public.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_public(&mut self) -> ::std::string::String {
        self.ip_public.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ip_private = 5;


    pub fn get_ip_private(&self) -> &str {
        match self.ip_private.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ip_private(&mut self) {
        self.ip_private.clear();
    }

    pub fn has_ip_private(&self) -> bool {
        self.ip_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_private(&mut self, v: ::std::string::String) {
        self.ip_private = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_private(&mut self) -> &mut ::std::string::String {
        if self.ip_private.is_none() {
            self.ip_private.set_default();
        }
        self.ip_private.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_private(&mut self) -> ::std::string::String {
        self.ip_private.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 bytes_available = 7;


    pub fn get_bytes_available(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }
    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientGetClientDetailsResponse.Game games_running = 6;


    pub fn get_games_running(&self) -> &[CMsgClientGetClientDetailsResponse_Game] {
        &self.games_running
    }
    pub fn clear_games_running(&mut self) {
        self.games_running.clear();
    }

    // Param is passed by value, moved
    pub fn set_games_running(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetClientDetailsResponse_Game>) {
        self.games_running = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games_running(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientGetClientDetailsResponse_Game> {
        &mut self.games_running
    }

    // Take field
    pub fn take_games_running(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetClientDetailsResponse_Game> {
        ::std::mem::replace(&mut self.games_running, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.games_running {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.package_version = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_public)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_private)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_available = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games_running)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.package_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.ip_public.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.ip_private.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bytes_available {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.games_running {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.package_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        if let Some(ref v) = self.os.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.machine_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.ip_public.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.ip_private.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.bytes_available {
            os.write_uint64(7, v)?;
        }
        for v in &self.games_running {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientDetailsResponse {
        CMsgClientGetClientDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "package_version",
                |m: &CMsgClientGetClientDetailsResponse| { &m.package_version },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.package_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgClientGetClientDetailsResponse| { &m.protocol_version },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.protocol_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os",
                |m: &CMsgClientGetClientDetailsResponse| { &m.os },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.os },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "machine_name",
                |m: &CMsgClientGetClientDetailsResponse| { &m.machine_name },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.machine_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip_public",
                |m: &CMsgClientGetClientDetailsResponse| { &m.ip_public },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.ip_public },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip_private",
                |m: &CMsgClientGetClientDetailsResponse| { &m.ip_private },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.ip_private },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_available",
                |m: &CMsgClientGetClientDetailsResponse| { &m.bytes_available },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.bytes_available },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientGetClientDetailsResponse_Game>>(
                "games_running",
                |m: &CMsgClientGetClientDetailsResponse| { &m.games_running },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.games_running },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetClientDetailsResponse>(
                "CMsgClientGetClientDetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientDetailsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetClientDetailsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetClientDetailsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientDetailsResponse {
    fn clear(&mut self) {
        self.package_version = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.os.clear();
        self.machine_name.clear();
        self.ip_public.clear();
        self.ip_private.clear();
        self.bytes_available = ::std::option::Option::None;
        self.games_running.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientDetailsResponse_Game {
    // message fields
    appid: ::std::option::Option<u32>,
    extra_info: ::protobuf::SingularField<::std::string::String>,
    time_running_sec: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetailsResponse_Game {
    fn default() -> &'a CMsgClientGetClientDetailsResponse_Game {
        <CMsgClientGetClientDetailsResponse_Game as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetailsResponse_Game {
    pub fn new() -> CMsgClientGetClientDetailsResponse_Game {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string extra_info = 2;


    pub fn get_extra_info(&self) -> &str {
        match self.extra_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_extra_info(&mut self) {
        self.extra_info.clear();
    }

    pub fn has_extra_info(&self) -> bool {
        self.extra_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_info(&mut self, v: ::std::string::String) {
        self.extra_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_info(&mut self) -> &mut ::std::string::String {
        if self.extra_info.is_none() {
            self.extra_info.set_default();
        }
        self.extra_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_info(&mut self) -> ::std::string::String {
        self.extra_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 time_running_sec = 3;


    pub fn get_time_running_sec(&self) -> u32 {
        self.time_running_sec.unwrap_or(0)
    }
    pub fn clear_time_running_sec(&mut self) {
        self.time_running_sec = ::std::option::Option::None;
    }

    pub fn has_time_running_sec(&self) -> bool {
        self.time_running_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_running_sec(&mut self, v: u32) {
        self.time_running_sec = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetailsResponse_Game {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.extra_info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_running_sec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_info.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.time_running_sec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.extra_info.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.time_running_sec {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientDetailsResponse_Game {
        CMsgClientGetClientDetailsResponse_Game::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientGetClientDetailsResponse_Game| { &m.appid },
                |m: &mut CMsgClientGetClientDetailsResponse_Game| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extra_info",
                |m: &CMsgClientGetClientDetailsResponse_Game| { &m.extra_info },
                |m: &mut CMsgClientGetClientDetailsResponse_Game| { &mut m.extra_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_running_sec",
                |m: &CMsgClientGetClientDetailsResponse_Game| { &m.time_running_sec },
                |m: &mut CMsgClientGetClientDetailsResponse_Game| { &mut m.time_running_sec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetClientDetailsResponse_Game>(
                "CMsgClientGetClientDetailsResponse.Game",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientDetailsResponse_Game {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetClientDetailsResponse_Game> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetClientDetailsResponse_Game::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientDetailsResponse_Game {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.extra_info.clear();
        self.time_running_sec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientDetailsResponse_Game {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientDetailsResponse_Game {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientAppList {
    // message fields
    media: ::std::option::Option<bool>,
    tools: ::std::option::Option<bool>,
    games: ::std::option::Option<bool>,
    only_installed: ::std::option::Option<bool>,
    only_changing: ::std::option::Option<bool>,
    comics: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppList {
    fn default() -> &'a CMsgClientGetClientAppList {
        <CMsgClientGetClientAppList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppList {
    pub fn new() -> CMsgClientGetClientAppList {
        ::std::default::Default::default()
    }

    // optional bool media = 1;


    pub fn get_media(&self) -> bool {
        self.media.unwrap_or(false)
    }
    pub fn clear_media(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: bool) {
        self.media = ::std::option::Option::Some(v);
    }

    // optional bool tools = 2;


    pub fn get_tools(&self) -> bool {
        self.tools.unwrap_or(false)
    }
    pub fn clear_tools(&mut self) {
        self.tools = ::std::option::Option::None;
    }

    pub fn has_tools(&self) -> bool {
        self.tools.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tools(&mut self, v: bool) {
        self.tools = ::std::option::Option::Some(v);
    }

    // optional bool games = 3;


    pub fn get_games(&self) -> bool {
        self.games.unwrap_or(false)
    }
    pub fn clear_games(&mut self) {
        self.games = ::std::option::Option::None;
    }

    pub fn has_games(&self) -> bool {
        self.games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: bool) {
        self.games = ::std::option::Option::Some(v);
    }

    // optional bool only_installed = 4;


    pub fn get_only_installed(&self) -> bool {
        self.only_installed.unwrap_or(false)
    }
    pub fn clear_only_installed(&mut self) {
        self.only_installed = ::std::option::Option::None;
    }

    pub fn has_only_installed(&self) -> bool {
        self.only_installed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_installed(&mut self, v: bool) {
        self.only_installed = ::std::option::Option::Some(v);
    }

    // optional bool only_changing = 5;


    pub fn get_only_changing(&self) -> bool {
        self.only_changing.unwrap_or(false)
    }
    pub fn clear_only_changing(&mut self) {
        self.only_changing = ::std::option::Option::None;
    }

    pub fn has_only_changing(&self) -> bool {
        self.only_changing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_changing(&mut self, v: bool) {
        self.only_changing = ::std::option::Option::Some(v);
    }

    // optional bool comics = 6;


    pub fn get_comics(&self) -> bool {
        self.comics.unwrap_or(false)
    }
    pub fn clear_comics(&mut self) {
        self.comics = ::std::option::Option::None;
    }

    pub fn has_comics(&self) -> bool {
        self.comics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comics(&mut self, v: bool) {
        self.comics = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.media = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tools = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.games = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.only_installed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.only_changing = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.comics = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.media {
            my_size += 2;
        }
        if let Some(v) = self.tools {
            my_size += 2;
        }
        if let Some(v) = self.games {
            my_size += 2;
        }
        if let Some(v) = self.only_installed {
            my_size += 2;
        }
        if let Some(v) = self.only_changing {
            my_size += 2;
        }
        if let Some(v) = self.comics {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.media {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.tools {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.games {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.only_installed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.only_changing {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.comics {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientAppList {
        CMsgClientGetClientAppList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "media",
                |m: &CMsgClientGetClientAppList| { &m.media },
                |m: &mut CMsgClientGetClientAppList| { &mut m.media },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tools",
                |m: &CMsgClientGetClientAppList| { &m.tools },
                |m: &mut CMsgClientGetClientAppList| { &mut m.tools },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "games",
                |m: &CMsgClientGetClientAppList| { &m.games },
                |m: &mut CMsgClientGetClientAppList| { &mut m.games },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "only_installed",
                |m: &CMsgClientGetClientAppList| { &m.only_installed },
                |m: &mut CMsgClientGetClientAppList| { &mut m.only_installed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "only_changing",
                |m: &CMsgClientGetClientAppList| { &m.only_changing },
                |m: &mut CMsgClientGetClientAppList| { &mut m.only_changing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "comics",
                |m: &CMsgClientGetClientAppList| { &m.comics },
                |m: &mut CMsgClientGetClientAppList| { &mut m.comics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetClientAppList>(
                "CMsgClientGetClientAppList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientAppList {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetClientAppList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetClientAppList::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientAppList {
    fn clear(&mut self) {
        self.media = ::std::option::Option::None;
        self.tools = ::std::option::Option::None;
        self.games = ::std::option::Option::None;
        self.only_installed = ::std::option::Option::None;
        self.only_changing = ::std::option::Option::None;
        self.comics = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientAppList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientAppList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientAppListResponse {
    // message fields
    pub apps: ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App>,
    bytes_available: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppListResponse {
    fn default() -> &'a CMsgClientGetClientAppListResponse {
        <CMsgClientGetClientAppListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppListResponse {
    pub fn new() -> CMsgClientGetClientAppListResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientGetClientAppListResponse.App apps = 1;


    pub fn get_apps(&self) -> &[CMsgClientGetClientAppListResponse_App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    // optional uint64 bytes_available = 2;


    pub fn get_bytes_available(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }
    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_available = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.bytes_available {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.apps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.bytes_available {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientAppListResponse {
        CMsgClientGetClientAppListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientGetClientAppListResponse_App>>(
                "apps",
                |m: &CMsgClientGetClientAppListResponse| { &m.apps },
                |m: &mut CMsgClientGetClientAppListResponse| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_available",
                |m: &CMsgClientGetClientAppListResponse| { &m.bytes_available },
                |m: &mut CMsgClientGetClientAppListResponse| { &mut m.bytes_available },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetClientAppListResponse>(
                "CMsgClientGetClientAppListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientAppListResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetClientAppListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetClientAppListResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientAppListResponse {
    fn clear(&mut self) {
        self.apps.clear();
        self.bytes_available = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientAppListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientAppListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientAppListResponse_App {
    // message fields
    appid: ::std::option::Option<u32>,
    category: ::protobuf::SingularField<::std::string::String>,
    app_type: ::protobuf::SingularField<::std::string::String>,
    favorite: ::std::option::Option<bool>,
    installed: ::std::option::Option<bool>,
    auto_update: ::std::option::Option<bool>,
    bytes_downloaded: ::std::option::Option<u64>,
    bytes_needed: ::std::option::Option<u64>,
    bytes_download_rate: ::std::option::Option<u32>,
    download_paused: ::std::option::Option<bool>,
    num_downloading: ::std::option::Option<u32>,
    num_paused: ::std::option::Option<u32>,
    changing: ::std::option::Option<bool>,
    available_on_platform: ::std::option::Option<bool>,
    pub dlcs: ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App_DLC>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppListResponse_App {
    fn default() -> &'a CMsgClientGetClientAppListResponse_App {
        <CMsgClientGetClientAppListResponse_App as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppListResponse_App {
    pub fn new() -> CMsgClientGetClientAppListResponse_App {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string category = 2;


    pub fn get_category(&self) -> &str {
        match self.category.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_category(&mut self) {
        self.category.clear();
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: ::std::string::String) {
        self.category = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category(&mut self) -> &mut ::std::string::String {
        if self.category.is_none() {
            self.category.set_default();
        }
        self.category.as_mut().unwrap()
    }

    // Take field
    pub fn take_category(&mut self) -> ::std::string::String {
        self.category.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string app_type = 10;


    pub fn get_app_type(&self) -> &str {
        match self.app_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_app_type(&mut self) {
        self.app_type.clear();
    }

    pub fn has_app_type(&self) -> bool {
        self.app_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_type(&mut self, v: ::std::string::String) {
        self.app_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_type(&mut self) -> &mut ::std::string::String {
        if self.app_type.is_none() {
            self.app_type.set_default();
        }
        self.app_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_type(&mut self) -> ::std::string::String {
        self.app_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool favorite = 3;


    pub fn get_favorite(&self) -> bool {
        self.favorite.unwrap_or(false)
    }
    pub fn clear_favorite(&mut self) {
        self.favorite = ::std::option::Option::None;
    }

    pub fn has_favorite(&self) -> bool {
        self.favorite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite(&mut self, v: bool) {
        self.favorite = ::std::option::Option::Some(v);
    }

    // optional bool installed = 4;


    pub fn get_installed(&self) -> bool {
        self.installed.unwrap_or(false)
    }
    pub fn clear_installed(&mut self) {
        self.installed = ::std::option::Option::None;
    }

    pub fn has_installed(&self) -> bool {
        self.installed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_installed(&mut self, v: bool) {
        self.installed = ::std::option::Option::Some(v);
    }

    // optional bool auto_update = 5;


    pub fn get_auto_update(&self) -> bool {
        self.auto_update.unwrap_or(false)
    }
    pub fn clear_auto_update(&mut self) {
        self.auto_update = ::std::option::Option::None;
    }

    pub fn has_auto_update(&self) -> bool {
        self.auto_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_update(&mut self, v: bool) {
        self.auto_update = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_downloaded = 6;


    pub fn get_bytes_downloaded(&self) -> u64 {
        self.bytes_downloaded.unwrap_or(0)
    }
    pub fn clear_bytes_downloaded(&mut self) {
        self.bytes_downloaded = ::std::option::Option::None;
    }

    pub fn has_bytes_downloaded(&self) -> bool {
        self.bytes_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_downloaded(&mut self, v: u64) {
        self.bytes_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_needed = 7;


    pub fn get_bytes_needed(&self) -> u64 {
        self.bytes_needed.unwrap_or(0)
    }
    pub fn clear_bytes_needed(&mut self) {
        self.bytes_needed = ::std::option::Option::None;
    }

    pub fn has_bytes_needed(&self) -> bool {
        self.bytes_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_needed(&mut self, v: u64) {
        self.bytes_needed = ::std::option::Option::Some(v);
    }

    // optional uint32 bytes_download_rate = 8;


    pub fn get_bytes_download_rate(&self) -> u32 {
        self.bytes_download_rate.unwrap_or(0)
    }
    pub fn clear_bytes_download_rate(&mut self) {
        self.bytes_download_rate = ::std::option::Option::None;
    }

    pub fn has_bytes_download_rate(&self) -> bool {
        self.bytes_download_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_download_rate(&mut self, v: u32) {
        self.bytes_download_rate = ::std::option::Option::Some(v);
    }

    // optional bool download_paused = 11;


    pub fn get_download_paused(&self) -> bool {
        self.download_paused.unwrap_or(false)
    }
    pub fn clear_download_paused(&mut self) {
        self.download_paused = ::std::option::Option::None;
    }

    pub fn has_download_paused(&self) -> bool {
        self.download_paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_paused(&mut self, v: bool) {
        self.download_paused = ::std::option::Option::Some(v);
    }

    // optional uint32 num_downloading = 12;


    pub fn get_num_downloading(&self) -> u32 {
        self.num_downloading.unwrap_or(0)
    }
    pub fn clear_num_downloading(&mut self) {
        self.num_downloading = ::std::option::Option::None;
    }

    pub fn has_num_downloading(&self) -> bool {
        self.num_downloading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_downloading(&mut self, v: u32) {
        self.num_downloading = ::std::option::Option::Some(v);
    }

    // optional uint32 num_paused = 13;


    pub fn get_num_paused(&self) -> u32 {
        self.num_paused.unwrap_or(0)
    }
    pub fn clear_num_paused(&mut self) {
        self.num_paused = ::std::option::Option::None;
    }

    pub fn has_num_paused(&self) -> bool {
        self.num_paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_paused(&mut self, v: u32) {
        self.num_paused = ::std::option::Option::Some(v);
    }

    // optional bool changing = 14;


    pub fn get_changing(&self) -> bool {
        self.changing.unwrap_or(false)
    }
    pub fn clear_changing(&mut self) {
        self.changing = ::std::option::Option::None;
    }

    pub fn has_changing(&self) -> bool {
        self.changing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changing(&mut self, v: bool) {
        self.changing = ::std::option::Option::Some(v);
    }

    // optional bool available_on_platform = 15;


    pub fn get_available_on_platform(&self) -> bool {
        self.available_on_platform.unwrap_or(false)
    }
    pub fn clear_available_on_platform(&mut self) {
        self.available_on_platform = ::std::option::Option::None;
    }

    pub fn has_available_on_platform(&self) -> bool {
        self.available_on_platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_on_platform(&mut self, v: bool) {
        self.available_on_platform = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientGetClientAppListResponse.App.DLC dlcs = 9;


    pub fn get_dlcs(&self) -> &[CMsgClientGetClientAppListResponse_App_DLC] {
        &self.dlcs
    }
    pub fn clear_dlcs(&mut self) {
        self.dlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_dlcs(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App_DLC>) {
        self.dlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dlcs(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App_DLC> {
        &mut self.dlcs
    }

    // Take field
    pub fn take_dlcs(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App_DLC> {
        ::std::mem::replace(&mut self.dlcs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppListResponse_App {
    fn is_initialized(&self) -> bool {
        for v in &self.dlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.category)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.app_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.favorite = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.installed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.auto_update = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_downloaded = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_needed = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bytes_download_rate = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.download_paused = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_downloading = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_paused = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.changing = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.available_on_platform = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dlcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.category.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.app_type.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.favorite {
            my_size += 2;
        }
        if let Some(v) = self.installed {
            my_size += 2;
        }
        if let Some(v) = self.auto_update {
            my_size += 2;
        }
        if let Some(v) = self.bytes_downloaded {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_needed {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_download_rate {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.download_paused {
            my_size += 2;
        }
        if let Some(v) = self.num_downloading {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_paused {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.changing {
            my_size += 2;
        }
        if let Some(v) = self.available_on_platform {
            my_size += 2;
        }
        for value in &self.dlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.category.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.app_type.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.favorite {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.installed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.auto_update {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.bytes_downloaded {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.bytes_needed {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.bytes_download_rate {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.download_paused {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.num_downloading {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.num_paused {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.changing {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.available_on_platform {
            os.write_bool(15, v)?;
        }
        for v in &self.dlcs {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientAppListResponse_App {
        CMsgClientGetClientAppListResponse_App::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.appid },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "category",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.category },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_type",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.app_type },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.app_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "favorite",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.favorite },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.favorite },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "installed",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.installed },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.installed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "auto_update",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.auto_update },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.auto_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_downloaded",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.bytes_downloaded },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.bytes_downloaded },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_needed",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.bytes_needed },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.bytes_needed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bytes_download_rate",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.bytes_download_rate },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.bytes_download_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "download_paused",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.download_paused },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.download_paused },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_downloading",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.num_downloading },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.num_downloading },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_paused",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.num_paused },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.num_paused },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "changing",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.changing },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.changing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "available_on_platform",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.available_on_platform },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.available_on_platform },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientGetClientAppListResponse_App_DLC>>(
                "dlcs",
                |m: &CMsgClientGetClientAppListResponse_App| { &m.dlcs },
                |m: &mut CMsgClientGetClientAppListResponse_App| { &mut m.dlcs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetClientAppListResponse_App>(
                "CMsgClientGetClientAppListResponse.App",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientAppListResponse_App {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetClientAppListResponse_App> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetClientAppListResponse_App::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientAppListResponse_App {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.category.clear();
        self.app_type.clear();
        self.favorite = ::std::option::Option::None;
        self.installed = ::std::option::Option::None;
        self.auto_update = ::std::option::Option::None;
        self.bytes_downloaded = ::std::option::Option::None;
        self.bytes_needed = ::std::option::Option::None;
        self.bytes_download_rate = ::std::option::Option::None;
        self.download_paused = ::std::option::Option::None;
        self.num_downloading = ::std::option::Option::None;
        self.num_paused = ::std::option::Option::None;
        self.changing = ::std::option::Option::None;
        self.available_on_platform = ::std::option::Option::None;
        self.dlcs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientAppListResponse_App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientAppListResponse_App {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientAppListResponse_App_DLC {
    // message fields
    appid: ::std::option::Option<u32>,
    installed: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppListResponse_App_DLC {
    fn default() -> &'a CMsgClientGetClientAppListResponse_App_DLC {
        <CMsgClientGetClientAppListResponse_App_DLC as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppListResponse_App_DLC {
    pub fn new() -> CMsgClientGetClientAppListResponse_App_DLC {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool installed = 2;


    pub fn get_installed(&self) -> bool {
        self.installed.unwrap_or(false)
    }
    pub fn clear_installed(&mut self) {
        self.installed = ::std::option::Option::None;
    }

    pub fn has_installed(&self) -> bool {
        self.installed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_installed(&mut self, v: bool) {
        self.installed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppListResponse_App_DLC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.installed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.installed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.installed {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientAppListResponse_App_DLC {
        CMsgClientGetClientAppListResponse_App_DLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientGetClientAppListResponse_App_DLC| { &m.appid },
                |m: &mut CMsgClientGetClientAppListResponse_App_DLC| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "installed",
                |m: &CMsgClientGetClientAppListResponse_App_DLC| { &m.installed },
                |m: &mut CMsgClientGetClientAppListResponse_App_DLC| { &mut m.installed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetClientAppListResponse_App_DLC>(
                "CMsgClientGetClientAppListResponse.App.DLC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientAppListResponse_App_DLC {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetClientAppListResponse_App_DLC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetClientAppListResponse_App_DLC::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientAppListResponse_App_DLC {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.installed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientAppListResponse_App_DLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientAppListResponse_App_DLC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientInstallClientApp {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientInstallClientApp {
    fn default() -> &'a CMsgClientInstallClientApp {
        <CMsgClientInstallClientApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInstallClientApp {
    pub fn new() -> CMsgClientInstallClientApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientInstallClientApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientInstallClientApp {
        CMsgClientInstallClientApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientInstallClientApp| { &m.appid },
                |m: &mut CMsgClientInstallClientApp| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientInstallClientApp>(
                "CMsgClientInstallClientApp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientInstallClientApp {
        static instance: ::protobuf::rt::LazyV2<CMsgClientInstallClientApp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientInstallClientApp::new)
    }
}

impl ::protobuf::Clear for CMsgClientInstallClientApp {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientInstallClientApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientInstallClientApp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientInstallClientAppResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientInstallClientAppResponse {
    fn default() -> &'a CMsgClientInstallClientAppResponse {
        <CMsgClientInstallClientAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInstallClientAppResponse {
    pub fn new() -> CMsgClientInstallClientAppResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientInstallClientAppResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientInstallClientAppResponse {
        CMsgClientInstallClientAppResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgClientInstallClientAppResponse| { &m.result },
                |m: &mut CMsgClientInstallClientAppResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientInstallClientAppResponse>(
                "CMsgClientInstallClientAppResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientInstallClientAppResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientInstallClientAppResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientInstallClientAppResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientInstallClientAppResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientInstallClientAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientInstallClientAppResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUninstallClientApp {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUninstallClientApp {
    fn default() -> &'a CMsgClientUninstallClientApp {
        <CMsgClientUninstallClientApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUninstallClientApp {
    pub fn new() -> CMsgClientUninstallClientApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUninstallClientApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUninstallClientApp {
        CMsgClientUninstallClientApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientUninstallClientApp| { &m.appid },
                |m: &mut CMsgClientUninstallClientApp| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUninstallClientApp>(
                "CMsgClientUninstallClientApp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUninstallClientApp {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUninstallClientApp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUninstallClientApp::new)
    }
}

impl ::protobuf::Clear for CMsgClientUninstallClientApp {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUninstallClientApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUninstallClientApp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUninstallClientAppResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUninstallClientAppResponse {
    fn default() -> &'a CMsgClientUninstallClientAppResponse {
        <CMsgClientUninstallClientAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUninstallClientAppResponse {
    pub fn new() -> CMsgClientUninstallClientAppResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUninstallClientAppResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUninstallClientAppResponse {
        CMsgClientUninstallClientAppResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgClientUninstallClientAppResponse| { &m.result },
                |m: &mut CMsgClientUninstallClientAppResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUninstallClientAppResponse>(
                "CMsgClientUninstallClientAppResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUninstallClientAppResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUninstallClientAppResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUninstallClientAppResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUninstallClientAppResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUninstallClientAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUninstallClientAppResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSetClientAppUpdateState {
    // message fields
    appid: ::std::option::Option<u32>,
    update: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetClientAppUpdateState {
    fn default() -> &'a CMsgClientSetClientAppUpdateState {
        <CMsgClientSetClientAppUpdateState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetClientAppUpdateState {
    pub fn new() -> CMsgClientSetClientAppUpdateState {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool update = 2;


    pub fn get_update(&self) -> bool {
        self.update.unwrap_or(false)
    }
    pub fn clear_update(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSetClientAppUpdateState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.update {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSetClientAppUpdateState {
        CMsgClientSetClientAppUpdateState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientSetClientAppUpdateState| { &m.appid },
                |m: &mut CMsgClientSetClientAppUpdateState| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update",
                |m: &CMsgClientSetClientAppUpdateState| { &m.update },
                |m: &mut CMsgClientSetClientAppUpdateState| { &mut m.update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientSetClientAppUpdateState>(
                "CMsgClientSetClientAppUpdateState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSetClientAppUpdateState {
        static instance: ::protobuf::rt::LazyV2<CMsgClientSetClientAppUpdateState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientSetClientAppUpdateState::new)
    }
}

impl ::protobuf::Clear for CMsgClientSetClientAppUpdateState {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSetClientAppUpdateState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSetClientAppUpdateState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSetClientAppUpdateStateResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetClientAppUpdateStateResponse {
    fn default() -> &'a CMsgClientSetClientAppUpdateStateResponse {
        <CMsgClientSetClientAppUpdateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetClientAppUpdateStateResponse {
    pub fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSetClientAppUpdateStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        CMsgClientSetClientAppUpdateStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgClientSetClientAppUpdateStateResponse| { &m.result },
                |m: &mut CMsgClientSetClientAppUpdateStateResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientSetClientAppUpdateStateResponse>(
                "CMsgClientSetClientAppUpdateStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSetClientAppUpdateStateResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientSetClientAppUpdateStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientSetClientAppUpdateStateResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientSetClientAppUpdateStateResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSetClientAppUpdateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSetClientAppUpdateStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadFileRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_size: ::std::option::Option<u32>,
    raw_file_size: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    platforms_to_sync_deprecated: ::std::option::Option<u32>,
    platforms_to_sync: ::std::option::Option<u32>,
    cell_id: ::std::option::Option<u32>,
    can_encrypt: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadFileRequest {
    fn default() -> &'a CMsgClientUFSUploadFileRequest {
        <CMsgClientUFSUploadFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadFileRequest {
    pub fn new() -> CMsgClientUFSUploadFileRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 2;


    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_file_size = 3;


    pub fn get_raw_file_size(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }
    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 time_stamp = 5;


    pub fn get_time_stamp(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }
    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional string file_name = 6;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 platforms_to_sync_deprecated = 7;


    pub fn get_platforms_to_sync_deprecated(&self) -> u32 {
        self.platforms_to_sync_deprecated.unwrap_or(0)
    }
    pub fn clear_platforms_to_sync_deprecated(&mut self) {
        self.platforms_to_sync_deprecated = ::std::option::Option::None;
    }

    pub fn has_platforms_to_sync_deprecated(&self) -> bool {
        self.platforms_to_sync_deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms_to_sync_deprecated(&mut self, v: u32) {
        self.platforms_to_sync_deprecated = ::std::option::Option::Some(v);
    }

    // optional uint32 platforms_to_sync = 8;


    pub fn get_platforms_to_sync(&self) -> u32 {
        self.platforms_to_sync.unwrap_or(4294967295u32)
    }
    pub fn clear_platforms_to_sync(&mut self) {
        self.platforms_to_sync = ::std::option::Option::None;
    }

    pub fn has_platforms_to_sync(&self) -> bool {
        self.platforms_to_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms_to_sync(&mut self, v: u32) {
        self.platforms_to_sync = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 9;


    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }
    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional bool can_encrypt = 10;


    pub fn get_can_encrypt(&self) -> bool {
        self.can_encrypt.unwrap_or(false)
    }
    pub fn clear_can_encrypt(&mut self) {
        self.can_encrypt = ::std::option::Option::None;
    }

    pub fn has_can_encrypt(&self) -> bool {
        self.can_encrypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_encrypt(&mut self, v: bool) {
        self.can_encrypt = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.raw_file_size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.time_stamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.platforms_to_sync_deprecated = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.platforms_to_sync = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_encrypt = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.raw_file_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.platforms_to_sync_deprecated {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.platforms_to_sync {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.can_encrypt {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.raw_file_size {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.platforms_to_sync_deprecated {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.platforms_to_sync {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.can_encrypt {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadFileRequest {
        CMsgClientUFSUploadFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSUploadFileRequest| { &m.app_id },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "file_size",
                |m: &CMsgClientUFSUploadFileRequest| { &m.file_size },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "raw_file_size",
                |m: &CMsgClientUFSUploadFileRequest| { &m.raw_file_size },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.raw_file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientUFSUploadFileRequest| { &m.sha_file },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "time_stamp",
                |m: &CMsgClientUFSUploadFileRequest| { &m.time_stamp },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.time_stamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUFSUploadFileRequest| { &m.file_name },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "platforms_to_sync_deprecated",
                |m: &CMsgClientUFSUploadFileRequest| { &m.platforms_to_sync_deprecated },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.platforms_to_sync_deprecated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "platforms_to_sync",
                |m: &CMsgClientUFSUploadFileRequest| { &m.platforms_to_sync },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.platforms_to_sync },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cell_id",
                |m: &CMsgClientUFSUploadFileRequest| { &m.cell_id },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.cell_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_encrypt",
                |m: &CMsgClientUFSUploadFileRequest| { &m.can_encrypt },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.can_encrypt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSUploadFileRequest>(
                "CMsgClientUFSUploadFileRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadFileRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSUploadFileRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSUploadFileRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadFileRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.raw_file_size = ::std::option::Option::None;
        self.sha_file.clear();
        self.time_stamp = ::std::option::Option::None;
        self.file_name.clear();
        self.platforms_to_sync_deprecated = ::std::option::Option::None;
        self.platforms_to_sync = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.can_encrypt = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadFileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    use_http: ::std::option::Option<bool>,
    http_host: ::protobuf::SingularField<::std::string::String>,
    http_url: ::protobuf::SingularField<::std::string::String>,
    kv_headers: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    use_https: ::std::option::Option<bool>,
    encrypt_file: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadFileResponse {
    fn default() -> &'a CMsgClientUFSUploadFileResponse {
        <CMsgClientUFSUploadFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadFileResponse {
    pub fn new() -> CMsgClientUFSUploadFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 2;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool use_http = 3;


    pub fn get_use_http(&self) -> bool {
        self.use_http.unwrap_or(false)
    }
    pub fn clear_use_http(&mut self) {
        self.use_http = ::std::option::Option::None;
    }

    pub fn has_use_http(&self) -> bool {
        self.use_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_http(&mut self, v: bool) {
        self.use_http = ::std::option::Option::Some(v);
    }

    // optional string http_host = 4;


    pub fn get_http_host(&self) -> &str {
        match self.http_host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_http_host(&mut self) {
        self.http_host.clear();
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host(&mut self) -> &mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host.set_default();
        }
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string http_url = 5;


    pub fn get_http_url(&self) -> &str {
        match self.http_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_http_url(&mut self) {
        self.http_url.clear();
    }

    pub fn has_http_url(&self) -> bool {
        self.http_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_url(&mut self, v: ::std::string::String) {
        self.http_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_url(&mut self) -> &mut ::std::string::String {
        if self.http_url.is_none() {
            self.http_url.set_default();
        }
        self.http_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_url(&mut self) -> ::std::string::String {
        self.http_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes kv_headers = 6;


    pub fn get_kv_headers(&self) -> &[u8] {
        match self.kv_headers.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_kv_headers(&mut self) {
        self.kv_headers.clear();
    }

    pub fn has_kv_headers(&self) -> bool {
        self.kv_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kv_headers(&mut self, v: ::std::vec::Vec<u8>) {
        self.kv_headers = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kv_headers(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.kv_headers.is_none() {
            self.kv_headers.set_default();
        }
        self.kv_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_kv_headers(&mut self) -> ::std::vec::Vec<u8> {
        self.kv_headers.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool use_https = 7;


    pub fn get_use_https(&self) -> bool {
        self.use_https.unwrap_or(false)
    }
    pub fn clear_use_https(&mut self) {
        self.use_https = ::std::option::Option::None;
    }

    pub fn has_use_https(&self) -> bool {
        self.use_https.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_https(&mut self, v: bool) {
        self.use_https = ::std::option::Option::Some(v);
    }

    // optional bool encrypt_file = 8;


    pub fn get_encrypt_file(&self) -> bool {
        self.encrypt_file.unwrap_or(false)
    }
    pub fn clear_encrypt_file(&mut self) {
        self.encrypt_file = ::std::option::Option::None;
    }

    pub fn has_encrypt_file(&self) -> bool {
        self.encrypt_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypt_file(&mut self, v: bool) {
        self.encrypt_file = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_http = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_host)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_url)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.kv_headers)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_https = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.encrypt_file = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.use_http {
            my_size += 2;
        }
        if let Some(ref v) = self.http_host.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.http_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.kv_headers.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.use_https {
            my_size += 2;
        }
        if let Some(v) = self.encrypt_file {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.use_http {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.http_host.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.http_url.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.kv_headers.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.use_https {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.encrypt_file {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadFileResponse {
        CMsgClientUFSUploadFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUFSUploadFileResponse| { &m.eresult },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientUFSUploadFileResponse| { &m.sha_file },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_http",
                |m: &CMsgClientUFSUploadFileResponse| { &m.use_http },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.use_http },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "http_host",
                |m: &CMsgClientUFSUploadFileResponse| { &m.http_host },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.http_host },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "http_url",
                |m: &CMsgClientUFSUploadFileResponse| { &m.http_url },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.http_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "kv_headers",
                |m: &CMsgClientUFSUploadFileResponse| { &m.kv_headers },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.kv_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_https",
                |m: &CMsgClientUFSUploadFileResponse| { &m.use_https },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.use_https },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "encrypt_file",
                |m: &CMsgClientUFSUploadFileResponse| { &m.encrypt_file },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.encrypt_file },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSUploadFileResponse>(
                "CMsgClientUFSUploadFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadFileResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSUploadFileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSUploadFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.sha_file.clear();
        self.use_http = ::std::option::Option::None;
        self.http_host.clear();
        self.http_url.clear();
        self.kv_headers.clear();
        self.use_https = ::std::option::Option::None;
        self.encrypt_file = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadFileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadCommit {
    // message fields
    pub files: ::protobuf::RepeatedField<CMsgClientUFSUploadCommit_File>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadCommit {
    fn default() -> &'a CMsgClientUFSUploadCommit {
        <CMsgClientUFSUploadCommit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadCommit {
    pub fn new() -> CMsgClientUFSUploadCommit {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientUFSUploadCommit.File files = 1;


    pub fn get_files(&self) -> &[CMsgClientUFSUploadCommit_File] {
        &self.files
    }
    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUFSUploadCommit_File>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUFSUploadCommit_File> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUFSUploadCommit_File> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommit {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadCommit {
        CMsgClientUFSUploadCommit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUFSUploadCommit_File>>(
                "files",
                |m: &CMsgClientUFSUploadCommit| { &m.files },
                |m: &mut CMsgClientUFSUploadCommit| { &mut m.files },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSUploadCommit>(
                "CMsgClientUFSUploadCommit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadCommit {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSUploadCommit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSUploadCommit::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadCommit {
    fn clear(&mut self) {
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadCommit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadCommit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadCommit_File {
    // message fields
    eresult: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    cub_file: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadCommit_File {
    fn default() -> &'a CMsgClientUFSUploadCommit_File {
        <CMsgClientUFSUploadCommit_File as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadCommit_File {
    pub fn new() -> CMsgClientUFSUploadCommit_File {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 3;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 cub_file = 4;


    pub fn get_cub_file(&self) -> u32 {
        self.cub_file.unwrap_or(0)
    }
    pub fn clear_cub_file(&mut self) {
        self.cub_file = ::std::option::Option::None;
    }

    pub fn has_cub_file(&self) -> bool {
        self.cub_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cub_file(&mut self, v: u32) {
        self.cub_file = ::std::option::Option::Some(v);
    }

    // optional string file_name = 5;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommit_File {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cub_file = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.cub_file {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.cub_file {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadCommit_File {
        CMsgClientUFSUploadCommit_File::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUFSUploadCommit_File| { &m.eresult },
                |m: &mut CMsgClientUFSUploadCommit_File| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSUploadCommit_File| { &m.app_id },
                |m: &mut CMsgClientUFSUploadCommit_File| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientUFSUploadCommit_File| { &m.sha_file },
                |m: &mut CMsgClientUFSUploadCommit_File| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cub_file",
                |m: &CMsgClientUFSUploadCommit_File| { &m.cub_file },
                |m: &mut CMsgClientUFSUploadCommit_File| { &mut m.cub_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUFSUploadCommit_File| { &m.file_name },
                |m: &mut CMsgClientUFSUploadCommit_File| { &mut m.file_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSUploadCommit_File>(
                "CMsgClientUFSUploadCommit.File",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadCommit_File {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSUploadCommit_File> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSUploadCommit_File::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadCommit_File {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.sha_file.clear();
        self.cub_file = ::std::option::Option::None;
        self.file_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadCommit_File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadCommit_File {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadCommitResponse {
    // message fields
    pub files: ::protobuf::RepeatedField<CMsgClientUFSUploadCommitResponse_File>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadCommitResponse {
    fn default() -> &'a CMsgClientUFSUploadCommitResponse {
        <CMsgClientUFSUploadCommitResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadCommitResponse {
    pub fn new() -> CMsgClientUFSUploadCommitResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientUFSUploadCommitResponse.File files = 1;


    pub fn get_files(&self) -> &[CMsgClientUFSUploadCommitResponse_File] {
        &self.files
    }
    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUFSUploadCommitResponse_File>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUFSUploadCommitResponse_File> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUFSUploadCommitResponse_File> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommitResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadCommitResponse {
        CMsgClientUFSUploadCommitResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUFSUploadCommitResponse_File>>(
                "files",
                |m: &CMsgClientUFSUploadCommitResponse| { &m.files },
                |m: &mut CMsgClientUFSUploadCommitResponse| { &mut m.files },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSUploadCommitResponse>(
                "CMsgClientUFSUploadCommitResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadCommitResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSUploadCommitResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSUploadCommitResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadCommitResponse {
    fn clear(&mut self) {
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadCommitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadCommitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadCommitResponse_File {
    // message fields
    eresult: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadCommitResponse_File {
    fn default() -> &'a CMsgClientUFSUploadCommitResponse_File {
        <CMsgClientUFSUploadCommitResponse_File as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadCommitResponse_File {
    pub fn new() -> CMsgClientUFSUploadCommitResponse_File {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 3;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommitResponse_File {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadCommitResponse_File {
        CMsgClientUFSUploadCommitResponse_File::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUFSUploadCommitResponse_File| { &m.eresult },
                |m: &mut CMsgClientUFSUploadCommitResponse_File| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSUploadCommitResponse_File| { &m.app_id },
                |m: &mut CMsgClientUFSUploadCommitResponse_File| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientUFSUploadCommitResponse_File| { &m.sha_file },
                |m: &mut CMsgClientUFSUploadCommitResponse_File| { &mut m.sha_file },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSUploadCommitResponse_File>(
                "CMsgClientUFSUploadCommitResponse.File",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadCommitResponse_File {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSUploadCommitResponse_File> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSUploadCommitResponse_File::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadCommitResponse_File {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.sha_file.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadCommitResponse_File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadCommitResponse_File {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSFileChunk {
    // message fields
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    file_start: ::std::option::Option<u32>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSFileChunk {
    fn default() -> &'a CMsgClientUFSFileChunk {
        <CMsgClientUFSFileChunk as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSFileChunk {
    pub fn new() -> CMsgClientUFSFileChunk {
        ::std::default::Default::default()
    }

    // optional bytes sha_file = 1;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 file_start = 2;


    pub fn get_file_start(&self) -> u32 {
        self.file_start.unwrap_or(0)
    }
    pub fn clear_file_start(&mut self) {
        self.file_start = ::std::option::Option::None;
    }

    pub fn has_file_start(&self) -> bool {
        self.file_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_start(&mut self, v: u32) {
        self.file_start = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSFileChunk {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_start = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.file_start {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.file_start {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSFileChunk {
        CMsgClientUFSFileChunk::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientUFSFileChunk| { &m.sha_file },
                |m: &mut CMsgClientUFSFileChunk| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "file_start",
                |m: &CMsgClientUFSFileChunk| { &m.file_start },
                |m: &mut CMsgClientUFSFileChunk| { &mut m.file_start },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &CMsgClientUFSFileChunk| { &m.data },
                |m: &mut CMsgClientUFSFileChunk| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSFileChunk>(
                "CMsgClientUFSFileChunk",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSFileChunk {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSFileChunk> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSFileChunk::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSFileChunk {
    fn clear(&mut self) {
        self.sha_file.clear();
        self.file_start = ::std::option::Option::None;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSFileChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSFileChunk {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSTransferHeartbeat {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSTransferHeartbeat {
    fn default() -> &'a CMsgClientUFSTransferHeartbeat {
        <CMsgClientUFSTransferHeartbeat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSTransferHeartbeat {
    pub fn new() -> CMsgClientUFSTransferHeartbeat {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientUFSTransferHeartbeat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSTransferHeartbeat {
        CMsgClientUFSTransferHeartbeat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSTransferHeartbeat>(
                "CMsgClientUFSTransferHeartbeat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSTransferHeartbeat {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSTransferHeartbeat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSTransferHeartbeat::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSTransferHeartbeat {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSTransferHeartbeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSTransferHeartbeat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadFileFinished {
    // message fields
    eresult: ::std::option::Option<i32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadFileFinished {
    fn default() -> &'a CMsgClientUFSUploadFileFinished {
        <CMsgClientUFSUploadFileFinished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadFileFinished {
    pub fn new() -> CMsgClientUFSUploadFileFinished {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 2;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileFinished {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadFileFinished {
        CMsgClientUFSUploadFileFinished::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUFSUploadFileFinished| { &m.eresult },
                |m: &mut CMsgClientUFSUploadFileFinished| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientUFSUploadFileFinished| { &m.sha_file },
                |m: &mut CMsgClientUFSUploadFileFinished| { &mut m.sha_file },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSUploadFileFinished>(
                "CMsgClientUFSUploadFileFinished",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadFileFinished {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSUploadFileFinished> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSUploadFileFinished::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadFileFinished {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.sha_file.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadFileFinished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadFileFinished {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSDeleteFileRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    is_explicit_delete: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDeleteFileRequest {
    fn default() -> &'a CMsgClientUFSDeleteFileRequest {
        <CMsgClientUFSDeleteFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDeleteFileRequest {
    pub fn new() -> CMsgClientUFSDeleteFileRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_explicit_delete = 3;


    pub fn get_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }
    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSDeleteFileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_explicit_delete = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_explicit_delete {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.is_explicit_delete {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSDeleteFileRequest {
        CMsgClientUFSDeleteFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSDeleteFileRequest| { &m.app_id },
                |m: &mut CMsgClientUFSDeleteFileRequest| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUFSDeleteFileRequest| { &m.file_name },
                |m: &mut CMsgClientUFSDeleteFileRequest| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_explicit_delete",
                |m: &CMsgClientUFSDeleteFileRequest| { &m.is_explicit_delete },
                |m: &mut CMsgClientUFSDeleteFileRequest| { &mut m.is_explicit_delete },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSDeleteFileRequest>(
                "CMsgClientUFSDeleteFileRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSDeleteFileRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSDeleteFileRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSDeleteFileRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSDeleteFileRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.is_explicit_delete = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDeleteFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDeleteFileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSDeleteFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDeleteFileResponse {
    fn default() -> &'a CMsgClientUFSDeleteFileResponse {
        <CMsgClientUFSDeleteFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDeleteFileResponse {
    pub fn new() -> CMsgClientUFSDeleteFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSDeleteFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSDeleteFileResponse {
        CMsgClientUFSDeleteFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUFSDeleteFileResponse| { &m.eresult },
                |m: &mut CMsgClientUFSDeleteFileResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUFSDeleteFileResponse| { &m.file_name },
                |m: &mut CMsgClientUFSDeleteFileResponse| { &mut m.file_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSDeleteFileResponse>(
                "CMsgClientUFSDeleteFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSDeleteFileResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSDeleteFileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSDeleteFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSDeleteFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.file_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDeleteFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDeleteFileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetFileListForApp {
    // message fields
    pub apps_to_query: ::std::vec::Vec<u32>,
    send_path_prefixes: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetFileListForApp {
    fn default() -> &'a CMsgClientUFSGetFileListForApp {
        <CMsgClientUFSGetFileListForApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetFileListForApp {
    pub fn new() -> CMsgClientUFSGetFileListForApp {
        ::std::default::Default::default()
    }

    // repeated uint32 apps_to_query = 1;


    pub fn get_apps_to_query(&self) -> &[u32] {
        &self.apps_to_query
    }
    pub fn clear_apps_to_query(&mut self) {
        self.apps_to_query.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps_to_query(&mut self, v: ::std::vec::Vec<u32>) {
        self.apps_to_query = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps_to_query(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.apps_to_query
    }

    // Take field
    pub fn take_apps_to_query(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.apps_to_query, ::std::vec::Vec::new())
    }

    // optional bool send_path_prefixes = 2;


    pub fn get_send_path_prefixes(&self) -> bool {
        self.send_path_prefixes.unwrap_or(false)
    }
    pub fn clear_send_path_prefixes(&mut self) {
        self.send_path_prefixes = ::std::option::Option::None;
    }

    pub fn has_send_path_prefixes(&self) -> bool {
        self.send_path_prefixes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_path_prefixes(&mut self, v: bool) {
        self.send_path_prefixes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSGetFileListForApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.apps_to_query)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.send_path_prefixes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.apps_to_query {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.send_path_prefixes {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.apps_to_query {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.send_path_prefixes {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetFileListForApp {
        CMsgClientUFSGetFileListForApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "apps_to_query",
                |m: &CMsgClientUFSGetFileListForApp| { &m.apps_to_query },
                |m: &mut CMsgClientUFSGetFileListForApp| { &mut m.apps_to_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "send_path_prefixes",
                |m: &CMsgClientUFSGetFileListForApp| { &m.send_path_prefixes },
                |m: &mut CMsgClientUFSGetFileListForApp| { &mut m.send_path_prefixes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSGetFileListForApp>(
                "CMsgClientUFSGetFileListForApp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetFileListForApp {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSGetFileListForApp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSGetFileListForApp::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetFileListForApp {
    fn clear(&mut self) {
        self.apps_to_query.clear();
        self.send_path_prefixes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetFileListForApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetFileListForApp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetFileListForAppResponse {
    // message fields
    pub files: ::protobuf::RepeatedField<CMsgClientUFSGetFileListForAppResponse_File>,
    pub path_prefixes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetFileListForAppResponse {
    fn default() -> &'a CMsgClientUFSGetFileListForAppResponse {
        <CMsgClientUFSGetFileListForAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetFileListForAppResponse {
    pub fn new() -> CMsgClientUFSGetFileListForAppResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientUFSGetFileListForAppResponse.File files = 1;


    pub fn get_files(&self) -> &[CMsgClientUFSGetFileListForAppResponse_File] {
        &self.files
    }
    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUFSGetFileListForAppResponse_File>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUFSGetFileListForAppResponse_File> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUFSGetFileListForAppResponse_File> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }

    // repeated string path_prefixes = 2;


    pub fn get_path_prefixes(&self) -> &[::std::string::String] {
        &self.path_prefixes
    }
    pub fn clear_path_prefixes(&mut self) {
        self.path_prefixes.clear();
    }

    // Param is passed by value, moved
    pub fn set_path_prefixes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.path_prefixes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path_prefixes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.path_prefixes
    }

    // Take field
    pub fn take_path_prefixes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.path_prefixes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSGetFileListForAppResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.files)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.path_prefixes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.path_prefixes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.path_prefixes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetFileListForAppResponse {
        CMsgClientUFSGetFileListForAppResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUFSGetFileListForAppResponse_File>>(
                "files",
                |m: &CMsgClientUFSGetFileListForAppResponse| { &m.files },
                |m: &mut CMsgClientUFSGetFileListForAppResponse| { &mut m.files },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path_prefixes",
                |m: &CMsgClientUFSGetFileListForAppResponse| { &m.path_prefixes },
                |m: &mut CMsgClientUFSGetFileListForAppResponse| { &mut m.path_prefixes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSGetFileListForAppResponse>(
                "CMsgClientUFSGetFileListForAppResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetFileListForAppResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSGetFileListForAppResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSGetFileListForAppResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetFileListForAppResponse {
    fn clear(&mut self) {
        self.files.clear();
        self.path_prefixes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetFileListForAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetFileListForAppResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetFileListForAppResponse_File {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    raw_file_size: ::std::option::Option<u32>,
    is_explicit_delete: ::std::option::Option<bool>,
    platforms_to_sync: ::std::option::Option<u32>,
    path_prefix_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetFileListForAppResponse_File {
    fn default() -> &'a CMsgClientUFSGetFileListForAppResponse_File {
        <CMsgClientUFSGetFileListForAppResponse_File as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetFileListForAppResponse_File {
    pub fn new() -> CMsgClientUFSGetFileListForAppResponse_File {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes sha_file = 3;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 time_stamp = 4;


    pub fn get_time_stamp(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }
    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_file_size = 5;


    pub fn get_raw_file_size(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }
    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    // optional bool is_explicit_delete = 6;


    pub fn get_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }
    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }

    // optional uint32 platforms_to_sync = 7;


    pub fn get_platforms_to_sync(&self) -> u32 {
        self.platforms_to_sync.unwrap_or(0)
    }
    pub fn clear_platforms_to_sync(&mut self) {
        self.platforms_to_sync = ::std::option::Option::None;
    }

    pub fn has_platforms_to_sync(&self) -> bool {
        self.platforms_to_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms_to_sync(&mut self, v: u32) {
        self.platforms_to_sync = ::std::option::Option::Some(v);
    }

    // optional uint32 path_prefix_index = 8;


    pub fn get_path_prefix_index(&self) -> u32 {
        self.path_prefix_index.unwrap_or(0)
    }
    pub fn clear_path_prefix_index(&mut self) {
        self.path_prefix_index = ::std::option::Option::None;
    }

    pub fn has_path_prefix_index(&self) -> bool {
        self.path_prefix_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path_prefix_index(&mut self, v: u32) {
        self.path_prefix_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSGetFileListForAppResponse_File {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.time_stamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.raw_file_size = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_explicit_delete = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.platforms_to_sync = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.path_prefix_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.raw_file_size {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_explicit_delete {
            my_size += 2;
        }
        if let Some(v) = self.platforms_to_sync {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.path_prefix_index {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.raw_file_size {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.is_explicit_delete {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.platforms_to_sync {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.path_prefix_index {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetFileListForAppResponse_File {
        CMsgClientUFSGetFileListForAppResponse_File::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSGetFileListForAppResponse_File| { &m.app_id },
                |m: &mut CMsgClientUFSGetFileListForAppResponse_File| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUFSGetFileListForAppResponse_File| { &m.file_name },
                |m: &mut CMsgClientUFSGetFileListForAppResponse_File| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientUFSGetFileListForAppResponse_File| { &m.sha_file },
                |m: &mut CMsgClientUFSGetFileListForAppResponse_File| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "time_stamp",
                |m: &CMsgClientUFSGetFileListForAppResponse_File| { &m.time_stamp },
                |m: &mut CMsgClientUFSGetFileListForAppResponse_File| { &mut m.time_stamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "raw_file_size",
                |m: &CMsgClientUFSGetFileListForAppResponse_File| { &m.raw_file_size },
                |m: &mut CMsgClientUFSGetFileListForAppResponse_File| { &mut m.raw_file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_explicit_delete",
                |m: &CMsgClientUFSGetFileListForAppResponse_File| { &m.is_explicit_delete },
                |m: &mut CMsgClientUFSGetFileListForAppResponse_File| { &mut m.is_explicit_delete },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "platforms_to_sync",
                |m: &CMsgClientUFSGetFileListForAppResponse_File| { &m.platforms_to_sync },
                |m: &mut CMsgClientUFSGetFileListForAppResponse_File| { &mut m.platforms_to_sync },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "path_prefix_index",
                |m: &CMsgClientUFSGetFileListForAppResponse_File| { &m.path_prefix_index },
                |m: &mut CMsgClientUFSGetFileListForAppResponse_File| { &mut m.path_prefix_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSGetFileListForAppResponse_File>(
                "CMsgClientUFSGetFileListForAppResponse.File",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetFileListForAppResponse_File {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSGetFileListForAppResponse_File> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSGetFileListForAppResponse_File::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetFileListForAppResponse_File {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.sha_file.clear();
        self.time_stamp = ::std::option::Option::None;
        self.raw_file_size = ::std::option::Option::None;
        self.is_explicit_delete = ::std::option::Option::None;
        self.platforms_to_sync = ::std::option::Option::None;
        self.path_prefix_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetFileListForAppResponse_File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetFileListForAppResponse_File {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSDownloadRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    can_handle_http: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDownloadRequest {
    fn default() -> &'a CMsgClientUFSDownloadRequest {
        <CMsgClientUFSDownloadRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDownloadRequest {
    pub fn new() -> CMsgClientUFSDownloadRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool can_handle_http = 3;


    pub fn get_can_handle_http(&self) -> bool {
        self.can_handle_http.unwrap_or(false)
    }
    pub fn clear_can_handle_http(&mut self) {
        self.can_handle_http = ::std::option::Option::None;
    }

    pub fn has_can_handle_http(&self) -> bool {
        self.can_handle_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_handle_http(&mut self, v: bool) {
        self.can_handle_http = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSDownloadRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_handle_http = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.can_handle_http {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.can_handle_http {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSDownloadRequest {
        CMsgClientUFSDownloadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSDownloadRequest| { &m.app_id },
                |m: &mut CMsgClientUFSDownloadRequest| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUFSDownloadRequest| { &m.file_name },
                |m: &mut CMsgClientUFSDownloadRequest| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_handle_http",
                |m: &CMsgClientUFSDownloadRequest| { &m.can_handle_http },
                |m: &mut CMsgClientUFSDownloadRequest| { &mut m.can_handle_http },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSDownloadRequest>(
                "CMsgClientUFSDownloadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSDownloadRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSDownloadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSDownloadRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSDownloadRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.can_handle_http = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDownloadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDownloadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSDownloadResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    file_size: ::std::option::Option<u32>,
    raw_file_size: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    is_explicit_delete: ::std::option::Option<bool>,
    use_http: ::std::option::Option<bool>,
    http_host: ::protobuf::SingularField<::std::string::String>,
    http_url: ::protobuf::SingularField<::std::string::String>,
    kv_headers: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    use_https: ::std::option::Option<bool>,
    encrypted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDownloadResponse {
    fn default() -> &'a CMsgClientUFSDownloadResponse {
        <CMsgClientUFSDownloadResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDownloadResponse {
    pub fn new() -> CMsgClientUFSDownloadResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 3;


    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_file_size = 4;


    pub fn get_raw_file_size(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }
    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 5;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 time_stamp = 6;


    pub fn get_time_stamp(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }
    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional bool is_explicit_delete = 7;


    pub fn get_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }
    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }

    // optional bool use_http = 8;


    pub fn get_use_http(&self) -> bool {
        self.use_http.unwrap_or(false)
    }
    pub fn clear_use_http(&mut self) {
        self.use_http = ::std::option::Option::None;
    }

    pub fn has_use_http(&self) -> bool {
        self.use_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_http(&mut self, v: bool) {
        self.use_http = ::std::option::Option::Some(v);
    }

    // optional string http_host = 9;


    pub fn get_http_host(&self) -> &str {
        match self.http_host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_http_host(&mut self) {
        self.http_host.clear();
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host(&mut self) -> &mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host.set_default();
        }
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string http_url = 10;


    pub fn get_http_url(&self) -> &str {
        match self.http_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_http_url(&mut self) {
        self.http_url.clear();
    }

    pub fn has_http_url(&self) -> bool {
        self.http_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_url(&mut self, v: ::std::string::String) {
        self.http_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_url(&mut self) -> &mut ::std::string::String {
        if self.http_url.is_none() {
            self.http_url.set_default();
        }
        self.http_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_url(&mut self) -> ::std::string::String {
        self.http_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes kv_headers = 11;


    pub fn get_kv_headers(&self) -> &[u8] {
        match self.kv_headers.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_kv_headers(&mut self) {
        self.kv_headers.clear();
    }

    pub fn has_kv_headers(&self) -> bool {
        self.kv_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kv_headers(&mut self, v: ::std::vec::Vec<u8>) {
        self.kv_headers = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kv_headers(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.kv_headers.is_none() {
            self.kv_headers.set_default();
        }
        self.kv_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_kv_headers(&mut self) -> ::std::vec::Vec<u8> {
        self.kv_headers.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool use_https = 12;


    pub fn get_use_https(&self) -> bool {
        self.use_https.unwrap_or(false)
    }
    pub fn clear_use_https(&mut self) {
        self.use_https = ::std::option::Option::None;
    }

    pub fn has_use_https(&self) -> bool {
        self.use_https.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_https(&mut self, v: bool) {
        self.use_https = ::std::option::Option::Some(v);
    }

    // optional bool encrypted = 13;


    pub fn get_encrypted(&self) -> bool {
        self.encrypted.unwrap_or(false)
    }
    pub fn clear_encrypted(&mut self) {
        self.encrypted = ::std::option::Option::None;
    }

    pub fn has_encrypted(&self) -> bool {
        self.encrypted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted(&mut self, v: bool) {
        self.encrypted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSDownloadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.raw_file_size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.time_stamp = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_explicit_delete = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_http = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_host)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_url)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.kv_headers)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_https = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.encrypted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.raw_file_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_explicit_delete {
            my_size += 2;
        }
        if let Some(v) = self.use_http {
            my_size += 2;
        }
        if let Some(ref v) = self.http_host.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.http_url.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.kv_headers.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.use_https {
            my_size += 2;
        }
        if let Some(v) = self.encrypted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.raw_file_size {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.is_explicit_delete {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.use_http {
            os.write_bool(8, v)?;
        }
        if let Some(ref v) = self.http_host.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.http_url.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.kv_headers.as_ref() {
            os.write_bytes(11, &v)?;
        }
        if let Some(v) = self.use_https {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.encrypted {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSDownloadResponse {
        CMsgClientUFSDownloadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUFSDownloadResponse| { &m.eresult },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSDownloadResponse| { &m.app_id },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "file_size",
                |m: &CMsgClientUFSDownloadResponse| { &m.file_size },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "raw_file_size",
                |m: &CMsgClientUFSDownloadResponse| { &m.raw_file_size },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.raw_file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientUFSDownloadResponse| { &m.sha_file },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "time_stamp",
                |m: &CMsgClientUFSDownloadResponse| { &m.time_stamp },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.time_stamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_explicit_delete",
                |m: &CMsgClientUFSDownloadResponse| { &m.is_explicit_delete },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.is_explicit_delete },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_http",
                |m: &CMsgClientUFSDownloadResponse| { &m.use_http },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.use_http },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "http_host",
                |m: &CMsgClientUFSDownloadResponse| { &m.http_host },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.http_host },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "http_url",
                |m: &CMsgClientUFSDownloadResponse| { &m.http_url },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.http_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "kv_headers",
                |m: &CMsgClientUFSDownloadResponse| { &m.kv_headers },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.kv_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_https",
                |m: &CMsgClientUFSDownloadResponse| { &m.use_https },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.use_https },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "encrypted",
                |m: &CMsgClientUFSDownloadResponse| { &m.encrypted },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.encrypted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSDownloadResponse>(
                "CMsgClientUFSDownloadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSDownloadResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSDownloadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSDownloadResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSDownloadResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.raw_file_size = ::std::option::Option::None;
        self.sha_file.clear();
        self.time_stamp = ::std::option::Option::None;
        self.is_explicit_delete = ::std::option::Option::None;
        self.use_http = ::std::option::Option::None;
        self.http_host.clear();
        self.http_url.clear();
        self.kv_headers.clear();
        self.use_https = ::std::option::Option::None;
        self.encrypted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDownloadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSLoginRequest {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    am_session_token: ::std::option::Option<u64>,
    pub apps: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSLoginRequest {
    fn default() -> &'a CMsgClientUFSLoginRequest {
        <CMsgClientUFSLoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSLoginRequest {
    pub fn new() -> CMsgClientUFSLoginRequest {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint64 am_session_token = 2;


    pub fn get_am_session_token(&self) -> u64 {
        self.am_session_token.unwrap_or(0)
    }
    pub fn clear_am_session_token(&mut self) {
        self.am_session_token = ::std::option::Option::None;
    }

    pub fn has_am_session_token(&self) -> bool {
        self.am_session_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_am_session_token(&mut self, v: u64) {
        self.am_session_token = ::std::option::Option::Some(v);
    }

    // repeated uint32 apps = 3;


    pub fn get_apps(&self) -> &[u32] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::std::vec::Vec<u32>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.apps, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSLoginRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.am_session_token = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.apps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.am_session_token {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.apps {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.am_session_token {
            os.write_uint64(2, v)?;
        }
        for v in &self.apps {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSLoginRequest {
        CMsgClientUFSLoginRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgClientUFSLoginRequest| { &m.protocol_version },
                |m: &mut CMsgClientUFSLoginRequest| { &mut m.protocol_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "am_session_token",
                |m: &CMsgClientUFSLoginRequest| { &m.am_session_token },
                |m: &mut CMsgClientUFSLoginRequest| { &mut m.am_session_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "apps",
                |m: &CMsgClientUFSLoginRequest| { &m.apps },
                |m: &mut CMsgClientUFSLoginRequest| { &mut m.apps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSLoginRequest>(
                "CMsgClientUFSLoginRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSLoginRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSLoginRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSLoginRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSLoginRequest {
    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.am_session_token = ::std::option::Option::None;
        self.apps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSLoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSLoginRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSLoginResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSLoginResponse {
    fn default() -> &'a CMsgClientUFSLoginResponse {
        <CMsgClientUFSLoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSLoginResponse {
    pub fn new() -> CMsgClientUFSLoginResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSLoginResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSLoginResponse {
        CMsgClientUFSLoginResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUFSLoginResponse| { &m.eresult },
                |m: &mut CMsgClientUFSLoginResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSLoginResponse>(
                "CMsgClientUFSLoginResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSLoginResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSLoginResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSLoginResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSLoginResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSLoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSLoginResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestEncryptedAppTicket {
    // message fields
    app_id: ::std::option::Option<u32>,
    userdata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestEncryptedAppTicket {
    fn default() -> &'a CMsgClientRequestEncryptedAppTicket {
        <CMsgClientRequestEncryptedAppTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestEncryptedAppTicket {
    pub fn new() -> CMsgClientRequestEncryptedAppTicket {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes userdata = 2;


    pub fn get_userdata(&self) -> &[u8] {
        match self.userdata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_userdata(&mut self) {
        self.userdata.clear();
    }

    pub fn has_userdata(&self) -> bool {
        self.userdata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userdata(&mut self, v: ::std::vec::Vec<u8>) {
        self.userdata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userdata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.userdata.is_none() {
            self.userdata.set_default();
        }
        self.userdata.as_mut().unwrap()
    }

    // Take field
    pub fn take_userdata(&mut self) -> ::std::vec::Vec<u8> {
        self.userdata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestEncryptedAppTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.userdata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.userdata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.userdata.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestEncryptedAppTicket {
        CMsgClientRequestEncryptedAppTicket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientRequestEncryptedAppTicket| { &m.app_id },
                |m: &mut CMsgClientRequestEncryptedAppTicket| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "userdata",
                |m: &CMsgClientRequestEncryptedAppTicket| { &m.userdata },
                |m: &mut CMsgClientRequestEncryptedAppTicket| { &mut m.userdata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestEncryptedAppTicket>(
                "CMsgClientRequestEncryptedAppTicket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicket {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestEncryptedAppTicket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestEncryptedAppTicket::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestEncryptedAppTicket {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.userdata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestEncryptedAppTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestEncryptedAppTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestEncryptedAppTicketResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    eresult: ::std::option::Option<i32>,
    pub encrypted_app_ticket: ::protobuf::SingularPtrField<super::encrypted_app_ticket::EncryptedAppTicket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestEncryptedAppTicketResponse {
    fn default() -> &'a CMsgClientRequestEncryptedAppTicketResponse {
        <CMsgClientRequestEncryptedAppTicketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestEncryptedAppTicketResponse {
    pub fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional .EncryptedAppTicket encrypted_app_ticket = 3;


    pub fn get_encrypted_app_ticket(&self) -> &super::encrypted_app_ticket::EncryptedAppTicket {
        self.encrypted_app_ticket.as_ref().unwrap_or_else(|| <super::encrypted_app_ticket::EncryptedAppTicket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encrypted_app_ticket(&mut self) {
        self.encrypted_app_ticket.clear();
    }

    pub fn has_encrypted_app_ticket(&self) -> bool {
        self.encrypted_app_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_app_ticket(&mut self, v: super::encrypted_app_ticket::EncryptedAppTicket) {
        self.encrypted_app_ticket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_app_ticket(&mut self) -> &mut super::encrypted_app_ticket::EncryptedAppTicket {
        if self.encrypted_app_ticket.is_none() {
            self.encrypted_app_ticket.set_default();
        }
        self.encrypted_app_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_app_ticket(&mut self) -> super::encrypted_app_ticket::EncryptedAppTicket {
        self.encrypted_app_ticket.take().unwrap_or_else(|| super::encrypted_app_ticket::EncryptedAppTicket::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestEncryptedAppTicketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.encrypted_app_ticket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encrypted_app_ticket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.encrypted_app_ticket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.encrypted_app_ticket.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        CMsgClientRequestEncryptedAppTicketResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.app_id },
                |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.eresult },
                |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::encrypted_app_ticket::EncryptedAppTicket>>(
                "encrypted_app_ticket",
                |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.encrypted_app_ticket },
                |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.encrypted_app_ticket },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestEncryptedAppTicketResponse>(
                "CMsgClientRequestEncryptedAppTicketResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicketResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestEncryptedAppTicketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestEncryptedAppTicketResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestEncryptedAppTicketResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.encrypted_app_ticket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestEncryptedAppTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestEncryptedAppTicketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWalletInfoUpdate {
    // message fields
    has_wallet: ::std::option::Option<bool>,
    balance: ::std::option::Option<i32>,
    currency: ::std::option::Option<i32>,
    balance_delayed: ::std::option::Option<i32>,
    balance64: ::std::option::Option<i64>,
    balance64_delayed: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWalletInfoUpdate {
    fn default() -> &'a CMsgClientWalletInfoUpdate {
        <CMsgClientWalletInfoUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWalletInfoUpdate {
    pub fn new() -> CMsgClientWalletInfoUpdate {
        ::std::default::Default::default()
    }

    // optional bool has_wallet = 1;


    pub fn get_has_wallet(&self) -> bool {
        self.has_wallet.unwrap_or(false)
    }
    pub fn clear_has_wallet(&mut self) {
        self.has_wallet = ::std::option::Option::None;
    }

    pub fn has_has_wallet(&self) -> bool {
        self.has_wallet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_wallet(&mut self, v: bool) {
        self.has_wallet = ::std::option::Option::Some(v);
    }

    // optional int32 balance = 2;


    pub fn get_balance(&self) -> i32 {
        self.balance.unwrap_or(0)
    }
    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;


    pub fn get_currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }
    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional int32 balance_delayed = 4;


    pub fn get_balance_delayed(&self) -> i32 {
        self.balance_delayed.unwrap_or(0)
    }
    pub fn clear_balance_delayed(&mut self) {
        self.balance_delayed = ::std::option::Option::None;
    }

    pub fn has_balance_delayed(&self) -> bool {
        self.balance_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_delayed(&mut self, v: i32) {
        self.balance_delayed = ::std::option::Option::Some(v);
    }

    // optional int64 balance64 = 5;


    pub fn get_balance64(&self) -> i64 {
        self.balance64.unwrap_or(0)
    }
    pub fn clear_balance64(&mut self) {
        self.balance64 = ::std::option::Option::None;
    }

    pub fn has_balance64(&self) -> bool {
        self.balance64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance64(&mut self, v: i64) {
        self.balance64 = ::std::option::Option::Some(v);
    }

    // optional int64 balance64_delayed = 6;


    pub fn get_balance64_delayed(&self) -> i64 {
        self.balance64_delayed.unwrap_or(0)
    }
    pub fn clear_balance64_delayed(&mut self) {
        self.balance64_delayed = ::std::option::Option::None;
    }

    pub fn has_balance64_delayed(&self) -> bool {
        self.balance64_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance64_delayed(&mut self, v: i64) {
        self.balance64_delayed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWalletInfoUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_wallet = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.balance = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.currency = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.balance_delayed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.balance64 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.balance64_delayed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.has_wallet {
            my_size += 2;
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance_delayed {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance64 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance64_delayed {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.has_wallet {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.balance {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.balance_delayed {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.balance64 {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.balance64_delayed {
            os.write_int64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWalletInfoUpdate {
        CMsgClientWalletInfoUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_wallet",
                |m: &CMsgClientWalletInfoUpdate| { &m.has_wallet },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.has_wallet },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "balance",
                |m: &CMsgClientWalletInfoUpdate| { &m.balance },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "currency",
                |m: &CMsgClientWalletInfoUpdate| { &m.currency },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.currency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "balance_delayed",
                |m: &CMsgClientWalletInfoUpdate| { &m.balance_delayed },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance_delayed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "balance64",
                |m: &CMsgClientWalletInfoUpdate| { &m.balance64 },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance64 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "balance64_delayed",
                |m: &CMsgClientWalletInfoUpdate| { &m.balance64_delayed },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance64_delayed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientWalletInfoUpdate>(
                "CMsgClientWalletInfoUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWalletInfoUpdate {
        static instance: ::protobuf::rt::LazyV2<CMsgClientWalletInfoUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientWalletInfoUpdate::new)
    }
}

impl ::protobuf::Clear for CMsgClientWalletInfoUpdate {
    fn clear(&mut self) {
        self.has_wallet = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.balance_delayed = ::std::option::Option::None;
        self.balance64 = ::std::option::Option::None;
        self.balance64_delayed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWalletInfoUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWalletInfoUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoUpdate {
    // message fields
    last_changenumber: ::std::option::Option<u32>,
    send_changelist: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoUpdate {
    fn default() -> &'a CMsgClientAppInfoUpdate {
        <CMsgClientAppInfoUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoUpdate {
    pub fn new() -> CMsgClientAppInfoUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 last_changenumber = 1;


    pub fn get_last_changenumber(&self) -> u32 {
        self.last_changenumber.unwrap_or(0)
    }
    pub fn clear_last_changenumber(&mut self) {
        self.last_changenumber = ::std::option::Option::None;
    }

    pub fn has_last_changenumber(&self) -> bool {
        self.last_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_changenumber(&mut self, v: u32) {
        self.last_changenumber = ::std::option::Option::Some(v);
    }

    // optional bool send_changelist = 2;


    pub fn get_send_changelist(&self) -> bool {
        self.send_changelist.unwrap_or(false)
    }
    pub fn clear_send_changelist(&mut self) {
        self.send_changelist = ::std::option::Option::None;
    }

    pub fn has_send_changelist(&self) -> bool {
        self.send_changelist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_changelist(&mut self, v: bool) {
        self.send_changelist = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAppInfoUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_changenumber = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.send_changelist = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.last_changenumber {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.send_changelist {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.last_changenumber {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.send_changelist {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoUpdate {
        CMsgClientAppInfoUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_changenumber",
                |m: &CMsgClientAppInfoUpdate| { &m.last_changenumber },
                |m: &mut CMsgClientAppInfoUpdate| { &mut m.last_changenumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "send_changelist",
                |m: &CMsgClientAppInfoUpdate| { &m.send_changelist },
                |m: &mut CMsgClientAppInfoUpdate| { &mut m.send_changelist },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAppInfoUpdate>(
                "CMsgClientAppInfoUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoUpdate {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAppInfoUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAppInfoUpdate::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoUpdate {
    fn clear(&mut self) {
        self.last_changenumber = ::std::option::Option::None;
        self.send_changelist = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoChanges {
    // message fields
    current_change_number: ::std::option::Option<u32>,
    force_full_update: ::std::option::Option<bool>,
    pub appIDs: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoChanges {
    fn default() -> &'a CMsgClientAppInfoChanges {
        <CMsgClientAppInfoChanges as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoChanges {
    pub fn new() -> CMsgClientAppInfoChanges {
        ::std::default::Default::default()
    }

    // optional uint32 current_change_number = 1;


    pub fn get_current_change_number(&self) -> u32 {
        self.current_change_number.unwrap_or(0)
    }
    pub fn clear_current_change_number(&mut self) {
        self.current_change_number = ::std::option::Option::None;
    }

    pub fn has_current_change_number(&self) -> bool {
        self.current_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_change_number(&mut self, v: u32) {
        self.current_change_number = ::std::option::Option::Some(v);
    }

    // optional bool force_full_update = 2;


    pub fn get_force_full_update(&self) -> bool {
        self.force_full_update.unwrap_or(false)
    }
    pub fn clear_force_full_update(&mut self) {
        self.force_full_update = ::std::option::Option::None;
    }

    pub fn has_force_full_update(&self) -> bool {
        self.force_full_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_update(&mut self, v: bool) {
        self.force_full_update = ::std::option::Option::Some(v);
    }

    // repeated uint32 appIDs = 3;


    pub fn get_appIDs(&self) -> &[u32] {
        &self.appIDs
    }
    pub fn clear_appIDs(&mut self) {
        self.appIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_appIDs(&mut self, v: ::std::vec::Vec<u32>) {
        self.appIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appIDs(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appIDs
    }

    // Take field
    pub fn take_appIDs(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appIDs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientAppInfoChanges {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current_change_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_full_update = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.current_change_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.force_full_update {
            my_size += 2;
        }
        for value in &self.appIDs {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.current_change_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.force_full_update {
            os.write_bool(2, v)?;
        }
        for v in &self.appIDs {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoChanges {
        CMsgClientAppInfoChanges::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "current_change_number",
                |m: &CMsgClientAppInfoChanges| { &m.current_change_number },
                |m: &mut CMsgClientAppInfoChanges| { &mut m.current_change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_full_update",
                |m: &CMsgClientAppInfoChanges| { &m.force_full_update },
                |m: &mut CMsgClientAppInfoChanges| { &mut m.force_full_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appIDs",
                |m: &CMsgClientAppInfoChanges| { &m.appIDs },
                |m: &mut CMsgClientAppInfoChanges| { &mut m.appIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAppInfoChanges>(
                "CMsgClientAppInfoChanges",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoChanges {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAppInfoChanges> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAppInfoChanges::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoChanges {
    fn clear(&mut self) {
        self.current_change_number = ::std::option::Option::None;
        self.force_full_update = ::std::option::Option::None;
        self.appIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoChanges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoChanges {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoRequest {
    // message fields
    pub apps: ::protobuf::RepeatedField<CMsgClientAppInfoRequest_App>,
    supports_batches: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoRequest {
    fn default() -> &'a CMsgClientAppInfoRequest {
        <CMsgClientAppInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoRequest {
    pub fn new() -> CMsgClientAppInfoRequest {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientAppInfoRequest.App apps = 1;


    pub fn get_apps(&self) -> &[CMsgClientAppInfoRequest_App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientAppInfoRequest_App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientAppInfoRequest_App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientAppInfoRequest_App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    // optional bool supports_batches = 2;


    pub fn get_supports_batches(&self) -> bool {
        self.supports_batches.unwrap_or(false)
    }
    pub fn clear_supports_batches(&mut self) {
        self.supports_batches = ::std::option::Option::None;
    }

    pub fn has_supports_batches(&self) -> bool {
        self.supports_batches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_batches(&mut self, v: bool) {
        self.supports_batches = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAppInfoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_batches = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.supports_batches {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.apps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.supports_batches {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoRequest {
        CMsgClientAppInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientAppInfoRequest_App>>(
                "apps",
                |m: &CMsgClientAppInfoRequest| { &m.apps },
                |m: &mut CMsgClientAppInfoRequest| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_batches",
                |m: &CMsgClientAppInfoRequest| { &m.supports_batches },
                |m: &mut CMsgClientAppInfoRequest| { &mut m.supports_batches },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAppInfoRequest>(
                "CMsgClientAppInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAppInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAppInfoRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoRequest {
    fn clear(&mut self) {
        self.apps.clear();
        self.supports_batches = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoRequest_App {
    // message fields
    app_id: ::std::option::Option<u32>,
    section_flags: ::std::option::Option<u32>,
    pub section_CRC: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoRequest_App {
    fn default() -> &'a CMsgClientAppInfoRequest_App {
        <CMsgClientAppInfoRequest_App as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoRequest_App {
    pub fn new() -> CMsgClientAppInfoRequest_App {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 section_flags = 2;


    pub fn get_section_flags(&self) -> u32 {
        self.section_flags.unwrap_or(0)
    }
    pub fn clear_section_flags(&mut self) {
        self.section_flags = ::std::option::Option::None;
    }

    pub fn has_section_flags(&self) -> bool {
        self.section_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_flags(&mut self, v: u32) {
        self.section_flags = ::std::option::Option::Some(v);
    }

    // repeated uint32 section_CRC = 3;


    pub fn get_section_CRC(&self) -> &[u32] {
        &self.section_CRC
    }
    pub fn clear_section_CRC(&mut self) {
        self.section_CRC.clear();
    }

    // Param is passed by value, moved
    pub fn set_section_CRC(&mut self, v: ::std::vec::Vec<u32>) {
        self.section_CRC = v;
    }

    // Mutable pointer to the field.
    pub fn mut_section_CRC(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.section_CRC
    }

    // Take field
    pub fn take_section_CRC(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.section_CRC, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientAppInfoRequest_App {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.section_flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.section_CRC)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.section_flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.section_CRC {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.section_flags {
            os.write_uint32(2, v)?;
        }
        for v in &self.section_CRC {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoRequest_App {
        CMsgClientAppInfoRequest_App::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientAppInfoRequest_App| { &m.app_id },
                |m: &mut CMsgClientAppInfoRequest_App| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "section_flags",
                |m: &CMsgClientAppInfoRequest_App| { &m.section_flags },
                |m: &mut CMsgClientAppInfoRequest_App| { &mut m.section_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "section_CRC",
                |m: &CMsgClientAppInfoRequest_App| { &m.section_CRC },
                |m: &mut CMsgClientAppInfoRequest_App| { &mut m.section_CRC },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAppInfoRequest_App>(
                "CMsgClientAppInfoRequest.App",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoRequest_App {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAppInfoRequest_App> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAppInfoRequest_App::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoRequest_App {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.section_flags = ::std::option::Option::None;
        self.section_CRC.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoRequest_App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoRequest_App {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoResponse {
    // message fields
    pub apps: ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App>,
    pub apps_unknown: ::std::vec::Vec<u32>,
    apps_pending: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoResponse {
    fn default() -> &'a CMsgClientAppInfoResponse {
        <CMsgClientAppInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoResponse {
    pub fn new() -> CMsgClientAppInfoResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientAppInfoResponse.App apps = 1;


    pub fn get_apps(&self) -> &[CMsgClientAppInfoResponse_App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 apps_unknown = 2;


    pub fn get_apps_unknown(&self) -> &[u32] {
        &self.apps_unknown
    }
    pub fn clear_apps_unknown(&mut self) {
        self.apps_unknown.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps_unknown(&mut self, v: ::std::vec::Vec<u32>) {
        self.apps_unknown = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps_unknown(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.apps_unknown
    }

    // Take field
    pub fn take_apps_unknown(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.apps_unknown, ::std::vec::Vec::new())
    }

    // optional uint32 apps_pending = 3;


    pub fn get_apps_pending(&self) -> u32 {
        self.apps_pending.unwrap_or(0)
    }
    pub fn clear_apps_pending(&mut self) {
        self.apps_pending = ::std::option::Option::None;
    }

    pub fn has_apps_pending(&self) -> bool {
        self.apps_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apps_pending(&mut self, v: u32) {
        self.apps_pending = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAppInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.apps_unknown)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.apps_pending = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.apps_unknown {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.apps_pending {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.apps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.apps_unknown {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.apps_pending {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoResponse {
        CMsgClientAppInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientAppInfoResponse_App>>(
                "apps",
                |m: &CMsgClientAppInfoResponse| { &m.apps },
                |m: &mut CMsgClientAppInfoResponse| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "apps_unknown",
                |m: &CMsgClientAppInfoResponse| { &m.apps_unknown },
                |m: &mut CMsgClientAppInfoResponse| { &mut m.apps_unknown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "apps_pending",
                |m: &CMsgClientAppInfoResponse| { &m.apps_pending },
                |m: &mut CMsgClientAppInfoResponse| { &mut m.apps_pending },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAppInfoResponse>(
                "CMsgClientAppInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAppInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAppInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoResponse {
    fn clear(&mut self) {
        self.apps.clear();
        self.apps_unknown.clear();
        self.apps_pending = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoResponse_App {
    // message fields
    app_id: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    pub sections: ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App_Section>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoResponse_App {
    fn default() -> &'a CMsgClientAppInfoResponse_App {
        <CMsgClientAppInfoResponse_App as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoResponse_App {
    pub fn new() -> CMsgClientAppInfoResponse_App {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 change_number = 2;


    pub fn get_change_number(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }
    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientAppInfoResponse.App.Section sections = 3;


    pub fn get_sections(&self) -> &[CMsgClientAppInfoResponse_App_Section] {
        &self.sections
    }
    pub fn clear_sections(&mut self) {
        self.sections.clear();
    }

    // Param is passed by value, moved
    pub fn set_sections(&mut self, v: ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App_Section>) {
        self.sections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sections(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App_Section> {
        &mut self.sections
    }

    // Take field
    pub fn take_sections(&mut self) -> ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App_Section> {
        ::std::mem::replace(&mut self.sections, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientAppInfoResponse_App {
    fn is_initialized(&self) -> bool {
        for v in &self.sections {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sections)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.change_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.change_number {
            os.write_uint32(2, v)?;
        }
        for v in &self.sections {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoResponse_App {
        CMsgClientAppInfoResponse_App::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientAppInfoResponse_App| { &m.app_id },
                |m: &mut CMsgClientAppInfoResponse_App| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "change_number",
                |m: &CMsgClientAppInfoResponse_App| { &m.change_number },
                |m: &mut CMsgClientAppInfoResponse_App| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientAppInfoResponse_App_Section>>(
                "sections",
                |m: &CMsgClientAppInfoResponse_App| { &m.sections },
                |m: &mut CMsgClientAppInfoResponse_App| { &mut m.sections },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAppInfoResponse_App>(
                "CMsgClientAppInfoResponse.App",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoResponse_App {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAppInfoResponse_App> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAppInfoResponse_App::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoResponse_App {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.change_number = ::std::option::Option::None;
        self.sections.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoResponse_App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoResponse_App {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoResponse_App_Section {
    // message fields
    section_id: ::std::option::Option<u32>,
    section_kv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoResponse_App_Section {
    fn default() -> &'a CMsgClientAppInfoResponse_App_Section {
        <CMsgClientAppInfoResponse_App_Section as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoResponse_App_Section {
    pub fn new() -> CMsgClientAppInfoResponse_App_Section {
        ::std::default::Default::default()
    }

    // optional uint32 section_id = 1;


    pub fn get_section_id(&self) -> u32 {
        self.section_id.unwrap_or(0)
    }
    pub fn clear_section_id(&mut self) {
        self.section_id = ::std::option::Option::None;
    }

    pub fn has_section_id(&self) -> bool {
        self.section_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_id(&mut self, v: u32) {
        self.section_id = ::std::option::Option::Some(v);
    }

    // optional bytes section_kv = 2;


    pub fn get_section_kv(&self) -> &[u8] {
        match self.section_kv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_section_kv(&mut self) {
        self.section_kv.clear();
    }

    pub fn has_section_kv(&self) -> bool {
        self.section_kv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_kv(&mut self, v: ::std::vec::Vec<u8>) {
        self.section_kv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_section_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.section_kv.is_none() {
            self.section_kv.set_default();
        }
        self.section_kv.as_mut().unwrap()
    }

    // Take field
    pub fn take_section_kv(&mut self) -> ::std::vec::Vec<u8> {
        self.section_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientAppInfoResponse_App_Section {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.section_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.section_kv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.section_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.section_kv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.section_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.section_kv.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoResponse_App_Section {
        CMsgClientAppInfoResponse_App_Section::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "section_id",
                |m: &CMsgClientAppInfoResponse_App_Section| { &m.section_id },
                |m: &mut CMsgClientAppInfoResponse_App_Section| { &mut m.section_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "section_kv",
                |m: &CMsgClientAppInfoResponse_App_Section| { &m.section_kv },
                |m: &mut CMsgClientAppInfoResponse_App_Section| { &mut m.section_kv },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAppInfoResponse_App_Section>(
                "CMsgClientAppInfoResponse.App.Section",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoResponse_App_Section {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAppInfoResponse_App_Section> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAppInfoResponse_App_Section::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoResponse_App_Section {
    fn clear(&mut self) {
        self.section_id = ::std::option::Option::None;
        self.section_kv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoResponse_App_Section {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoResponse_App_Section {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPackageInfoRequest {
    // message fields
    pub package_ids: ::std::vec::Vec<u32>,
    meta_data_only: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPackageInfoRequest {
    fn default() -> &'a CMsgClientPackageInfoRequest {
        <CMsgClientPackageInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPackageInfoRequest {
    pub fn new() -> CMsgClientPackageInfoRequest {
        ::std::default::Default::default()
    }

    // repeated uint32 package_ids = 1;


    pub fn get_package_ids(&self) -> &[u32] {
        &self.package_ids
    }
    pub fn clear_package_ids(&mut self) {
        self.package_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.package_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.package_ids
    }

    // Take field
    pub fn take_package_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.package_ids, ::std::vec::Vec::new())
    }

    // optional bool meta_data_only = 2;


    pub fn get_meta_data_only(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }
    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPackageInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.package_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.meta_data_only = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.package_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.meta_data_only {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.package_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.meta_data_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPackageInfoRequest {
        CMsgClientPackageInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "package_ids",
                |m: &CMsgClientPackageInfoRequest| { &m.package_ids },
                |m: &mut CMsgClientPackageInfoRequest| { &mut m.package_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "meta_data_only",
                |m: &CMsgClientPackageInfoRequest| { &m.meta_data_only },
                |m: &mut CMsgClientPackageInfoRequest| { &mut m.meta_data_only },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPackageInfoRequest>(
                "CMsgClientPackageInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPackageInfoRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPackageInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPackageInfoRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientPackageInfoRequest {
    fn clear(&mut self) {
        self.package_ids.clear();
        self.meta_data_only = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPackageInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPackageInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPackageInfoResponse {
    // message fields
    pub packages: ::protobuf::RepeatedField<CMsgClientPackageInfoResponse_Package>,
    pub packages_unknown: ::std::vec::Vec<u32>,
    packages_pending: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPackageInfoResponse {
    fn default() -> &'a CMsgClientPackageInfoResponse {
        <CMsgClientPackageInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPackageInfoResponse {
    pub fn new() -> CMsgClientPackageInfoResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientPackageInfoResponse.Package packages = 1;


    pub fn get_packages(&self) -> &[CMsgClientPackageInfoResponse_Package] {
        &self.packages
    }
    pub fn clear_packages(&mut self) {
        self.packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages(&mut self, v: ::protobuf::RepeatedField<CMsgClientPackageInfoResponse_Package>) {
        self.packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPackageInfoResponse_Package> {
        &mut self.packages
    }

    // Take field
    pub fn take_packages(&mut self) -> ::protobuf::RepeatedField<CMsgClientPackageInfoResponse_Package> {
        ::std::mem::replace(&mut self.packages, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 packages_unknown = 2;


    pub fn get_packages_unknown(&self) -> &[u32] {
        &self.packages_unknown
    }
    pub fn clear_packages_unknown(&mut self) {
        self.packages_unknown.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages_unknown(&mut self, v: ::std::vec::Vec<u32>) {
        self.packages_unknown = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages_unknown(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packages_unknown
    }

    // Take field
    pub fn take_packages_unknown(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packages_unknown, ::std::vec::Vec::new())
    }

    // optional uint32 packages_pending = 3;


    pub fn get_packages_pending(&self) -> u32 {
        self.packages_pending.unwrap_or(0)
    }
    pub fn clear_packages_pending(&mut self) {
        self.packages_pending = ::std::option::Option::None;
    }

    pub fn has_packages_pending(&self) -> bool {
        self.packages_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packages_pending(&mut self, v: u32) {
        self.packages_pending = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPackageInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.packages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.packages)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.packages_unknown)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packages_pending = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.packages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.packages_unknown {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.packages_pending {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.packages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.packages_unknown {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.packages_pending {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPackageInfoResponse {
        CMsgClientPackageInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPackageInfoResponse_Package>>(
                "packages",
                |m: &CMsgClientPackageInfoResponse| { &m.packages },
                |m: &mut CMsgClientPackageInfoResponse| { &mut m.packages },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packages_unknown",
                |m: &CMsgClientPackageInfoResponse| { &m.packages_unknown },
                |m: &mut CMsgClientPackageInfoResponse| { &mut m.packages_unknown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packages_pending",
                |m: &CMsgClientPackageInfoResponse| { &m.packages_pending },
                |m: &mut CMsgClientPackageInfoResponse| { &mut m.packages_pending },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPackageInfoResponse>(
                "CMsgClientPackageInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPackageInfoResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPackageInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPackageInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientPackageInfoResponse {
    fn clear(&mut self) {
        self.packages.clear();
        self.packages_unknown.clear();
        self.packages_pending = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPackageInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPackageInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPackageInfoResponse_Package {
    // message fields
    package_id: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    buffer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPackageInfoResponse_Package {
    fn default() -> &'a CMsgClientPackageInfoResponse_Package {
        <CMsgClientPackageInfoResponse_Package as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPackageInfoResponse_Package {
    pub fn new() -> CMsgClientPackageInfoResponse_Package {
        ::std::default::Default::default()
    }

    // optional uint32 package_id = 1;


    pub fn get_package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }
    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional uint32 change_number = 2;


    pub fn get_change_number(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }
    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    // optional bytes sha = 3;


    pub fn get_sha(&self) -> &[u8] {
        match self.sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha(&mut self) {
        self.sha.clear();
    }

    pub fn has_sha(&self) -> bool {
        self.sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha.is_none() {
            self.sha.set_default();
        }
        self.sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes buffer = 4;


    pub fn get_buffer(&self) -> &[u8] {
        match self.buffer.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_buffer(&mut self) {
        self.buffer.clear();
    }

    pub fn has_buffer(&self) -> bool {
        self.buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.buffer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.buffer.is_none() {
            self.buffer.set_default();
        }
        self.buffer.as_mut().unwrap()
    }

    // Take field
    pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
        self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientPackageInfoResponse_Package {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.package_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buffer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.package_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.change_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.buffer.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.package_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.change_number {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.sha.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.buffer.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPackageInfoResponse_Package {
        CMsgClientPackageInfoResponse_Package::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "package_id",
                |m: &CMsgClientPackageInfoResponse_Package| { &m.package_id },
                |m: &mut CMsgClientPackageInfoResponse_Package| { &mut m.package_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "change_number",
                |m: &CMsgClientPackageInfoResponse_Package| { &m.change_number },
                |m: &mut CMsgClientPackageInfoResponse_Package| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha",
                |m: &CMsgClientPackageInfoResponse_Package| { &m.sha },
                |m: &mut CMsgClientPackageInfoResponse_Package| { &mut m.sha },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "buffer",
                |m: &CMsgClientPackageInfoResponse_Package| { &m.buffer },
                |m: &mut CMsgClientPackageInfoResponse_Package| { &mut m.buffer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPackageInfoResponse_Package>(
                "CMsgClientPackageInfoResponse.Package",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPackageInfoResponse_Package {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPackageInfoResponse_Package> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPackageInfoResponse_Package::new)
    }
}

impl ::protobuf::Clear for CMsgClientPackageInfoResponse_Package {
    fn clear(&mut self) {
        self.package_id = ::std::option::Option::None;
        self.change_number = ::std::option::Option::None;
        self.sha.clear();
        self.buffer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPackageInfoResponse_Package {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPackageInfoResponse_Package {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSChangesSinceRequest {
    // message fields
    since_change_number: ::std::option::Option<u32>,
    send_app_info_changes: ::std::option::Option<bool>,
    send_package_info_changes: ::std::option::Option<bool>,
    num_app_info_cached: ::std::option::Option<u32>,
    num_package_info_cached: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSChangesSinceRequest {
    fn default() -> &'a CMsgClientPICSChangesSinceRequest {
        <CMsgClientPICSChangesSinceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSChangesSinceRequest {
    pub fn new() -> CMsgClientPICSChangesSinceRequest {
        ::std::default::Default::default()
    }

    // optional uint32 since_change_number = 1;


    pub fn get_since_change_number(&self) -> u32 {
        self.since_change_number.unwrap_or(0)
    }
    pub fn clear_since_change_number(&mut self) {
        self.since_change_number = ::std::option::Option::None;
    }

    pub fn has_since_change_number(&self) -> bool {
        self.since_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_since_change_number(&mut self, v: u32) {
        self.since_change_number = ::std::option::Option::Some(v);
    }

    // optional bool send_app_info_changes = 2;


    pub fn get_send_app_info_changes(&self) -> bool {
        self.send_app_info_changes.unwrap_or(false)
    }
    pub fn clear_send_app_info_changes(&mut self) {
        self.send_app_info_changes = ::std::option::Option::None;
    }

    pub fn has_send_app_info_changes(&self) -> bool {
        self.send_app_info_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_app_info_changes(&mut self, v: bool) {
        self.send_app_info_changes = ::std::option::Option::Some(v);
    }

    // optional bool send_package_info_changes = 3;


    pub fn get_send_package_info_changes(&self) -> bool {
        self.send_package_info_changes.unwrap_or(false)
    }
    pub fn clear_send_package_info_changes(&mut self) {
        self.send_package_info_changes = ::std::option::Option::None;
    }

    pub fn has_send_package_info_changes(&self) -> bool {
        self.send_package_info_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_package_info_changes(&mut self, v: bool) {
        self.send_package_info_changes = ::std::option::Option::Some(v);
    }

    // optional uint32 num_app_info_cached = 4;


    pub fn get_num_app_info_cached(&self) -> u32 {
        self.num_app_info_cached.unwrap_or(0)
    }
    pub fn clear_num_app_info_cached(&mut self) {
        self.num_app_info_cached = ::std::option::Option::None;
    }

    pub fn has_num_app_info_cached(&self) -> bool {
        self.num_app_info_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_app_info_cached(&mut self, v: u32) {
        self.num_app_info_cached = ::std::option::Option::Some(v);
    }

    // optional uint32 num_package_info_cached = 5;


    pub fn get_num_package_info_cached(&self) -> u32 {
        self.num_package_info_cached.unwrap_or(0)
    }
    pub fn clear_num_package_info_cached(&mut self) {
        self.num_package_info_cached = ::std::option::Option::None;
    }

    pub fn has_num_package_info_cached(&self) -> bool {
        self.num_package_info_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_package_info_cached(&mut self, v: u32) {
        self.num_package_info_cached = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.since_change_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.send_app_info_changes = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.send_package_info_changes = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_app_info_cached = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_package_info_cached = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.since_change_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.send_app_info_changes {
            my_size += 2;
        }
        if let Some(v) = self.send_package_info_changes {
            my_size += 2;
        }
        if let Some(v) = self.num_app_info_cached {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_package_info_cached {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.since_change_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.send_app_info_changes {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.send_package_info_changes {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.num_app_info_cached {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.num_package_info_cached {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSChangesSinceRequest {
        CMsgClientPICSChangesSinceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "since_change_number",
                |m: &CMsgClientPICSChangesSinceRequest| { &m.since_change_number },
                |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.since_change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "send_app_info_changes",
                |m: &CMsgClientPICSChangesSinceRequest| { &m.send_app_info_changes },
                |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.send_app_info_changes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "send_package_info_changes",
                |m: &CMsgClientPICSChangesSinceRequest| { &m.send_package_info_changes },
                |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.send_package_info_changes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_app_info_cached",
                |m: &CMsgClientPICSChangesSinceRequest| { &m.num_app_info_cached },
                |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.num_app_info_cached },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_package_info_cached",
                |m: &CMsgClientPICSChangesSinceRequest| { &m.num_package_info_cached },
                |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.num_package_info_cached },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSChangesSinceRequest>(
                "CMsgClientPICSChangesSinceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSChangesSinceRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSChangesSinceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSChangesSinceRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSChangesSinceRequest {
    fn clear(&mut self) {
        self.since_change_number = ::std::option::Option::None;
        self.send_app_info_changes = ::std::option::Option::None;
        self.send_package_info_changes = ::std::option::Option::None;
        self.num_app_info_cached = ::std::option::Option::None;
        self.num_package_info_cached = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSChangesSinceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSChangesSinceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSChangesSinceResponse {
    // message fields
    current_change_number: ::std::option::Option<u32>,
    since_change_number: ::std::option::Option<u32>,
    force_full_update: ::std::option::Option<bool>,
    pub package_changes: ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_PackageChange>,
    pub app_changes: ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_AppChange>,
    force_full_app_update: ::std::option::Option<bool>,
    force_full_package_update: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSChangesSinceResponse {
    fn default() -> &'a CMsgClientPICSChangesSinceResponse {
        <CMsgClientPICSChangesSinceResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSChangesSinceResponse {
    pub fn new() -> CMsgClientPICSChangesSinceResponse {
        ::std::default::Default::default()
    }

    // optional uint32 current_change_number = 1;


    pub fn get_current_change_number(&self) -> u32 {
        self.current_change_number.unwrap_or(0)
    }
    pub fn clear_current_change_number(&mut self) {
        self.current_change_number = ::std::option::Option::None;
    }

    pub fn has_current_change_number(&self) -> bool {
        self.current_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_change_number(&mut self, v: u32) {
        self.current_change_number = ::std::option::Option::Some(v);
    }

    // optional uint32 since_change_number = 2;


    pub fn get_since_change_number(&self) -> u32 {
        self.since_change_number.unwrap_or(0)
    }
    pub fn clear_since_change_number(&mut self) {
        self.since_change_number = ::std::option::Option::None;
    }

    pub fn has_since_change_number(&self) -> bool {
        self.since_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_since_change_number(&mut self, v: u32) {
        self.since_change_number = ::std::option::Option::Some(v);
    }

    // optional bool force_full_update = 3;


    pub fn get_force_full_update(&self) -> bool {
        self.force_full_update.unwrap_or(false)
    }
    pub fn clear_force_full_update(&mut self) {
        self.force_full_update = ::std::option::Option::None;
    }

    pub fn has_force_full_update(&self) -> bool {
        self.force_full_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_update(&mut self, v: bool) {
        self.force_full_update = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientPICSChangesSinceResponse.PackageChange package_changes = 4;


    pub fn get_package_changes(&self) -> &[CMsgClientPICSChangesSinceResponse_PackageChange] {
        &self.package_changes
    }
    pub fn clear_package_changes(&mut self) {
        self.package_changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_changes(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_PackageChange>) {
        self.package_changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package_changes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_PackageChange> {
        &mut self.package_changes
    }

    // Take field
    pub fn take_package_changes(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_PackageChange> {
        ::std::mem::replace(&mut self.package_changes, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgClientPICSChangesSinceResponse.AppChange app_changes = 5;


    pub fn get_app_changes(&self) -> &[CMsgClientPICSChangesSinceResponse_AppChange] {
        &self.app_changes
    }
    pub fn clear_app_changes(&mut self) {
        self.app_changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_changes(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_AppChange>) {
        self.app_changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_changes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_AppChange> {
        &mut self.app_changes
    }

    // Take field
    pub fn take_app_changes(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_AppChange> {
        ::std::mem::replace(&mut self.app_changes, ::protobuf::RepeatedField::new())
    }

    // optional bool force_full_app_update = 6;


    pub fn get_force_full_app_update(&self) -> bool {
        self.force_full_app_update.unwrap_or(false)
    }
    pub fn clear_force_full_app_update(&mut self) {
        self.force_full_app_update = ::std::option::Option::None;
    }

    pub fn has_force_full_app_update(&self) -> bool {
        self.force_full_app_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_app_update(&mut self, v: bool) {
        self.force_full_app_update = ::std::option::Option::Some(v);
    }

    // optional bool force_full_package_update = 7;


    pub fn get_force_full_package_update(&self) -> bool {
        self.force_full_package_update.unwrap_or(false)
    }
    pub fn clear_force_full_package_update(&mut self) {
        self.force_full_package_update = ::std::option::Option::None;
    }

    pub fn has_force_full_package_update(&self) -> bool {
        self.force_full_package_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_package_update(&mut self, v: bool) {
        self.force_full_package_update = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.package_changes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_changes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current_change_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.since_change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_full_update = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.package_changes)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.app_changes)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_full_app_update = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_full_package_update = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.current_change_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.since_change_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.force_full_update {
            my_size += 2;
        }
        for value in &self.package_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.app_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.force_full_app_update {
            my_size += 2;
        }
        if let Some(v) = self.force_full_package_update {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.current_change_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.since_change_number {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.force_full_update {
            os.write_bool(3, v)?;
        }
        for v in &self.package_changes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.app_changes {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.force_full_app_update {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.force_full_package_update {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSChangesSinceResponse {
        CMsgClientPICSChangesSinceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "current_change_number",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.current_change_number },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.current_change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "since_change_number",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.since_change_number },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.since_change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_full_update",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.force_full_update },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.force_full_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPICSChangesSinceResponse_PackageChange>>(
                "package_changes",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.package_changes },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.package_changes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPICSChangesSinceResponse_AppChange>>(
                "app_changes",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.app_changes },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.app_changes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_full_app_update",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.force_full_app_update },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.force_full_app_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_full_package_update",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.force_full_package_update },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.force_full_package_update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSChangesSinceResponse>(
                "CMsgClientPICSChangesSinceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSChangesSinceResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSChangesSinceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSChangesSinceResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSChangesSinceResponse {
    fn clear(&mut self) {
        self.current_change_number = ::std::option::Option::None;
        self.since_change_number = ::std::option::Option::None;
        self.force_full_update = ::std::option::Option::None;
        self.package_changes.clear();
        self.app_changes.clear();
        self.force_full_app_update = ::std::option::Option::None;
        self.force_full_package_update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSChangesSinceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSChangesSinceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSChangesSinceResponse_PackageChange {
    // message fields
    packageid: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    needs_token: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSChangesSinceResponse_PackageChange {
    fn default() -> &'a CMsgClientPICSChangesSinceResponse_PackageChange {
        <CMsgClientPICSChangesSinceResponse_PackageChange as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSChangesSinceResponse_PackageChange {
    pub fn new() -> CMsgClientPICSChangesSinceResponse_PackageChange {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;


    pub fn get_packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }
    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 change_number = 2;


    pub fn get_change_number(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }
    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    // optional bool needs_token = 3;


    pub fn get_needs_token(&self) -> bool {
        self.needs_token.unwrap_or(false)
    }
    pub fn clear_needs_token(&mut self) {
        self.needs_token = ::std::option::Option::None;
    }

    pub fn has_needs_token(&self) -> bool {
        self.needs_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_token(&mut self, v: bool) {
        self.needs_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceResponse_PackageChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packageid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.change_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.needs_token {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.change_number {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.needs_token {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSChangesSinceResponse_PackageChange {
        CMsgClientPICSChangesSinceResponse_PackageChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packageid",
                |m: &CMsgClientPICSChangesSinceResponse_PackageChange| { &m.packageid },
                |m: &mut CMsgClientPICSChangesSinceResponse_PackageChange| { &mut m.packageid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "change_number",
                |m: &CMsgClientPICSChangesSinceResponse_PackageChange| { &m.change_number },
                |m: &mut CMsgClientPICSChangesSinceResponse_PackageChange| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needs_token",
                |m: &CMsgClientPICSChangesSinceResponse_PackageChange| { &m.needs_token },
                |m: &mut CMsgClientPICSChangesSinceResponse_PackageChange| { &mut m.needs_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSChangesSinceResponse_PackageChange>(
                "CMsgClientPICSChangesSinceResponse.PackageChange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSChangesSinceResponse_PackageChange {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSChangesSinceResponse_PackageChange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSChangesSinceResponse_PackageChange::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSChangesSinceResponse_PackageChange {
    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.change_number = ::std::option::Option::None;
        self.needs_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSChangesSinceResponse_PackageChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSChangesSinceResponse_PackageChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSChangesSinceResponse_AppChange {
    // message fields
    appid: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    needs_token: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSChangesSinceResponse_AppChange {
    fn default() -> &'a CMsgClientPICSChangesSinceResponse_AppChange {
        <CMsgClientPICSChangesSinceResponse_AppChange as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSChangesSinceResponse_AppChange {
    pub fn new() -> CMsgClientPICSChangesSinceResponse_AppChange {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 change_number = 2;


    pub fn get_change_number(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }
    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    // optional bool needs_token = 3;


    pub fn get_needs_token(&self) -> bool {
        self.needs_token.unwrap_or(false)
    }
    pub fn clear_needs_token(&mut self) {
        self.needs_token = ::std::option::Option::None;
    }

    pub fn has_needs_token(&self) -> bool {
        self.needs_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_token(&mut self, v: bool) {
        self.needs_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceResponse_AppChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.change_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.needs_token {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.change_number {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.needs_token {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSChangesSinceResponse_AppChange {
        CMsgClientPICSChangesSinceResponse_AppChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientPICSChangesSinceResponse_AppChange| { &m.appid },
                |m: &mut CMsgClientPICSChangesSinceResponse_AppChange| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "change_number",
                |m: &CMsgClientPICSChangesSinceResponse_AppChange| { &m.change_number },
                |m: &mut CMsgClientPICSChangesSinceResponse_AppChange| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needs_token",
                |m: &CMsgClientPICSChangesSinceResponse_AppChange| { &m.needs_token },
                |m: &mut CMsgClientPICSChangesSinceResponse_AppChange| { &mut m.needs_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSChangesSinceResponse_AppChange>(
                "CMsgClientPICSChangesSinceResponse.AppChange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSChangesSinceResponse_AppChange {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSChangesSinceResponse_AppChange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSChangesSinceResponse_AppChange::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSChangesSinceResponse_AppChange {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.change_number = ::std::option::Option::None;
        self.needs_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSChangesSinceResponse_AppChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSChangesSinceResponse_AppChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSProductInfoRequest {
    // message fields
    pub packages: ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_PackageInfo>,
    pub apps: ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_AppInfo>,
    meta_data_only: ::std::option::Option<bool>,
    num_prev_failed: ::std::option::Option<u32>,
    supports_package_tokens: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSProductInfoRequest {
    fn default() -> &'a CMsgClientPICSProductInfoRequest {
        <CMsgClientPICSProductInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSProductInfoRequest {
    pub fn new() -> CMsgClientPICSProductInfoRequest {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientPICSProductInfoRequest.PackageInfo packages = 1;


    pub fn get_packages(&self) -> &[CMsgClientPICSProductInfoRequest_PackageInfo] {
        &self.packages
    }
    pub fn clear_packages(&mut self) {
        self.packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_PackageInfo>) {
        self.packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_PackageInfo> {
        &mut self.packages
    }

    // Take field
    pub fn take_packages(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_PackageInfo> {
        ::std::mem::replace(&mut self.packages, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgClientPICSProductInfoRequest.AppInfo apps = 2;


    pub fn get_apps(&self) -> &[CMsgClientPICSProductInfoRequest_AppInfo] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_AppInfo>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_AppInfo> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_AppInfo> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    // optional bool meta_data_only = 3;


    pub fn get_meta_data_only(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }
    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }

    // optional uint32 num_prev_failed = 4;


    pub fn get_num_prev_failed(&self) -> u32 {
        self.num_prev_failed.unwrap_or(0)
    }
    pub fn clear_num_prev_failed(&mut self) {
        self.num_prev_failed = ::std::option::Option::None;
    }

    pub fn has_num_prev_failed(&self) -> bool {
        self.num_prev_failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_prev_failed(&mut self, v: u32) {
        self.num_prev_failed = ::std::option::Option::Some(v);
    }

    // optional uint32 supports_package_tokens = 5;


    pub fn get_supports_package_tokens(&self) -> u32 {
        self.supports_package_tokens.unwrap_or(0)
    }
    pub fn clear_supports_package_tokens(&mut self) {
        self.supports_package_tokens = ::std::option::Option::None;
    }

    pub fn has_supports_package_tokens(&self) -> bool {
        self.supports_package_tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_package_tokens(&mut self, v: u32) {
        self.supports_package_tokens = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.packages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.packages)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.meta_data_only = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_prev_failed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.supports_package_tokens = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.packages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.meta_data_only {
            my_size += 2;
        }
        if let Some(v) = self.num_prev_failed {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.supports_package_tokens {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.packages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.apps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.meta_data_only {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.num_prev_failed {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.supports_package_tokens {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSProductInfoRequest {
        CMsgClientPICSProductInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPICSProductInfoRequest_PackageInfo>>(
                "packages",
                |m: &CMsgClientPICSProductInfoRequest| { &m.packages },
                |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.packages },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPICSProductInfoRequest_AppInfo>>(
                "apps",
                |m: &CMsgClientPICSProductInfoRequest| { &m.apps },
                |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "meta_data_only",
                |m: &CMsgClientPICSProductInfoRequest| { &m.meta_data_only },
                |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.meta_data_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_prev_failed",
                |m: &CMsgClientPICSProductInfoRequest| { &m.num_prev_failed },
                |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.num_prev_failed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "supports_package_tokens",
                |m: &CMsgClientPICSProductInfoRequest| { &m.supports_package_tokens },
                |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.supports_package_tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSProductInfoRequest>(
                "CMsgClientPICSProductInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSProductInfoRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSProductInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSProductInfoRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoRequest {
    fn clear(&mut self) {
        self.packages.clear();
        self.apps.clear();
        self.meta_data_only = ::std::option::Option::None;
        self.num_prev_failed = ::std::option::Option::None;
        self.supports_package_tokens = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSProductInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSProductInfoRequest_AppInfo {
    // message fields
    appid: ::std::option::Option<u32>,
    access_token: ::std::option::Option<u64>,
    only_public_obsolete: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSProductInfoRequest_AppInfo {
    fn default() -> &'a CMsgClientPICSProductInfoRequest_AppInfo {
        <CMsgClientPICSProductInfoRequest_AppInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSProductInfoRequest_AppInfo {
    pub fn new() -> CMsgClientPICSProductInfoRequest_AppInfo {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 access_token = 2;


    pub fn get_access_token(&self) -> u64 {
        self.access_token.unwrap_or(0)
    }
    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: u64) {
        self.access_token = ::std::option::Option::Some(v);
    }

    // optional bool only_public_obsolete = 3;


    pub fn get_only_public_obsolete(&self) -> bool {
        self.only_public_obsolete.unwrap_or(false)
    }
    pub fn clear_only_public_obsolete(&mut self) {
        self.only_public_obsolete = ::std::option::Option::None;
    }

    pub fn has_only_public_obsolete(&self) -> bool {
        self.only_public_obsolete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_public_obsolete(&mut self, v: bool) {
        self.only_public_obsolete = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoRequest_AppInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.access_token = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.only_public_obsolete = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.access_token {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.only_public_obsolete {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.access_token {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.only_public_obsolete {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSProductInfoRequest_AppInfo {
        CMsgClientPICSProductInfoRequest_AppInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientPICSProductInfoRequest_AppInfo| { &m.appid },
                |m: &mut CMsgClientPICSProductInfoRequest_AppInfo| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "access_token",
                |m: &CMsgClientPICSProductInfoRequest_AppInfo| { &m.access_token },
                |m: &mut CMsgClientPICSProductInfoRequest_AppInfo| { &mut m.access_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "only_public_obsolete",
                |m: &CMsgClientPICSProductInfoRequest_AppInfo| { &m.only_public_obsolete },
                |m: &mut CMsgClientPICSProductInfoRequest_AppInfo| { &mut m.only_public_obsolete },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSProductInfoRequest_AppInfo>(
                "CMsgClientPICSProductInfoRequest.AppInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSProductInfoRequest_AppInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSProductInfoRequest_AppInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSProductInfoRequest_AppInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoRequest_AppInfo {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.access_token = ::std::option::Option::None;
        self.only_public_obsolete = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoRequest_AppInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSProductInfoRequest_AppInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSProductInfoRequest_PackageInfo {
    // message fields
    packageid: ::std::option::Option<u32>,
    access_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSProductInfoRequest_PackageInfo {
    fn default() -> &'a CMsgClientPICSProductInfoRequest_PackageInfo {
        <CMsgClientPICSProductInfoRequest_PackageInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSProductInfoRequest_PackageInfo {
    pub fn new() -> CMsgClientPICSProductInfoRequest_PackageInfo {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;


    pub fn get_packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }
    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional uint64 access_token = 2;


    pub fn get_access_token(&self) -> u64 {
        self.access_token.unwrap_or(0)
    }
    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: u64) {
        self.access_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoRequest_PackageInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packageid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.access_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.access_token {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.access_token {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSProductInfoRequest_PackageInfo {
        CMsgClientPICSProductInfoRequest_PackageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packageid",
                |m: &CMsgClientPICSProductInfoRequest_PackageInfo| { &m.packageid },
                |m: &mut CMsgClientPICSProductInfoRequest_PackageInfo| { &mut m.packageid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "access_token",
                |m: &CMsgClientPICSProductInfoRequest_PackageInfo| { &m.access_token },
                |m: &mut CMsgClientPICSProductInfoRequest_PackageInfo| { &mut m.access_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSProductInfoRequest_PackageInfo>(
                "CMsgClientPICSProductInfoRequest.PackageInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSProductInfoRequest_PackageInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSProductInfoRequest_PackageInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSProductInfoRequest_PackageInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoRequest_PackageInfo {
    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.access_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoRequest_PackageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSProductInfoRequest_PackageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSProductInfoResponse {
    // message fields
    pub apps: ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_AppInfo>,
    pub unknown_appids: ::std::vec::Vec<u32>,
    pub packages: ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_PackageInfo>,
    pub unknown_packageids: ::std::vec::Vec<u32>,
    meta_data_only: ::std::option::Option<bool>,
    response_pending: ::std::option::Option<bool>,
    http_min_size: ::std::option::Option<u32>,
    http_host: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSProductInfoResponse {
    fn default() -> &'a CMsgClientPICSProductInfoResponse {
        <CMsgClientPICSProductInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSProductInfoResponse {
    pub fn new() -> CMsgClientPICSProductInfoResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientPICSProductInfoResponse.AppInfo apps = 1;


    pub fn get_apps(&self) -> &[CMsgClientPICSProductInfoResponse_AppInfo] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_AppInfo>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_AppInfo> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_AppInfo> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 unknown_appids = 2;


    pub fn get_unknown_appids(&self) -> &[u32] {
        &self.unknown_appids
    }
    pub fn clear_unknown_appids(&mut self) {
        self.unknown_appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_unknown_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.unknown_appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unknown_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.unknown_appids
    }

    // Take field
    pub fn take_unknown_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.unknown_appids, ::std::vec::Vec::new())
    }

    // repeated .CMsgClientPICSProductInfoResponse.PackageInfo packages = 3;


    pub fn get_packages(&self) -> &[CMsgClientPICSProductInfoResponse_PackageInfo] {
        &self.packages
    }
    pub fn clear_packages(&mut self) {
        self.packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_PackageInfo>) {
        self.packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_PackageInfo> {
        &mut self.packages
    }

    // Take field
    pub fn take_packages(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_PackageInfo> {
        ::std::mem::replace(&mut self.packages, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 unknown_packageids = 4;


    pub fn get_unknown_packageids(&self) -> &[u32] {
        &self.unknown_packageids
    }
    pub fn clear_unknown_packageids(&mut self) {
        self.unknown_packageids.clear();
    }

    // Param is passed by value, moved
    pub fn set_unknown_packageids(&mut self, v: ::std::vec::Vec<u32>) {
        self.unknown_packageids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unknown_packageids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.unknown_packageids
    }

    // Take field
    pub fn take_unknown_packageids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.unknown_packageids, ::std::vec::Vec::new())
    }

    // optional bool meta_data_only = 5;


    pub fn get_meta_data_only(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }
    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }

    // optional bool response_pending = 6;


    pub fn get_response_pending(&self) -> bool {
        self.response_pending.unwrap_or(false)
    }
    pub fn clear_response_pending(&mut self) {
        self.response_pending = ::std::option::Option::None;
    }

    pub fn has_response_pending(&self) -> bool {
        self.response_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_pending(&mut self, v: bool) {
        self.response_pending = ::std::option::Option::Some(v);
    }

    // optional uint32 http_min_size = 7;


    pub fn get_http_min_size(&self) -> u32 {
        self.http_min_size.unwrap_or(0)
    }
    pub fn clear_http_min_size(&mut self) {
        self.http_min_size = ::std::option::Option::None;
    }

    pub fn has_http_min_size(&self) -> bool {
        self.http_min_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_min_size(&mut self, v: u32) {
        self.http_min_size = ::std::option::Option::Some(v);
    }

    // optional string http_host = 8;


    pub fn get_http_host(&self) -> &str {
        match self.http_host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_http_host(&mut self) {
        self.http_host.clear();
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host(&mut self) -> &mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host.set_default();
        }
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.packages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.unknown_appids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.packages)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.unknown_packageids)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.meta_data_only = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.response_pending = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.http_min_size = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unknown_appids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.packages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unknown_packageids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.meta_data_only {
            my_size += 2;
        }
        if let Some(v) = self.response_pending {
            my_size += 2;
        }
        if let Some(v) = self.http_min_size {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.http_host.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.apps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unknown_appids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.packages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unknown_packageids {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.meta_data_only {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.response_pending {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.http_min_size {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.http_host.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSProductInfoResponse {
        CMsgClientPICSProductInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPICSProductInfoResponse_AppInfo>>(
                "apps",
                |m: &CMsgClientPICSProductInfoResponse| { &m.apps },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "unknown_appids",
                |m: &CMsgClientPICSProductInfoResponse| { &m.unknown_appids },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.unknown_appids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPICSProductInfoResponse_PackageInfo>>(
                "packages",
                |m: &CMsgClientPICSProductInfoResponse| { &m.packages },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.packages },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "unknown_packageids",
                |m: &CMsgClientPICSProductInfoResponse| { &m.unknown_packageids },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.unknown_packageids },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "meta_data_only",
                |m: &CMsgClientPICSProductInfoResponse| { &m.meta_data_only },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.meta_data_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "response_pending",
                |m: &CMsgClientPICSProductInfoResponse| { &m.response_pending },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.response_pending },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "http_min_size",
                |m: &CMsgClientPICSProductInfoResponse| { &m.http_min_size },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.http_min_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "http_host",
                |m: &CMsgClientPICSProductInfoResponse| { &m.http_host },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.http_host },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSProductInfoResponse>(
                "CMsgClientPICSProductInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSProductInfoResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSProductInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSProductInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoResponse {
    fn clear(&mut self) {
        self.apps.clear();
        self.unknown_appids.clear();
        self.packages.clear();
        self.unknown_packageids.clear();
        self.meta_data_only = ::std::option::Option::None;
        self.response_pending = ::std::option::Option::None;
        self.http_min_size = ::std::option::Option::None;
        self.http_host.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSProductInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSProductInfoResponse_AppInfo {
    // message fields
    appid: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    missing_token: ::std::option::Option<bool>,
    sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    buffer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    only_public: ::std::option::Option<bool>,
    size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSProductInfoResponse_AppInfo {
    fn default() -> &'a CMsgClientPICSProductInfoResponse_AppInfo {
        <CMsgClientPICSProductInfoResponse_AppInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSProductInfoResponse_AppInfo {
    pub fn new() -> CMsgClientPICSProductInfoResponse_AppInfo {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 change_number = 2;


    pub fn get_change_number(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }
    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    // optional bool missing_token = 3;


    pub fn get_missing_token(&self) -> bool {
        self.missing_token.unwrap_or(false)
    }
    pub fn clear_missing_token(&mut self) {
        self.missing_token = ::std::option::Option::None;
    }

    pub fn has_missing_token(&self) -> bool {
        self.missing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_token(&mut self, v: bool) {
        self.missing_token = ::std::option::Option::Some(v);
    }

    // optional bytes sha = 4;


    pub fn get_sha(&self) -> &[u8] {
        match self.sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha(&mut self) {
        self.sha.clear();
    }

    pub fn has_sha(&self) -> bool {
        self.sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha.is_none() {
            self.sha.set_default();
        }
        self.sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes buffer = 5;


    pub fn get_buffer(&self) -> &[u8] {
        match self.buffer.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_buffer(&mut self) {
        self.buffer.clear();
    }

    pub fn has_buffer(&self) -> bool {
        self.buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.buffer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.buffer.is_none() {
            self.buffer.set_default();
        }
        self.buffer.as_mut().unwrap()
    }

    // Take field
    pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
        self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool only_public = 6;


    pub fn get_only_public(&self) -> bool {
        self.only_public.unwrap_or(false)
    }
    pub fn clear_only_public(&mut self) {
        self.only_public = ::std::option::Option::None;
    }

    pub fn has_only_public(&self) -> bool {
        self.only_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_public(&mut self, v: bool) {
        self.only_public = ::std::option::Option::Some(v);
    }

    // optional uint32 size = 7;


    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoResponse_AppInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_token = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buffer)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.only_public = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.change_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_token {
            my_size += 2;
        }
        if let Some(ref v) = self.sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.buffer.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.only_public {
            my_size += 2;
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.change_number {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.missing_token {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.sha.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.buffer.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.only_public {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSProductInfoResponse_AppInfo {
        CMsgClientPICSProductInfoResponse_AppInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientPICSProductInfoResponse_AppInfo| { &m.appid },
                |m: &mut CMsgClientPICSProductInfoResponse_AppInfo| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "change_number",
                |m: &CMsgClientPICSProductInfoResponse_AppInfo| { &m.change_number },
                |m: &mut CMsgClientPICSProductInfoResponse_AppInfo| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_token",
                |m: &CMsgClientPICSProductInfoResponse_AppInfo| { &m.missing_token },
                |m: &mut CMsgClientPICSProductInfoResponse_AppInfo| { &mut m.missing_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha",
                |m: &CMsgClientPICSProductInfoResponse_AppInfo| { &m.sha },
                |m: &mut CMsgClientPICSProductInfoResponse_AppInfo| { &mut m.sha },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "buffer",
                |m: &CMsgClientPICSProductInfoResponse_AppInfo| { &m.buffer },
                |m: &mut CMsgClientPICSProductInfoResponse_AppInfo| { &mut m.buffer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "only_public",
                |m: &CMsgClientPICSProductInfoResponse_AppInfo| { &m.only_public },
                |m: &mut CMsgClientPICSProductInfoResponse_AppInfo| { &mut m.only_public },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "size",
                |m: &CMsgClientPICSProductInfoResponse_AppInfo| { &m.size },
                |m: &mut CMsgClientPICSProductInfoResponse_AppInfo| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSProductInfoResponse_AppInfo>(
                "CMsgClientPICSProductInfoResponse.AppInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSProductInfoResponse_AppInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSProductInfoResponse_AppInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSProductInfoResponse_AppInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoResponse_AppInfo {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.change_number = ::std::option::Option::None;
        self.missing_token = ::std::option::Option::None;
        self.sha.clear();
        self.buffer.clear();
        self.only_public = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoResponse_AppInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSProductInfoResponse_AppInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSProductInfoResponse_PackageInfo {
    // message fields
    packageid: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    missing_token: ::std::option::Option<bool>,
    sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    buffer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSProductInfoResponse_PackageInfo {
    fn default() -> &'a CMsgClientPICSProductInfoResponse_PackageInfo {
        <CMsgClientPICSProductInfoResponse_PackageInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSProductInfoResponse_PackageInfo {
    pub fn new() -> CMsgClientPICSProductInfoResponse_PackageInfo {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;


    pub fn get_packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }
    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 change_number = 2;


    pub fn get_change_number(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }
    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    // optional bool missing_token = 3;


    pub fn get_missing_token(&self) -> bool {
        self.missing_token.unwrap_or(false)
    }
    pub fn clear_missing_token(&mut self) {
        self.missing_token = ::std::option::Option::None;
    }

    pub fn has_missing_token(&self) -> bool {
        self.missing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_token(&mut self, v: bool) {
        self.missing_token = ::std::option::Option::Some(v);
    }

    // optional bytes sha = 4;


    pub fn get_sha(&self) -> &[u8] {
        match self.sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha(&mut self) {
        self.sha.clear();
    }

    pub fn has_sha(&self) -> bool {
        self.sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha.is_none() {
            self.sha.set_default();
        }
        self.sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes buffer = 5;


    pub fn get_buffer(&self) -> &[u8] {
        match self.buffer.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_buffer(&mut self) {
        self.buffer.clear();
    }

    pub fn has_buffer(&self) -> bool {
        self.buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.buffer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.buffer.is_none() {
            self.buffer.set_default();
        }
        self.buffer.as_mut().unwrap()
    }

    // Take field
    pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
        self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 size = 6;


    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoResponse_PackageInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packageid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_token = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buffer)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.change_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_token {
            my_size += 2;
        }
        if let Some(ref v) = self.sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.buffer.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.change_number {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.missing_token {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.sha.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.buffer.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSProductInfoResponse_PackageInfo {
        CMsgClientPICSProductInfoResponse_PackageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packageid",
                |m: &CMsgClientPICSProductInfoResponse_PackageInfo| { &m.packageid },
                |m: &mut CMsgClientPICSProductInfoResponse_PackageInfo| { &mut m.packageid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "change_number",
                |m: &CMsgClientPICSProductInfoResponse_PackageInfo| { &m.change_number },
                |m: &mut CMsgClientPICSProductInfoResponse_PackageInfo| { &mut m.change_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_token",
                |m: &CMsgClientPICSProductInfoResponse_PackageInfo| { &m.missing_token },
                |m: &mut CMsgClientPICSProductInfoResponse_PackageInfo| { &mut m.missing_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha",
                |m: &CMsgClientPICSProductInfoResponse_PackageInfo| { &m.sha },
                |m: &mut CMsgClientPICSProductInfoResponse_PackageInfo| { &mut m.sha },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "buffer",
                |m: &CMsgClientPICSProductInfoResponse_PackageInfo| { &m.buffer },
                |m: &mut CMsgClientPICSProductInfoResponse_PackageInfo| { &mut m.buffer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "size",
                |m: &CMsgClientPICSProductInfoResponse_PackageInfo| { &m.size },
                |m: &mut CMsgClientPICSProductInfoResponse_PackageInfo| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSProductInfoResponse_PackageInfo>(
                "CMsgClientPICSProductInfoResponse.PackageInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSProductInfoResponse_PackageInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSProductInfoResponse_PackageInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSProductInfoResponse_PackageInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoResponse_PackageInfo {
    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.change_number = ::std::option::Option::None;
        self.missing_token = ::std::option::Option::None;
        self.sha.clear();
        self.buffer.clear();
        self.size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoResponse_PackageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSProductInfoResponse_PackageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSAccessTokenRequest {
    // message fields
    pub packageids: ::std::vec::Vec<u32>,
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSAccessTokenRequest {
    fn default() -> &'a CMsgClientPICSAccessTokenRequest {
        <CMsgClientPICSAccessTokenRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSAccessTokenRequest {
    pub fn new() -> CMsgClientPICSAccessTokenRequest {
        ::std::default::Default::default()
    }

    // repeated uint32 packageids = 1;


    pub fn get_packageids(&self) -> &[u32] {
        &self.packageids
    }
    pub fn clear_packageids(&mut self) {
        self.packageids.clear();
    }

    // Param is passed by value, moved
    pub fn set_packageids(&mut self, v: ::std::vec::Vec<u32>) {
        self.packageids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packageids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packageids
    }

    // Take field
    pub fn take_packageids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packageids, ::std::vec::Vec::new())
    }

    // repeated uint32 appids = 2;


    pub fn get_appids(&self) -> &[u32] {
        &self.appids
    }
    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.packageids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.packageids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.appids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.packageids {
            os.write_uint32(1, *v)?;
        };
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSAccessTokenRequest {
        CMsgClientPICSAccessTokenRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packageids",
                |m: &CMsgClientPICSAccessTokenRequest| { &m.packageids },
                |m: &mut CMsgClientPICSAccessTokenRequest| { &mut m.packageids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appids",
                |m: &CMsgClientPICSAccessTokenRequest| { &m.appids },
                |m: &mut CMsgClientPICSAccessTokenRequest| { &mut m.appids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSAccessTokenRequest>(
                "CMsgClientPICSAccessTokenRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSAccessTokenRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSAccessTokenRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSAccessTokenRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSAccessTokenRequest {
    fn clear(&mut self) {
        self.packageids.clear();
        self.appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSAccessTokenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSAccessTokenRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSAccessTokenResponse {
    // message fields
    pub package_access_tokens: ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_PackageToken>,
    pub package_denied_tokens: ::std::vec::Vec<u32>,
    pub app_access_tokens: ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_AppToken>,
    pub app_denied_tokens: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSAccessTokenResponse {
    fn default() -> &'a CMsgClientPICSAccessTokenResponse {
        <CMsgClientPICSAccessTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSAccessTokenResponse {
    pub fn new() -> CMsgClientPICSAccessTokenResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientPICSAccessTokenResponse.PackageToken package_access_tokens = 1;


    pub fn get_package_access_tokens(&self) -> &[CMsgClientPICSAccessTokenResponse_PackageToken] {
        &self.package_access_tokens
    }
    pub fn clear_package_access_tokens(&mut self) {
        self.package_access_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_access_tokens(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_PackageToken>) {
        self.package_access_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package_access_tokens(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_PackageToken> {
        &mut self.package_access_tokens
    }

    // Take field
    pub fn take_package_access_tokens(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_PackageToken> {
        ::std::mem::replace(&mut self.package_access_tokens, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 package_denied_tokens = 2;


    pub fn get_package_denied_tokens(&self) -> &[u32] {
        &self.package_denied_tokens
    }
    pub fn clear_package_denied_tokens(&mut self) {
        self.package_denied_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_denied_tokens(&mut self, v: ::std::vec::Vec<u32>) {
        self.package_denied_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package_denied_tokens(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.package_denied_tokens
    }

    // Take field
    pub fn take_package_denied_tokens(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.package_denied_tokens, ::std::vec::Vec::new())
    }

    // repeated .CMsgClientPICSAccessTokenResponse.AppToken app_access_tokens = 3;


    pub fn get_app_access_tokens(&self) -> &[CMsgClientPICSAccessTokenResponse_AppToken] {
        &self.app_access_tokens
    }
    pub fn clear_app_access_tokens(&mut self) {
        self.app_access_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_access_tokens(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_AppToken>) {
        self.app_access_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_access_tokens(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_AppToken> {
        &mut self.app_access_tokens
    }

    // Take field
    pub fn take_app_access_tokens(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_AppToken> {
        ::std::mem::replace(&mut self.app_access_tokens, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 app_denied_tokens = 4;


    pub fn get_app_denied_tokens(&self) -> &[u32] {
        &self.app_denied_tokens
    }
    pub fn clear_app_denied_tokens(&mut self) {
        self.app_denied_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_denied_tokens(&mut self, v: ::std::vec::Vec<u32>) {
        self.app_denied_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_denied_tokens(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.app_denied_tokens
    }

    // Take field
    pub fn take_app_denied_tokens(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.app_denied_tokens, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.package_access_tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_access_tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.package_access_tokens)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.package_denied_tokens)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.app_access_tokens)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.app_denied_tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.package_access_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.package_denied_tokens {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.app_access_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.app_denied_tokens {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.package_access_tokens {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.package_denied_tokens {
            os.write_uint32(2, *v)?;
        };
        for v in &self.app_access_tokens {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.app_denied_tokens {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSAccessTokenResponse {
        CMsgClientPICSAccessTokenResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPICSAccessTokenResponse_PackageToken>>(
                "package_access_tokens",
                |m: &CMsgClientPICSAccessTokenResponse| { &m.package_access_tokens },
                |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.package_access_tokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "package_denied_tokens",
                |m: &CMsgClientPICSAccessTokenResponse| { &m.package_denied_tokens },
                |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.package_denied_tokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPICSAccessTokenResponse_AppToken>>(
                "app_access_tokens",
                |m: &CMsgClientPICSAccessTokenResponse| { &m.app_access_tokens },
                |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.app_access_tokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_denied_tokens",
                |m: &CMsgClientPICSAccessTokenResponse| { &m.app_denied_tokens },
                |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.app_denied_tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSAccessTokenResponse>(
                "CMsgClientPICSAccessTokenResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSAccessTokenResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSAccessTokenResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSAccessTokenResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSAccessTokenResponse {
    fn clear(&mut self) {
        self.package_access_tokens.clear();
        self.package_denied_tokens.clear();
        self.app_access_tokens.clear();
        self.app_denied_tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSAccessTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSAccessTokenResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSAccessTokenResponse_PackageToken {
    // message fields
    packageid: ::std::option::Option<u32>,
    access_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSAccessTokenResponse_PackageToken {
    fn default() -> &'a CMsgClientPICSAccessTokenResponse_PackageToken {
        <CMsgClientPICSAccessTokenResponse_PackageToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSAccessTokenResponse_PackageToken {
    pub fn new() -> CMsgClientPICSAccessTokenResponse_PackageToken {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;


    pub fn get_packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }
    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional uint64 access_token = 2;


    pub fn get_access_token(&self) -> u64 {
        self.access_token.unwrap_or(0)
    }
    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: u64) {
        self.access_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenResponse_PackageToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packageid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.access_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.access_token {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.access_token {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSAccessTokenResponse_PackageToken {
        CMsgClientPICSAccessTokenResponse_PackageToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packageid",
                |m: &CMsgClientPICSAccessTokenResponse_PackageToken| { &m.packageid },
                |m: &mut CMsgClientPICSAccessTokenResponse_PackageToken| { &mut m.packageid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "access_token",
                |m: &CMsgClientPICSAccessTokenResponse_PackageToken| { &m.access_token },
                |m: &mut CMsgClientPICSAccessTokenResponse_PackageToken| { &mut m.access_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSAccessTokenResponse_PackageToken>(
                "CMsgClientPICSAccessTokenResponse.PackageToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSAccessTokenResponse_PackageToken {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSAccessTokenResponse_PackageToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSAccessTokenResponse_PackageToken::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSAccessTokenResponse_PackageToken {
    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.access_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSAccessTokenResponse_PackageToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSAccessTokenResponse_PackageToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSAccessTokenResponse_AppToken {
    // message fields
    appid: ::std::option::Option<u32>,
    access_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSAccessTokenResponse_AppToken {
    fn default() -> &'a CMsgClientPICSAccessTokenResponse_AppToken {
        <CMsgClientPICSAccessTokenResponse_AppToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSAccessTokenResponse_AppToken {
    pub fn new() -> CMsgClientPICSAccessTokenResponse_AppToken {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 access_token = 2;


    pub fn get_access_token(&self) -> u64 {
        self.access_token.unwrap_or(0)
    }
    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: u64) {
        self.access_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenResponse_AppToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.access_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.access_token {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.access_token {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSAccessTokenResponse_AppToken {
        CMsgClientPICSAccessTokenResponse_AppToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientPICSAccessTokenResponse_AppToken| { &m.appid },
                |m: &mut CMsgClientPICSAccessTokenResponse_AppToken| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "access_token",
                |m: &CMsgClientPICSAccessTokenResponse_AppToken| { &m.access_token },
                |m: &mut CMsgClientPICSAccessTokenResponse_AppToken| { &mut m.access_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPICSAccessTokenResponse_AppToken>(
                "CMsgClientPICSAccessTokenResponse.AppToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSAccessTokenResponse_AppToken {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPICSAccessTokenResponse_AppToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPICSAccessTokenResponse_AppToken::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSAccessTokenResponse_AppToken {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.access_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSAccessTokenResponse_AppToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSAccessTokenResponse_AppToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetUGCDetails {
    // message fields
    hcontent: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetUGCDetails {
    fn default() -> &'a CMsgClientUFSGetUGCDetails {
        <CMsgClientUFSGetUGCDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetUGCDetails {
    pub fn new() -> CMsgClientUFSGetUGCDetails {
        ::std::default::Default::default()
    }

    // optional fixed64 hcontent = 1;


    pub fn get_hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(18446744073709551615u64)
    }
    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSGetUGCDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.hcontent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hcontent {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hcontent {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetUGCDetails {
        CMsgClientUFSGetUGCDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "hcontent",
                |m: &CMsgClientUFSGetUGCDetails| { &m.hcontent },
                |m: &mut CMsgClientUFSGetUGCDetails| { &mut m.hcontent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSGetUGCDetails>(
                "CMsgClientUFSGetUGCDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetUGCDetails {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSGetUGCDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSGetUGCDetails::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetUGCDetails {
    fn clear(&mut self) {
        self.hcontent = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetUGCDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetUGCDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetUGCDetailsResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    url: ::protobuf::SingularField<::std::string::String>,
    app_id: ::std::option::Option<u32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    steamid_creator: ::std::option::Option<u64>,
    file_size: ::std::option::Option<u32>,
    compressed_file_size: ::std::option::Option<u32>,
    rangecheck_host: ::protobuf::SingularField<::std::string::String>,
    file_encoded_sha1: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetUGCDetailsResponse {
    fn default() -> &'a CMsgClientUFSGetUGCDetailsResponse {
        <CMsgClientUFSGetUGCDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetUGCDetailsResponse {
    pub fn new() -> CMsgClientUFSGetUGCDetailsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 3;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 steamid_creator = 5;


    pub fn get_steamid_creator(&self) -> u64 {
        self.steamid_creator.unwrap_or(0)
    }
    pub fn clear_steamid_creator(&mut self) {
        self.steamid_creator = ::std::option::Option::None;
    }

    pub fn has_steamid_creator(&self) -> bool {
        self.steamid_creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_creator(&mut self, v: u64) {
        self.steamid_creator = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 6;


    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 compressed_file_size = 7;


    pub fn get_compressed_file_size(&self) -> u32 {
        self.compressed_file_size.unwrap_or(0)
    }
    pub fn clear_compressed_file_size(&mut self) {
        self.compressed_file_size = ::std::option::Option::None;
    }

    pub fn has_compressed_file_size(&self) -> bool {
        self.compressed_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressed_file_size(&mut self, v: u32) {
        self.compressed_file_size = ::std::option::Option::Some(v);
    }

    // optional string rangecheck_host = 8;


    pub fn get_rangecheck_host(&self) -> &str {
        match self.rangecheck_host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_rangecheck_host(&mut self) {
        self.rangecheck_host.clear();
    }

    pub fn has_rangecheck_host(&self) -> bool {
        self.rangecheck_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rangecheck_host(&mut self, v: ::std::string::String) {
        self.rangecheck_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rangecheck_host(&mut self) -> &mut ::std::string::String {
        if self.rangecheck_host.is_none() {
            self.rangecheck_host.set_default();
        }
        self.rangecheck_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_rangecheck_host(&mut self) -> ::std::string::String {
        self.rangecheck_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_encoded_sha1 = 9;


    pub fn get_file_encoded_sha1(&self) -> &str {
        match self.file_encoded_sha1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_encoded_sha1(&mut self) {
        self.file_encoded_sha1.clear();
    }

    pub fn has_file_encoded_sha1(&self) -> bool {
        self.file_encoded_sha1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_encoded_sha1(&mut self, v: ::std::string::String) {
        self.file_encoded_sha1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_encoded_sha1(&mut self) -> &mut ::std::string::String {
        if self.file_encoded_sha1.is_none() {
            self.file_encoded_sha1.set_default();
        }
        self.file_encoded_sha1.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_encoded_sha1(&mut self) -> ::std::string::String {
        self.file_encoded_sha1.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSGetUGCDetailsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_creator = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.compressed_file_size = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rangecheck_host)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_encoded_sha1)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.steamid_creator {
            my_size += 9;
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.compressed_file_size {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rangecheck_host.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.file_encoded_sha1.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.steamid_creator {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.compressed_file_size {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.rangecheck_host.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.file_encoded_sha1.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetUGCDetailsResponse {
        CMsgClientUFSGetUGCDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.eresult },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.url },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.app_id },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.filename },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.filename },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_creator",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.steamid_creator },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.steamid_creator },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "file_size",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.file_size },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "compressed_file_size",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.compressed_file_size },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.compressed_file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rangecheck_host",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.rangecheck_host },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.rangecheck_host },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_encoded_sha1",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.file_encoded_sha1 },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.file_encoded_sha1 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSGetUGCDetailsResponse>(
                "CMsgClientUFSGetUGCDetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetUGCDetailsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSGetUGCDetailsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSGetUGCDetailsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetUGCDetailsResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.url.clear();
        self.app_id = ::std::option::Option::None;
        self.filename.clear();
        self.steamid_creator = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.compressed_file_size = ::std::option::Option::None;
        self.rangecheck_host.clear();
        self.file_encoded_sha1.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetUGCDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetUGCDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetSingleFileInfo {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetSingleFileInfo {
    fn default() -> &'a CMsgClientUFSGetSingleFileInfo {
        <CMsgClientUFSGetSingleFileInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetSingleFileInfo {
    pub fn new() -> CMsgClientUFSGetSingleFileInfo {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSGetSingleFileInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetSingleFileInfo {
        CMsgClientUFSGetSingleFileInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSGetSingleFileInfo| { &m.app_id },
                |m: &mut CMsgClientUFSGetSingleFileInfo| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUFSGetSingleFileInfo| { &m.file_name },
                |m: &mut CMsgClientUFSGetSingleFileInfo| { &mut m.file_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSGetSingleFileInfo>(
                "CMsgClientUFSGetSingleFileInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetSingleFileInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSGetSingleFileInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSGetSingleFileInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetSingleFileInfo {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetSingleFileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetSingleFileInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetSingleFileInfoResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    raw_file_size: ::std::option::Option<u32>,
    is_explicit_delete: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetSingleFileInfoResponse {
    fn default() -> &'a CMsgClientUFSGetSingleFileInfoResponse {
        <CMsgClientUFSGetSingleFileInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetSingleFileInfoResponse {
    pub fn new() -> CMsgClientUFSGetSingleFileInfoResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 3;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes sha_file = 4;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 time_stamp = 5;


    pub fn get_time_stamp(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }
    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_file_size = 6;


    pub fn get_raw_file_size(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }
    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    // optional bool is_explicit_delete = 7;


    pub fn get_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }
    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSGetSingleFileInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.time_stamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.raw_file_size = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_explicit_delete = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.raw_file_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_explicit_delete {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.raw_file_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_explicit_delete {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetSingleFileInfoResponse {
        CMsgClientUFSGetSingleFileInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.eresult },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.app_id },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.file_name },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.sha_file },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "time_stamp",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.time_stamp },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.time_stamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "raw_file_size",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.raw_file_size },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.raw_file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_explicit_delete",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.is_explicit_delete },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.is_explicit_delete },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSGetSingleFileInfoResponse>(
                "CMsgClientUFSGetSingleFileInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetSingleFileInfoResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSGetSingleFileInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSGetSingleFileInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetSingleFileInfoResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.sha_file.clear();
        self.time_stamp = ::std::option::Option::None;
        self.raw_file_size = ::std::option::Option::None;
        self.is_explicit_delete = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetSingleFileInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetSingleFileInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSShareFile {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSShareFile {
    fn default() -> &'a CMsgClientUFSShareFile {
        <CMsgClientUFSShareFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSShareFile {
    pub fn new() -> CMsgClientUFSShareFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSShareFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSShareFile {
        CMsgClientUFSShareFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUFSShareFile| { &m.app_id },
                |m: &mut CMsgClientUFSShareFile| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUFSShareFile| { &m.file_name },
                |m: &mut CMsgClientUFSShareFile| { &mut m.file_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSShareFile>(
                "CMsgClientUFSShareFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSShareFile {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSShareFile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSShareFile::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSShareFile {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSShareFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSShareFile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSShareFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    hcontent: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSShareFileResponse {
    fn default() -> &'a CMsgClientUFSShareFileResponse {
        <CMsgClientUFSShareFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSShareFileResponse {
    pub fn new() -> CMsgClientUFSShareFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 hcontent = 2;


    pub fn get_hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(18446744073709551615u64)
    }
    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSShareFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.hcontent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hcontent {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hcontent {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSShareFileResponse {
        CMsgClientUFSShareFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUFSShareFileResponse| { &m.eresult },
                |m: &mut CMsgClientUFSShareFileResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "hcontent",
                |m: &CMsgClientUFSShareFileResponse| { &m.hcontent },
                |m: &mut CMsgClientUFSShareFileResponse| { &mut m.hcontent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUFSShareFileResponse>(
                "CMsgClientUFSShareFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSShareFileResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUFSShareFileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUFSShareFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSShareFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.hcontent = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSShareFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSShareFileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetClanOfficers {
    // message fields
    steamid_clan: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetClanOfficers {
    fn default() -> &'a CMsgClientAMGetClanOfficers {
        <CMsgClientAMGetClanOfficers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetClanOfficers {
    pub fn new() -> CMsgClientAMGetClanOfficers {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_clan = 1;


    pub fn get_steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }
    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAMGetClanOfficers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_clan = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_clan {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetClanOfficers {
        CMsgClientAMGetClanOfficers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_clan",
                |m: &CMsgClientAMGetClanOfficers| { &m.steamid_clan },
                |m: &mut CMsgClientAMGetClanOfficers| { &mut m.steamid_clan },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAMGetClanOfficers>(
                "CMsgClientAMGetClanOfficers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetClanOfficers {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAMGetClanOfficers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAMGetClanOfficers::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetClanOfficers {
    fn clear(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetClanOfficers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetClanOfficers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetClanOfficersResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    steamid_clan: ::std::option::Option<u64>,
    officer_count: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetClanOfficersResponse {
    fn default() -> &'a CMsgClientAMGetClanOfficersResponse {
        <CMsgClientAMGetClanOfficersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetClanOfficersResponse {
    pub fn new() -> CMsgClientAMGetClanOfficersResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_clan = 2;


    pub fn get_steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }
    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    // optional int32 officer_count = 3;


    pub fn get_officer_count(&self) -> i32 {
        self.officer_count.unwrap_or(0)
    }
    pub fn clear_officer_count(&mut self) {
        self.officer_count = ::std::option::Option::None;
    }

    pub fn has_officer_count(&self) -> bool {
        self.officer_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_officer_count(&mut self, v: i32) {
        self.officer_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAMGetClanOfficersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_clan = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.officer_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid_clan {
            my_size += 9;
        }
        if let Some(v) = self.officer_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.officer_count {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetClanOfficersResponse {
        CMsgClientAMGetClanOfficersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientAMGetClanOfficersResponse| { &m.eresult },
                |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_clan",
                |m: &CMsgClientAMGetClanOfficersResponse| { &m.steamid_clan },
                |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.steamid_clan },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "officer_count",
                |m: &CMsgClientAMGetClanOfficersResponse| { &m.officer_count },
                |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.officer_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAMGetClanOfficersResponse>(
                "CMsgClientAMGetClanOfficersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetClanOfficersResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAMGetClanOfficersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAMGetClanOfficersResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetClanOfficersResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steamid_clan = ::std::option::Option::None;
        self.officer_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetClanOfficersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetClanOfficersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistory {
    // message fields
    id_count: ::std::option::Option<i32>,
    pub Ids: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistory_IdInstance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistory {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistory {
        <CMsgClientAMGetPersonaNameHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistory {
    pub fn new() -> CMsgClientAMGetPersonaNameHistory {
        ::std::default::Default::default()
    }

    // optional int32 id_count = 1;


    pub fn get_id_count(&self) -> i32 {
        self.id_count.unwrap_or(0)
    }
    pub fn clear_id_count(&mut self) {
        self.id_count = ::std::option::Option::None;
    }

    pub fn has_id_count(&self) -> bool {
        self.id_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id_count(&mut self, v: i32) {
        self.id_count = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientAMGetPersonaNameHistory.IdInstance Ids = 2;


    pub fn get_Ids(&self) -> &[CMsgClientAMGetPersonaNameHistory_IdInstance] {
        &self.Ids
    }
    pub fn clear_Ids(&mut self) {
        self.Ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ids(&mut self, v: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistory_IdInstance>) {
        self.Ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Ids(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistory_IdInstance> {
        &mut self.Ids
    }

    // Take field
    pub fn take_Ids(&mut self) -> ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistory_IdInstance> {
        ::std::mem::replace(&mut self.Ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistory {
    fn is_initialized(&self) -> bool {
        for v in &self.Ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id_count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.Ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id_count {
            os.write_int32(1, v)?;
        }
        for v in &self.Ids {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetPersonaNameHistory {
        CMsgClientAMGetPersonaNameHistory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id_count",
                |m: &CMsgClientAMGetPersonaNameHistory| { &m.id_count },
                |m: &mut CMsgClientAMGetPersonaNameHistory| { &mut m.id_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientAMGetPersonaNameHistory_IdInstance>>(
                "Ids",
                |m: &CMsgClientAMGetPersonaNameHistory| { &m.Ids },
                |m: &mut CMsgClientAMGetPersonaNameHistory| { &mut m.Ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAMGetPersonaNameHistory>(
                "CMsgClientAMGetPersonaNameHistory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistory {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAMGetPersonaNameHistory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAMGetPersonaNameHistory::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistory {
    fn clear(&mut self) {
        self.id_count = ::std::option::Option::None;
        self.Ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistory_IdInstance {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistory_IdInstance {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistory_IdInstance {
        <CMsgClientAMGetPersonaNameHistory_IdInstance as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistory_IdInstance {
    pub fn new() -> CMsgClientAMGetPersonaNameHistory_IdInstance {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistory_IdInstance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetPersonaNameHistory_IdInstance {
        CMsgClientAMGetPersonaNameHistory_IdInstance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgClientAMGetPersonaNameHistory_IdInstance| { &m.steamid },
                |m: &mut CMsgClientAMGetPersonaNameHistory_IdInstance| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAMGetPersonaNameHistory_IdInstance>(
                "CMsgClientAMGetPersonaNameHistory.IdInstance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistory_IdInstance {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAMGetPersonaNameHistory_IdInstance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAMGetPersonaNameHistory_IdInstance::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistory_IdInstance {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistory_IdInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistory_IdInstance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistoryResponse {
    // message fields
    pub responses: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistoryResponse {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistoryResponse {
        <CMsgClientAMGetPersonaNameHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistoryResponse {
    pub fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance responses = 2;


    pub fn get_responses(&self) -> &[CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance] {
        &self.responses
    }
    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.responses {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        CMsgClientAMGetPersonaNameHistoryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>>(
                "responses",
                |m: &CMsgClientAMGetPersonaNameHistoryResponse| { &m.responses },
                |m: &mut CMsgClientAMGetPersonaNameHistoryResponse| { &mut m.responses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAMGetPersonaNameHistoryResponse>(
                "CMsgClientAMGetPersonaNameHistoryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistoryResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAMGetPersonaNameHistoryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAMGetPersonaNameHistoryResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistoryResponse {
    fn clear(&mut self) {
        self.responses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    // message fields
    eresult: ::std::option::Option<i32>,
    steamid: ::std::option::Option<u64>,
    pub names: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
        <CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    pub fn new() -> CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance names = 3;


    pub fn get_names(&self) -> &[CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    fn is_initialized(&self) -> bool {
        for v in &self.names {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        for value in &self.names {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        for v in &self.names {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
        CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance| { &m.eresult },
                |m: &mut CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance| { &m.steamid },
                |m: &mut CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>>(
                "names",
                |m: &CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance| { &m.names },
                |m: &mut CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance| { &mut m.names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>(
                "CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    // message fields
    name_since: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
        <CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    pub fn new() -> CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
        ::std::default::Default::default()
    }

    // optional fixed32 name_since = 1;


    pub fn get_name_since(&self) -> u32 {
        self.name_since.unwrap_or(0)
    }
    pub fn clear_name_since(&mut self) {
        self.name_since = ::std::option::Option::None;
    }

    pub fn has_name_since(&self) -> bool {
        self.name_since.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_since(&mut self, v: u32) {
        self.name_since = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.name_since = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name_since {
            my_size += 5;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name_since {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
        CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "name_since",
                |m: &CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance| { &m.name_since },
                |m: &mut CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance| { &mut m.name_since },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance| { &m.name },
                |m: &mut CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>(
                "CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    fn clear(&mut self) {
        self.name_since = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDeregisterWithServer {
    // message fields
    eservertype: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeregisterWithServer {
    fn default() -> &'a CMsgClientDeregisterWithServer {
        <CMsgClientDeregisterWithServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeregisterWithServer {
    pub fn new() -> CMsgClientDeregisterWithServer {
        ::std::default::Default::default()
    }

    // optional uint32 eservertype = 1;


    pub fn get_eservertype(&self) -> u32 {
        self.eservertype.unwrap_or(0)
    }
    pub fn clear_eservertype(&mut self) {
        self.eservertype = ::std::option::Option::None;
    }

    pub fn has_eservertype(&self) -> bool {
        self.eservertype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eservertype(&mut self, v: u32) {
        self.eservertype = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeregisterWithServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eservertype = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eservertype {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eservertype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDeregisterWithServer {
        CMsgClientDeregisterWithServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eservertype",
                |m: &CMsgClientDeregisterWithServer| { &m.eservertype },
                |m: &mut CMsgClientDeregisterWithServer| { &mut m.eservertype },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientDeregisterWithServer| { &m.app_id },
                |m: &mut CMsgClientDeregisterWithServer| { &mut m.app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientDeregisterWithServer>(
                "CMsgClientDeregisterWithServer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDeregisterWithServer {
        static instance: ::protobuf::rt::LazyV2<CMsgClientDeregisterWithServer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientDeregisterWithServer::new)
    }
}

impl ::protobuf::Clear for CMsgClientDeregisterWithServer {
    fn clear(&mut self) {
        self.eservertype = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDeregisterWithServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeregisterWithServer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientClanState {
    // message fields
    steamid_clan: ::std::option::Option<u64>,
    clan_account_flags: ::std::option::Option<u32>,
    pub name_info: ::protobuf::SingularPtrField<CMsgClientClanState_NameInfo>,
    pub user_counts: ::protobuf::SingularPtrField<CMsgClientClanState_UserCounts>,
    pub events: ::protobuf::RepeatedField<CMsgClientClanState_Event>,
    pub announcements: ::protobuf::RepeatedField<CMsgClientClanState_Event>,
    chat_room_private: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientClanState {
    fn default() -> &'a CMsgClientClanState {
        <CMsgClientClanState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientClanState {
    pub fn new() -> CMsgClientClanState {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_clan = 1;


    pub fn get_steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }
    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    // optional uint32 clan_account_flags = 3;


    pub fn get_clan_account_flags(&self) -> u32 {
        self.clan_account_flags.unwrap_or(0)
    }
    pub fn clear_clan_account_flags(&mut self) {
        self.clan_account_flags = ::std::option::Option::None;
    }

    pub fn has_clan_account_flags(&self) -> bool {
        self.clan_account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_account_flags(&mut self, v: u32) {
        self.clan_account_flags = ::std::option::Option::Some(v);
    }

    // optional .CMsgClientClanState.NameInfo name_info = 4;


    pub fn get_name_info(&self) -> &CMsgClientClanState_NameInfo {
        self.name_info.as_ref().unwrap_or_else(|| <CMsgClientClanState_NameInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name_info(&mut self) {
        self.name_info.clear();
    }

    pub fn has_name_info(&self) -> bool {
        self.name_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_info(&mut self, v: CMsgClientClanState_NameInfo) {
        self.name_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_info(&mut self) -> &mut CMsgClientClanState_NameInfo {
        if self.name_info.is_none() {
            self.name_info.set_default();
        }
        self.name_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_info(&mut self) -> CMsgClientClanState_NameInfo {
        self.name_info.take().unwrap_or_else(|| CMsgClientClanState_NameInfo::new())
    }

    // optional .CMsgClientClanState.UserCounts user_counts = 5;


    pub fn get_user_counts(&self) -> &CMsgClientClanState_UserCounts {
        self.user_counts.as_ref().unwrap_or_else(|| <CMsgClientClanState_UserCounts as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_counts(&mut self) {
        self.user_counts.clear();
    }

    pub fn has_user_counts(&self) -> bool {
        self.user_counts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_counts(&mut self, v: CMsgClientClanState_UserCounts) {
        self.user_counts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_counts(&mut self) -> &mut CMsgClientClanState_UserCounts {
        if self.user_counts.is_none() {
            self.user_counts.set_default();
        }
        self.user_counts.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_counts(&mut self) -> CMsgClientClanState_UserCounts {
        self.user_counts.take().unwrap_or_else(|| CMsgClientClanState_UserCounts::new())
    }

    // repeated .CMsgClientClanState.Event events = 6;


    pub fn get_events(&self) -> &[CMsgClientClanState_Event] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<CMsgClientClanState_Event>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientClanState_Event> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<CMsgClientClanState_Event> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgClientClanState.Event announcements = 7;


    pub fn get_announcements(&self) -> &[CMsgClientClanState_Event] {
        &self.announcements
    }
    pub fn clear_announcements(&mut self) {
        self.announcements.clear();
    }

    // Param is passed by value, moved
    pub fn set_announcements(&mut self, v: ::protobuf::RepeatedField<CMsgClientClanState_Event>) {
        self.announcements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_announcements(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientClanState_Event> {
        &mut self.announcements
    }

    // Take field
    pub fn take_announcements(&mut self) -> ::protobuf::RepeatedField<CMsgClientClanState_Event> {
        ::std::mem::replace(&mut self.announcements, ::protobuf::RepeatedField::new())
    }

    // optional bool chat_room_private = 8;


    pub fn get_chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }
    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientClanState {
    fn is_initialized(&self) -> bool {
        for v in &self.name_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_counts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.announcements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_clan = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.clan_account_flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name_info)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_counts)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.announcements)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chat_room_private = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_clan {
            my_size += 9;
        }
        if let Some(v) = self.clan_account_flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.announcements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.chat_room_private {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.clan_account_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.name_info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_counts.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.events {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.announcements {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.chat_room_private {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientClanState {
        CMsgClientClanState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_clan",
                |m: &CMsgClientClanState| { &m.steamid_clan },
                |m: &mut CMsgClientClanState| { &mut m.steamid_clan },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "clan_account_flags",
                |m: &CMsgClientClanState| { &m.clan_account_flags },
                |m: &mut CMsgClientClanState| { &mut m.clan_account_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientClanState_NameInfo>>(
                "name_info",
                |m: &CMsgClientClanState| { &m.name_info },
                |m: &mut CMsgClientClanState| { &mut m.name_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientClanState_UserCounts>>(
                "user_counts",
                |m: &CMsgClientClanState| { &m.user_counts },
                |m: &mut CMsgClientClanState| { &mut m.user_counts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientClanState_Event>>(
                "events",
                |m: &CMsgClientClanState| { &m.events },
                |m: &mut CMsgClientClanState| { &mut m.events },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientClanState_Event>>(
                "announcements",
                |m: &CMsgClientClanState| { &m.announcements },
                |m: &mut CMsgClientClanState| { &mut m.announcements },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "chat_room_private",
                |m: &CMsgClientClanState| { &m.chat_room_private },
                |m: &mut CMsgClientClanState| { &mut m.chat_room_private },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientClanState>(
                "CMsgClientClanState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientClanState {
        static instance: ::protobuf::rt::LazyV2<CMsgClientClanState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientClanState::new)
    }
}

impl ::protobuf::Clear for CMsgClientClanState {
    fn clear(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
        self.clan_account_flags = ::std::option::Option::None;
        self.name_info.clear();
        self.user_counts.clear();
        self.events.clear();
        self.announcements.clear();
        self.chat_room_private = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientClanState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientClanState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientClanState_NameInfo {
    // message fields
    clan_name: ::protobuf::SingularField<::std::string::String>,
    sha_avatar: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientClanState_NameInfo {
    fn default() -> &'a CMsgClientClanState_NameInfo {
        <CMsgClientClanState_NameInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientClanState_NameInfo {
    pub fn new() -> CMsgClientClanState_NameInfo {
        ::std::default::Default::default()
    }

    // optional string clan_name = 1;


    pub fn get_clan_name(&self) -> &str {
        match self.clan_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clan_name(&mut self) {
        self.clan_name.clear();
    }

    pub fn has_clan_name(&self) -> bool {
        self.clan_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_name(&mut self, v: ::std::string::String) {
        self.clan_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clan_name(&mut self) -> &mut ::std::string::String {
        if self.clan_name.is_none() {
            self.clan_name.set_default();
        }
        self.clan_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_clan_name(&mut self) -> ::std::string::String {
        self.clan_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes sha_avatar = 2;


    pub fn get_sha_avatar(&self) -> &[u8] {
        match self.sha_avatar.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_avatar(&mut self) {
        self.sha_avatar.clear();
    }

    pub fn has_sha_avatar(&self) -> bool {
        self.sha_avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_avatar(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_avatar = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_avatar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_avatar.is_none() {
            self.sha_avatar.set_default();
        }
        self.sha_avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_avatar(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_avatar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientClanState_NameInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clan_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_avatar)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clan_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.sha_avatar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clan_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.sha_avatar.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientClanState_NameInfo {
        CMsgClientClanState_NameInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clan_name",
                |m: &CMsgClientClanState_NameInfo| { &m.clan_name },
                |m: &mut CMsgClientClanState_NameInfo| { &mut m.clan_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_avatar",
                |m: &CMsgClientClanState_NameInfo| { &m.sha_avatar },
                |m: &mut CMsgClientClanState_NameInfo| { &mut m.sha_avatar },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientClanState_NameInfo>(
                "CMsgClientClanState.NameInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientClanState_NameInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientClanState_NameInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientClanState_NameInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientClanState_NameInfo {
    fn clear(&mut self) {
        self.clan_name.clear();
        self.sha_avatar.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientClanState_NameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientClanState_NameInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientClanState_UserCounts {
    // message fields
    members: ::std::option::Option<u32>,
    online: ::std::option::Option<u32>,
    chatting: ::std::option::Option<u32>,
    in_game: ::std::option::Option<u32>,
    chat_room_members: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientClanState_UserCounts {
    fn default() -> &'a CMsgClientClanState_UserCounts {
        <CMsgClientClanState_UserCounts as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientClanState_UserCounts {
    pub fn new() -> CMsgClientClanState_UserCounts {
        ::std::default::Default::default()
    }

    // optional uint32 members = 1;


    pub fn get_members(&self) -> u32 {
        self.members.unwrap_or(0)
    }
    pub fn clear_members(&mut self) {
        self.members = ::std::option::Option::None;
    }

    pub fn has_members(&self) -> bool {
        self.members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: u32) {
        self.members = ::std::option::Option::Some(v);
    }

    // optional uint32 online = 2;


    pub fn get_online(&self) -> u32 {
        self.online.unwrap_or(0)
    }
    pub fn clear_online(&mut self) {
        self.online = ::std::option::Option::None;
    }

    pub fn has_online(&self) -> bool {
        self.online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online(&mut self, v: u32) {
        self.online = ::std::option::Option::Some(v);
    }

    // optional uint32 chatting = 3;


    pub fn get_chatting(&self) -> u32 {
        self.chatting.unwrap_or(0)
    }
    pub fn clear_chatting(&mut self) {
        self.chatting = ::std::option::Option::None;
    }

    pub fn has_chatting(&self) -> bool {
        self.chatting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatting(&mut self, v: u32) {
        self.chatting = ::std::option::Option::Some(v);
    }

    // optional uint32 in_game = 4;


    pub fn get_in_game(&self) -> u32 {
        self.in_game.unwrap_or(0)
    }
    pub fn clear_in_game(&mut self) {
        self.in_game = ::std::option::Option::None;
    }

    pub fn has_in_game(&self) -> bool {
        self.in_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game(&mut self, v: u32) {
        self.in_game = ::std::option::Option::Some(v);
    }

    // optional uint32 chat_room_members = 5;


    pub fn get_chat_room_members(&self) -> u32 {
        self.chat_room_members.unwrap_or(0)
    }
    pub fn clear_chat_room_members(&mut self) {
        self.chat_room_members = ::std::option::Option::None;
    }

    pub fn has_chat_room_members(&self) -> bool {
        self.chat_room_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_members(&mut self, v: u32) {
        self.chat_room_members = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientClanState_UserCounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.members = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.online = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chatting = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.in_game = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chat_room_members = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.members {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.online {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chatting {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_game {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_room_members {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.members {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.online {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.chatting {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_game {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.chat_room_members {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientClanState_UserCounts {
        CMsgClientClanState_UserCounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "members",
                |m: &CMsgClientClanState_UserCounts| { &m.members },
                |m: &mut CMsgClientClanState_UserCounts| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "online",
                |m: &CMsgClientClanState_UserCounts| { &m.online },
                |m: &mut CMsgClientClanState_UserCounts| { &mut m.online },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chatting",
                |m: &CMsgClientClanState_UserCounts| { &m.chatting },
                |m: &mut CMsgClientClanState_UserCounts| { &mut m.chatting },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "in_game",
                |m: &CMsgClientClanState_UserCounts| { &m.in_game },
                |m: &mut CMsgClientClanState_UserCounts| { &mut m.in_game },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chat_room_members",
                |m: &CMsgClientClanState_UserCounts| { &m.chat_room_members },
                |m: &mut CMsgClientClanState_UserCounts| { &mut m.chat_room_members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientClanState_UserCounts>(
                "CMsgClientClanState.UserCounts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientClanState_UserCounts {
        static instance: ::protobuf::rt::LazyV2<CMsgClientClanState_UserCounts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientClanState_UserCounts::new)
    }
}

impl ::protobuf::Clear for CMsgClientClanState_UserCounts {
    fn clear(&mut self) {
        self.members = ::std::option::Option::None;
        self.online = ::std::option::Option::None;
        self.chatting = ::std::option::Option::None;
        self.in_game = ::std::option::Option::None;
        self.chat_room_members = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientClanState_UserCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientClanState_UserCounts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientClanState_Event {
    // message fields
    gid: ::std::option::Option<u64>,
    event_time: ::std::option::Option<u32>,
    headline: ::protobuf::SingularField<::std::string::String>,
    game_id: ::std::option::Option<u64>,
    just_posted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientClanState_Event {
    fn default() -> &'a CMsgClientClanState_Event {
        <CMsgClientClanState_Event as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientClanState_Event {
    pub fn new() -> CMsgClientClanState_Event {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;


    pub fn get_gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }
    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint32 event_time = 2;


    pub fn get_event_time(&self) -> u32 {
        self.event_time.unwrap_or(0)
    }
    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: u32) {
        self.event_time = ::std::option::Option::Some(v);
    }

    // optional string headline = 3;


    pub fn get_headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_headline(&mut self) {
        self.headline.clear();
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline.set_default();
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 game_id = 4;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional bool just_posted = 5;


    pub fn get_just_posted(&self) -> bool {
        self.just_posted.unwrap_or(false)
    }
    pub fn clear_just_posted(&mut self) {
        self.just_posted = ::std::option::Option::None;
    }

    pub fn has_just_posted(&self) -> bool {
        self.just_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_just_posted(&mut self, v: bool) {
        self.just_posted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientClanState_Event {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.gid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headline)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.just_posted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 9;
        }
        if let Some(v) = self.event_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.just_posted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.headline.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.just_posted {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientClanState_Event {
        CMsgClientClanState_Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "gid",
                |m: &CMsgClientClanState_Event| { &m.gid },
                |m: &mut CMsgClientClanState_Event| { &mut m.gid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_time",
                |m: &CMsgClientClanState_Event| { &m.event_time },
                |m: &mut CMsgClientClanState_Event| { &mut m.event_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "headline",
                |m: &CMsgClientClanState_Event| { &m.headline },
                |m: &mut CMsgClientClanState_Event| { &mut m.headline },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_id",
                |m: &CMsgClientClanState_Event| { &m.game_id },
                |m: &mut CMsgClientClanState_Event| { &mut m.game_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "just_posted",
                |m: &CMsgClientClanState_Event| { &m.just_posted },
                |m: &mut CMsgClientClanState_Event| { &mut m.just_posted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientClanState_Event>(
                "CMsgClientClanState.Event",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientClanState_Event {
        static instance: ::protobuf::rt::LazyV2<CMsgClientClanState_Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientClanState_Event::new)
    }
}

impl ::protobuf::Clear for CMsgClientClanState_Event {
    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.event_time = ::std::option::Option::None;
        self.headline.clear();
        self.game_id = ::std::option::Option::None;
        self.just_posted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientClanState_Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientClanState_Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUnsignedInstallScript {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    file_size: ::std::option::Option<u32>,
    signature_broken: ::std::option::Option<bool>,
    depot_id: ::std::option::Option<u32>,
    manifest_id: ::std::option::Option<u64>,
    file_flags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUnsignedInstallScript {
    fn default() -> &'a CMsgClientUnsignedInstallScript {
        <CMsgClientUnsignedInstallScript as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUnsignedInstallScript {
    pub fn new() -> CMsgClientUnsignedInstallScript {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 file_size = 3;


    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional bool signature_broken = 4;


    pub fn get_signature_broken(&self) -> bool {
        self.signature_broken.unwrap_or(false)
    }
    pub fn clear_signature_broken(&mut self) {
        self.signature_broken = ::std::option::Option::None;
    }

    pub fn has_signature_broken(&self) -> bool {
        self.signature_broken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature_broken(&mut self, v: bool) {
        self.signature_broken = ::std::option::Option::Some(v);
    }

    // optional uint32 depot_id = 5;


    pub fn get_depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }
    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 manifest_id = 6;


    pub fn get_manifest_id(&self) -> u64 {
        self.manifest_id.unwrap_or(0)
    }
    pub fn clear_manifest_id(&mut self) {
        self.manifest_id = ::std::option::Option::None;
    }

    pub fn has_manifest_id(&self) -> bool {
        self.manifest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest_id(&mut self, v: u64) {
        self.manifest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_flags = 7;


    pub fn get_file_flags(&self) -> u32 {
        self.file_flags.unwrap_or(0)
    }
    pub fn clear_file_flags(&mut self) {
        self.file_flags = ::std::option::Option::None;
    }

    pub fn has_file_flags(&self) -> bool {
        self.file_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_flags(&mut self, v: u32) {
        self.file_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUnsignedInstallScript {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.signature_broken = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.depot_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.manifest_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signature_broken {
            my_size += 2;
        }
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.manifest_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_flags {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.signature_broken {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.depot_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.manifest_id {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.file_flags {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUnsignedInstallScript {
        CMsgClientUnsignedInstallScript::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUnsignedInstallScript| { &m.app_id },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUnsignedInstallScript| { &m.file_name },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "file_size",
                |m: &CMsgClientUnsignedInstallScript| { &m.file_size },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "signature_broken",
                |m: &CMsgClientUnsignedInstallScript| { &m.signature_broken },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.signature_broken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "depot_id",
                |m: &CMsgClientUnsignedInstallScript| { &m.depot_id },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.depot_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "manifest_id",
                |m: &CMsgClientUnsignedInstallScript| { &m.manifest_id },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.manifest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "file_flags",
                |m: &CMsgClientUnsignedInstallScript| { &m.file_flags },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.file_flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUnsignedInstallScript>(
                "CMsgClientUnsignedInstallScript",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUnsignedInstallScript {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUnsignedInstallScript> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUnsignedInstallScript::new)
    }
}

impl ::protobuf::Clear for CMsgClientUnsignedInstallScript {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.file_size = ::std::option::Option::None;
        self.signature_broken = ::std::option::Option::None;
        self.depot_id = ::std::option::Option::None;
        self.manifest_id = ::std::option::Option::None;
        self.file_flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUnsignedInstallScript {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUnsignedInstallScript {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EMMSLobbyStatus {
    k_EMMSLobbyStatusInvalid = 0,
    k_EMMSLobbyStatusExists = 1,
    k_EMMSLobbyStatusDoesNotExist = 2,
    k_EMMSLobbyStatusNotAMember = 3,
}

impl ::protobuf::ProtobufEnum for EMMSLobbyStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMMSLobbyStatus> {
        match value {
            0 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            1 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusExists),
            2 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist),
            3 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EMMSLobbyStatus] = &[
            EMMSLobbyStatus::k_EMMSLobbyStatusInvalid,
            EMMSLobbyStatus::k_EMMSLobbyStatusExists,
            EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist,
            EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EMMSLobbyStatus>("EMMSLobbyStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EMMSLobbyStatus {
}

impl ::std::default::Default for EMMSLobbyStatus {
    fn default() -> Self {
        EMMSLobbyStatus::k_EMMSLobbyStatusInvalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EMMSLobbyStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20steammessages_clientserver.proto\x1a\x18steammessages_base.proto\
    \x1a\x1aencrypted_app_ticket.proto\"]\n\x1eCMsgClientUDSP2PSessionStarte\
    d\x12%\n\x0esteamid_remote\x18\x01\x20\x01(\x06R\rsteamidRemote\x12\x14\
    \n\x05appid\x18\x02\x20\x01(\x05R\x05appid\"\x87\x03\n\x1cCMsgClientUDSP\
    2PSessionEnded\x12%\n\x0esteamid_remote\x18\x01\x20\x01(\x06R\rsteamidRe\
    mote\x12\x14\n\x05appid\x18\x02\x20\x01(\x05R\x05appid\x12,\n\x12session\
    _length_sec\x18\x03\x20\x01(\x05R\x10sessionLengthSec\x12#\n\rsession_er\
    ror\x18\x04\x20\x01(\x05R\x0csessionError\x12\x18\n\x07nattype\x18\x05\
    \x20\x01(\x05R\x07nattype\x12\x1d\n\nbytes_recv\x18\x06\x20\x01(\x05R\tb\
    ytesRecv\x12\x1d\n\nbytes_sent\x18\x07\x20\x01(\x05R\tbytesSent\x12(\n\
    \x10bytes_sent_relay\x18\x08\x20\x01(\x05R\x0ebytesSentRelay\x12(\n\x10b\
    ytes_recv_relay\x18\t\x20\x01(\x05R\x0ebytesRecvRelay\x12+\n\x12time_to_\
    connect_ms\x18\n\x20\x01(\x05R\x0ftimeToConnectMs\"\x95\x01\n\"CMsgClien\
    tRegisterAuthTicketWithCM\x12)\n\x10protocol_version\x18\x01\x20\x01(\rR\
    \x0fprotocolVersion\x12\x16\n\x06ticket\x18\x03\x20\x01(\x0cR\x06ticket\
    \x12,\n\x12client_instance_id\x18\x04\x20\x01(\x04R\x10clientInstanceId\
    \"\xbb\x02\n\x1cCMsgClientTicketAuthComplete\x12\x19\n\x08steam_id\x18\
    \x01\x20\x01(\x06R\x07steamId\x12\x17\n\x07game_id\x18\x02\x20\x01(\x06R\
    \x06gameId\x12\x16\n\x06estate\x18\x03\x20\x01(\rR\x06estate\x124\n\x16e\
    auth_session_response\x18\x04\x20\x01(\rR\x14eauthSessionResponse\x12+\n\
    \x11DEPRECATED_ticket\x18\x05\x20\x01(\x0cR\x10DEPRECATEDTicket\x12\x1d\
    \n\nticket_crc\x18\x06\x20\x01(\rR\tticketCrc\x12'\n\x0fticket_sequence\
    \x18\x07\x20\x01(\rR\x0eticketSequence\x12$\n\x0eowner_steam_id\x18\x08\
    \x20\x01(\x06R\x0cownerSteamId\"\xc7\x01\n\x10CMsgClientCMList\x12!\n\
    \x0ccm_addresses\x18\x01\x20\x03(\rR\x0bcmAddresses\x12\x19\n\x08cm_port\
    s\x18\x02\x20\x03(\rR\x07cmPorts\x124\n\x16cm_websocket_addresses\x18\
    \x03\x20\x03(\tR\x14cmWebsocketAddresses\x12?\n\x1cpercent_default_to_we\
    bsocket\x18\x04\x20\x01(\rR\x19percentDefaultToWebsocket\"\xe4\x01\n\x1b\
    CMsgClientP2PConnectionInfo\x12\"\n\rsteam_id_dest\x18\x01\x20\x01(\x06R\
    \x0bsteamIdDest\x12\x20\n\x0csteam_id_src\x18\x02\x20\x01(\x06R\nsteamId\
    Src\x12\x15\n\x06app_id\x18\x03\x20\x01(\rR\x05appId\x12\x1c\n\tcandidat\
    e\x18\x04\x20\x01(\x0cR\tcandidate\x12*\n\x11connection_id_src\x18\x05\
    \x20\x01(\x06R\x0fconnectionIdSrc\x12\x1e\n\nrendezvous\x18\x06\x20\x01(\
    \x0cR\nrendezvous\"\xa2\x02\n\x1fCMsgClientP2PConnectionFailInfo\x12\"\n\
    \rsteam_id_dest\x18\x01\x20\x01(\x06R\x0bsteamIdDest\x12\x20\n\x0csteam_\
    id_src\x18\x02\x20\x01(\x06R\nsteamIdSrc\x12\x15\n\x06app_id\x18\x03\x20\
    \x01(\rR\x05appId\x12,\n\x12ep2p_session_error\x18\x04\x20\x01(\rR\x10ep\
    2pSessionError\x12,\n\x12connection_id_dest\x18\x05\x20\x01(\x06R\x10con\
    nectionIdDest\x12!\n\x0cclose_reason\x18\x07\x20\x01(\rR\x0bcloseReason\
    \x12#\n\rclose_message\x18\x08\x20\x01(\tR\x0ccloseMessage\"S\n\x1fCMsgC\
    lientNetworkingCertRequest\x12\x19\n\x08key_data\x18\x02\x20\x01(\x0cR\
    \x07keyData\x12\x15\n\x06app_id\x18\x03\x20\x01(\rR\x05appId\"r\n\x1dCMs\
    gClientNetworkingCertReply\x12\x12\n\x04cert\x18\x04\x20\x01(\x0cR\x04ce\
    rt\x12\x1a\n\tca_key_id\x18\x05\x20\x01(\x06R\x07caKeyId\x12!\n\x0cca_si\
    gnature\x18\x06\x20\x01(\x0cR\x0bcaSignature\">\n%CMsgClientNetworkingMo\
    bileCertRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\"H\n#CM\
    sgClientNetworkingMobileCertReply\x12!\n\x0cencoded_cert\x18\x01\x20\x01\
    (\tR\x0bencodedCert\"8\n\x1fCMsgClientGetAppOwnershipTicket\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\"u\n'CMsgClientGetAppOwnershipTi\
    cketResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\
    \x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12\x16\n\x06ticket\
    \x18\x03\x20\x01(\x0cR\x06ticket\".\n\x16CMsgClientSessionToken\x12\x14\
    \n\x05token\x18\x01\x20\x01(\x04R\x05token\"f\n\x1bCMsgClientGameConnect\
    Tokens\x12/\n\x12max_tokens_to_keep\x18\x01\x20\x01(\r:\x0210R\x0fmaxTok\
    ensToKeep\x12\x16\n\x06tokens\x18\x02\x20\x03(\x0cR\x06tokens\"\x8c\x02\
    \n\x10CMsgGSServerType\x12\"\n\rapp_id_served\x18\x01\x20\x01(\rR\x0bapp\
    IdServed\x12\x14\n\x05flags\x18\x02\x20\x01(\rR\x05flags\x12;\n\x1adepre\
    cated_game_ip_address\x18\x03\x20\x01(\rR\x17deprecatedGameIpAddress\x12\
    \x1b\n\tgame_port\x18\x04\x20\x01(\rR\x08gamePort\x12\x19\n\x08game_dir\
    \x18\x05\x20\x01(\tR\x07gameDir\x12!\n\x0cgame_version\x18\x06\x20\x01(\
    \tR\x0bgameVersion\x12&\n\x0fgame_query_port\x18\x07\x20\x01(\rR\rgameQu\
    eryPort\"0\n\x11CMsgGSStatusReply\x12\x1b\n\tis_secure\x18\x01\x20\x01(\
    \x08R\x08isSecure\"\xe1\x01\n\x10CMsgGSPlayerList\x122\n\x07players\x18\
    \x01\x20\x03(\x0b2\x18.CMsgGSPlayerList.PlayerR\x07players\x1a\x98\x01\n\
    \x06Player\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x04R\x07steamId\x120\n\
    \x14deprecated_public_ip\x18\x02\x20\x01(\rR\x12deprecatedPublicIp\x12\
    \x14\n\x05token\x18\x03\x20\x01(\x0cR\x05token\x12+\n\tpublic_ip\x18\x04\
    \x20\x01(\x0b2\x0e.CMsgIPAddressR\x08publicIp\"\xa3\x01\n\x11CMsgGSUserP\
    laying\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x120\n\x14\
    deprecated_public_ip\x18\x02\x20\x01(\rR\x12deprecatedPublicIp\x12\x14\n\
    \x05token\x18\x03\x20\x01(\x0cR\x05token\x12+\n\tpublic_ip\x18\x04\x20\
    \x01(\x0b2\x0e.CMsgIPAddressR\x08publicIp\"3\n\x16CMsgGSDisconnectNotice\
    \x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"\xf9\t\n\x15CMs\
    gClientGamesPlayed\x12D\n\x0cgames_played\x18\x01\x20\x03(\x0b2!.CMsgCli\
    entGamesPlayed.GamePlayedR\x0bgamesPlayed\x12$\n\x0eclient_os_type\x18\
    \x02\x20\x01(\rR\x0cclientOsType\x122\n\x15cloud_gaming_platform\x18\x03\
    \x20\x01(\rR\x13cloudGamingPlatform\x1a\xbf\x08\n\nGamePlayed\x12\x1e\n\
    \x0bsteam_id_gs\x18\x01\x20\x01(\x04R\tsteamIdGs\x12\x17\n\x07game_id\
    \x18\x02\x20\x01(\x06R\x06gameId\x12;\n\x1adeprecated_game_ip_address\
    \x18\x03\x20\x01(\rR\x17deprecatedGameIpAddress\x12\x1b\n\tgame_port\x18\
    \x04\x20\x01(\rR\x08gamePort\x12\x1b\n\tis_secure\x18\x05\x20\x01(\x08R\
    \x08isSecure\x12\x14\n\x05token\x18\x06\x20\x01(\x0cR\x05token\x12&\n\
    \x0fgame_extra_info\x18\x07\x20\x01(\tR\rgameExtraInfo\x12$\n\x0egame_da\
    ta_blob\x18\x08\x20\x01(\x0cR\x0cgameDataBlob\x12\x1d\n\nprocess_id\x18\
    \t\x20\x01(\rR\tprocessId\x122\n\x15streaming_provider_id\x18\n\x20\x01(\
    \rR\x13streamingProviderId\x12\x1d\n\ngame_flags\x18\x0b\x20\x01(\rR\tga\
    meFlags\x12\x19\n\x08owner_id\x18\x0c\x20\x01(\rR\x07ownerId\x12\"\n\rvr\
    _hmd_vendor\x18\r\x20\x01(\tR\x0bvrHmdVendor\x12\x20\n\x0cvr_hmd_model\
    \x18\x0e\x20\x01(\tR\nvrHmdModel\x12/\n\x12launch_option_type\x18\x0f\
    \x20\x01(\r:\x010R\x10launchOptionType\x12:\n\x17primary_controller_type\
    \x18\x10\x20\x01(\x05:\x02-1R\x15primaryControllerType\x12E\n\x1fprimary\
    _steam_controller_serial\x18\x11\x20\x01(\tR\x1cprimarySteamControllerSe\
    rial\x12B\n\x1ctotal_steam_controller_count\x18\x12\x20\x01(\r:\x010R\
    \x19totalSteamControllerCount\x12I\n\x20total_non_steam_controller_count\
    \x18\x13\x20\x01(\r:\x010R\x1ctotalNonSteamControllerCount\x12@\n\x1bcon\
    troller_workshop_file_id\x18\x14\x20\x01(\x04:\x010R\x18controllerWorksh\
    opFileId\x12&\n\rlaunch_source\x18\x15\x20\x01(\r:\x010R\x0claunchSource\
    \x12$\n\x0evr_hmd_runtime\x18\x16\x20\x01(\rR\x0cvrHmdRuntime\x126\n\x0f\
    game_ip_address\x18\x17\x20\x01(\x0b2\x0e.CMsgIPAddressR\rgameIpAddress\
    \x12?\n\x1acontroller_connection_type\x18\x18\x20\x01(\r:\x010R\x18contr\
    ollerConnectionType\"P\n\rCMsgGSApprove\x12\x19\n\x08steam_id\x18\x01\
    \x20\x01(\x06R\x07steamId\x12$\n\x0eowner_steam_id\x18\x02\x20\x01(\x06R\
    \x0cownerSteamId\"k\n\nCMsgGSDeny\x12\x19\n\x08steam_id\x18\x01\x20\x01(\
    \x06R\x07steamId\x12!\n\x0cedeny_reason\x18\x02\x20\x01(\x05R\x0bedenyRe\
    ason\x12\x1f\n\x0bdeny_string\x18\x03\x20\x01(\tR\ndenyString\"J\n\nCMsg\
    GSKick\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12!\n\x0c\
    edeny_reason\x18\x02\x20\x01(\x05R\x0bedenyReason\"\x8e\x02\n\x12CMsgCli\
    entAuthList\x12\x1f\n\x0btokens_left\x18\x01\x20\x01(\rR\ntokensLeft\x12\
    (\n\x10last_request_seq\x18\x02\x20\x01(\rR\x0elastRequestSeq\x12>\n\x1c\
    last_request_seq_from_server\x18\x03\x20\x01(\rR\x18lastRequestSeqFromSe\
    rver\x12)\n\x07tickets\x18\x04\x20\x03(\x0b2\x0f.CMsgAuthTicketR\x07tick\
    ets\x12\x17\n\x07app_ids\x18\x05\x20\x03(\rR\x06appIds\x12)\n\x10message\
    _sequence\x18\x06\x20\x01(\rR\x0fmessageSequence\"z\n\x15CMsgClientAuthL\
    istAck\x12\x1d\n\nticket_crc\x18\x01\x20\x03(\rR\tticketCrc\x12\x17\n\
    \x07app_ids\x18\x02\x20\x03(\rR\x06appIds\x12)\n\x10message_sequence\x18\
    \x03\x20\x01(\rR\x0fmessageSequence\"\xa0\x06\n\x15CMsgClientLicenseList\
    \x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12:\n\x08l\
    icenses\x18\x02\x20\x03(\x0b2\x1e.CMsgClientLicenseList.LicenseR\x08lice\
    nses\x1a\xad\x05\n\x07License\x12\x1d\n\npackage_id\x18\x01\x20\x01(\rR\
    \tpackageId\x12!\n\x0ctime_created\x18\x02\x20\x01(\x07R\x0btimeCreated\
    \x12*\n\x11time_next_process\x18\x03\x20\x01(\x07R\x0ftimeNextProcess\
    \x12!\n\x0cminute_limit\x18\x04\x20\x01(\x05R\x0bminuteLimit\x12!\n\x0cm\
    inutes_used\x18\x05\x20\x01(\x05R\x0bminutesUsed\x12%\n\x0epayment_metho\
    d\x18\x06\x20\x01(\rR\rpaymentMethod\x12\x14\n\x05flags\x18\x07\x20\x01(\
    \rR\x05flags\x122\n\x15purchase_country_code\x18\x08\x20\x01(\tR\x13purc\
    haseCountryCode\x12!\n\x0clicense_type\x18\t\x20\x01(\rR\x0blicenseType\
    \x12%\n\x0eterritory_code\x18\n\x20\x01(\x05R\rterritoryCode\x12#\n\rcha\
    nge_number\x18\x0b\x20\x01(\x05R\x0cchangeNumber\x12\x19\n\x08owner_id\
    \x18\x0c\x20\x01(\rR\x07ownerId\x12%\n\x0einitial_period\x18\r\x20\x01(\
    \rR\rinitialPeriod\x12*\n\x11initial_time_unit\x18\x0e\x20\x01(\rR\x0fin\
    itialTimeUnit\x12%\n\x0erenewal_period\x18\x0f\x20\x01(\rR\rrenewalPerio\
    d\x12*\n\x11renewal_time_unit\x18\x10\x20\x01(\rR\x0frenewalTimeUnit\x12\
    !\n\x0caccess_token\x18\x11\x20\x01(\x04R\x0baccessToken\x12*\n\x11maste\
    r_package_id\x18\x12\x20\x01(\rR\x0fmasterPackageId\"\xb5\x01\n\x15CMsgC\
    lientLBSSetScore\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12%\n\
    \x0eleaderboard_id\x18\x02\x20\x01(\x05R\rleaderboardId\x12\x14\n\x05sco\
    re\x18\x03\x20\x01(\x05R\x05score\x12\x18\n\x07details\x18\x04\x20\x01(\
    \x0cR\x07details\x12.\n\x13upload_score_method\x18\x05\x20\x01(\x05R\x11\
    uploadScoreMethod\"\xf3\x01\n\x1dCMsgClientLBSSetScoreResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x126\n\x17leaderboard\
    _entry_count\x18\x02\x20\x01(\x05R\x15leaderboardEntryCount\x12#\n\rscor\
    e_changed\x18\x03\x20\x01(\x08R\x0cscoreChanged\x120\n\x14global_rank_pr\
    evious\x18\x04\x20\x01(\x05R\x12globalRankPrevious\x12&\n\x0fglobal_rank\
    _new\x18\x05\x20\x01(\x05R\rglobalRankNew\"j\n\x13CMsgClientLBSSetUGC\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12%\n\x0eleaderboard_\
    id\x18\x02\x20\x01(\x05R\rleaderboardId\x12\x15\n\x06ugc_id\x18\x03\x20\
    \x01(\x06R\x05ugcId\":\n\x1bCMsgClientLBSSetUGCResponse\x12\x1b\n\x07ere\
    sult\x18\x01\x20\x01(\x05:\x012R\x07eresult\"\x80\x02\n\x1bCMsgClientLBS\
    FindOrCreateLB\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x126\n\
    \x17leaderboard_sort_method\x18\x02\x20\x01(\x05R\x15leaderboardSortMeth\
    od\x128\n\x18leaderboard_display_type\x18\x03\x20\x01(\x05R\x16leaderboa\
    rdDisplayType\x12-\n\x13create_if_not_found\x18\x04\x20\x01(\x08R\x10cre\
    ateIfNotFound\x12)\n\x10leaderboard_name\x18\x05\x20\x01(\tR\x0fleaderbo\
    ardName\"\xc4\x02\n#CMsgClientLBSFindOrCreateLBResponse\x12\x1b\n\x07ere\
    sult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12%\n\x0eleaderboard_id\x18\
    \x02\x20\x01(\x05R\rleaderboardId\x126\n\x17leaderboard_entry_count\x18\
    \x03\x20\x01(\x05R\x15leaderboardEntryCount\x129\n\x17leaderboard_sort_m\
    ethod\x18\x04\x20\x01(\x05:\x010R\x15leaderboardSortMethod\x12;\n\x18lea\
    derboard_display_type\x18\x05\x20\x01(\x05:\x010R\x16leaderboardDisplayT\
    ype\x12)\n\x10leaderboard_name\x18\x06\x20\x01(\tR\x0fleaderboardName\"\
    \xed\x01\n\x19CMsgClientLBSGetLBEntries\x12\x15\n\x06app_id\x18\x01\x20\
    \x01(\x05R\x05appId\x12%\n\x0eleaderboard_id\x18\x02\x20\x01(\x05R\rlead\
    erboardId\x12\x1f\n\x0brange_start\x18\x03\x20\x01(\x05R\nrangeStart\x12\
    \x1b\n\trange_end\x18\x04\x20\x01(\x05R\x08rangeEnd\x128\n\x18leaderboar\
    d_data_request\x18\x05\x20\x01(\x05R\x16leaderboardDataRequest\x12\x1a\n\
    \x08steamids\x18\x06\x20\x03(\x06R\x08steamids\"\xd2\x02\n!CMsgClientLBS\
    GetLBEntriesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x126\n\x17leaderboard_entry_count\x18\x02\x20\x01(\x05R\x15l\
    eaderboardEntryCount\x12B\n\x07entries\x18\x03\x20\x03(\x0b2(.CMsgClient\
    LBSGetLBEntriesResponse.EntryR\x07entries\x1a\x93\x01\n\x05Entry\x12\"\n\
    \rsteam_id_user\x18\x01\x20\x01(\x06R\x0bsteamIdUser\x12\x1f\n\x0bglobal\
    _rank\x18\x02\x20\x01(\x05R\nglobalRank\x12\x14\n\x05score\x18\x03\x20\
    \x01(\x05R\x05score\x12\x18\n\x07details\x18\x04\x20\x01(\x0cR\x07detail\
    s\x12\x15\n\x06ugc_id\x18\x05\x20\x01(\x06R\x05ugcId\"\x8c\x02\n\x1aCMsg\
    ClientIsLimitedAccount\x12.\n\x13bis_limited_account\x18\x01\x20\x01(\
    \x08R\x11bisLimitedAccount\x120\n\x14bis_community_banned\x18\x02\x20\
    \x01(\x08R\x12bisCommunityBanned\x12,\n\x12bis_locked_account\x18\x03\
    \x20\x01(\x08R\x10bisLockedAccount\x12^\n-bis_limited_account_allowed_to\
    _invite_friends\x18\x04\x20\x01(\x08R'bisLimitedAccountAllowedToInviteFr\
    iends\"\xd5\x01\n\x1eCMsgClientRequestedClientStats\x12O\n\rstats_to_sen\
    d\x18\x01\x20\x03(\x0b2+.CMsgClientRequestedClientStats.StatsToSendR\x0b\
    statsToSend\x1ab\n\x0bStatsToSend\x12\x1f\n\x0bclient_stat\x18\x01\x20\
    \x01(\rR\nclientStat\x122\n\x15stat_aggregate_method\x18\x02\x20\x01(\rR\
    \x13statAggregateMethod\"\x85\x02\n\x0fCMsgClientStat2\x12<\n\x0bstat_de\
    tail\x18\x01\x20\x03(\x0b2\x1b.CMsgClientStat2.StatDetailR\nstatDetail\
    \x1a\xb3\x01\n\nStatDetail\x12\x1f\n\x0bclient_stat\x18\x01\x20\x01(\rR\
    \nclientStat\x12\x19\n\x08ll_value\x18\x02\x20\x01(\x03R\x07llValue\x12\
    \x1e\n\x0btime_of_day\x18\x03\x20\x01(\rR\ttimeOfDay\x12\x17\n\x07cell_i\
    d\x18\x04\x20\x01(\rR\x06cellId\x12\x19\n\x08depot_id\x18\x05\x20\x01(\r\
    R\x07depotId\x12\x15\n\x06app_id\x18\x06\x20\x01(\rR\x05appId\"\xdf\x01\
    \n'CMsgClientMMSSetRatelimitPolicyOnClient\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12,\n\x12enable_rate_limits\x18\x02\x20\x01(\x08R\
    \x10enableRateLimits\x12.\n\x13seconds_per_message\x18\x03\x20\x01(\x05R\
    \x11secondsPerMessage\x12?\n\x1cmilliseconds_per_data_update\x18\x04\x20\
    \x01(\x05R\x19millisecondsPerDataUpdate\"\xd4\x02\n\x18CMsgClientMMSCrea\
    teLobby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1f\n\x0bma\
    x_members\x18\x02\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\
    \x03\x20\x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\x04\x20\x01(\
    \x05R\nlobbyFlags\x12\x17\n\x07cell_id\x18\x05\x20\x01(\rR\x06cellId\x12\
    0\n\x14deprecated_public_ip\x18\x06\x20\x01(\rR\x12deprecatedPublicIp\
    \x12\x1a\n\x08metadata\x18\x07\x20\x01(\x0cR\x08metadata\x12,\n\x12perso\
    na_name_owner\x18\x08\x20\x01(\tR\x10personaNameOwner\x12+\n\tpublic_ip\
    \x18\t\x20\x01(\x0b2\x0e.CMsgIPAddressR\x08publicIp\"|\n\x20CMsgClientMM\
    SCreateLobbyResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\
    \x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\x1b\
    \n\x07eresult\x18\x03\x20\x01(\x05:\x012R\x07eresult\"x\n\x16CMsgClientM\
    MSJoinLobby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0es\
    team_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12!\n\x0cpersona_na\
    me\x18\x03\x20\x01(\tR\x0bpersonaName\"\xdf\x03\n\x1eCMsgClientMMSJoinLo\
    bbyResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0es\
    team_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x127\n\x18chat_room_\
    enter_response\x18\x03\x20\x01(\x05R\x15chatRoomEnterResponse\x12\x1f\n\
    \x0bmax_members\x18\x04\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\
    \x18\x05\x20\x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\x06\x20\
    \x01(\x05R\nlobbyFlags\x12$\n\x0esteam_id_owner\x18\x07\x20\x01(\x06R\
    \x0csteamIdOwner\x12\x1a\n\x08metadata\x18\x08\x20\x01(\x0cR\x08metadata\
    \x12@\n\x07members\x18\t\x20\x03(\x0b2&.CMsgClientMMSJoinLobbyResponse.M\
    emberR\x07members\x1ab\n\x06Member\x12\x19\n\x08steam_id\x18\x01\x20\x01\
    (\x06R\x07steamId\x12!\n\x0cpersona_name\x18\x02\x20\x01(\tR\x0bpersonaN\
    ame\x12\x1a\n\x08metadata\x18\x03\x20\x01(\x0cR\x08metadata\"V\n\x17CMsg\
    ClientMMSLeaveLobby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\
    $\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\"{\n\x1fCMsg\
    ClientMMSLeaveLobbyResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05a\
    ppId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\
    \x1b\n\x07eresult\x18\x03\x20\x01(\x05:\x012R\x07eresult\"\x90\x03\n\x19\
    CMsgClientMMSGetLobbyList\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05app\
    Id\x122\n\x15num_lobbies_requested\x18\x03\x20\x01(\x05R\x13numLobbiesRe\
    quested\x12\x17\n\x07cell_id\x18\x04\x20\x01(\rR\x06cellId\x120\n\x14dep\
    recated_public_ip\x18\x05\x20\x01(\rR\x12deprecatedPublicIp\x12;\n\x07fi\
    lters\x18\x06\x20\x03(\x0b2!.CMsgClientMMSGetLobbyList.FilterR\x07filter\
    s\x12+\n\tpublic_ip\x18\x07\x20\x01(\x0b2\x0e.CMsgIPAddressR\x08publicIp\
    \x1as\n\x06Filter\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value\x12\x20\n\x0bcomparision\x18\x03\
    \x20\x01(\x05R\x0bcomparision\x12\x1f\n\x0bfilter_type\x18\x04\x20\x01(\
    \x05R\nfilterType\"\x92\x03\n!CMsgClientMMSGetLobbyListResponse\x12\x15\
    \n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\x07eresult\x18\x03\
    \x20\x01(\x05:\x012R\x07eresult\x12B\n\x07lobbies\x18\x04\x20\x03(\x0b2(\
    .CMsgClientMMSGetLobbyListResponse.LobbyR\x07lobbies\x1a\xf4\x01\n\x05Lo\
    bby\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12\x1f\n\x0b\
    max_members\x18\x02\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\
    \x03\x20\x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\x04\x20\x01(\
    \x05R\nlobbyFlags\x12\x1a\n\x08metadata\x18\x05\x20\x01(\x0cR\x08metadat\
    a\x12\x1f\n\x0bnum_members\x18\x06\x20\x01(\x05R\nnumMembers\x12\x1a\n\
    \x08distance\x18\x07\x20\x01(\x02R\x08distance\x12\x16\n\x06weight\x18\
    \x08\x20\x01(\x03R\x06weight\"\xfd\x01\n\x19CMsgClientMMSSetLobbyData\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lob\
    by\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_member\x18\
    \x03\x20\x01(\x06R\rsteamIdMember\x12\x1f\n\x0bmax_members\x18\x04\x20\
    \x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\x05\x20\x01(\x05R\tlobb\
    yType\x12\x1f\n\x0blobby_flags\x18\x06\x20\x01(\x05R\nlobbyFlags\x12\x1a\
    \n\x08metadata\x18\x07\x20\x01(\x0cR\x08metadata\"}\n!CMsgClientMMSSetLo\
    bbyDataResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\
    \x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\x1b\n\x07er\
    esult\x18\x03\x20\x01(\x05:\x012R\x07eresult\"X\n\x19CMsgClientMMSGetLob\
    byData\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_\
    id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\"\x99\x04\n\x16CMsgClient\
    MMSLobbyData\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0e\
    steam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\x1f\n\x0bnum_me\
    mbers\x18\x03\x20\x01(\x05R\nnumMembers\x12\x1f\n\x0bmax_members\x18\x04\
    \x20\x01(\x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\x05\x20\x01(\x05R\t\
    lobbyType\x12\x1f\n\x0blobby_flags\x18\x06\x20\x01(\x05R\nlobbyFlags\x12\
    $\n\x0esteam_id_owner\x18\x07\x20\x01(\x06R\x0csteamIdOwner\x12\x1a\n\
    \x08metadata\x18\x08\x20\x01(\x0cR\x08metadata\x128\n\x07members\x18\t\
    \x20\x03(\x0b2\x1e.CMsgClientMMSLobbyData.MemberR\x07members\x12!\n\x0cl\
    obby_cellid\x18\n\x20\x01(\rR\x0blobbyCellid\x12=\n\x1bowner_should_acce\
    pt_changes\x18\x0b\x20\x01(\x08R\x18ownerShouldAcceptChanges\x1ab\n\x06M\
    ember\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12!\n\x0cp\
    ersona_name\x18\x02\x20\x01(\tR\x0bpersonaName\x12\x1a\n\x08metadata\x18\
    \x03\x20\x01(\x0cR\x08metadata\"\xa9\x01\n\x1dCMsgClientMMSSendLobbyChat\
    Msg\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_\
    lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_target\
    \x18\x03\x20\x01(\x06R\rsteamIdTarget\x12#\n\rlobby_message\x18\x04\x20\
    \x01(\x0cR\x0clobbyMessage\"\xa5\x01\n\x19CMsgClientMMSLobbyChatMsg\x12\
    \x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\
    \x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_sender\x18\x03\
    \x20\x01(\x06R\rsteamIdSender\x12#\n\rlobby_message\x18\x04\x20\x01(\x0c\
    R\x0clobbyMessage\"\x86\x01\n\x1aCMsgClientMMSSetLobbyOwner\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\
    \x20\x01(\x06R\x0csteamIdLobby\x12+\n\x12steam_id_new_owner\x18\x03\x20\
    \x01(\x06R\x0fsteamIdNewOwner\"~\n\"CMsgClientMMSSetLobbyOwnerResponse\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lob\
    by\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\x1b\n\x07eresult\x18\x03\
    \x20\x01(\x05:\x012R\x07eresult\"\x82\x01\n\x1bCMsgClientMMSSetLobbyLink\
    ed\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_l\
    obby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_lobby2\x18\
    \x03\x20\x01(\x06R\rsteamIdLobby2\"\xaa\x02\n\x1fCMsgClientMMSSetLobbyGa\
    meServer\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0estea\
    m_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x129\n\x19deprecated_ga\
    me_server_ip\x18\x03\x20\x01(\rR\x16deprecatedGameServerIp\x12(\n\x10gam\
    e_server_port\x18\x04\x20\x01(\rR\x0egameServerPort\x12/\n\x14game_serve\
    r_steam_id\x18\x05\x20\x01(\x06R\x11gameServerSteamId\x124\n\x0egame_ser\
    ver_ip\x18\x06\x20\x01(\x0b2\x0e.CMsgIPAddressR\x0cgameServerIp\"\xaa\
    \x02\n\x1fCMsgClientMMSLobbyGameServerSet\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0c\
    steamIdLobby\x129\n\x19deprecated_game_server_ip\x18\x03\x20\x01(\rR\x16\
    deprecatedGameServerIp\x12(\n\x10game_server_port\x18\x04\x20\x01(\rR\
    \x0egameServerPort\x12/\n\x14game_server_steam_id\x18\x05\x20\x01(\x06R\
    \x11gameServerSteamId\x124\n\x0egame_server_ip\x18\x06\x20\x01(\x0b2\x0e\
    .CMsgIPAddressR\x0cgameServerIp\"\xa2\x01\n\x1cCMsgClientMMSUserJoinedLo\
    bby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_\
    lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\"\n\rsteam_id_user\x18\
    \x03\x20\x01(\x06R\x0bsteamIdUser\x12!\n\x0cpersona_name\x18\x04\x20\x01\
    (\tR\x0bpersonaName\"\xa0\x01\n\x1aCMsgClientMMSUserLeftLobby\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\
    \x20\x01(\x06R\x0csteamIdLobby\x12\"\n\rsteam_id_user\x18\x03\x20\x01(\
    \x06R\x0bsteamIdUser\x12!\n\x0cpersona_name\x18\x04\x20\x01(\tR\x0bperso\
    naName\"\x8c\x01\n\x1aCMsgClientMMSInviteToLobby\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\
    \x0csteamIdLobby\x121\n\x15steam_id_user_invited\x18\x03\x20\x01(\x06R\
    \x12steamIdUserInvited\"\xae\x01\n\x1bCMsgClientMMSGetLobbyStatus\x12\
    \x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\
    \x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12)\n\x10claim_membership\x18\
    \x03\x20\x01(\x08R\x0fclaimMembership\x12'\n\x0fclaim_ownership\x18\x04\
    \x20\x01(\x08R\x0eclaimOwnership\"\xb1\x01\n#CMsgClientMMSGetLobbyStatus\
    Response\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0estea\
    m_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12M\n\x0clobby_status\
    \x18\x03\x20\x01(\x0e2\x10.EMMSLobbyStatus:\x18k_EMMSLobbyStatusInvalidR\
    \x0blobbyStatus\"\xa6\x01\n\x16CMsgClientInviteToGame\x12\"\n\rsteam_id_\
    dest\x18\x01\x20\x01(\x06R\x0bsteamIdDest\x12\x20\n\x0csteam_id_src\x18\
    \x02\x20\x01(\x06R\nsteamIdSrc\x12%\n\x0econnect_string\x18\x03\x20\x01(\
    \tR\rconnectString\x12\x1f\n\x0bremote_play\x18\x04\x20\x01(\tR\nremoteP\
    lay\"\x98\x02\n\x14CMsgClientChatInvite\x12(\n\x10steam_id_invited\x18\
    \x01\x20\x01(\x06R\x0esteamIdInvited\x12\"\n\rsteam_id_chat\x18\x02\x20\
    \x01(\x06R\x0bsteamIdChat\x12&\n\x0fsteam_id_patron\x18\x03\x20\x01(\x06\
    R\rsteamIdPatron\x12#\n\rchatroom_type\x18\x04\x20\x01(\x05R\x0cchatroom\
    Type\x12/\n\x14steam_id_friend_chat\x18\x05\x20\x01(\x06R\x11steamIdFrie\
    ndChat\x12\x1b\n\tchat_name\x18\x06\x20\x01(\tR\x08chatName\x12\x17\n\
    \x07game_id\x18\x07\x20\x01(\x06R\x06gameId\"\x93\x0c\n\x19CMsgClientCon\
    nectionStats\x12G\n\x0bstats_logon\x18\x01\x20\x01(\x0b2&.CMsgClientConn\
    ectionStats.Stats_LogonR\nstatsLogon\x12G\n\x0bstats_vconn\x18\x02\x20\
    \x01(\x0b2&.CMsgClientConnectionStats.Stats_VConnR\nstatsVconn\x1a\xc1\
    \x02\n\x0bStats_Logon\x12)\n\x10connect_attempts\x18\x01\x20\x01(\x05R\
    \x0fconnectAttempts\x12+\n\x11connect_successes\x18\x02\x20\x01(\x05R\
    \x10connectSuccesses\x12)\n\x10connect_failures\x18\x03\x20\x01(\x05R\
    \x0fconnectFailures\x12/\n\x13connections_dropped\x18\x04\x20\x01(\x05R\
    \x12connectionsDropped\x12'\n\x0fseconds_running\x18\x05\x20\x01(\rR\x0e\
    secondsRunning\x121\n\x14msec_tologonthistime\x18\x06\x20\x01(\rR\x13mse\
    cTologonthistime\x12\"\n\rcount_bad_cms\x18\x07\x20\x01(\rR\x0bcountBadC\
    ms\x1a\xaa\x01\n\tStats_UDP\x12\x1b\n\tpkts_sent\x18\x01\x20\x01(\x04R\
    \x08pktsSent\x12\x1d\n\nbytes_sent\x18\x02\x20\x01(\x04R\tbytesSent\x12\
    \x1b\n\tpkts_recv\x18\x03\x20\x01(\x04R\x08pktsRecv\x12%\n\x0epkts_proce\
    ssed\x18\x04\x20\x01(\x04R\rpktsProcessed\x12\x1d\n\nbytes_recv\x18\x05\
    \x20\x01(\x04R\tbytesRecv\x1a\xf2\x06\n\x0bStats_VConn\x12'\n\x0fconnect\
    ions_udp\x18\x01\x20\x01(\rR\x0econnectionsUdp\x12'\n\x0fconnections_tcp\
    \x18\x02\x20\x01(\rR\x0econnectionsTcp\x12A\n\tstats_udp\x18\x03\x20\x01\
    (\x0b2$.CMsgClientConnectionStats.Stats_UDPR\x08statsUdp\x12%\n\x0epkts_\
    abandoned\x18\x04\x20\x01(\x04R\rpktsAbandoned\x12*\n\x11conn_req_receiv\
    ed\x18\x05\x20\x01(\x04R\x0fconnReqReceived\x12\x1f\n\x0bpkts_resent\x18\
    \x06\x20\x01(\x04R\npktsResent\x12\x1b\n\tmsgs_sent\x18\x07\x20\x01(\x04\
    R\x08msgsSent\x12(\n\x10msgs_sent_failed\x18\x08\x20\x01(\x04R\x0emsgsSe\
    ntFailed\x12\x1b\n\tmsgs_recv\x18\t\x20\x01(\x04R\x08msgsRecv\x12%\n\x0e\
    datagrams_sent\x18\n\x20\x01(\x04R\rdatagramsSent\x12%\n\x0edatagrams_re\
    cv\x18\x0b\x20\x01(\x04R\rdatagramsRecv\x12\"\n\rbad_pkts_recv\x18\x0c\
    \x20\x01(\x04R\x0bbadPktsRecv\x123\n\x16unknown_conn_pkts_recv\x18\r\x20\
    \x01(\x04R\x13unknownConnPktsRecv\x12(\n\x10missed_pkts_recv\x18\x0e\x20\
    \x01(\x04R\x0emissedPktsRecv\x12\"\n\rdup_pkts_recv\x18\x0f\x20\x01(\x04\
    R\x0bdupPktsRecv\x12:\n\x19failed_connect_challenges\x18\x10\x20\x01(\
    \x04R\x17failedConnectChallenges\x121\n\x15micro_sec_avg_latency\x18\x11\
    \x20\x01(\rR\x12microSecAvgLatency\x121\n\x15micro_sec_min_latency\x18\
    \x12\x20\x01(\rR\x12microSecMinLatency\x121\n\x15micro_sec_max_latency\
    \x18\x13\x20\x01(\rR\x12microSecMaxLatency\x12,\n\x13mem_pool_msg_in_use\
    \x18\x14\x20\x01(\rR\x0fmemPoolMsgInUse\"\x94\x02\n\x1aCMsgClientServers\
    Available\x12h\n\x16server_types_available\x18\x01\x20\x03(\x0b22.CMsgCl\
    ientServersAvailable.Server_Types_AvailableR\x14serverTypesAvailable\x12\
    @\n\x1dserver_type_for_auth_services\x18\x02\x20\x01(\rR\x19serverTypeFo\
    rAuthServices\x1aJ\n\x16Server_Types_Available\x12\x16\n\x06server\x18\
    \x01\x20\x01(\rR\x06server\x12\x18\n\x07changed\x18\x02\x20\x01(\x08R\
    \x07changed\"\xab\x01\n\x16CMsgClientGetUserStats\x12\x17\n\x07game_id\
    \x18\x01\x20\x01(\x06R\x06gameId\x12\x1b\n\tcrc_stats\x18\x02\x20\x01(\r\
    R\x08crcStats\x120\n\x14schema_local_version\x18\x03\x20\x01(\x05R\x12sc\
    hemaLocalVersion\x12)\n\x11steam_id_for_user\x18\x04\x20\x01(\x06R\x0est\
    eamIdForUser\"\xca\x03\n\x1eCMsgClientGetUserStatsResponse\x12\x17\n\x07\
    game_id\x18\x01\x20\x01(\x06R\x06gameId\x12\x1b\n\x07eresult\x18\x02\x20\
    \x01(\x05:\x012R\x07eresult\x12\x1b\n\tcrc_stats\x18\x03\x20\x01(\rR\x08\
    crcStats\x12\x16\n\x06schema\x18\x04\x20\x01(\x0cR\x06schema\x12;\n\x05s\
    tats\x18\x05\x20\x03(\x0b2%.CMsgClientGetUserStatsResponse.StatsR\x05sta\
    ts\x12a\n\x12achievement_blocks\x18\x06\x20\x03(\x0b22.CMsgClientGetUser\
    StatsResponse.Achievement_BlocksR\x11achievementBlocks\x1a?\n\x05Stats\
    \x12\x17\n\x07stat_id\x18\x01\x20\x01(\rR\x06statId\x12\x1d\n\nstat_valu\
    e\x18\x02\x20\x01(\rR\tstatValue\x1a\\\n\x12Achievement_Blocks\x12%\n\
    \x0eachievement_id\x18\x01\x20\x01(\rR\rachievementId\x12\x1f\n\x0bunloc\
    k_time\x18\x02\x20\x03(\x07R\nunlockTime\"\xf7\x02\n\x20CMsgClientStoreU\
    serStatsResponse\x12\x17\n\x07game_id\x18\x01\x20\x01(\x06R\x06gameId\
    \x12\x1b\n\x07eresult\x18\x02\x20\x01(\x05:\x012R\x07eresult\x12\x1b\n\t\
    crc_stats\x18\x03\x20\x01(\rR\x08crcStats\x12q\n\x17stats_failed_validat\
    ion\x18\x04\x20\x03(\x0b29.CMsgClientStoreUserStatsResponse.Stats_Failed\
    _ValidationR\x15statsFailedValidation\x12)\n\x11stats_out_of_date\x18\
    \x05\x20\x01(\x08R\x0estatsOutOfDate\x1ab\n\x17Stats_Failed_Validation\
    \x12\x17\n\x07stat_id\x18\x01\x20\x01(\rR\x06statId\x12.\n\x13reverted_s\
    tat_value\x18\x02\x20\x01(\rR\x11revertedStatValue\"\xc1\x02\n\x19CMsgCl\
    ientStoreUserStats2\x12\x17\n\x07game_id\x18\x01\x20\x01(\x06R\x06gameId\
    \x12&\n\x0fsettor_steam_id\x18\x02\x20\x01(\x06R\rsettorSteamId\x12&\n\
    \x0fsettee_steam_id\x18\x03\x20\x01(\x06R\rsetteeSteamId\x12\x1b\n\tcrc_\
    stats\x18\x04\x20\x01(\rR\x08crcStats\x12%\n\x0eexplicit_reset\x18\x05\
    \x20\x01(\x08R\rexplicitReset\x126\n\x05stats\x18\x06\x20\x03(\x0b2\x20.\
    CMsgClientStoreUserStats2.StatsR\x05stats\x1a?\n\x05Stats\x12\x17\n\x07s\
    tat_id\x18\x01\x20\x01(\rR\x06statId\x12\x1d\n\nstat_value\x18\x02\x20\
    \x01(\rR\tstatValue\"\xfe\x01\n\x16CMsgClientStatsUpdated\x12\x19\n\x08s\
    team_id\x18\x01\x20\x01(\x06R\x07steamId\x12\x17\n\x07game_id\x18\x02\
    \x20\x01(\x06R\x06gameId\x12\x1b\n\tcrc_stats\x18\x03\x20\x01(\rR\x08crc\
    Stats\x12J\n\rupdated_stats\x18\x04\x20\x03(\x0b2%.CMsgClientStatsUpdate\
    d.Updated_StatsR\x0cupdatedStats\x1aG\n\rUpdated_Stats\x12\x17\n\x07stat\
    _id\x18\x01\x20\x01(\rR\x06statId\x12\x1d\n\nstat_value\x18\x02\x20\x01(\
    \rR\tstatValue\"\xf4\x01\n\x18CMsgClientStoreUserStats\x12\x17\n\x07game\
    _id\x18\x01\x20\x01(\x06R\x06gameId\x12%\n\x0eexplicit_reset\x18\x02\x20\
    \x01(\x08R\rexplicitReset\x12N\n\x0estats_to_store\x18\x03\x20\x03(\x0b2\
    (.CMsgClientStoreUserStats.Stats_To_StoreR\x0cstatsToStore\x1aH\n\x0eSta\
    ts_To_Store\x12\x17\n\x07stat_id\x18\x01\x20\x01(\rR\x06statId\x12\x1d\n\
    \nstat_value\x18\x02\x20\x01(\rR\tstatValue\"\x1c\n\x1aCMsgClientGetClie\
    ntDetails\"O\n$CMsgClientReportOverlayDetourFailure\x12'\n\x0ffailure_st\
    rings\x18\x01\x20\x03(\tR\x0efailureStrings\"\xc6\x03\n\"CMsgClientGetCl\
    ientDetailsResponse\x12'\n\x0fpackage_version\x18\x01\x20\x01(\rR\x0epac\
    kageVersion\x12)\n\x10protocol_version\x18\x08\x20\x01(\rR\x0fprotocolVe\
    rsion\x12\x0e\n\x02os\x18\x02\x20\x01(\tR\x02os\x12!\n\x0cmachine_name\
    \x18\x03\x20\x01(\tR\x0bmachineName\x12\x1b\n\tip_public\x18\x04\x20\x01\
    (\tR\x08ipPublic\x12\x1d\n\nip_private\x18\x05\x20\x01(\tR\tipPrivate\
    \x12'\n\x0fbytes_available\x18\x07\x20\x01(\x04R\x0ebytesAvailable\x12M\
    \n\rgames_running\x18\x06\x20\x03(\x0b2(.CMsgClientGetClientDetailsRespo\
    nse.GameR\x0cgamesRunning\x1ae\n\x04Game\x12\x14\n\x05appid\x18\x01\x20\
    \x01(\rR\x05appid\x12\x1d\n\nextra_info\x18\x02\x20\x01(\tR\textraInfo\
    \x12(\n\x10time_running_sec\x18\x03\x20\x01(\rR\x0etimeRunningSec\"\xc2\
    \x01\n\x1aCMsgClientGetClientAppList\x12\x14\n\x05media\x18\x01\x20\x01(\
    \x08R\x05media\x12\x14\n\x05tools\x18\x02\x20\x01(\x08R\x05tools\x12\x14\
    \n\x05games\x18\x03\x20\x01(\x08R\x05games\x12%\n\x0eonly_installed\x18\
    \x04\x20\x01(\x08R\ronlyInstalled\x12#\n\ronly_changing\x18\x05\x20\x01(\
    \x08R\x0conlyChanging\x12\x16\n\x06comics\x18\x06\x20\x01(\x08R\x06comic\
    s\"\xf5\x05\n\"CMsgClientGetClientAppListResponse\x12;\n\x04apps\x18\x01\
    \x20\x03(\x0b2'.CMsgClientGetClientAppListResponse.AppR\x04apps\x12'\n\
    \x0fbytes_available\x18\x02\x20\x01(\x04R\x0ebytesAvailable\x1a\xe8\x04\
    \n\x03App\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1a\n\x08c\
    ategory\x18\x02\x20\x01(\tR\x08category\x12\x19\n\x08app_type\x18\n\x20\
    \x01(\tR\x07appType\x12\x1a\n\x08favorite\x18\x03\x20\x01(\x08R\x08favor\
    ite\x12\x1c\n\tinstalled\x18\x04\x20\x01(\x08R\tinstalled\x12\x1f\n\x0ba\
    uto_update\x18\x05\x20\x01(\x08R\nautoUpdate\x12)\n\x10bytes_downloaded\
    \x18\x06\x20\x01(\x04R\x0fbytesDownloaded\x12!\n\x0cbytes_needed\x18\x07\
    \x20\x01(\x04R\x0bbytesNeeded\x12.\n\x13bytes_download_rate\x18\x08\x20\
    \x01(\rR\x11bytesDownloadRate\x12'\n\x0fdownload_paused\x18\x0b\x20\x01(\
    \x08R\x0edownloadPaused\x12'\n\x0fnum_downloading\x18\x0c\x20\x01(\rR\
    \x0enumDownloading\x12\x1d\n\nnum_paused\x18\r\x20\x01(\rR\tnumPaused\
    \x12\x1a\n\x08changing\x18\x0e\x20\x01(\x08R\x08changing\x122\n\x15avail\
    able_on_platform\x18\x0f\x20\x01(\x08R\x13availableOnPlatform\x12?\n\x04\
    dlcs\x18\t\x20\x03(\x0b2+.CMsgClientGetClientAppListResponse.App.DLCR\
    \x04dlcs\x1a9\n\x03DLC\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \x12\x1c\n\tinstalled\x18\x02\x20\x01(\x08R\tinstalled\"2\n\x1aCMsgClien\
    tInstallClientApp\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"<\n\"\
    CMsgClientInstallClientAppResponse\x12\x16\n\x06result\x18\x01\x20\x01(\
    \rR\x06result\"4\n\x1cCMsgClientUninstallClientApp\x12\x14\n\x05appid\
    \x18\x01\x20\x01(\rR\x05appid\">\n$CMsgClientUninstallClientAppResponse\
    \x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"Q\n!CMsgClientSetCli\
    entAppUpdateState\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\
    \x16\n\x06update\x18\x02\x20\x01(\x08R\x06update\"C\n)CMsgClientSetClien\
    tAppUpdateStateResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06resul\
    t\"\x82\x03\n\x1eCMsgClientUFSUploadFileRequest\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile_size\x18\x02\x20\x01(\rR\x08fi\
    leSize\x12\"\n\rraw_file_size\x18\x03\x20\x01(\rR\x0brawFileSize\x12\x19\
    \n\x08sha_file\x18\x04\x20\x01(\x0cR\x07shaFile\x12\x1d\n\ntime_stamp\
    \x18\x05\x20\x01(\x04R\ttimeStamp\x12\x1b\n\tfile_name\x18\x06\x20\x01(\
    \tR\x08fileName\x12?\n\x1cplatforms_to_sync_deprecated\x18\x07\x20\x01(\
    \rR\x19platformsToSyncDeprecated\x126\n\x11platforms_to_sync\x18\x08\x20\
    \x01(\r:\n4294967295R\x0fplatformsToSync\x12\x17\n\x07cell_id\x18\t\x20\
    \x01(\rR\x06cellId\x12\x1f\n\x0bcan_encrypt\x18\n\x20\x01(\x08R\ncanEncr\
    ypt\"\x8b\x02\n\x1fCMsgClientUFSUploadFileResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x19\n\x08sha_file\x18\x02\
    \x20\x01(\x0cR\x07shaFile\x12\x19\n\x08use_http\x18\x03\x20\x01(\x08R\
    \x07useHttp\x12\x1b\n\thttp_host\x18\x04\x20\x01(\tR\x08httpHost\x12\x19\
    \n\x08http_url\x18\x05\x20\x01(\tR\x07httpUrl\x12\x1d\n\nkv_headers\x18\
    \x06\x20\x01(\x0cR\tkvHeaders\x12\x1b\n\tuse_https\x18\x07\x20\x01(\x08R\
    \x08useHttps\x12!\n\x0cencrypt_file\x18\x08\x20\x01(\x08R\x0bencryptFile\
    \"\xe2\x01\n\x19CMsgClientUFSUploadCommit\x125\n\x05files\x18\x01\x20\
    \x03(\x0b2\x1f.CMsgClientUFSUploadCommit.FileR\x05files\x1a\x8d\x01\n\
    \x04File\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\
    \x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12\x19\n\x08sha_file\x18\
    \x03\x20\x01(\x0cR\x07shaFile\x12\x19\n\x08cub_file\x18\x04\x20\x01(\rR\
    \x07cubFile\x12\x1b\n\tfile_name\x18\x05\x20\x01(\tR\x08fileName\"\xb9\
    \x01\n!CMsgClientUFSUploadCommitResponse\x12=\n\x05files\x18\x01\x20\x03\
    (\x0b2'.CMsgClientUFSUploadCommitResponse.FileR\x05files\x1aU\n\x04File\
    \x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x15\n\
    \x06app_id\x18\x02\x20\x01(\rR\x05appId\x12\x19\n\x08sha_file\x18\x03\
    \x20\x01(\x0cR\x07shaFile\"f\n\x16CMsgClientUFSFileChunk\x12\x19\n\x08sh\
    a_file\x18\x01\x20\x01(\x0cR\x07shaFile\x12\x1d\n\nfile_start\x18\x02\
    \x20\x01(\rR\tfileStart\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\
    \"\x20\n\x1eCMsgClientUFSTransferHeartbeat\"Y\n\x1fCMsgClientUFSUploadFi\
    leFinished\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\
    \x12\x19\n\x08sha_file\x18\x02\x20\x01(\x0cR\x07shaFile\"\x82\x01\n\x1eC\
    MsgClientUFSDeleteFileRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\x12,\n\
    \x12is_explicit_delete\x18\x03\x20\x01(\x08R\x10isExplicitDelete\"[\n\
    \x1fCMsgClientUFSDeleteFileResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01\
    (\x05:\x012R\x07eresult\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08file\
    Name\"r\n\x1eCMsgClientUFSGetFileListForApp\x12\"\n\rapps_to_query\x18\
    \x01\x20\x03(\rR\x0bappsToQuery\x12,\n\x12send_path_prefixes\x18\x02\x20\
    \x01(\x08R\x10sendPathPrefixes\"\xbc\x03\n&CMsgClientUFSGetFileListForAp\
    pResponse\x12B\n\x05files\x18\x01\x20\x03(\x0b2,.CMsgClientUFSGetFileLis\
    tForAppResponse.FileR\x05files\x12#\n\rpath_prefixes\x18\x02\x20\x03(\tR\
    \x0cpathPrefixes\x1a\x9e\x02\n\x04File\x12\x15\n\x06app_id\x18\x01\x20\
    \x01(\rR\x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\
    \x12\x19\n\x08sha_file\x18\x03\x20\x01(\x0cR\x07shaFile\x12\x1d\n\ntime_\
    stamp\x18\x04\x20\x01(\x04R\ttimeStamp\x12\"\n\rraw_file_size\x18\x05\
    \x20\x01(\rR\x0brawFileSize\x12,\n\x12is_explicit_delete\x18\x06\x20\x01\
    (\x08R\x10isExplicitDelete\x12*\n\x11platforms_to_sync\x18\x07\x20\x01(\
    \rR\x0fplatformsToSync\x12*\n\x11path_prefix_index\x18\x08\x20\x01(\rR\
    \x0fpathPrefixIndex:\x08\x80\xb5\x18\x08\x88\xb5\x18\x10\"z\n\x1cCMsgCli\
    entUFSDownloadRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\
    \x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\x12&\n\x0fcan_hand\
    le_http\x18\x03\x20\x01(\x08R\rcanHandleHttp\"\xa9\x03\n\x1dCMsgClientUF\
    SDownloadResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07er\
    esult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12\x1b\n\tfile_s\
    ize\x18\x03\x20\x01(\rR\x08fileSize\x12\"\n\rraw_file_size\x18\x04\x20\
    \x01(\rR\x0brawFileSize\x12\x19\n\x08sha_file\x18\x05\x20\x01(\x0cR\x07s\
    haFile\x12\x1d\n\ntime_stamp\x18\x06\x20\x01(\x04R\ttimeStamp\x12,\n\x12\
    is_explicit_delete\x18\x07\x20\x01(\x08R\x10isExplicitDelete\x12\x19\n\
    \x08use_http\x18\x08\x20\x01(\x08R\x07useHttp\x12\x1b\n\thttp_host\x18\t\
    \x20\x01(\tR\x08httpHost\x12\x19\n\x08http_url\x18\n\x20\x01(\tR\x07http\
    Url\x12\x1d\n\nkv_headers\x18\x0b\x20\x01(\x0cR\tkvHeaders\x12\x1b\n\tus\
    e_https\x18\x0c\x20\x01(\x08R\x08useHttps\x12\x1c\n\tencrypted\x18\r\x20\
    \x01(\x08R\tencrypted\"\x84\x01\n\x19CMsgClientUFSLoginRequest\x12)\n\
    \x10protocol_version\x18\x01\x20\x01(\rR\x0fprotocolVersion\x12(\n\x10am\
    _session_token\x18\x02\x20\x01(\x04R\x0eamSessionToken\x12\x12\n\x04apps\
    \x18\x03\x20\x03(\rR\x04apps\"9\n\x1aCMsgClientUFSLoginResponse\x12\x1b\
    \n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\"X\n#CMsgClientRequ\
    estEncryptedAppTicket\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\
    \x12\x1a\n\x08userdata\x18\x02\x20\x01(\x0cR\x08userdata\"\xa8\x01\n+CMs\
    gClientRequestEncryptedAppTicketResponse\x12\x15\n\x06app_id\x18\x01\x20\
    \x01(\rR\x05appId\x12\x1b\n\x07eresult\x18\x02\x20\x01(\x05:\x012R\x07er\
    esult\x12E\n\x14encrypted_app_ticket\x18\x03\x20\x01(\x0b2\x13.Encrypted\
    AppTicketR\x12encryptedAppTicket\"\xf1\x01\n\x1aCMsgClientWalletInfoUpda\
    te\x12\x1d\n\nhas_wallet\x18\x01\x20\x01(\x08R\thasWallet\x12\x18\n\x07b\
    alance\x18\x02\x20\x01(\x05R\x07balance\x12\x1a\n\x08currency\x18\x03\
    \x20\x01(\x05R\x08currency\x12'\n\x0fbalance_delayed\x18\x04\x20\x01(\
    \x05R\x0ebalanceDelayed\x12\"\n\tbalance64\x18\x05\x20\x01(\x03R\tbalanc\
    e64B\x04\xa0\xb6\x18\x01\x121\n\x11balance64_delayed\x18\x06\x20\x01(\
    \x03R\x10balance64DelayedB\x04\xa0\xb6\x18\x01\"o\n\x17CMsgClientAppInfo\
    Update\x12+\n\x11last_changenumber\x18\x01\x20\x01(\rR\x10lastChangenumb\
    er\x12'\n\x0fsend_changelist\x18\x02\x20\x01(\x08R\x0esendChangelist\"\
    \x92\x01\n\x18CMsgClientAppInfoChanges\x122\n\x15current_change_number\
    \x18\x01\x20\x01(\rR\x13currentChangeNumber\x12*\n\x11force_full_update\
    \x18\x02\x20\x01(\x08R\x0fforceFullUpdate\x12\x16\n\x06appIDs\x18\x03\
    \x20\x03(\rR\x06appIDs\"\xe3\x01\n\x18CMsgClientAppInfoRequest\x121\n\
    \x04apps\x18\x01\x20\x03(\x0b2\x1d.CMsgClientAppInfoRequest.AppR\x04apps\
    \x120\n\x10supports_batches\x18\x02\x20\x01(\x08:\x05falseR\x0fsupportsB\
    atches\x1ab\n\x03App\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\
    \x12#\n\rsection_flags\x18\x02\x20\x01(\rR\x0csectionFlags\x12\x1f\n\x0b\
    section_CRC\x18\x03\x20\x03(\rR\nsectionCRC\"\xec\x02\n\x19CMsgClientApp\
    InfoResponse\x122\n\x04apps\x18\x01\x20\x03(\x0b2\x1e.CMsgClientAppInfoR\
    esponse.AppR\x04apps\x12!\n\x0capps_unknown\x18\x02\x20\x03(\rR\x0bappsU\
    nknown\x12!\n\x0capps_pending\x18\x03\x20\x01(\rR\x0bappsPending\x1a\xce\
    \x01\n\x03App\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12#\n\rc\
    hange_number\x18\x02\x20\x01(\rR\x0cchangeNumber\x12B\n\x08sections\x18\
    \x03\x20\x03(\x0b2&.CMsgClientAppInfoResponse.App.SectionR\x08sections\
    \x1aG\n\x07Section\x12\x1d\n\nsection_id\x18\x01\x20\x01(\rR\tsectionId\
    \x12\x1d\n\nsection_kv\x18\x02\x20\x01(\x0cR\tsectionKv:\x04\x88\xb5\x18\
    \0\"e\n\x1cCMsgClientPackageInfoRequest\x12\x1f\n\x0bpackage_ids\x18\x01\
    \x20\x03(\rR\npackageIds\x12$\n\x0emeta_data_only\x18\x02\x20\x01(\x08R\
    \x0cmetaDataOnly\"\xb2\x02\n\x1dCMsgClientPackageInfoResponse\x12B\n\x08\
    packages\x18\x01\x20\x03(\x0b2&.CMsgClientPackageInfoResponse.PackageR\
    \x08packages\x12)\n\x10packages_unknown\x18\x02\x20\x03(\rR\x0fpackagesU\
    nknown\x12)\n\x10packages_pending\x18\x03\x20\x01(\rR\x0fpackagesPending\
    \x1aw\n\x07Package\x12\x1d\n\npackage_id\x18\x01\x20\x01(\rR\tpackageId\
    \x12#\n\rchange_number\x18\x02\x20\x01(\rR\x0cchangeNumber\x12\x10\n\x03\
    sha\x18\x03\x20\x01(\x0cR\x03sha\x12\x16\n\x06buffer\x18\x04\x20\x01(\
    \x0cR\x06buffer\"\xa7\x02\n!CMsgClientPICSChangesSinceRequest\x12.\n\x13\
    since_change_number\x18\x01\x20\x01(\rR\x11sinceChangeNumber\x121\n\x15s\
    end_app_info_changes\x18\x02\x20\x01(\x08R\x12sendAppInfoChanges\x129\n\
    \x19send_package_info_changes\x18\x03\x20\x01(\x08R\x16sendPackageInfoCh\
    anges\x12-\n\x13num_app_info_cached\x18\x04\x20\x01(\rR\x10numAppInfoCac\
    hed\x125\n\x17num_package_info_cached\x18\x05\x20\x01(\rR\x14numPackageI\
    nfoCached\"\xac\x05\n\"CMsgClientPICSChangesSinceResponse\x122\n\x15curr\
    ent_change_number\x18\x01\x20\x01(\rR\x13currentChangeNumber\x12.\n\x13s\
    ince_change_number\x18\x02\x20\x01(\rR\x11sinceChangeNumber\x12*\n\x11fo\
    rce_full_update\x18\x03\x20\x01(\x08R\x0fforceFullUpdate\x12Z\n\x0fpacka\
    ge_changes\x18\x04\x20\x03(\x0b21.CMsgClientPICSChangesSinceResponse.Pac\
    kageChangeR\x0epackageChanges\x12N\n\x0bapp_changes\x18\x05\x20\x03(\x0b\
    2-.CMsgClientPICSChangesSinceResponse.AppChangeR\nappChanges\x121\n\x15f\
    orce_full_app_update\x18\x06\x20\x01(\x08R\x12forceFullAppUpdate\x129\n\
    \x19force_full_package_update\x18\x07\x20\x01(\x08R\x16forceFullPackageU\
    pdate\x1as\n\rPackageChange\x12\x1c\n\tpackageid\x18\x01\x20\x01(\rR\tpa\
    ckageid\x12#\n\rchange_number\x18\x02\x20\x01(\rR\x0cchangeNumber\x12\
    \x1f\n\x0bneeds_token\x18\x03\x20\x01(\x08R\nneedsToken\x1ag\n\tAppChang\
    e\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12#\n\rchange_number\
    \x18\x02\x20\x01(\rR\x0cchangeNumber\x12\x1f\n\x0bneeds_token\x18\x03\
    \x20\x01(\x08R\nneedsToken\"\xf8\x03\n\x20CMsgClientPICSProductInfoReque\
    st\x12I\n\x08packages\x18\x01\x20\x03(\x0b2-.CMsgClientPICSProductInfoRe\
    quest.PackageInfoR\x08packages\x12=\n\x04apps\x18\x02\x20\x03(\x0b2).CMs\
    gClientPICSProductInfoRequest.AppInfoR\x04apps\x12$\n\x0emeta_data_only\
    \x18\x03\x20\x01(\x08R\x0cmetaDataOnly\x12&\n\x0fnum_prev_failed\x18\x04\
    \x20\x01(\rR\rnumPrevFailed\x126\n\x17supports_package_tokens\x18\x05\
    \x20\x01(\rR\x15supportsPackageTokens\x1at\n\x07AppInfo\x12\x14\n\x05app\
    id\x18\x01\x20\x01(\rR\x05appid\x12!\n\x0caccess_token\x18\x02\x20\x01(\
    \x04R\x0baccessToken\x120\n\x14only_public_obsolete\x18\x03\x20\x01(\x08\
    R\x12onlyPublicObsolete\x1aN\n\x0bPackageInfo\x12\x1c\n\tpackageid\x18\
    \x01\x20\x01(\rR\tpackageid\x12!\n\x0caccess_token\x18\x02\x20\x01(\x04R\
    \x0baccessToken\"\x9e\x06\n!CMsgClientPICSProductInfoResponse\x12>\n\x04\
    apps\x18\x01\x20\x03(\x0b2*.CMsgClientPICSProductInfoResponse.AppInfoR\
    \x04apps\x12%\n\x0eunknown_appids\x18\x02\x20\x03(\rR\runknownAppids\x12\
    J\n\x08packages\x18\x03\x20\x03(\x0b2..CMsgClientPICSProductInfoResponse\
    .PackageInfoR\x08packages\x12-\n\x12unknown_packageids\x18\x04\x20\x03(\
    \rR\x11unknownPackageids\x12$\n\x0emeta_data_only\x18\x05\x20\x01(\x08R\
    \x0cmetaDataOnly\x12)\n\x10response_pending\x18\x06\x20\x01(\x08R\x0fres\
    ponsePending\x12\"\n\rhttp_min_size\x18\x07\x20\x01(\rR\x0bhttpMinSize\
    \x12\x1b\n\thttp_host\x18\x08\x20\x01(\tR\x08httpHost\x1a\xc8\x01\n\x07A\
    ppInfo\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12#\n\rchange_nu\
    mber\x18\x02\x20\x01(\rR\x0cchangeNumber\x12#\n\rmissing_token\x18\x03\
    \x20\x01(\x08R\x0cmissingToken\x12\x10\n\x03sha\x18\x04\x20\x01(\x0cR\
    \x03sha\x12\x16\n\x06buffer\x18\x05\x20\x01(\x0cR\x06buffer\x12\x1f\n\
    \x0bonly_public\x18\x06\x20\x01(\x08R\nonlyPublic\x12\x12\n\x04size\x18\
    \x07\x20\x01(\rR\x04size\x1a\xb3\x01\n\x0bPackageInfo\x12\x1c\n\tpackage\
    id\x18\x01\x20\x01(\rR\tpackageid\x12#\n\rchange_number\x18\x02\x20\x01(\
    \rR\x0cchangeNumber\x12#\n\rmissing_token\x18\x03\x20\x01(\x08R\x0cmissi\
    ngToken\x12\x10\n\x03sha\x18\x04\x20\x01(\x0cR\x03sha\x12\x16\n\x06buffe\
    r\x18\x05\x20\x01(\x0cR\x06buffer\x12\x12\n\x04size\x18\x06\x20\x01(\rR\
    \x04size:\x04\x88\xb5\x18\0\"Z\n\x20CMsgClientPICSAccessTokenRequest\x12\
    \x1e\n\npackageids\x18\x01\x20\x03(\rR\npackageids\x12\x16\n\x06appids\
    \x18\x02\x20\x03(\rR\x06appids\"\xd7\x03\n!CMsgClientPICSAccessTokenResp\
    onse\x12c\n\x15package_access_tokens\x18\x01\x20\x03(\x0b2/.CMsgClientPI\
    CSAccessTokenResponse.PackageTokenR\x13packageAccessTokens\x122\n\x15pac\
    kage_denied_tokens\x18\x02\x20\x03(\rR\x13packageDeniedTokens\x12W\n\x11\
    app_access_tokens\x18\x03\x20\x03(\x0b2+.CMsgClientPICSAccessTokenRespon\
    se.AppTokenR\x0fappAccessTokens\x12*\n\x11app_denied_tokens\x18\x04\x20\
    \x03(\rR\x0fappDeniedTokens\x1aO\n\x0cPackageToken\x12\x1c\n\tpackageid\
    \x18\x01\x20\x01(\rR\tpackageid\x12!\n\x0caccess_token\x18\x02\x20\x01(\
    \x04R\x0baccessToken\x1aC\n\x08AppToken\x12\x14\n\x05appid\x18\x01\x20\
    \x01(\rR\x05appid\x12!\n\x0caccess_token\x18\x02\x20\x01(\x04R\x0baccess\
    Token\"N\n\x1aCMsgClientUFSGetUGCDetails\x120\n\x08hcontent\x18\x01\x20\
    \x01(\x06:\x1418446744073709551615R\x08hcontent\"\xd3\x02\n\"CMsgClientU\
    FSGetUGCDetailsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x15\n\x06app\
    _id\x18\x03\x20\x01(\rR\x05appId\x12\x1a\n\x08filename\x18\x04\x20\x01(\
    \tR\x08filename\x12'\n\x0fsteamid_creator\x18\x05\x20\x01(\x06R\x0esteam\
    idCreator\x12\x1b\n\tfile_size\x18\x06\x20\x01(\rR\x08fileSize\x120\n\
    \x14compressed_file_size\x18\x07\x20\x01(\rR\x12compressedFileSize\x12'\
    \n\x0frangecheck_host\x18\x08\x20\x01(\tR\x0erangecheckHost\x12*\n\x11fi\
    le_encoded_sha1\x18\t\x20\x01(\tR\x0ffileEncodedSha1\"T\n\x1eCMsgClientU\
    FSGetSingleFileInfo\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\
    \x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\"\x85\x02\n&CMsgClient\
    UFSGetSingleFileInfoResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\
    \x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12\
    \x1b\n\tfile_name\x18\x03\x20\x01(\tR\x08fileName\x12\x19\n\x08sha_file\
    \x18\x04\x20\x01(\x0cR\x07shaFile\x12\x1d\n\ntime_stamp\x18\x05\x20\x01(\
    \x04R\ttimeStamp\x12\"\n\rraw_file_size\x18\x06\x20\x01(\rR\x0brawFileSi\
    ze\x12,\n\x12is_explicit_delete\x18\x07\x20\x01(\x08R\x10isExplicitDelet\
    e\"L\n\x16CMsgClientUFSShareFile\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\"o\n\x1eC\
    MsgClientUFSShareFileResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\
    \x012R\x07eresult\x120\n\x08hcontent\x18\x02\x20\x01(\x06:\x141844674407\
    3709551615R\x08hcontent\"@\n\x1bCMsgClientAMGetClanOfficers\x12!\n\x0cst\
    eamid_clan\x18\x01\x20\x01(\x06R\x0bsteamidClan\"\x8a\x01\n#CMsgClientAM\
    GetClanOfficersResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12!\n\x0csteamid_clan\x18\x02\x20\x01(\x06R\x0bsteamidClan\
    \x12#\n\rofficer_count\x18\x03\x20\x01(\x05R\x0cofficerCount\"\xa7\x01\n\
    !CMsgClientAMGetPersonaNameHistory\x12\x19\n\x08id_count\x18\x01\x20\x01\
    (\x05R\x07idCount\x12?\n\x03Ids\x18\x02\x20\x03(\x0b2-.CMsgClientAMGetPe\
    rsonaNameHistory.IdInstanceR\x03Ids\x1a&\n\nIdInstance\x12\x18\n\x07stea\
    mid\x18\x01\x20\x01(\x06R\x07steamid\"\xf8\x02\n)CMsgClientAMGetPersonaN\
    ameHistoryResponse\x12Z\n\tresponses\x18\x02\x20\x03(\x0b2<.CMsgClientAM\
    GetPersonaNameHistoryResponse.NameTableInstanceR\tresponses\x1a\xee\x01\
    \n\x11NameTableInstance\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\x12_\n\
    \x05names\x18\x03\x20\x03(\x0b2I.CMsgClientAMGetPersonaNameHistoryRespon\
    se.NameTableInstance.NameInstanceR\x05names\x1aA\n\x0cNameInstance\x12\
    \x1d\n\nname_since\x18\x01\x20\x01(\x07R\tnameSince\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\"Y\n\x1eCMsgClientDeregisterWithServer\x12\
    \x20\n\x0beservertype\x18\x01\x20\x01(\rR\x0beservertype\x12\x15\n\x06ap\
    p_id\x18\x02\x20\x01(\rR\x05appId\"\x81\x06\n\x13CMsgClientClanState\x12\
    !\n\x0csteamid_clan\x18\x01\x20\x01(\x06R\x0bsteamidClan\x12,\n\x12clan_\
    account_flags\x18\x03\x20\x01(\rR\x10clanAccountFlags\x12:\n\tname_info\
    \x18\x04\x20\x01(\x0b2\x1d.CMsgClientClanState.NameInfoR\x08nameInfo\x12\
    @\n\x0buser_counts\x18\x05\x20\x01(\x0b2\x1f.CMsgClientClanState.UserCou\
    ntsR\nuserCounts\x122\n\x06events\x18\x06\x20\x03(\x0b2\x1a.CMsgClientCl\
    anState.EventR\x06events\x12@\n\rannouncements\x18\x07\x20\x03(\x0b2\x1a\
    .CMsgClientClanState.EventR\rannouncements\x12*\n\x11chat_room_private\
    \x18\x08\x20\x01(\x08R\x0fchatRoomPrivate\x1aF\n\x08NameInfo\x12\x1b\n\t\
    clan_name\x18\x01\x20\x01(\tR\x08clanName\x12\x1d\n\nsha_avatar\x18\x02\
    \x20\x01(\x0cR\tshaAvatar\x1a\x9f\x01\n\nUserCounts\x12\x18\n\x07members\
    \x18\x01\x20\x01(\rR\x07members\x12\x16\n\x06online\x18\x02\x20\x01(\rR\
    \x06online\x12\x1a\n\x08chatting\x18\x03\x20\x01(\rR\x08chatting\x12\x17\
    \n\x07in_game\x18\x04\x20\x01(\rR\x06inGame\x12*\n\x11chat_room_members\
    \x18\x05\x20\x01(\rR\x0fchatRoomMembers\x1a\x8e\x01\n\x05Event\x12\x10\n\
    \x03gid\x18\x01\x20\x01(\x06R\x03gid\x12\x1d\n\nevent_time\x18\x02\x20\
    \x01(\rR\teventTime\x12\x1a\n\x08headline\x18\x03\x20\x01(\tR\x08headlin\
    e\x12\x17\n\x07game_id\x18\x04\x20\x01(\x06R\x06gameId\x12\x1f\n\x0bjust\
    _posted\x18\x05\x20\x01(\x08R\njustPosted\"\xf8\x01\n\x1fCMsgClientUnsig\
    nedInstallScript\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\
    \x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\x12\x1b\n\tfile_size\
    \x18\x03\x20\x01(\rR\x08fileSize\x12)\n\x10signature_broken\x18\x04\x20\
    \x01(\x08R\x0fsignatureBroken\x12\x19\n\x08depot_id\x18\x05\x20\x01(\rR\
    \x07depotId\x12\x1f\n\x0bmanifest_id\x18\x06\x20\x01(\x04R\nmanifestId\
    \x12\x1d\n\nfile_flags\x18\x07\x20\x01(\rR\tfileFlags*\x90\x01\n\x0fEMMS\
    LobbyStatus\x12\x1c\n\x18k_EMMSLobbyStatusInvalid\x10\0\x12\x1b\n\x17k_E\
    MMSLobbyStatusExists\x10\x01\x12!\n\x1dk_EMMSLobbyStatusDoesNotExist\x10\
    \x02\x12\x1f\n\x1bk_EMMSLobbyStatusNotAMember\x10\x03B\x05H\x01\x80\x01\
    \0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
