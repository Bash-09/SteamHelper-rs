//! Message Module
//!
//!
//!
//!
//!
//! Check link below for more info:
//! https://github.com/ValvePython/steam/blob/09f4f51a287ee7aec1f159c7e8098add5f14bed3/steam/core/msg/headers.py

use serde::{Deserialize, Serialize};

use steam_language_gen::generated::headers::SerializableMessageHeader;
use steam_language_gen::generated::messages::SerializableMessageBody;

#[cfg(test)]
mod tests {
    use protobuf::Message;

    use steam_language_gen::generated::enums::{EMsg, EUniverse};
    use steam_language_gen::generated::headers::{StandardMessageHeader, SerializableMessageHeader, ExtendedMessageHeader};
    use steam_language_gen::generated::messages::{MsgChannelEncryptRequest, MsgClientChatEnter, SerializableMessageBody};

    /// ChannelEncryptRequest
                                /// This has standard header
    fn get_channel_encrypt_request() -> Vec<u8> {
        let on_connection_packet = vec![
            23, 5, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 1, 0, 0, 0, 1, 0, 0, 0, 66, 126, 251, 245, 88, 122, 243, 123, 102, 163, 11, 54,
            151, 145, 31, 54,
        ];
        on_connection_packet
    }

    /// ClientChatEnter, EMsg(807)
    fn get_client_chat_enter() -> Vec<u8> {
        let struct_msg_data = vec![
            0x27, 0x03, 0x00, 0x00, 0x24, 0x02, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xAC, 0x15, 0x89, 0x00,
            0x01, 0x00, 0x10, 0x01, 0x8E, 0x56, 0x11, 0x00, 0xBC, 0x4E, 0x2A, 0x00, 0x00, 0x00,
            0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
            0xBC, 0x4E, 0x2A, 0x00, 0x00, 0x00, 0x70, 0x01, 0xBC, 0x4E, 0x2A, 0x00, 0x00, 0x00,
            0x70, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x53, 0x61, 0x78,
            0x74, 0x6F, 0x6E, 0x20, 0x48, 0x65, 0x6C, 0x6C, 0x00, 0x00, 0x4D, 0x65, 0x73, 0x73,
            0x61, 0x67, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x07, 0x73, 0x74, 0x65,
            0x61, 0x6D, 0x69, 0x64, 0x00, 0xAC, 0x15, 0x89, 0x00, 0x01, 0x00, 0x10, 0x01, 0x02,
            0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x00, 0x7B, 0x03,
            0x00, 0x00, 0x02, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x00, 0x01, 0x00, 0x00,
            0x00, 0x08, 0x08, 0x00, 0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4F, 0x62, 0x6A,
            0x65, 0x63, 0x74, 0x00, 0x07, 0x73, 0x74, 0x65, 0x61, 0x6D, 0x69, 0x64, 0x00, 0x00,
            0x28, 0x90, 0x00, 0x01, 0x00, 0x10, 0x01, 0x02, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73,
            0x73, 0x69, 0x6F, 0x6E, 0x73, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x44, 0x65, 0x74,
            0x61, 0x69, 0x6C, 0x73, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x4D, 0x65,
            0x73, 0x73, 0x61, 0x67, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x07, 0x73,
            0x74, 0x65, 0x61, 0x6D, 0x69, 0x64, 0x00, 0xB0, 0xDC, 0x5B, 0x04, 0x01, 0x00, 0x10,
            0x01, 0x02, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x02, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4F,
            0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x07, 0x73, 0x74, 0x65, 0x61, 0x6D, 0x69, 0x64,
            0x00, 0x39, 0xCB, 0x77, 0x05, 0x01, 0x00, 0x10, 0x01, 0x02, 0x70, 0x65, 0x72, 0x6D,
            0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x02, 0x44,
            0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x08, 0xE8,
            0x03, 0x00, 0x00,
        ];
        struct_msg_data
    }

    #[test]
    fn deserialize_client_chat_enter() {
        let message = get_client_chat_enter();

        let emsg = EMsg::from_raw_message(&message).unwrap();
        let message_complete = EMsg::strip_message(&message);
        let (header, message): (&[u8], &[u8]) = ExtendedMessageHeader::strip_as_bytes(message_complete);

        assert_eq!(EMsg::ClientChatEnter, emsg);

        let msg = MsgClientChatEnter::from_bytes(message);
        println!(": {:#?}", msg);
    }

    #[test]
    fn deserialize_msg_encrypt_request() {
        let message = b"\x17\x05\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\
        \xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00".to_vec();

        let emsg = EMsg::from_raw_message(&message).unwrap();
        let message_complete = EMsg::strip_message(&message);
        let (header, message): (&[u8], &[u8]) = StandardMessageHeader::strip_as_bytes(message_complete);
        let msgheader_default: StandardMessageHeader = StandardMessageHeader::new();

        assert_eq!(EMsg::ChannelEncryptRequest, emsg);
        assert_eq!(msgheader_default.to_bytes(), header);
        assert_eq!(StandardMessageHeader::from_bytes(header), msgheader_default);

        let msg = MsgChannelEncryptRequest { protocol_version: 1, universe: EUniverse::Public };
        assert_eq!(MsgChannelEncryptRequest::from_bytes(message), msg);
    }
}

//  if message is proto: emsg_enum, raw_data from packet
// new MessageHeaderProtobuf
// steammessages_base_pb2. CMSGProtobufHeader

//  if not proto: emsg_enum, raw_data from packet -> extender
// novo  ExtendedMessageHeader
