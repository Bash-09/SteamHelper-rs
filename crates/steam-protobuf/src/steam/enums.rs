// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `enums.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EPublishedFileQueryType {
    k_PublishedFileQueryType_RankedByVote = 0,
    k_PublishedFileQueryType_RankedByPublicationDate = 1,
    k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate = 2,
    k_PublishedFileQueryType_RankedByTrend = 3,
    k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate = 4,
    k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate = 5,
    k_PublishedFileQueryType_RankedByNumTimesReported = 6,
    k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate = 7,
    k_PublishedFileQueryType_NotYetRated = 8,
    k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions = 9,
    k_PublishedFileQueryType_RankedByTotalVotesAsc = 10,
    k_PublishedFileQueryType_RankedByVotesUp = 11,
    k_PublishedFileQueryType_RankedByTextSearch = 12,
    k_PublishedFileQueryType_RankedByPlaytimeTrend = 13,
    k_PublishedFileQueryType_RankedByTotalPlaytime = 14,
    k_PublishedFileQueryType_RankedByAveragePlaytimeTrend = 15,
    k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime = 16,
    k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend = 17,
    k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions = 18,
    k_PublishedFileQueryType_RankedByInappropriateContentRating = 19,
}

impl ::protobuf::ProtobufEnum for EPublishedFileQueryType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileQueryType> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote),
            1 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate),
            2 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate),
            3 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend),
            4 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate),
            5 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate),
            6 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported),
            7 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate),
            8 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated),
            9 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions),
            10 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc),
            11 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp),
            12 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch),
            13 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend),
            14 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime),
            15 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend),
            16 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime),
            17 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend),
            18 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions),
            19 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EPublishedFileQueryType] = &[
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate,
            EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend,
            EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate,
            EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported,
            EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate,
            EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions,
            EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EPublishedFileQueryType>("EPublishedFileQueryType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EPublishedFileQueryType {
}

impl ::std::default::Default for EPublishedFileQueryType {
    fn default() -> Self {
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote
    }
}

impl ::protobuf::reflect::ProtobufValue for EPublishedFileQueryType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EPublishedFileInappropriateProvider {
    k_EPublishedFileInappropriateProvider_Invalid = 0,
    k_EPublishedFileInappropriateProvider_Google = 1,
    k_EPublishedFileInappropriateProvider_Amazon = 2,
}

impl ::protobuf::ProtobufEnum for EPublishedFileInappropriateProvider {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileInappropriateProvider> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid),
            1 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google),
            2 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EPublishedFileInappropriateProvider] = &[
            EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid,
            EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google,
            EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EPublishedFileInappropriateProvider>("EPublishedFileInappropriateProvider", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EPublishedFileInappropriateProvider {
}

impl ::std::default::Default for EPublishedFileInappropriateProvider {
    fn default() -> Self {
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EPublishedFileInappropriateProvider {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EPublishedFileInappropriateResult {
    k_EPublishedFileInappropriateResult_NotScanned = 0,
    k_EPublishedFileInappropriateResult_VeryUnlikely = 1,
    k_EPublishedFileInappropriateResult_Unlikely = 30,
    k_EPublishedFileInappropriateResult_Possible = 50,
    k_EPublishedFileInappropriateResult_Likely = 75,
    k_EPublishedFileInappropriateResult_VeryLikely = 100,
}

impl ::protobuf::ProtobufEnum for EPublishedFileInappropriateResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileInappropriateResult> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned),
            1 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely),
            30 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely),
            50 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible),
            75 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely),
            100 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EPublishedFileInappropriateResult] = &[
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EPublishedFileInappropriateResult>("EPublishedFileInappropriateResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EPublishedFileInappropriateResult {
}

impl ::std::default::Default for EPublishedFileInappropriateResult {
    fn default() -> Self {
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned
    }
}

impl ::protobuf::reflect::ProtobufValue for EPublishedFileInappropriateResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EPersonaStateFlag {
    k_EPersonaStateFlag_HasRichPresence = 1,
    k_EPersonaStateFlag_InJoinableGame = 2,
    k_EPersonaStateFlag_Golden = 4,
    k_EPersonaStateFlag_RemotePlayTogether = 8,
    k_EPersonaStateFlag_ClientTypeWeb = 256,
    k_EPersonaStateFlag_ClientTypeMobile = 512,
    k_EPersonaStateFlag_ClientTypeTenfoot = 1024,
    k_EPersonaStateFlag_ClientTypeVR = 2048,
    k_EPersonaStateFlag_LaunchTypeGamepad = 4096,
    k_EPersonaStateFlag_LaunchTypeCompatTool = 8192,
}

impl ::protobuf::ProtobufEnum for EPersonaStateFlag {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPersonaStateFlag> {
        match value {
            1 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence),
            2 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame),
            4 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_Golden),
            8 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether),
            256 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb),
            512 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile),
            1024 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot),
            2048 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR),
            4096 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad),
            8192 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EPersonaStateFlag] = &[
            EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence,
            EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame,
            EPersonaStateFlag::k_EPersonaStateFlag_Golden,
            EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR,
            EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad,
            EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EPersonaStateFlag>("EPersonaStateFlag", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EPersonaStateFlag {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EPersonaStateFlag {
    fn default() -> Self {
        EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence
    }
}

impl ::protobuf::reflect::ProtobufValue for EPersonaStateFlag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EContentCheckProvider {
    k_EContentCheckProvider_Invalid = 0,
    k_EContentCheckProvider_Google = 1,
    k_EContentCheckProvider_Amazon = 2,
    k_EContentCheckProvider_Local = 3,
}

impl ::protobuf::ProtobufEnum for EContentCheckProvider {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EContentCheckProvider> {
        match value {
            0 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Invalid),
            1 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Google),
            2 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Amazon),
            3 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Local),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EContentCheckProvider] = &[
            EContentCheckProvider::k_EContentCheckProvider_Invalid,
            EContentCheckProvider::k_EContentCheckProvider_Google,
            EContentCheckProvider::k_EContentCheckProvider_Amazon,
            EContentCheckProvider::k_EContentCheckProvider_Local,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EContentCheckProvider>("EContentCheckProvider", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EContentCheckProvider {
}

impl ::std::default::Default for EContentCheckProvider {
    fn default() -> Self {
        EContentCheckProvider::k_EContentCheckProvider_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EContentCheckProvider {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EBanContentCheckResult {
    k_EBanContentCheckResult_NotScanned = 0,
    k_EBanContentCheckResult_Reset = 1,
    k_EBanContentCheckResult_NeedsChecking = 2,
    k_EBanContentCheckResult_VeryUnlikely = 5,
    k_EBanContentCheckResult_Unlikely = 30,
    k_EBanContentCheckResult_Possible = 50,
    k_EBanContentCheckResult_Likely = 75,
    k_EBanContentCheckResult_VeryLikely = 100,
}

impl ::protobuf::ProtobufEnum for EBanContentCheckResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBanContentCheckResult> {
        match value {
            0 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NotScanned),
            1 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Reset),
            2 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking),
            5 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely),
            30 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Unlikely),
            50 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Possible),
            75 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Likely),
            100 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EBanContentCheckResult] = &[
            EBanContentCheckResult::k_EBanContentCheckResult_NotScanned,
            EBanContentCheckResult::k_EBanContentCheckResult_Reset,
            EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking,
            EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely,
            EBanContentCheckResult::k_EBanContentCheckResult_Unlikely,
            EBanContentCheckResult::k_EBanContentCheckResult_Possible,
            EBanContentCheckResult::k_EBanContentCheckResult_Likely,
            EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EBanContentCheckResult>("EBanContentCheckResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EBanContentCheckResult {
}

impl ::std::default::Default for EBanContentCheckResult {
    fn default() -> Self {
        EBanContentCheckResult::k_EBanContentCheckResult_NotScanned
    }
}

impl ::protobuf::reflect::ProtobufValue for EBanContentCheckResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0benums.proto\x1a\x18steammessages_base.proto*\x94\t\n\x17EPublished\
    FileQueryType\x12)\n%k_PublishedFileQueryType_RankedByVote\x10\0\x124\n0\
    k_PublishedFileQueryType_RankedByPublicationDate\x10\x01\x12B\n>k_Publis\
    hedFileQueryType_AcceptedForGameRankedByAcceptanceDate\x10\x02\x12*\n&k_\
    PublishedFileQueryType_RankedByTrend\x10\x03\x12F\nBk_PublishedFileQuery\
    Type_FavoritedByFriendsRankedByPublicationDate\x10\x04\x12D\n@k_Publishe\
    dFileQueryType_CreatedByFriendsRankedByPublicationDate\x10\x05\x125\n1k_\
    PublishedFileQueryType_RankedByNumTimesReported\x10\x06\x12J\nFk_Publish\
    edFileQueryType_CreatedByFollowedUsersRankedByPublicationDate\x10\x07\
    \x12(\n$k_PublishedFileQueryType_NotYetRated\x10\x08\x12=\n9k_PublishedF\
    ileQueryType_RankedByTotalUniqueSubscriptions\x10\t\x122\n.k_PublishedFi\
    leQueryType_RankedByTotalVotesAsc\x10\n\x12,\n(k_PublishedFileQueryType_\
    RankedByVotesUp\x10\x0b\x12/\n+k_PublishedFileQueryType_RankedByTextSear\
    ch\x10\x0c\x122\n.k_PublishedFileQueryType_RankedByPlaytimeTrend\x10\r\
    \x122\n.k_PublishedFileQueryType_RankedByTotalPlaytime\x10\x0e\x129\n5k_\
    PublishedFileQueryType_RankedByAveragePlaytimeTrend\x10\x0f\x12<\n8k_Pub\
    lishedFileQueryType_RankedByLifetimeAveragePlaytime\x10\x10\x12:\n6k_Pub\
    lishedFileQueryType_RankedByPlaytimeSessionsTrend\x10\x11\x12=\n9k_Publi\
    shedFileQueryType_RankedByLifetimePlaytimeSessions\x10\x12\x12?\n;k_Publ\
    ishedFileQueryType_RankedByInappropriateContentRating\x10\x13*\xbc\x01\n\
    #EPublishedFileInappropriateProvider\x121\n-k_EPublishedFileInappropriat\
    eProvider_Invalid\x10\0\x120\n,k_EPublishedFileInappropriateProvider_Goo\
    gle\x10\x01\x120\n,k_EPublishedFileInappropriateProvider_Amazon\x10\x02*\
    \xd5\x02\n!EPublishedFileInappropriateResult\x122\n.k_EPublishedFileInap\
    propriateResult_NotScanned\x10\0\x124\n0k_EPublishedFileInappropriateRes\
    ult_VeryUnlikely\x10\x01\x120\n,k_EPublishedFileInappropriateResult_Unli\
    kely\x10\x1e\x120\n,k_EPublishedFileInappropriateResult_Possible\x102\
    \x12.\n*k_EPublishedFileInappropriateResult_Likely\x10K\x122\n.k_EPublis\
    hedFileInappropriateResult_VeryLikely\x10d*\xb1\x03\n\x11EPersonaStateFl\
    ag\x12'\n#k_EPersonaStateFlag_HasRichPresence\x10\x01\x12&\n\"k_EPersona\
    StateFlag_InJoinableGame\x10\x02\x12\x1e\n\x1ak_EPersonaStateFlag_Golden\
    \x10\x04\x12*\n&k_EPersonaStateFlag_RemotePlayTogether\x10\x08\x12&\n!k_\
    EPersonaStateFlag_ClientTypeWeb\x10\x80\x02\x12)\n$k_EPersonaStateFlag_C\
    lientTypeMobile\x10\x80\x04\x12*\n%k_EPersonaStateFlag_ClientTypeTenfoot\
    \x10\x80\x08\x12%\n\x20k_EPersonaStateFlag_ClientTypeVR\x10\x80\x10\x12*\
    \n%k_EPersonaStateFlag_LaunchTypeGamepad\x10\x80\x20\x12-\n(k_EPersonaSt\
    ateFlag_LaunchTypeCompatTool\x10\x80@*\xa7\x01\n\x15EContentCheckProvide\
    r\x12#\n\x1fk_EContentCheckProvider_Invalid\x10\0\x12\"\n\x1ek_EContentC\
    heckProvider_Google\x10\x01\x12\"\n\x1ek_EContentCheckProvider_Amazon\
    \x10\x02\x12!\n\x1dk_EContentCheckProvider_Local\x10\x03*\xd8\x02\n\x16E\
    BanContentCheckResult\x12'\n#k_EBanContentCheckResult_NotScanned\x10\0\
    \x12\"\n\x1ek_EBanContentCheckResult_Reset\x10\x01\x12*\n&k_EBanContentC\
    heckResult_NeedsChecking\x10\x02\x12)\n%k_EBanContentCheckResult_VeryUnl\
    ikely\x10\x05\x12%\n!k_EBanContentCheckResult_Unlikely\x10\x1e\x12%\n!k_\
    EBanContentCheckResult_Possible\x102\x12#\n\x1fk_EBanContentCheckResult_\
    Likely\x10K\x12'\n#k_EBanContentCheckResult_VeryLikely\x10dB\tH\x01\x80\
    \x01\x01\x80\xb5\x18\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
