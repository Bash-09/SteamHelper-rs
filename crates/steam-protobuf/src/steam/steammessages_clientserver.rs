// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.10.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//! Generated file from `steammessages_clientserver.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUDSP2PSessionStarted {
    // message fields
    steamid_remote: ::std::option::Option<u64>,
    appid: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUDSP2PSessionStarted {
    fn default() -> &'a CMsgClientUDSP2PSessionStarted {
        <CMsgClientUDSP2PSessionStarted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUDSP2PSessionStarted {
    pub fn new() -> CMsgClientUDSP2PSessionStarted {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_remote = 1;

    pub fn get_steamid_remote(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }

    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 2;

    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUDSP2PSessionStarted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_remote = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_remote {
            my_size += 9;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_remote {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUDSP2PSessionStarted {
        CMsgClientUDSP2PSessionStarted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_remote",
                |m: &CMsgClientUDSP2PSessionStarted| { &m.steamid_remote },
                |m: &mut CMsgClientUDSP2PSessionStarted| { &mut m.steamid_remote },
                CMsgClientUDSP2PSessionStarted::get_steamid_remote,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "appid",
                |m: &CMsgClientUDSP2PSessionStarted| { &m.appid },
                |m: &mut CMsgClientUDSP2PSessionStarted| { &mut m.appid },
                CMsgClientUDSP2PSessionStarted::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUDSP2PSessionStarted>(
                "CMsgClientUDSP2PSessionStarted",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUDSP2PSessionStarted {
        static instance: ::protobuf::rt::Lazy<CMsgClientUDSP2PSessionStarted> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUDSP2PSessionStarted::new)
    }
}

impl ::protobuf::Clear for CMsgClientUDSP2PSessionStarted {
    fn clear(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUDSP2PSessionStarted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUDSP2PSessionStarted {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUDSP2PSessionEnded {
    // message fields
    steamid_remote: ::std::option::Option<u64>,
    appid: ::std::option::Option<i32>,
    session_length_sec: ::std::option::Option<i32>,
    session_error: ::std::option::Option<i32>,
    nattype: ::std::option::Option<i32>,
    bytes_recv: ::std::option::Option<i32>,
    bytes_sent: ::std::option::Option<i32>,
    bytes_sent_relay: ::std::option::Option<i32>,
    bytes_recv_relay: ::std::option::Option<i32>,
    time_to_connect_ms: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUDSP2PSessionEnded {
    fn default() -> &'a CMsgClientUDSP2PSessionEnded {
        <CMsgClientUDSP2PSessionEnded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUDSP2PSessionEnded {
    pub fn new() -> CMsgClientUDSP2PSessionEnded {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_remote = 1;

    pub fn get_steamid_remote(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }

    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 2;

    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 session_length_sec = 3;

    pub fn get_session_length_sec(&self) -> i32 {
        self.session_length_sec.unwrap_or(0)
    }

    pub fn clear_session_length_sec(&mut self) {
        self.session_length_sec = ::std::option::Option::None;
    }

    pub fn has_session_length_sec(&self) -> bool {
        self.session_length_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_sec(&mut self, v: i32) {
        self.session_length_sec = ::std::option::Option::Some(v);
    }

    // optional int32 session_error = 4;

    pub fn get_session_error(&self) -> i32 {
        self.session_error.unwrap_or(0)
    }

    pub fn clear_session_error(&mut self) {
        self.session_error = ::std::option::Option::None;
    }

    pub fn has_session_error(&self) -> bool {
        self.session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_error(&mut self, v: i32) {
        self.session_error = ::std::option::Option::Some(v);
    }

    // optional int32 nattype = 5;

    pub fn get_nattype(&self) -> i32 {
        self.nattype.unwrap_or(0)
    }

    pub fn clear_nattype(&mut self) {
        self.nattype = ::std::option::Option::None;
    }

    pub fn has_nattype(&self) -> bool {
        self.nattype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nattype(&mut self, v: i32) {
        self.nattype = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_recv = 6;

    pub fn get_bytes_recv(&self) -> i32 {
        self.bytes_recv.unwrap_or(0)
    }

    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = ::std::option::Option::None;
    }

    pub fn has_bytes_recv(&self) -> bool {
        self.bytes_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: i32) {
        self.bytes_recv = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_sent = 7;

    pub fn get_bytes_sent(&self) -> i32 {
        self.bytes_sent.unwrap_or(0)
    }

    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = ::std::option::Option::None;
    }

    pub fn has_bytes_sent(&self) -> bool {
        self.bytes_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: i32) {
        self.bytes_sent = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_sent_relay = 8;

    pub fn get_bytes_sent_relay(&self) -> i32 {
        self.bytes_sent_relay.unwrap_or(0)
    }

    pub fn clear_bytes_sent_relay(&mut self) {
        self.bytes_sent_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_sent_relay(&self) -> bool {
        self.bytes_sent_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent_relay(&mut self, v: i32) {
        self.bytes_sent_relay = ::std::option::Option::Some(v);
    }

    // optional int32 bytes_recv_relay = 9;

    pub fn get_bytes_recv_relay(&self) -> i32 {
        self.bytes_recv_relay.unwrap_or(0)
    }

    pub fn clear_bytes_recv_relay(&mut self) {
        self.bytes_recv_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_recv_relay(&self) -> bool {
        self.bytes_recv_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv_relay(&mut self, v: i32) {
        self.bytes_recv_relay = ::std::option::Option::Some(v);
    }

    // optional int32 time_to_connect_ms = 10;

    pub fn get_time_to_connect_ms(&self) -> i32 {
        self.time_to_connect_ms.unwrap_or(0)
    }

    pub fn clear_time_to_connect_ms(&mut self) {
        self.time_to_connect_ms = ::std::option::Option::None;
    }

    pub fn has_time_to_connect_ms(&self) -> bool {
        self.time_to_connect_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_connect_ms(&mut self, v: i32) {
        self.time_to_connect_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUDSP2PSessionEnded {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_remote = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.session_length_sec = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.session_error = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.nattype = ::std::option::Option::Some(is.read_int32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bytes_recv = ::std::option::Option::Some(is.read_int32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bytes_sent = ::std::option::Option::Some(is.read_int32()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bytes_sent_relay = ::std::option::Option::Some(is.read_int32()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bytes_recv_relay = ::std::option::Option::Some(is.read_int32()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_to_connect_ms = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_remote {
            my_size += 9;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session_length_sec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.session_error {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nattype {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_recv {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_sent {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_sent_relay {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_recv_relay {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_to_connect_ms {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_remote {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.session_length_sec {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.session_error {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.nattype {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.bytes_recv {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.bytes_sent {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.bytes_sent_relay {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.bytes_recv_relay {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.time_to_connect_ms {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUDSP2PSessionEnded {
        CMsgClientUDSP2PSessionEnded::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_remote",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.steamid_remote },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.steamid_remote },
                CMsgClientUDSP2PSessionEnded::get_steamid_remote,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "appid",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.appid },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.appid },
                CMsgClientUDSP2PSessionEnded::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "session_length_sec",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.session_length_sec },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.session_length_sec },
                CMsgClientUDSP2PSessionEnded::get_session_length_sec,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "session_error",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.session_error },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.session_error },
                CMsgClientUDSP2PSessionEnded::get_session_error,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "nattype",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.nattype },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.nattype },
                CMsgClientUDSP2PSessionEnded::get_nattype,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "bytes_recv",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_recv },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_recv },
                CMsgClientUDSP2PSessionEnded::get_bytes_recv,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "bytes_sent",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_sent },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_sent },
                CMsgClientUDSP2PSessionEnded::get_bytes_sent,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "bytes_sent_relay",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_sent_relay },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_sent_relay },
                CMsgClientUDSP2PSessionEnded::get_bytes_sent_relay,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "bytes_recv_relay",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.bytes_recv_relay },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.bytes_recv_relay },
                CMsgClientUDSP2PSessionEnded::get_bytes_recv_relay,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "time_to_connect_ms",
                |m: &CMsgClientUDSP2PSessionEnded| { &m.time_to_connect_ms },
                |m: &mut CMsgClientUDSP2PSessionEnded| { &mut m.time_to_connect_ms },
                CMsgClientUDSP2PSessionEnded::get_time_to_connect_ms,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUDSP2PSessionEnded>(
                "CMsgClientUDSP2PSessionEnded",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUDSP2PSessionEnded {
        static instance: ::protobuf::rt::Lazy<CMsgClientUDSP2PSessionEnded> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUDSP2PSessionEnded::new)
    }
}

impl ::protobuf::Clear for CMsgClientUDSP2PSessionEnded {
    fn clear(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.session_length_sec = ::std::option::Option::None;
        self.session_error = ::std::option::Option::None;
        self.nattype = ::std::option::Option::None;
        self.bytes_recv = ::std::option::Option::None;
        self.bytes_sent = ::std::option::Option::None;
        self.bytes_sent_relay = ::std::option::Option::None;
        self.bytes_recv_relay = ::std::option::Option::None;
        self.time_to_connect_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUDSP2PSessionEnded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUDSP2PSessionEnded {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRegisterAuthTicketWithCM {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    client_instance_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterAuthTicketWithCM {
    fn default() -> &'a CMsgClientRegisterAuthTicketWithCM {
        <CMsgClientRegisterAuthTicketWithCM as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterAuthTicketWithCM {
    pub fn new() -> CMsgClientRegisterAuthTicketWithCM {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;

    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 3;

    pub fn get_ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket.set_default();
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 client_instance_id = 4;

    pub fn get_client_instance_id(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }

    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRegisterAuthTicketWithCM {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ticket)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.client_instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.client_instance_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.client_instance_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRegisterAuthTicketWithCM {
        CMsgClientRegisterAuthTicketWithCM::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "protocol_version",
                |m: &CMsgClientRegisterAuthTicketWithCM| { &m.protocol_version },
                |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.protocol_version },
                CMsgClientRegisterAuthTicketWithCM::get_protocol_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "ticket",
                |m: &CMsgClientRegisterAuthTicketWithCM| { &m.ticket },
                |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.ticket },
                CMsgClientRegisterAuthTicketWithCM::get_ticket,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "client_instance_id",
                |m: &CMsgClientRegisterAuthTicketWithCM| { &m.client_instance_id },
                |m: &mut CMsgClientRegisterAuthTicketWithCM| { &mut m.client_instance_id },
                CMsgClientRegisterAuthTicketWithCM::get_client_instance_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRegisterAuthTicketWithCM>(
                "CMsgClientRegisterAuthTicketWithCM",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRegisterAuthTicketWithCM {
        static instance: ::protobuf::rt::Lazy<CMsgClientRegisterAuthTicketWithCM> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRegisterAuthTicketWithCM::new)
    }
}

impl ::protobuf::Clear for CMsgClientRegisterAuthTicketWithCM {
    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.ticket.clear();
        self.client_instance_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRegisterAuthTicketWithCM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterAuthTicketWithCM {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientTicketAuthComplete {
    // message fields
    steam_id: ::std::option::Option<u64>,
    game_id: ::std::option::Option<u64>,
    estate: ::std::option::Option<u32>,
    eauth_session_response: ::std::option::Option<u32>,
    DEPRECATED_ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ticket_crc: ::std::option::Option<u32>,
    ticket_sequence: ::std::option::Option<u32>,
    owner_steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientTicketAuthComplete {
    fn default() -> &'a CMsgClientTicketAuthComplete {
        <CMsgClientTicketAuthComplete as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientTicketAuthComplete {
    pub fn new() -> CMsgClientTicketAuthComplete {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_id = 2;

    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 estate = 3;

    pub fn get_estate(&self) -> u32 {
        self.estate.unwrap_or(0)
    }

    pub fn clear_estate(&mut self) {
        self.estate = ::std::option::Option::None;
    }

    pub fn has_estate(&self) -> bool {
        self.estate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estate(&mut self, v: u32) {
        self.estate = ::std::option::Option::Some(v);
    }

    // optional uint32 eauth_session_response = 4;

    pub fn get_eauth_session_response(&self) -> u32 {
        self.eauth_session_response.unwrap_or(0)
    }

    pub fn clear_eauth_session_response(&mut self) {
        self.eauth_session_response = ::std::option::Option::None;
    }

    pub fn has_eauth_session_response(&self) -> bool {
        self.eauth_session_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eauth_session_response(&mut self, v: u32) {
        self.eauth_session_response = ::std::option::Option::Some(v);
    }

    // optional bytes DEPRECATED_ticket = 5;

    pub fn get_DEPRECATED_ticket(&self) -> &[u8] {
        match self.DEPRECATED_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_DEPRECATED_ticket(&mut self) {
        self.DEPRECATED_ticket.clear();
    }

    pub fn has_DEPRECATED_ticket(&self) -> bool {
        self.DEPRECATED_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DEPRECATED_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.DEPRECATED_ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DEPRECATED_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.DEPRECATED_ticket.is_none() {
            self.DEPRECATED_ticket.set_default();
        }
        self.DEPRECATED_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_DEPRECATED_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.DEPRECATED_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ticket_crc = 6;

    pub fn get_ticket_crc(&self) -> u32 {
        self.ticket_crc.unwrap_or(0)
    }

    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc = ::std::option::Option::None;
    }

    pub fn has_ticket_crc(&self) -> bool {
        self.ticket_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: u32) {
        self.ticket_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 ticket_sequence = 7;

    pub fn get_ticket_sequence(&self) -> u32 {
        self.ticket_sequence.unwrap_or(0)
    }

    pub fn clear_ticket_sequence(&mut self) {
        self.ticket_sequence = ::std::option::Option::None;
    }

    pub fn has_ticket_sequence(&self) -> bool {
        self.ticket_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_sequence(&mut self, v: u32) {
        self.ticket_sequence = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steam_id = 8;

    pub fn get_owner_steam_id(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }

    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientTicketAuthComplete {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.estate = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eauth_session_response = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.DEPRECATED_ticket)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ticket_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ticket_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.owner_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.estate {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eauth_session_response {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.DEPRECATED_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.ticket_crc {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ticket_sequence {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.estate {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.eauth_session_response {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.DEPRECATED_ticket.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.ticket_crc {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ticket_sequence {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.owner_steam_id {
            os.write_fixed64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientTicketAuthComplete {
        CMsgClientTicketAuthComplete::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id",
                |m: &CMsgClientTicketAuthComplete| { &m.steam_id },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.steam_id },
                CMsgClientTicketAuthComplete::get_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "game_id",
                |m: &CMsgClientTicketAuthComplete| { &m.game_id },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.game_id },
                CMsgClientTicketAuthComplete::get_game_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "estate",
                |m: &CMsgClientTicketAuthComplete| { &m.estate },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.estate },
                CMsgClientTicketAuthComplete::get_estate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eauth_session_response",
                |m: &CMsgClientTicketAuthComplete| { &m.eauth_session_response },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.eauth_session_response },
                CMsgClientTicketAuthComplete::get_eauth_session_response,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "DEPRECATED_ticket",
                |m: &CMsgClientTicketAuthComplete| { &m.DEPRECATED_ticket },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.DEPRECATED_ticket },
                CMsgClientTicketAuthComplete::get_DEPRECATED_ticket,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "ticket_crc",
                |m: &CMsgClientTicketAuthComplete| { &m.ticket_crc },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.ticket_crc },
                CMsgClientTicketAuthComplete::get_ticket_crc,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "ticket_sequence",
                |m: &CMsgClientTicketAuthComplete| { &m.ticket_sequence },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.ticket_sequence },
                CMsgClientTicketAuthComplete::get_ticket_sequence,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "owner_steam_id",
                |m: &CMsgClientTicketAuthComplete| { &m.owner_steam_id },
                |m: &mut CMsgClientTicketAuthComplete| { &mut m.owner_steam_id },
                CMsgClientTicketAuthComplete::get_owner_steam_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientTicketAuthComplete>(
                "CMsgClientTicketAuthComplete",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientTicketAuthComplete {
        static instance: ::protobuf::rt::Lazy<CMsgClientTicketAuthComplete> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientTicketAuthComplete::new)
    }
}

impl ::protobuf::Clear for CMsgClientTicketAuthComplete {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.estate = ::std::option::Option::None;
        self.eauth_session_response = ::std::option::Option::None;
        self.DEPRECATED_ticket.clear();
        self.ticket_crc = ::std::option::Option::None;
        self.ticket_sequence = ::std::option::Option::None;
        self.owner_steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientTicketAuthComplete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientTicketAuthComplete {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCMList {
    // message fields
    pub cm_addresses: ::std::vec::Vec<u32>,
    pub cm_ports: ::std::vec::Vec<u32>,
    pub cm_websocket_addresses: ::protobuf::RepeatedField<::std::string::String>,
    percent_default_to_websocket: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCMList {
    fn default() -> &'a CMsgClientCMList {
        <CMsgClientCMList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCMList {
    pub fn new() -> CMsgClientCMList {
        ::std::default::Default::default()
    }

    // optional uint32 percent_default_to_websocket = 4;

    pub fn get_percent_default_to_websocket(&self) -> u32 {
        self.percent_default_to_websocket.unwrap_or(0)
    }

    pub fn clear_percent_default_to_websocket(&mut self) {
        self.percent_default_to_websocket = ::std::option::Option::None;
    }

    pub fn has_percent_default_to_websocket(&self) -> bool {
        self.percent_default_to_websocket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percent_default_to_websocket(&mut self, v: u32) {
        self.percent_default_to_websocket = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCMList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.cm_addresses)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.cm_ports)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cm_websocket_addresses)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.percent_default_to_websocket = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cm_addresses {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.cm_ports {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.cm_websocket_addresses {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.percent_default_to_websocket {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cm_addresses {
            os.write_uint32(1, *v)?;
        };
        for v in &self.cm_ports {
            os.write_uint32(2, *v)?;
        };
        for v in &self.cm_websocket_addresses {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.percent_default_to_websocket {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCMList {
        CMsgClientCMList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "cm_addresses",
                |m: &CMsgClientCMList| { &m.cm_addresses },
                |m: &mut CMsgClientCMList| { &mut m.cm_addresses },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "cm_ports",
                |m: &CMsgClientCMList| { &m.cm_ports },
                |m: &mut CMsgClientCMList| { &mut m.cm_ports },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "cm_websocket_addresses",
                |m: &CMsgClientCMList| { &m.cm_websocket_addresses },
                |m: &mut CMsgClientCMList| { &mut m.cm_websocket_addresses },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "percent_default_to_websocket",
                |m: &CMsgClientCMList| { &m.percent_default_to_websocket },
                |m: &mut CMsgClientCMList| { &mut m.percent_default_to_websocket },
                CMsgClientCMList::get_percent_default_to_websocket,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientCMList>(
                "CMsgClientCMList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCMList {
        static instance: ::protobuf::rt::Lazy<CMsgClientCMList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientCMList::new)
    }
}

impl ::protobuf::Clear for CMsgClientCMList {
    fn clear(&mut self) {
        self.cm_addresses.clear();
        self.cm_ports.clear();
        self.cm_websocket_addresses.clear();
        self.percent_default_to_websocket = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCMList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCMList {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientP2PConnectionInfo {
    // message fields
    steam_id_dest: ::std::option::Option<u64>,
    steam_id_src: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    candidate: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    connection_id_src: ::std::option::Option<u64>,
    rendezvous: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientP2PConnectionInfo {
    fn default() -> &'a CMsgClientP2PConnectionInfo {
        <CMsgClientP2PConnectionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientP2PConnectionInfo {
    pub fn new() -> CMsgClientP2PConnectionInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn get_steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn get_steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes candidate = 4;

    pub fn get_candidate(&self) -> &[u8] {
        match self.candidate.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::vec::Vec<u8>) {
        self.candidate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.candidate.is_none() {
            self.candidate.set_default();
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::vec::Vec<u8> {
        self.candidate.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 connection_id_src = 5;

    pub fn get_connection_id_src(&self) -> u64 {
        self.connection_id_src.unwrap_or(0)
    }

    pub fn clear_connection_id_src(&mut self) {
        self.connection_id_src = ::std::option::Option::None;
    }

    pub fn has_connection_id_src(&self) -> bool {
        self.connection_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id_src(&mut self, v: u64) {
        self.connection_id_src = ::std::option::Option::Some(v);
    }

    // optional bytes rendezvous = 6;

    pub fn get_rendezvous(&self) -> &[u8] {
        match self.rendezvous.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rendezvous(&mut self) {
        self.rendezvous.clear();
    }

    pub fn has_rendezvous(&self) -> bool {
        self.rendezvous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rendezvous(&mut self, v: ::std::vec::Vec<u8>) {
        self.rendezvous = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rendezvous(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rendezvous.is_none() {
            self.rendezvous.set_default();
        }
        self.rendezvous.as_mut().unwrap()
    }

    // Take field
    pub fn take_rendezvous(&mut self) -> ::std::vec::Vec<u8> {
        self.rendezvous.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientP2PConnectionInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.candidate)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rendezvous)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.candidate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.connection_id_src {
            my_size += 9;
        }
        if let Some(v) = self.rendezvous.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.candidate.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.connection_id_src {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.rendezvous.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientP2PConnectionInfo {
        CMsgClientP2PConnectionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_dest",
                |m: &CMsgClientP2PConnectionInfo| { &m.steam_id_dest },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.steam_id_dest },
                CMsgClientP2PConnectionInfo::get_steam_id_dest,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_src",
                |m: &CMsgClientP2PConnectionInfo| { &m.steam_id_src },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.steam_id_src },
                CMsgClientP2PConnectionInfo::get_steam_id_src,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientP2PConnectionInfo| { &m.app_id },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.app_id },
                CMsgClientP2PConnectionInfo::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "candidate",
                |m: &CMsgClientP2PConnectionInfo| { &m.candidate },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.candidate },
                CMsgClientP2PConnectionInfo::get_candidate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "connection_id_src",
                |m: &CMsgClientP2PConnectionInfo| { &m.connection_id_src },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.connection_id_src },
                CMsgClientP2PConnectionInfo::get_connection_id_src,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "rendezvous",
                |m: &CMsgClientP2PConnectionInfo| { &m.rendezvous },
                |m: &mut CMsgClientP2PConnectionInfo| { &mut m.rendezvous },
                CMsgClientP2PConnectionInfo::get_rendezvous,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientP2PConnectionInfo>(
                "CMsgClientP2PConnectionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientP2PConnectionInfo {
        static instance: ::protobuf::rt::Lazy<CMsgClientP2PConnectionInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientP2PConnectionInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientP2PConnectionInfo {
    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.candidate.clear();
        self.connection_id_src = ::std::option::Option::None;
        self.rendezvous.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientP2PConnectionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientP2PConnectionInfo {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientP2PConnectionFailInfo {
    // message fields
    steam_id_dest: ::std::option::Option<u64>,
    steam_id_src: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    ep2p_session_error: ::std::option::Option<u32>,
    connection_id_dest: ::std::option::Option<u64>,
    close_reason: ::std::option::Option<u32>,
    close_message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientP2PConnectionFailInfo {
    fn default() -> &'a CMsgClientP2PConnectionFailInfo {
        <CMsgClientP2PConnectionFailInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientP2PConnectionFailInfo {
    pub fn new() -> CMsgClientP2PConnectionFailInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn get_steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn get_steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ep2p_session_error = 4;

    pub fn get_ep2p_session_error(&self) -> u32 {
        self.ep2p_session_error.unwrap_or(0)
    }

    pub fn clear_ep2p_session_error(&mut self) {
        self.ep2p_session_error = ::std::option::Option::None;
    }

    pub fn has_ep2p_session_error(&self) -> bool {
        self.ep2p_session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ep2p_session_error(&mut self, v: u32) {
        self.ep2p_session_error = ::std::option::Option::Some(v);
    }

    // optional fixed64 connection_id_dest = 5;

    pub fn get_connection_id_dest(&self) -> u64 {
        self.connection_id_dest.unwrap_or(0)
    }

    pub fn clear_connection_id_dest(&mut self) {
        self.connection_id_dest = ::std::option::Option::None;
    }

    pub fn has_connection_id_dest(&self) -> bool {
        self.connection_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id_dest(&mut self, v: u64) {
        self.connection_id_dest = ::std::option::Option::Some(v);
    }

    // optional uint32 close_reason = 7;

    pub fn get_close_reason(&self) -> u32 {
        self.close_reason.unwrap_or(0)
    }

    pub fn clear_close_reason(&mut self) {
        self.close_reason = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        self.close_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: u32) {
        self.close_reason = ::std::option::Option::Some(v);
    }

    // optional string close_message = 8;

    pub fn get_close_message(&self) -> &str {
        match self.close_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_close_message(&mut self) {
        self.close_message.clear();
    }

    pub fn has_close_message(&self) -> bool {
        self.close_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_message(&mut self, v: ::std::string::String) {
        self.close_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_message(&mut self) -> &mut ::std::string::String {
        if self.close_message.is_none() {
            self.close_message.set_default();
        }
        self.close_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_message(&mut self) -> ::std::string::String {
        self.close_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientP2PConnectionFailInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ep2p_session_error = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connection_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.close_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.close_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ep2p_session_error {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connection_id_dest {
            my_size += 9;
        }
        if let Some(v) = self.close_reason {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.close_message.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ep2p_session_error {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.connection_id_dest {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.close_reason {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.close_message.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientP2PConnectionFailInfo {
        CMsgClientP2PConnectionFailInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_dest",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.steam_id_dest },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.steam_id_dest },
                CMsgClientP2PConnectionFailInfo::get_steam_id_dest,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_src",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.steam_id_src },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.steam_id_src },
                CMsgClientP2PConnectionFailInfo::get_steam_id_src,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.app_id },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.app_id },
                CMsgClientP2PConnectionFailInfo::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "ep2p_session_error",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.ep2p_session_error },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.ep2p_session_error },
                CMsgClientP2PConnectionFailInfo::get_ep2p_session_error,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "connection_id_dest",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.connection_id_dest },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.connection_id_dest },
                CMsgClientP2PConnectionFailInfo::get_connection_id_dest,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "close_reason",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.close_reason },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.close_reason },
                CMsgClientP2PConnectionFailInfo::get_close_reason,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "close_message",
                |m: &CMsgClientP2PConnectionFailInfo| { &m.close_message },
                |m: &mut CMsgClientP2PConnectionFailInfo| { &mut m.close_message },
                CMsgClientP2PConnectionFailInfo::get_close_message,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientP2PConnectionFailInfo>(
                "CMsgClientP2PConnectionFailInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientP2PConnectionFailInfo {
        static instance: ::protobuf::rt::Lazy<CMsgClientP2PConnectionFailInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientP2PConnectionFailInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientP2PConnectionFailInfo {
    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.ep2p_session_error = ::std::option::Option::None;
        self.connection_id_dest = ::std::option::Option::None;
        self.close_reason = ::std::option::Option::None;
        self.close_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientP2PConnectionFailInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientP2PConnectionFailInfo {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientNetworkingCertRequest {
    // message fields
    key_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingCertRequest {
    fn default() -> &'a CMsgClientNetworkingCertRequest {
        <CMsgClientNetworkingCertRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingCertRequest {
    pub fn new() -> CMsgClientNetworkingCertRequest {
        ::std::default::Default::default()
    }

    // optional bytes key_data = 2;

    pub fn get_key_data(&self) -> &[u8] {
        match self.key_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key_data(&mut self) {
        self.key_data.clear();
    }

    pub fn has_key_data(&self) -> bool {
        self.key_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_data.is_none() {
            self.key_data.set_default();
        }
        self.key_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::std::vec::Vec<u8> {
        self.key_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 app_id = 3;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientNetworkingCertRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key_data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientNetworkingCertRequest {
        CMsgClientNetworkingCertRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "key_data",
                |m: &CMsgClientNetworkingCertRequest| { &m.key_data },
                |m: &mut CMsgClientNetworkingCertRequest| { &mut m.key_data },
                CMsgClientNetworkingCertRequest::get_key_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientNetworkingCertRequest| { &m.app_id },
                |m: &mut CMsgClientNetworkingCertRequest| { &mut m.app_id },
                CMsgClientNetworkingCertRequest::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientNetworkingCertRequest>(
                "CMsgClientNetworkingCertRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientNetworkingCertRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientNetworkingCertRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientNetworkingCertRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientNetworkingCertRequest {
    fn clear(&mut self) {
        self.key_data.clear();
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientNetworkingCertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingCertRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientNetworkingCertReply {
    // message fields
    cert: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ca_key_id: ::std::option::Option<u64>,
    ca_signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingCertReply {
    fn default() -> &'a CMsgClientNetworkingCertReply {
        <CMsgClientNetworkingCertReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingCertReply {
    pub fn new() -> CMsgClientNetworkingCertReply {
        ::std::default::Default::default()
    }

    // optional bytes cert = 4;

    pub fn get_cert(&self) -> &[u8] {
        match self.cert.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::std::vec::Vec<u8>) {
        self.cert = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> ::std::vec::Vec<u8> {
        self.cert.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 ca_key_id = 5;

    pub fn get_ca_key_id(&self) -> u64 {
        self.ca_key_id.unwrap_or(0)
    }

    pub fn clear_ca_key_id(&mut self) {
        self.ca_key_id = ::std::option::Option::None;
    }

    pub fn has_ca_key_id(&self) -> bool {
        self.ca_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ca_key_id(&mut self, v: u64) {
        self.ca_key_id = ::std::option::Option::Some(v);
    }

    // optional bytes ca_signature = 6;

    pub fn get_ca_signature(&self) -> &[u8] {
        match self.ca_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ca_signature(&mut self) {
        self.ca_signature.clear();
    }

    pub fn has_ca_signature(&self) -> bool {
        self.ca_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ca_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.ca_signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ca_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ca_signature.is_none() {
            self.ca_signature.set_default();
        }
        self.ca_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_ca_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.ca_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientNetworkingCertReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.cert)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ca_key_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ca_signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cert.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ca_key_id {
            my_size += 9;
        }
        if let Some(v) = self.ca_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cert.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.ca_key_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.ca_signature.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientNetworkingCertReply {
        CMsgClientNetworkingCertReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "cert",
                |m: &CMsgClientNetworkingCertReply| { &m.cert },
                |m: &mut CMsgClientNetworkingCertReply| { &mut m.cert },
                CMsgClientNetworkingCertReply::get_cert,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "ca_key_id",
                |m: &CMsgClientNetworkingCertReply| { &m.ca_key_id },
                |m: &mut CMsgClientNetworkingCertReply| { &mut m.ca_key_id },
                CMsgClientNetworkingCertReply::get_ca_key_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "ca_signature",
                |m: &CMsgClientNetworkingCertReply| { &m.ca_signature },
                |m: &mut CMsgClientNetworkingCertReply| { &mut m.ca_signature },
                CMsgClientNetworkingCertReply::get_ca_signature,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientNetworkingCertReply>(
                "CMsgClientNetworkingCertReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientNetworkingCertReply {
        static instance: ::protobuf::rt::Lazy<CMsgClientNetworkingCertReply> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientNetworkingCertReply::new)
    }
}

impl ::protobuf::Clear for CMsgClientNetworkingCertReply {
    fn clear(&mut self) {
        self.cert.clear();
        self.ca_key_id = ::std::option::Option::None;
        self.ca_signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientNetworkingCertReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingCertReply {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientNetworkingMobileCertRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingMobileCertRequest {
    fn default() -> &'a CMsgClientNetworkingMobileCertRequest {
        <CMsgClientNetworkingMobileCertRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingMobileCertRequest {
    pub fn new() -> CMsgClientNetworkingMobileCertRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientNetworkingMobileCertRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientNetworkingMobileCertRequest {
        CMsgClientNetworkingMobileCertRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientNetworkingMobileCertRequest| { &m.app_id },
                |m: &mut CMsgClientNetworkingMobileCertRequest| { &mut m.app_id },
                CMsgClientNetworkingMobileCertRequest::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientNetworkingMobileCertRequest>(
                "CMsgClientNetworkingMobileCertRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientNetworkingMobileCertRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientNetworkingMobileCertRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientNetworkingMobileCertRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientNetworkingMobileCertRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientNetworkingMobileCertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingMobileCertRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientNetworkingMobileCertReply {
    // message fields
    encoded_cert: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingMobileCertReply {
    fn default() -> &'a CMsgClientNetworkingMobileCertReply {
        <CMsgClientNetworkingMobileCertReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingMobileCertReply {
    pub fn new() -> CMsgClientNetworkingMobileCertReply {
        ::std::default::Default::default()
    }

    // optional string encoded_cert = 1;

    pub fn get_encoded_cert(&self) -> &str {
        match self.encoded_cert.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_encoded_cert(&mut self) {
        self.encoded_cert.clear();
    }

    pub fn has_encoded_cert(&self) -> bool {
        self.encoded_cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoded_cert(&mut self, v: ::std::string::String) {
        self.encoded_cert = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoded_cert(&mut self) -> &mut ::std::string::String {
        if self.encoded_cert.is_none() {
            self.encoded_cert.set_default();
        }
        self.encoded_cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_encoded_cert(&mut self) -> ::std::string::String {
        self.encoded_cert.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientNetworkingMobileCertReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encoded_cert)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.encoded_cert.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.encoded_cert.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientNetworkingMobileCertReply {
        CMsgClientNetworkingMobileCertReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "encoded_cert",
                |m: &CMsgClientNetworkingMobileCertReply| { &m.encoded_cert },
                |m: &mut CMsgClientNetworkingMobileCertReply| { &mut m.encoded_cert },
                CMsgClientNetworkingMobileCertReply::get_encoded_cert,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientNetworkingMobileCertReply>(
                "CMsgClientNetworkingMobileCertReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientNetworkingMobileCertReply {
        static instance: ::protobuf::rt::Lazy<CMsgClientNetworkingMobileCertReply> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientNetworkingMobileCertReply::new)
    }
}

impl ::protobuf::Clear for CMsgClientNetworkingMobileCertReply {
    fn clear(&mut self) {
        self.encoded_cert.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientNetworkingMobileCertReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientNetworkingMobileCertReply {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetAppOwnershipTicket {
    // message fields
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAppOwnershipTicket {
    fn default() -> &'a CMsgClientGetAppOwnershipTicket {
        <CMsgClientGetAppOwnershipTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAppOwnershipTicket {
    pub fn new() -> CMsgClientGetAppOwnershipTicket {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetAppOwnershipTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetAppOwnershipTicket {
        CMsgClientGetAppOwnershipTicket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientGetAppOwnershipTicket| { &m.app_id },
                |m: &mut CMsgClientGetAppOwnershipTicket| { &mut m.app_id },
                CMsgClientGetAppOwnershipTicket::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetAppOwnershipTicket>(
                "CMsgClientGetAppOwnershipTicket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetAppOwnershipTicket {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetAppOwnershipTicket> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetAppOwnershipTicket::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetAppOwnershipTicket {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetAppOwnershipTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAppOwnershipTicket {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetAppOwnershipTicketResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAppOwnershipTicketResponse {
    fn default() -> &'a CMsgClientGetAppOwnershipTicketResponse {
        <CMsgClientGetAppOwnershipTicketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAppOwnershipTicketResponse {
    pub fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 3;

    pub fn get_ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket.set_default();
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientGetAppOwnershipTicketResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ticket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        CMsgClientGetAppOwnershipTicketResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.eresult },
                |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.eresult },
                CMsgClientGetAppOwnershipTicketResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.app_id },
                |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.app_id },
                CMsgClientGetAppOwnershipTicketResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "ticket",
                |m: &CMsgClientGetAppOwnershipTicketResponse| { &m.ticket },
                |m: &mut CMsgClientGetAppOwnershipTicketResponse| { &mut m.ticket },
                CMsgClientGetAppOwnershipTicketResponse::get_ticket,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetAppOwnershipTicketResponse>(
                "CMsgClientGetAppOwnershipTicketResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetAppOwnershipTicketResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetAppOwnershipTicketResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetAppOwnershipTicketResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetAppOwnershipTicketResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.ticket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetAppOwnershipTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAppOwnershipTicketResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSessionToken {
    // message fields
    token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSessionToken {
    fn default() -> &'a CMsgClientSessionToken {
        <CMsgClientSessionToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSessionToken {
    pub fn new() -> CMsgClientSessionToken {
        ::std::default::Default::default()
    }

    // optional uint64 token = 1;

    pub fn get_token(&self) -> u64 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u64) {
        self.token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSessionToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.token = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.token {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSessionToken {
        CMsgClientSessionToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "token",
                |m: &CMsgClientSessionToken| { &m.token },
                |m: &mut CMsgClientSessionToken| { &mut m.token },
                CMsgClientSessionToken::get_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSessionToken>(
                "CMsgClientSessionToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSessionToken {
        static instance: ::protobuf::rt::Lazy<CMsgClientSessionToken> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientSessionToken::new)
    }
}

impl ::protobuf::Clear for CMsgClientSessionToken {
    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSessionToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSessionToken {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGameConnectTokens {
    // message fields
    max_tokens_to_keep: ::std::option::Option<u32>,
    pub tokens: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGameConnectTokens {
    fn default() -> &'a CMsgClientGameConnectTokens {
        <CMsgClientGameConnectTokens as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGameConnectTokens {
    pub fn new() -> CMsgClientGameConnectTokens {
        ::std::default::Default::default()
    }

    // optional uint32 max_tokens_to_keep = 1;

    pub fn get_max_tokens_to_keep(&self) -> u32 {
        self.max_tokens_to_keep.unwrap_or(10u32)
    }

    pub fn clear_max_tokens_to_keep(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
    }

    pub fn has_max_tokens_to_keep(&self) -> bool {
        self.max_tokens_to_keep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_tokens_to_keep(&mut self, v: u32) {
        self.max_tokens_to_keep = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGameConnectTokens {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.max_tokens_to_keep = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.max_tokens_to_keep {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tokens {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.max_tokens_to_keep {
            os.write_uint32(1, v)?;
        }
        for v in &self.tokens {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGameConnectTokens {
        CMsgClientGameConnectTokens::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "max_tokens_to_keep",
                |m: &CMsgClientGameConnectTokens| { &m.max_tokens_to_keep },
                |m: &mut CMsgClientGameConnectTokens| { &mut m.max_tokens_to_keep },
                CMsgClientGameConnectTokens::get_max_tokens_to_keep,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes>(
                "tokens",
                |m: &CMsgClientGameConnectTokens| { &m.tokens },
                |m: &mut CMsgClientGameConnectTokens| { &mut m.tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGameConnectTokens>(
                "CMsgClientGameConnectTokens",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGameConnectTokens {
        static instance: ::protobuf::rt::Lazy<CMsgClientGameConnectTokens> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGameConnectTokens::new)
    }
}

impl ::protobuf::Clear for CMsgClientGameConnectTokens {
    fn clear(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
        self.tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGameConnectTokens {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGameConnectTokens {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSServerType {
    // message fields
    app_id_served: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    deprecated_game_ip_address: ::std::option::Option<u32>,
    game_port: ::std::option::Option<u32>,
    game_dir: ::protobuf::SingularField<::std::string::String>,
    game_version: ::protobuf::SingularField<::std::string::String>,
    game_query_port: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSServerType {
    fn default() -> &'a CMsgGSServerType {
        <CMsgGSServerType as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSServerType {
    pub fn new() -> CMsgGSServerType {
        ::std::default::Default::default()
    }

    // optional uint32 app_id_served = 1;

    pub fn get_app_id_served(&self) -> u32 {
        self.app_id_served.unwrap_or(0)
    }

    pub fn clear_app_id_served(&mut self) {
        self.app_id_served = ::std::option::Option::None;
    }

    pub fn has_app_id_served(&self) -> bool {
        self.app_id_served.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id_served(&mut self, v: u32) {
        self.app_id_served = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 2;

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_ip_address = 3;

    pub fn get_deprecated_game_ip_address(&self) -> u32 {
        self.deprecated_game_ip_address.unwrap_or(0)
    }

    pub fn clear_deprecated_game_ip_address(&mut self) {
        self.deprecated_game_ip_address = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_ip_address(&self) -> bool {
        self.deprecated_game_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_ip_address(&mut self, v: u32) {
        self.deprecated_game_ip_address = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn get_game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional string game_dir = 5;

    pub fn get_game_dir(&self) -> &str {
        match self.game_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_dir(&mut self) {
        self.game_dir.clear();
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: ::std::string::String) {
        self.game_dir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir(&mut self) -> &mut ::std::string::String {
        if self.game_dir.is_none() {
            self.game_dir.set_default();
        }
        self.game_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_dir(&mut self) -> ::std::string::String {
        self.game_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_version = 6;

    pub fn get_game_version(&self) -> &str {
        match self.game_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_version(&mut self) {
        self.game_version.clear();
    }

    pub fn has_game_version(&self) -> bool {
        self.game_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_version(&mut self, v: ::std::string::String) {
        self.game_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_version(&mut self) -> &mut ::std::string::String {
        if self.game_version.is_none() {
            self.game_version.set_default();
        }
        self.game_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_version(&mut self) -> ::std::string::String {
        self.game_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 game_query_port = 7;

    pub fn get_game_query_port(&self) -> u32 {
        self.game_query_port.unwrap_or(0)
    }

    pub fn clear_game_query_port(&mut self) {
        self.game_query_port = ::std::option::Option::None;
    }

    pub fn has_game_query_port(&self) -> bool {
        self.game_query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_query_port(&mut self, v: u32) {
        self.game_query_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSServerType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id_served = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deprecated_game_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_dir)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_version)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id_served {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deprecated_game_ip_address {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_dir.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.game_version.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.game_query_port {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id_served {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deprecated_game_ip_address {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_dir.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.game_version.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.game_query_port {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSServerType {
        CMsgGSServerType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id_served",
                |m: &CMsgGSServerType| { &m.app_id_served },
                |m: &mut CMsgGSServerType| { &mut m.app_id_served },
                CMsgGSServerType::get_app_id_served,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "flags",
                |m: &CMsgGSServerType| { &m.flags },
                |m: &mut CMsgGSServerType| { &mut m.flags },
                CMsgGSServerType::get_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "deprecated_game_ip_address",
                |m: &CMsgGSServerType| { &m.deprecated_game_ip_address },
                |m: &mut CMsgGSServerType| { &mut m.deprecated_game_ip_address },
                CMsgGSServerType::get_deprecated_game_ip_address,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "game_port",
                |m: &CMsgGSServerType| { &m.game_port },
                |m: &mut CMsgGSServerType| { &mut m.game_port },
                CMsgGSServerType::get_game_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "game_dir",
                |m: &CMsgGSServerType| { &m.game_dir },
                |m: &mut CMsgGSServerType| { &mut m.game_dir },
                CMsgGSServerType::get_game_dir,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "game_version",
                |m: &CMsgGSServerType| { &m.game_version },
                |m: &mut CMsgGSServerType| { &mut m.game_version },
                CMsgGSServerType::get_game_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "game_query_port",
                |m: &CMsgGSServerType| { &m.game_query_port },
                |m: &mut CMsgGSServerType| { &mut m.game_query_port },
                CMsgGSServerType::get_game_query_port,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSServerType>(
                "CMsgGSServerType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSServerType {
        static instance: ::protobuf::rt::Lazy<CMsgGSServerType> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSServerType::new)
    }
}

impl ::protobuf::Clear for CMsgGSServerType {
    fn clear(&mut self) {
        self.app_id_served = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.deprecated_game_ip_address = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.game_dir.clear();
        self.game_version.clear();
        self.game_query_port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSServerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSServerType {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSStatusReply {
    // message fields
    is_secure: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSStatusReply {
    fn default() -> &'a CMsgGSStatusReply {
        <CMsgGSStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSStatusReply {
    pub fn new() -> CMsgGSStatusReply {
        ::std::default::Default::default()
    }

    // optional bool is_secure = 1;

    pub fn get_is_secure(&self) -> bool {
        self.is_secure.unwrap_or(false)
    }

    pub fn clear_is_secure(&mut self) {
        self.is_secure = ::std::option::Option::None;
    }

    pub fn has_is_secure(&self) -> bool {
        self.is_secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_secure(&mut self, v: bool) {
        self.is_secure = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSStatusReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_secure = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_secure {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_secure {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSStatusReply {
        CMsgGSStatusReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_secure",
                |m: &CMsgGSStatusReply| { &m.is_secure },
                |m: &mut CMsgGSStatusReply| { &mut m.is_secure },
                CMsgGSStatusReply::get_is_secure,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSStatusReply>(
                "CMsgGSStatusReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSStatusReply {
        static instance: ::protobuf::rt::Lazy<CMsgGSStatusReply> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSStatusReply::new)
    }
}

impl ::protobuf::Clear for CMsgGSStatusReply {
    fn clear(&mut self) {
        self.is_secure = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSStatusReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSStatusReply {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSPlayerList {
    // message fields
    pub players: ::protobuf::RepeatedField<cmsg_gsplayer_list::Player>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSPlayerList {
    fn default() -> &'a CMsgGSPlayerList {
        <CMsgGSPlayerList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSPlayerList {
    pub fn new() -> CMsgGSPlayerList {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGSPlayerList {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSPlayerList {
        CMsgGSPlayerList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_gsplayer_list::Player>>(
                "players",
                |m: &CMsgGSPlayerList| { &m.players },
                |m: &mut CMsgGSPlayerList| { &mut m.players },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSPlayerList>(
                "CMsgGSPlayerList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSPlayerList {
        static instance: ::protobuf::rt::Lazy<CMsgGSPlayerList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSPlayerList::new)
    }
}

impl ::protobuf::Clear for CMsgGSPlayerList {
    fn clear(&mut self) {
        self.players.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSPlayerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSPlayerList {
}

/// Nested message and enums of message `CMsgGSPlayerList`
pub mod cmsg_gsplayer_list {
    #[derive(PartialEq,Clone,Default)]
    pub struct Player {
        // message fields
        steam_id: ::std::option::Option<u64>,
        deprecated_public_ip: ::std::option::Option<u32>,
        token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        pub public_ip: ::protobuf::SingularPtrField<super::super::steammessages_base::CMsgIPAddress>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint64 steam_id = 1;

        pub fn get_steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 deprecated_public_ip = 2;

        pub fn get_deprecated_public_ip(&self) -> u32 {
            self.deprecated_public_ip.unwrap_or(0)
        }

        pub fn clear_deprecated_public_ip(&mut self) {
            self.deprecated_public_ip = ::std::option::Option::None;
        }

        pub fn has_deprecated_public_ip(&self) -> bool {
            self.deprecated_public_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_public_ip(&mut self, v: u32) {
            self.deprecated_public_ip = ::std::option::Option::Some(v);
        }

        // optional bytes token = 3;

        pub fn get_token(&self) -> &[u8] {
            match self.token.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_token(&mut self) {
            self.token.clear();
        }

        pub fn has_token(&self) -> bool {
            self.token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
            self.token = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.token.is_none() {
                self.token.set_default();
            }
            self.token.as_mut().unwrap()
        }

        // Take field
        pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
            self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for Player {
        fn is_initialized(&self) -> bool {
            for v in &self.public_ip {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                    },
                    4 => {
                        ::protobuf::rt::read_singular_message_into::<super::super::steammessages_base::CMsgIPAddress, _>(wire_type, is, &mut self.public_ip)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.deprecated_public_ip {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.token.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.public_ip.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steam_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.deprecated_public_ip {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.token.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.public_ip.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Player {
            Player::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "steam_id",
                    |m: &Player| { &m.steam_id },
                    |m: &mut Player| { &mut m.steam_id },
                    Player::get_steam_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "deprecated_public_ip",
                    |m: &Player| { &m.deprecated_public_ip },
                    |m: &mut Player| { &mut m.deprecated_public_ip },
                    Player::get_deprecated_public_ip,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "token",
                    |m: &Player| { &m.token },
                    |m: &mut Player| { &mut m.token },
                    Player::get_token,
                ));
                fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::super::steammessages_base::CMsgIPAddress>, _>(
                    "public_ip",
                    |m: &Player| { &m.public_ip },
                    |m: &mut Player| { &mut m.public_ip },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Player>(
                    "CMsgGSPlayerList.Player",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Player {
            static instance: ::protobuf::rt::Lazy<Player> = ::protobuf::rt::Lazy::INIT;
            instance.get(Player::new)
        }
    }

    impl ::protobuf::Clear for Player {
        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.deprecated_public_ip = ::std::option::Option::None;
            self.token.clear();
            self.public_ip.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSUserPlaying {
    // message fields
    steam_id: ::std::option::Option<u64>,
    deprecated_public_ip: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub public_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSUserPlaying {
    fn default() -> &'a CMsgGSUserPlaying {
        <CMsgGSUserPlaying as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSUserPlaying {
    pub fn new() -> CMsgGSUserPlaying {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 2;

    pub fn get_deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes token = 3;

    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGSUserPlaying {
    fn is_initialized(&self) -> bool {
        for v in &self.public_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<super::steammessages_base::CMsgIPAddress, _>(wire_type, is, &mut self.public_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.public_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSUserPlaying {
        CMsgGSUserPlaying::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id",
                |m: &CMsgGSUserPlaying| { &m.steam_id },
                |m: &mut CMsgGSUserPlaying| { &mut m.steam_id },
                CMsgGSUserPlaying::get_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "deprecated_public_ip",
                |m: &CMsgGSUserPlaying| { &m.deprecated_public_ip },
                |m: &mut CMsgGSUserPlaying| { &mut m.deprecated_public_ip },
                CMsgGSUserPlaying::get_deprecated_public_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "token",
                |m: &CMsgGSUserPlaying| { &m.token },
                |m: &mut CMsgGSUserPlaying| { &mut m.token },
                CMsgGSUserPlaying::get_token,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>, _>(
                "public_ip",
                |m: &CMsgGSUserPlaying| { &m.public_ip },
                |m: &mut CMsgGSUserPlaying| { &mut m.public_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSUserPlaying>(
                "CMsgGSUserPlaying",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSUserPlaying {
        static instance: ::protobuf::rt::Lazy<CMsgGSUserPlaying> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSUserPlaying::new)
    }
}

impl ::protobuf::Clear for CMsgGSUserPlaying {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.token.clear();
        self.public_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSUserPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSUserPlaying {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSDisconnectNotice {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSDisconnectNotice {
    fn default() -> &'a CMsgGSDisconnectNotice {
        <CMsgGSDisconnectNotice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSDisconnectNotice {
    pub fn new() -> CMsgGSDisconnectNotice {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSDisconnectNotice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSDisconnectNotice {
        CMsgGSDisconnectNotice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id",
                |m: &CMsgGSDisconnectNotice| { &m.steam_id },
                |m: &mut CMsgGSDisconnectNotice| { &mut m.steam_id },
                CMsgGSDisconnectNotice::get_steam_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSDisconnectNotice>(
                "CMsgGSDisconnectNotice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSDisconnectNotice {
        static instance: ::protobuf::rt::Lazy<CMsgGSDisconnectNotice> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSDisconnectNotice::new)
    }
}

impl ::protobuf::Clear for CMsgGSDisconnectNotice {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSDisconnectNotice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSDisconnectNotice {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGamesPlayed {
    // message fields
    pub games_played: ::protobuf::RepeatedField<cmsg_client_games_played::GamePlayed>,
    client_os_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGamesPlayed {
    fn default() -> &'a CMsgClientGamesPlayed {
        <CMsgClientGamesPlayed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGamesPlayed {
    pub fn new() -> CMsgClientGamesPlayed {
        ::std::default::Default::default()
    }

    // optional uint32 client_os_type = 2;

    pub fn get_client_os_type(&self) -> u32 {
        self.client_os_type.unwrap_or(0)
    }

    pub fn clear_client_os_type(&mut self) {
        self.client_os_type = ::std::option::Option::None;
    }

    pub fn has_client_os_type(&self) -> bool {
        self.client_os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_os_type(&mut self, v: u32) {
        self.client_os_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGamesPlayed {
    fn is_initialized(&self) -> bool {
        for v in &self.games_played {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.games_played)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.client_os_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.games_played {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.client_os_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.games_played {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.client_os_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGamesPlayed {
        CMsgClientGamesPlayed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_games_played::GamePlayed>>(
                "games_played",
                |m: &CMsgClientGamesPlayed| { &m.games_played },
                |m: &mut CMsgClientGamesPlayed| { &mut m.games_played },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "client_os_type",
                |m: &CMsgClientGamesPlayed| { &m.client_os_type },
                |m: &mut CMsgClientGamesPlayed| { &mut m.client_os_type },
                CMsgClientGamesPlayed::get_client_os_type,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGamesPlayed>(
                "CMsgClientGamesPlayed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGamesPlayed {
        static instance: ::protobuf::rt::Lazy<CMsgClientGamesPlayed> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGamesPlayed::new)
    }
}

impl ::protobuf::Clear for CMsgClientGamesPlayed {
    fn clear(&mut self) {
        self.games_played.clear();
        self.client_os_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGamesPlayed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGamesPlayed {
}

/// Nested message and enums of message `CMsgClientGamesPlayed`
pub mod cmsg_client_games_played {
    #[derive(PartialEq,Clone,Default)]
    pub struct GamePlayed {
        // message fields
        steam_id_gs: ::std::option::Option<u64>,
        game_id: ::std::option::Option<u64>,
        deprecated_game_ip_address: ::std::option::Option<u32>,
        game_port: ::std::option::Option<u32>,
        is_secure: ::std::option::Option<bool>,
        token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        game_extra_info: ::protobuf::SingularField<::std::string::String>,
        game_data_blob: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        process_id: ::std::option::Option<u32>,
        streaming_provider_id: ::std::option::Option<u32>,
        game_flags: ::std::option::Option<u32>,
        owner_id: ::std::option::Option<u32>,
        vr_hmd_vendor: ::protobuf::SingularField<::std::string::String>,
        vr_hmd_model: ::protobuf::SingularField<::std::string::String>,
        launch_option_type: ::std::option::Option<u32>,
        primary_controller_type: ::std::option::Option<i32>,
        primary_steam_controller_serial: ::protobuf::SingularField<::std::string::String>,
        total_steam_controller_count: ::std::option::Option<u32>,
        total_non_steam_controller_count: ::std::option::Option<u32>,
        controller_workshop_file_id: ::std::option::Option<u64>,
        launch_source: ::std::option::Option<u32>,
        vr_hmd_runtime: ::std::option::Option<u32>,
        pub game_ip_address: ::protobuf::SingularPtrField<super::super::steammessages_base::CMsgIPAddress>,
        controller_connection_type: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a GamePlayed {
        fn default() -> &'a GamePlayed {
            <GamePlayed as ::protobuf::Message>::default_instance()
        }
    }

    impl GamePlayed {
        pub fn new() -> GamePlayed {
            ::std::default::Default::default()
        }

        // optional uint64 steam_id_gs = 1;

        pub fn get_steam_id_gs(&self) -> u64 {
            self.steam_id_gs.unwrap_or(0)
        }

        pub fn clear_steam_id_gs(&mut self) {
            self.steam_id_gs = ::std::option::Option::None;
        }

        pub fn has_steam_id_gs(&self) -> bool {
            self.steam_id_gs.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id_gs(&mut self, v: u64) {
            self.steam_id_gs = ::std::option::Option::Some(v);
        }

        // optional fixed64 game_id = 2;

        pub fn get_game_id(&self) -> u64 {
            self.game_id.unwrap_or(0)
        }

        pub fn clear_game_id(&mut self) {
            self.game_id = ::std::option::Option::None;
        }

        pub fn has_game_id(&self) -> bool {
            self.game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_id(&mut self, v: u64) {
            self.game_id = ::std::option::Option::Some(v);
        }

        // optional uint32 deprecated_game_ip_address = 3;

        pub fn get_deprecated_game_ip_address(&self) -> u32 {
            self.deprecated_game_ip_address.unwrap_or(0)
        }

        pub fn clear_deprecated_game_ip_address(&mut self) {
            self.deprecated_game_ip_address = ::std::option::Option::None;
        }

        pub fn has_deprecated_game_ip_address(&self) -> bool {
            self.deprecated_game_ip_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_game_ip_address(&mut self, v: u32) {
            self.deprecated_game_ip_address = ::std::option::Option::Some(v);
        }

        // optional uint32 game_port = 4;

        pub fn get_game_port(&self) -> u32 {
            self.game_port.unwrap_or(0)
        }

        pub fn clear_game_port(&mut self) {
            self.game_port = ::std::option::Option::None;
        }

        pub fn has_game_port(&self) -> bool {
            self.game_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_port(&mut self, v: u32) {
            self.game_port = ::std::option::Option::Some(v);
        }

        // optional bool is_secure = 5;

        pub fn get_is_secure(&self) -> bool {
            self.is_secure.unwrap_or(false)
        }

        pub fn clear_is_secure(&mut self) {
            self.is_secure = ::std::option::Option::None;
        }

        pub fn has_is_secure(&self) -> bool {
            self.is_secure.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_secure(&mut self, v: bool) {
            self.is_secure = ::std::option::Option::Some(v);
        }

        // optional bytes token = 6;

        pub fn get_token(&self) -> &[u8] {
            match self.token.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_token(&mut self) {
            self.token.clear();
        }

        pub fn has_token(&self) -> bool {
            self.token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
            self.token = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.token.is_none() {
                self.token.set_default();
            }
            self.token.as_mut().unwrap()
        }

        // Take field
        pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
            self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional string game_extra_info = 7;

        pub fn get_game_extra_info(&self) -> &str {
            match self.game_extra_info.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_extra_info(&mut self) {
            self.game_extra_info.clear();
        }

        pub fn has_game_extra_info(&self) -> bool {
            self.game_extra_info.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_extra_info(&mut self, v: ::std::string::String) {
            self.game_extra_info = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_extra_info(&mut self) -> &mut ::std::string::String {
            if self.game_extra_info.is_none() {
                self.game_extra_info.set_default();
            }
            self.game_extra_info.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_extra_info(&mut self) -> ::std::string::String {
            self.game_extra_info.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes game_data_blob = 8;

        pub fn get_game_data_blob(&self) -> &[u8] {
            match self.game_data_blob.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_game_data_blob(&mut self) {
            self.game_data_blob.clear();
        }

        pub fn has_game_data_blob(&self) -> bool {
            self.game_data_blob.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_data_blob(&mut self, v: ::std::vec::Vec<u8>) {
            self.game_data_blob = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_data_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.game_data_blob.is_none() {
                self.game_data_blob.set_default();
            }
            self.game_data_blob.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_data_blob(&mut self) -> ::std::vec::Vec<u8> {
            self.game_data_blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 process_id = 9;

        pub fn get_process_id(&self) -> u32 {
            self.process_id.unwrap_or(0)
        }

        pub fn clear_process_id(&mut self) {
            self.process_id = ::std::option::Option::None;
        }

        pub fn has_process_id(&self) -> bool {
            self.process_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_process_id(&mut self, v: u32) {
            self.process_id = ::std::option::Option::Some(v);
        }

        // optional uint32 streaming_provider_id = 10;

        pub fn get_streaming_provider_id(&self) -> u32 {
            self.streaming_provider_id.unwrap_or(0)
        }

        pub fn clear_streaming_provider_id(&mut self) {
            self.streaming_provider_id = ::std::option::Option::None;
        }

        pub fn has_streaming_provider_id(&self) -> bool {
            self.streaming_provider_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_streaming_provider_id(&mut self, v: u32) {
            self.streaming_provider_id = ::std::option::Option::Some(v);
        }

        // optional uint32 game_flags = 11;

        pub fn get_game_flags(&self) -> u32 {
            self.game_flags.unwrap_or(0)
        }

        pub fn clear_game_flags(&mut self) {
            self.game_flags = ::std::option::Option::None;
        }

        pub fn has_game_flags(&self) -> bool {
            self.game_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_flags(&mut self, v: u32) {
            self.game_flags = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 12;

        pub fn get_owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional string vr_hmd_vendor = 13;

        pub fn get_vr_hmd_vendor(&self) -> &str {
            match self.vr_hmd_vendor.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vr_hmd_vendor(&mut self) {
            self.vr_hmd_vendor.clear();
        }

        pub fn has_vr_hmd_vendor(&self) -> bool {
            self.vr_hmd_vendor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_vendor(&mut self, v: ::std::string::String) {
            self.vr_hmd_vendor = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vr_hmd_vendor(&mut self) -> &mut ::std::string::String {
            if self.vr_hmd_vendor.is_none() {
                self.vr_hmd_vendor.set_default();
            }
            self.vr_hmd_vendor.as_mut().unwrap()
        }

        // Take field
        pub fn take_vr_hmd_vendor(&mut self) -> ::std::string::String {
            self.vr_hmd_vendor.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string vr_hmd_model = 14;

        pub fn get_vr_hmd_model(&self) -> &str {
            match self.vr_hmd_model.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vr_hmd_model(&mut self) {
            self.vr_hmd_model.clear();
        }

        pub fn has_vr_hmd_model(&self) -> bool {
            self.vr_hmd_model.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_model(&mut self, v: ::std::string::String) {
            self.vr_hmd_model = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vr_hmd_model(&mut self) -> &mut ::std::string::String {
            if self.vr_hmd_model.is_none() {
                self.vr_hmd_model.set_default();
            }
            self.vr_hmd_model.as_mut().unwrap()
        }

        // Take field
        pub fn take_vr_hmd_model(&mut self) -> ::std::string::String {
            self.vr_hmd_model.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 launch_option_type = 15;

        pub fn get_launch_option_type(&self) -> u32 {
            self.launch_option_type.unwrap_or(0u32)
        }

        pub fn clear_launch_option_type(&mut self) {
            self.launch_option_type = ::std::option::Option::None;
        }

        pub fn has_launch_option_type(&self) -> bool {
            self.launch_option_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_launch_option_type(&mut self, v: u32) {
            self.launch_option_type = ::std::option::Option::Some(v);
        }

        // optional int32 primary_controller_type = 16;

        pub fn get_primary_controller_type(&self) -> i32 {
            self.primary_controller_type.unwrap_or(-1i32)
        }

        pub fn clear_primary_controller_type(&mut self) {
            self.primary_controller_type = ::std::option::Option::None;
        }

        pub fn has_primary_controller_type(&self) -> bool {
            self.primary_controller_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary_controller_type(&mut self, v: i32) {
            self.primary_controller_type = ::std::option::Option::Some(v);
        }

        // optional string primary_steam_controller_serial = 17;

        pub fn get_primary_steam_controller_serial(&self) -> &str {
            match self.primary_steam_controller_serial.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_primary_steam_controller_serial(&mut self) {
            self.primary_steam_controller_serial.clear();
        }

        pub fn has_primary_steam_controller_serial(&self) -> bool {
            self.primary_steam_controller_serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary_steam_controller_serial(&mut self, v: ::std::string::String) {
            self.primary_steam_controller_serial = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_primary_steam_controller_serial(&mut self) -> &mut ::std::string::String {
            if self.primary_steam_controller_serial.is_none() {
                self.primary_steam_controller_serial.set_default();
            }
            self.primary_steam_controller_serial.as_mut().unwrap()
        }

        // Take field
        pub fn take_primary_steam_controller_serial(&mut self) -> ::std::string::String {
            self.primary_steam_controller_serial.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 total_steam_controller_count = 18;

        pub fn get_total_steam_controller_count(&self) -> u32 {
            self.total_steam_controller_count.unwrap_or(0u32)
        }

        pub fn clear_total_steam_controller_count(&mut self) {
            self.total_steam_controller_count = ::std::option::Option::None;
        }

        pub fn has_total_steam_controller_count(&self) -> bool {
            self.total_steam_controller_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_steam_controller_count(&mut self, v: u32) {
            self.total_steam_controller_count = ::std::option::Option::Some(v);
        }

        // optional uint32 total_non_steam_controller_count = 19;

        pub fn get_total_non_steam_controller_count(&self) -> u32 {
            self.total_non_steam_controller_count.unwrap_or(0u32)
        }

        pub fn clear_total_non_steam_controller_count(&mut self) {
            self.total_non_steam_controller_count = ::std::option::Option::None;
        }

        pub fn has_total_non_steam_controller_count(&self) -> bool {
            self.total_non_steam_controller_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_non_steam_controller_count(&mut self, v: u32) {
            self.total_non_steam_controller_count = ::std::option::Option::Some(v);
        }

        // optional uint64 controller_workshop_file_id = 20;

        pub fn get_controller_workshop_file_id(&self) -> u64 {
            self.controller_workshop_file_id.unwrap_or(0u64)
        }

        pub fn clear_controller_workshop_file_id(&mut self) {
            self.controller_workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_controller_workshop_file_id(&self) -> bool {
            self.controller_workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_workshop_file_id(&mut self, v: u64) {
            self.controller_workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 launch_source = 21;

        pub fn get_launch_source(&self) -> u32 {
            self.launch_source.unwrap_or(0u32)
        }

        pub fn clear_launch_source(&mut self) {
            self.launch_source = ::std::option::Option::None;
        }

        pub fn has_launch_source(&self) -> bool {
            self.launch_source.is_some()
        }

        // Param is passed by value, moved
        pub fn set_launch_source(&mut self, v: u32) {
            self.launch_source = ::std::option::Option::Some(v);
        }

        // optional uint32 vr_hmd_runtime = 22;

        pub fn get_vr_hmd_runtime(&self) -> u32 {
            self.vr_hmd_runtime.unwrap_or(0)
        }

        pub fn clear_vr_hmd_runtime(&mut self) {
            self.vr_hmd_runtime = ::std::option::Option::None;
        }

        pub fn has_vr_hmd_runtime(&self) -> bool {
            self.vr_hmd_runtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_runtime(&mut self, v: u32) {
            self.vr_hmd_runtime = ::std::option::Option::Some(v);
        }

        // optional uint32 controller_connection_type = 24;

        pub fn get_controller_connection_type(&self) -> u32 {
            self.controller_connection_type.unwrap_or(0u32)
        }

        pub fn clear_controller_connection_type(&mut self) {
            self.controller_connection_type = ::std::option::Option::None;
        }

        pub fn has_controller_connection_type(&self) -> bool {
            self.controller_connection_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_connection_type(&mut self, v: u32) {
            self.controller_connection_type = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for GamePlayed {
        fn is_initialized(&self) -> bool {
            for v in &self.game_ip_address {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steam_id_gs = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.deprecated_game_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.is_secure = ::std::option::Option::Some(is.read_bool()?);
                    },
                    6 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                    },
                    7 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_extra_info)?;
                    },
                    8 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.game_data_blob)?;
                    },
                    9 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    10 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.streaming_provider_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    11 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.game_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    12 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    13 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vr_hmd_vendor)?;
                    },
                    14 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vr_hmd_model)?;
                    },
                    15 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.launch_option_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.primary_controller_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    17 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.primary_steam_controller_serial)?;
                    },
                    18 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.total_steam_controller_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    19 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.total_non_steam_controller_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    20 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.controller_workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    21 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.launch_source = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    22 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.vr_hmd_runtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    23 => {
                        ::protobuf::rt::read_singular_message_into::<super::super::steammessages_base::CMsgIPAddress, _>(wire_type, is, &mut self.game_ip_address)?;
                    },
                    24 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.controller_connection_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id_gs {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.game_id {
                my_size += 9;
            }
            if let Some(v) = self.deprecated_game_ip_address {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.game_port {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.is_secure {
                my_size += 2;
            }
            if let Some(v) = self.token.as_ref() {
                my_size += ::protobuf::rt::bytes_size(6, &v);
            }
            if let Some(v) = self.game_extra_info.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                my_size += ::protobuf::rt::bytes_size(8, &v);
            }
            if let Some(v) = self.process_id {
                my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.streaming_provider_id {
                my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.game_flags {
                my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.vr_hmd_vendor.as_ref() {
                my_size += ::protobuf::rt::string_size(13, &v);
            }
            if let Some(v) = self.vr_hmd_model.as_ref() {
                my_size += ::protobuf::rt::string_size(14, &v);
            }
            if let Some(v) = self.launch_option_type {
                my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.primary_controller_type {
                my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.primary_steam_controller_serial.as_ref() {
                my_size += ::protobuf::rt::string_size(17, &v);
            }
            if let Some(v) = self.total_steam_controller_count {
                my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.total_non_steam_controller_count {
                my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.controller_workshop_file_id {
                my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.launch_source {
                my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.vr_hmd_runtime {
                my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.game_ip_address.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            }
            if let Some(v) = self.controller_connection_type {
                my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steam_id_gs {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.game_id {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.deprecated_game_ip_address {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_port {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.is_secure {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.token.as_ref() {
                os.write_bytes(6, v)?;
            }
            if let Some(v) = self.game_extra_info.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                os.write_bytes(8, v)?;
            }
            if let Some(v) = self.process_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.streaming_provider_id {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.game_flags {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.vr_hmd_vendor.as_ref() {
                os.write_string(13, v)?;
            }
            if let Some(v) = self.vr_hmd_model.as_ref() {
                os.write_string(14, v)?;
            }
            if let Some(v) = self.launch_option_type {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.primary_controller_type {
                os.write_int32(16, v)?;
            }
            if let Some(v) = self.primary_steam_controller_serial.as_ref() {
                os.write_string(17, v)?;
            }
            if let Some(v) = self.total_steam_controller_count {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.total_non_steam_controller_count {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.controller_workshop_file_id {
                os.write_uint64(20, v)?;
            }
            if let Some(v) = self.launch_source {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.vr_hmd_runtime {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.game_ip_address.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
            }
            if let Some(v) = self.controller_connection_type {
                os.write_uint32(24, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> GamePlayed {
            GamePlayed::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "steam_id_gs",
                    |m: &GamePlayed| { &m.steam_id_gs },
                    |m: &mut GamePlayed| { &mut m.steam_id_gs },
                    GamePlayed::get_steam_id_gs,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "game_id",
                    |m: &GamePlayed| { &m.game_id },
                    |m: &mut GamePlayed| { &mut m.game_id },
                    GamePlayed::get_game_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "deprecated_game_ip_address",
                    |m: &GamePlayed| { &m.deprecated_game_ip_address },
                    |m: &mut GamePlayed| { &mut m.deprecated_game_ip_address },
                    GamePlayed::get_deprecated_game_ip_address,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "game_port",
                    |m: &GamePlayed| { &m.game_port },
                    |m: &mut GamePlayed| { &mut m.game_port },
                    GamePlayed::get_game_port,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "is_secure",
                    |m: &GamePlayed| { &m.is_secure },
                    |m: &mut GamePlayed| { &mut m.is_secure },
                    GamePlayed::get_is_secure,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "token",
                    |m: &GamePlayed| { &m.token },
                    |m: &mut GamePlayed| { &mut m.token },
                    GamePlayed::get_token,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "game_extra_info",
                    |m: &GamePlayed| { &m.game_extra_info },
                    |m: &mut GamePlayed| { &mut m.game_extra_info },
                    GamePlayed::get_game_extra_info,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "game_data_blob",
                    |m: &GamePlayed| { &m.game_data_blob },
                    |m: &mut GamePlayed| { &mut m.game_data_blob },
                    GamePlayed::get_game_data_blob,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "process_id",
                    |m: &GamePlayed| { &m.process_id },
                    |m: &mut GamePlayed| { &mut m.process_id },
                    GamePlayed::get_process_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "streaming_provider_id",
                    |m: &GamePlayed| { &m.streaming_provider_id },
                    |m: &mut GamePlayed| { &mut m.streaming_provider_id },
                    GamePlayed::get_streaming_provider_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "game_flags",
                    |m: &GamePlayed| { &m.game_flags },
                    |m: &mut GamePlayed| { &mut m.game_flags },
                    GamePlayed::get_game_flags,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "owner_id",
                    |m: &GamePlayed| { &m.owner_id },
                    |m: &mut GamePlayed| { &mut m.owner_id },
                    GamePlayed::get_owner_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "vr_hmd_vendor",
                    |m: &GamePlayed| { &m.vr_hmd_vendor },
                    |m: &mut GamePlayed| { &mut m.vr_hmd_vendor },
                    GamePlayed::get_vr_hmd_vendor,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "vr_hmd_model",
                    |m: &GamePlayed| { &m.vr_hmd_model },
                    |m: &mut GamePlayed| { &mut m.vr_hmd_model },
                    GamePlayed::get_vr_hmd_model,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "launch_option_type",
                    |m: &GamePlayed| { &m.launch_option_type },
                    |m: &mut GamePlayed| { &mut m.launch_option_type },
                    GamePlayed::get_launch_option_type,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "primary_controller_type",
                    |m: &GamePlayed| { &m.primary_controller_type },
                    |m: &mut GamePlayed| { &mut m.primary_controller_type },
                    GamePlayed::get_primary_controller_type,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "primary_steam_controller_serial",
                    |m: &GamePlayed| { &m.primary_steam_controller_serial },
                    |m: &mut GamePlayed| { &mut m.primary_steam_controller_serial },
                    GamePlayed::get_primary_steam_controller_serial,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "total_steam_controller_count",
                    |m: &GamePlayed| { &m.total_steam_controller_count },
                    |m: &mut GamePlayed| { &mut m.total_steam_controller_count },
                    GamePlayed::get_total_steam_controller_count,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "total_non_steam_controller_count",
                    |m: &GamePlayed| { &m.total_non_steam_controller_count },
                    |m: &mut GamePlayed| { &mut m.total_non_steam_controller_count },
                    GamePlayed::get_total_non_steam_controller_count,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "controller_workshop_file_id",
                    |m: &GamePlayed| { &m.controller_workshop_file_id },
                    |m: &mut GamePlayed| { &mut m.controller_workshop_file_id },
                    GamePlayed::get_controller_workshop_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "launch_source",
                    |m: &GamePlayed| { &m.launch_source },
                    |m: &mut GamePlayed| { &mut m.launch_source },
                    GamePlayed::get_launch_source,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "vr_hmd_runtime",
                    |m: &GamePlayed| { &m.vr_hmd_runtime },
                    |m: &mut GamePlayed| { &mut m.vr_hmd_runtime },
                    GamePlayed::get_vr_hmd_runtime,
                ));
                fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::super::steammessages_base::CMsgIPAddress>, _>(
                    "game_ip_address",
                    |m: &GamePlayed| { &m.game_ip_address },
                    |m: &mut GamePlayed| { &mut m.game_ip_address },
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "controller_connection_type",
                    |m: &GamePlayed| { &m.controller_connection_type },
                    |m: &mut GamePlayed| { &mut m.controller_connection_type },
                    GamePlayed::get_controller_connection_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GamePlayed>(
                    "CMsgClientGamesPlayed.GamePlayed",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static GamePlayed {
            static instance: ::protobuf::rt::Lazy<GamePlayed> = ::protobuf::rt::Lazy::INIT;
            instance.get(GamePlayed::new)
        }
    }

    impl ::protobuf::Clear for GamePlayed {
        fn clear(&mut self) {
            self.steam_id_gs = ::std::option::Option::None;
            self.game_id = ::std::option::Option::None;
            self.deprecated_game_ip_address = ::std::option::Option::None;
            self.game_port = ::std::option::Option::None;
            self.is_secure = ::std::option::Option::None;
            self.token.clear();
            self.game_extra_info.clear();
            self.game_data_blob.clear();
            self.process_id = ::std::option::Option::None;
            self.streaming_provider_id = ::std::option::Option::None;
            self.game_flags = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.vr_hmd_vendor.clear();
            self.vr_hmd_model.clear();
            self.launch_option_type = ::std::option::Option::None;
            self.primary_controller_type = ::std::option::Option::None;
            self.primary_steam_controller_serial.clear();
            self.total_steam_controller_count = ::std::option::Option::None;
            self.total_non_steam_controller_count = ::std::option::Option::None;
            self.controller_workshop_file_id = ::std::option::Option::None;
            self.launch_source = ::std::option::Option::None;
            self.vr_hmd_runtime = ::std::option::Option::None;
            self.game_ip_address.clear();
            self.controller_connection_type = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for GamePlayed {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GamePlayed {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSApprove {
    // message fields
    steam_id: ::std::option::Option<u64>,
    owner_steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSApprove {
    fn default() -> &'a CMsgGSApprove {
        <CMsgGSApprove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSApprove {
    pub fn new() -> CMsgGSApprove {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steam_id = 2;

    pub fn get_owner_steam_id(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }

    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSApprove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.owner_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.owner_steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.owner_steam_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSApprove {
        CMsgGSApprove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id",
                |m: &CMsgGSApprove| { &m.steam_id },
                |m: &mut CMsgGSApprove| { &mut m.steam_id },
                CMsgGSApprove::get_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "owner_steam_id",
                |m: &CMsgGSApprove| { &m.owner_steam_id },
                |m: &mut CMsgGSApprove| { &mut m.owner_steam_id },
                CMsgGSApprove::get_owner_steam_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSApprove>(
                "CMsgGSApprove",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSApprove {
        static instance: ::protobuf::rt::Lazy<CMsgGSApprove> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSApprove::new)
    }
}

impl ::protobuf::Clear for CMsgGSApprove {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.owner_steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSApprove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSApprove {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSDeny {
    // message fields
    steam_id: ::std::option::Option<u64>,
    edeny_reason: ::std::option::Option<i32>,
    deny_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSDeny {
    fn default() -> &'a CMsgGSDeny {
        <CMsgGSDeny as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSDeny {
    pub fn new() -> CMsgGSDeny {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 edeny_reason = 2;

    pub fn get_edeny_reason(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }

    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }

    // optional string deny_string = 3;

    pub fn get_deny_string(&self) -> &str {
        match self.deny_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deny_string(&mut self) {
        self.deny_string.clear();
    }

    pub fn has_deny_string(&self) -> bool {
        self.deny_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny_string(&mut self, v: ::std::string::String) {
        self.deny_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deny_string(&mut self) -> &mut ::std::string::String {
        if self.deny_string.is_none() {
            self.deny_string.set_default();
        }
        self.deny_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_deny_string(&mut self) -> ::std::string::String {
        self.deny_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGSDeny {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.edeny_reason = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deny_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.edeny_reason {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deny_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.edeny_reason {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.deny_string.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSDeny {
        CMsgGSDeny::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id",
                |m: &CMsgGSDeny| { &m.steam_id },
                |m: &mut CMsgGSDeny| { &mut m.steam_id },
                CMsgGSDeny::get_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "edeny_reason",
                |m: &CMsgGSDeny| { &m.edeny_reason },
                |m: &mut CMsgGSDeny| { &mut m.edeny_reason },
                CMsgGSDeny::get_edeny_reason,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "deny_string",
                |m: &CMsgGSDeny| { &m.deny_string },
                |m: &mut CMsgGSDeny| { &mut m.deny_string },
                CMsgGSDeny::get_deny_string,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSDeny>(
                "CMsgGSDeny",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSDeny {
        static instance: ::protobuf::rt::Lazy<CMsgGSDeny> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSDeny::new)
    }
}

impl ::protobuf::Clear for CMsgGSDeny {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.edeny_reason = ::std::option::Option::None;
        self.deny_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSDeny {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSDeny {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSKick {
    // message fields
    steam_id: ::std::option::Option<u64>,
    edeny_reason: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSKick {
    fn default() -> &'a CMsgGSKick {
        <CMsgGSKick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSKick {
    pub fn new() -> CMsgGSKick {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 edeny_reason = 2;

    pub fn get_edeny_reason(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }

    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSKick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.edeny_reason = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.edeny_reason {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.edeny_reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSKick {
        CMsgGSKick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id",
                |m: &CMsgGSKick| { &m.steam_id },
                |m: &mut CMsgGSKick| { &mut m.steam_id },
                CMsgGSKick::get_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "edeny_reason",
                |m: &CMsgGSKick| { &m.edeny_reason },
                |m: &mut CMsgGSKick| { &mut m.edeny_reason },
                CMsgGSKick::get_edeny_reason,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSKick>(
                "CMsgGSKick",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSKick {
        static instance: ::protobuf::rt::Lazy<CMsgGSKick> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSKick::new)
    }
}

impl ::protobuf::Clear for CMsgGSKick {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.edeny_reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSKick {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAuthList {
    // message fields
    tokens_left: ::std::option::Option<u32>,
    last_request_seq: ::std::option::Option<u32>,
    last_request_seq_from_server: ::std::option::Option<u32>,
    pub tickets: ::protobuf::RepeatedField<super::steammessages_base::CMsgAuthTicket>,
    pub app_ids: ::std::vec::Vec<u32>,
    message_sequence: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthList {
    fn default() -> &'a CMsgClientAuthList {
        <CMsgClientAuthList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthList {
    pub fn new() -> CMsgClientAuthList {
        ::std::default::Default::default()
    }

    // optional uint32 tokens_left = 1;

    pub fn get_tokens_left(&self) -> u32 {
        self.tokens_left.unwrap_or(0)
    }

    pub fn clear_tokens_left(&mut self) {
        self.tokens_left = ::std::option::Option::None;
    }

    pub fn has_tokens_left(&self) -> bool {
        self.tokens_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens_left(&mut self, v: u32) {
        self.tokens_left = ::std::option::Option::Some(v);
    }

    // optional uint32 last_request_seq = 2;

    pub fn get_last_request_seq(&self) -> u32 {
        self.last_request_seq.unwrap_or(0)
    }

    pub fn clear_last_request_seq(&mut self) {
        self.last_request_seq = ::std::option::Option::None;
    }

    pub fn has_last_request_seq(&self) -> bool {
        self.last_request_seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq(&mut self, v: u32) {
        self.last_request_seq = ::std::option::Option::Some(v);
    }

    // optional uint32 last_request_seq_from_server = 3;

    pub fn get_last_request_seq_from_server(&self) -> u32 {
        self.last_request_seq_from_server.unwrap_or(0)
    }

    pub fn clear_last_request_seq_from_server(&mut self) {
        self.last_request_seq_from_server = ::std::option::Option::None;
    }

    pub fn has_last_request_seq_from_server(&self) -> bool {
        self.last_request_seq_from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq_from_server(&mut self, v: u32) {
        self.last_request_seq_from_server = ::std::option::Option::Some(v);
    }

    // optional uint32 message_sequence = 6;

    pub fn get_message_sequence(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }

    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthList {
    fn is_initialized(&self) -> bool {
        for v in &self.tickets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.tokens_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_request_seq = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_request_seq_from_server = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.tickets)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.app_ids)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tokens_left {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_request_seq {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_request_seq_from_server {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tickets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.app_ids {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.message_sequence {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tokens_left {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_request_seq {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.last_request_seq_from_server {
            os.write_uint32(3, v)?;
        }
        for v in &self.tickets {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.app_ids {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.message_sequence {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAuthList {
        CMsgClientAuthList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "tokens_left",
                |m: &CMsgClientAuthList| { &m.tokens_left },
                |m: &mut CMsgClientAuthList| { &mut m.tokens_left },
                CMsgClientAuthList::get_tokens_left,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_request_seq",
                |m: &CMsgClientAuthList| { &m.last_request_seq },
                |m: &mut CMsgClientAuthList| { &mut m.last_request_seq },
                CMsgClientAuthList::get_last_request_seq,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_request_seq_from_server",
                |m: &CMsgClientAuthList| { &m.last_request_seq_from_server },
                |m: &mut CMsgClientAuthList| { &mut m.last_request_seq_from_server },
                CMsgClientAuthList::get_last_request_seq_from_server,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::steammessages_base::CMsgAuthTicket>>(
                "tickets",
                |m: &CMsgClientAuthList| { &m.tickets },
                |m: &mut CMsgClientAuthList| { &mut m.tickets },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "app_ids",
                |m: &CMsgClientAuthList| { &m.app_ids },
                |m: &mut CMsgClientAuthList| { &mut m.app_ids },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "message_sequence",
                |m: &CMsgClientAuthList| { &m.message_sequence },
                |m: &mut CMsgClientAuthList| { &mut m.message_sequence },
                CMsgClientAuthList::get_message_sequence,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAuthList>(
                "CMsgClientAuthList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAuthList {
        static instance: ::protobuf::rt::Lazy<CMsgClientAuthList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAuthList::new)
    }
}

impl ::protobuf::Clear for CMsgClientAuthList {
    fn clear(&mut self) {
        self.tokens_left = ::std::option::Option::None;
        self.last_request_seq = ::std::option::Option::None;
        self.last_request_seq_from_server = ::std::option::Option::None;
        self.tickets.clear();
        self.app_ids.clear();
        self.message_sequence = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAuthList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthList {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAuthListAck {
    // message fields
    pub ticket_crc: ::std::vec::Vec<u32>,
    pub app_ids: ::std::vec::Vec<u32>,
    message_sequence: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthListAck {
    fn default() -> &'a CMsgClientAuthListAck {
        <CMsgClientAuthListAck as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthListAck {
    pub fn new() -> CMsgClientAuthListAck {
        ::std::default::Default::default()
    }

    // optional uint32 message_sequence = 3;

    pub fn get_message_sequence(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }

    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthListAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.ticket_crc)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.app_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ticket_crc {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.app_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.message_sequence {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ticket_crc {
            os.write_uint32(1, *v)?;
        };
        for v in &self.app_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.message_sequence {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAuthListAck {
        CMsgClientAuthListAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "ticket_crc",
                |m: &CMsgClientAuthListAck| { &m.ticket_crc },
                |m: &mut CMsgClientAuthListAck| { &mut m.ticket_crc },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "app_ids",
                |m: &CMsgClientAuthListAck| { &m.app_ids },
                |m: &mut CMsgClientAuthListAck| { &mut m.app_ids },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "message_sequence",
                |m: &CMsgClientAuthListAck| { &m.message_sequence },
                |m: &mut CMsgClientAuthListAck| { &mut m.message_sequence },
                CMsgClientAuthListAck::get_message_sequence,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAuthListAck>(
                "CMsgClientAuthListAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAuthListAck {
        static instance: ::protobuf::rt::Lazy<CMsgClientAuthListAck> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAuthListAck::new)
    }
}

impl ::protobuf::Clear for CMsgClientAuthListAck {
    fn clear(&mut self) {
        self.ticket_crc.clear();
        self.app_ids.clear();
        self.message_sequence = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAuthListAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthListAck {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLicenseList {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub licenses: ::protobuf::RepeatedField<cmsg_client_license_list::License>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLicenseList {
    fn default() -> &'a CMsgClientLicenseList {
        <CMsgClientLicenseList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLicenseList {
    pub fn new() -> CMsgClientLicenseList {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLicenseList {
    fn is_initialized(&self) -> bool {
        for v in &self.licenses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.licenses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.licenses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.licenses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLicenseList {
        CMsgClientLicenseList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientLicenseList| { &m.eresult },
                |m: &mut CMsgClientLicenseList| { &mut m.eresult },
                CMsgClientLicenseList::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_license_list::License>>(
                "licenses",
                |m: &CMsgClientLicenseList| { &m.licenses },
                |m: &mut CMsgClientLicenseList| { &mut m.licenses },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLicenseList>(
                "CMsgClientLicenseList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLicenseList {
        static instance: ::protobuf::rt::Lazy<CMsgClientLicenseList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientLicenseList::new)
    }
}

impl ::protobuf::Clear for CMsgClientLicenseList {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.licenses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLicenseList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLicenseList {
}

/// Nested message and enums of message `CMsgClientLicenseList`
pub mod cmsg_client_license_list {
    #[derive(PartialEq,Clone,Default)]
    pub struct License {
        // message fields
        package_id: ::std::option::Option<u32>,
        time_created: ::std::option::Option<u32>,
        time_next_process: ::std::option::Option<u32>,
        minute_limit: ::std::option::Option<i32>,
        minutes_used: ::std::option::Option<i32>,
        payment_method: ::std::option::Option<u32>,
        flags: ::std::option::Option<u32>,
        purchase_country_code: ::protobuf::SingularField<::std::string::String>,
        license_type: ::std::option::Option<u32>,
        territory_code: ::std::option::Option<i32>,
        change_number: ::std::option::Option<i32>,
        owner_id: ::std::option::Option<u32>,
        initial_period: ::std::option::Option<u32>,
        initial_time_unit: ::std::option::Option<u32>,
        renewal_period: ::std::option::Option<u32>,
        renewal_time_unit: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a License {
        fn default() -> &'a License {
            <License as ::protobuf::Message>::default_instance()
        }
    }

    impl License {
        pub fn new() -> License {
            ::std::default::Default::default()
        }

        // optional uint32 package_id = 1;

        pub fn get_package_id(&self) -> u32 {
            self.package_id.unwrap_or(0)
        }

        pub fn clear_package_id(&mut self) {
            self.package_id = ::std::option::Option::None;
        }

        pub fn has_package_id(&self) -> bool {
            self.package_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_package_id(&mut self, v: u32) {
            self.package_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 time_created = 2;

        pub fn get_time_created(&self) -> u32 {
            self.time_created.unwrap_or(0)
        }

        pub fn clear_time_created(&mut self) {
            self.time_created = ::std::option::Option::None;
        }

        pub fn has_time_created(&self) -> bool {
            self.time_created.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_created(&mut self, v: u32) {
            self.time_created = ::std::option::Option::Some(v);
        }

        // optional fixed32 time_next_process = 3;

        pub fn get_time_next_process(&self) -> u32 {
            self.time_next_process.unwrap_or(0)
        }

        pub fn clear_time_next_process(&mut self) {
            self.time_next_process = ::std::option::Option::None;
        }

        pub fn has_time_next_process(&self) -> bool {
            self.time_next_process.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_next_process(&mut self, v: u32) {
            self.time_next_process = ::std::option::Option::Some(v);
        }

        // optional int32 minute_limit = 4;

        pub fn get_minute_limit(&self) -> i32 {
            self.minute_limit.unwrap_or(0)
        }

        pub fn clear_minute_limit(&mut self) {
            self.minute_limit = ::std::option::Option::None;
        }

        pub fn has_minute_limit(&self) -> bool {
            self.minute_limit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minute_limit(&mut self, v: i32) {
            self.minute_limit = ::std::option::Option::Some(v);
        }

        // optional int32 minutes_used = 5;

        pub fn get_minutes_used(&self) -> i32 {
            self.minutes_used.unwrap_or(0)
        }

        pub fn clear_minutes_used(&mut self) {
            self.minutes_used = ::std::option::Option::None;
        }

        pub fn has_minutes_used(&self) -> bool {
            self.minutes_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_used(&mut self, v: i32) {
            self.minutes_used = ::std::option::Option::Some(v);
        }

        // optional uint32 payment_method = 6;

        pub fn get_payment_method(&self) -> u32 {
            self.payment_method.unwrap_or(0)
        }

        pub fn clear_payment_method(&mut self) {
            self.payment_method = ::std::option::Option::None;
        }

        pub fn has_payment_method(&self) -> bool {
            self.payment_method.is_some()
        }

        // Param is passed by value, moved
        pub fn set_payment_method(&mut self, v: u32) {
            self.payment_method = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 7;

        pub fn get_flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional string purchase_country_code = 8;

        pub fn get_purchase_country_code(&self) -> &str {
            match self.purchase_country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_purchase_country_code(&mut self) {
            self.purchase_country_code.clear();
        }

        pub fn has_purchase_country_code(&self) -> bool {
            self.purchase_country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_purchase_country_code(&mut self, v: ::std::string::String) {
            self.purchase_country_code = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_purchase_country_code(&mut self) -> &mut ::std::string::String {
            if self.purchase_country_code.is_none() {
                self.purchase_country_code.set_default();
            }
            self.purchase_country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_purchase_country_code(&mut self) -> ::std::string::String {
            self.purchase_country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 license_type = 9;

        pub fn get_license_type(&self) -> u32 {
            self.license_type.unwrap_or(0)
        }

        pub fn clear_license_type(&mut self) {
            self.license_type = ::std::option::Option::None;
        }

        pub fn has_license_type(&self) -> bool {
            self.license_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_license_type(&mut self, v: u32) {
            self.license_type = ::std::option::Option::Some(v);
        }

        // optional int32 territory_code = 10;

        pub fn get_territory_code(&self) -> i32 {
            self.territory_code.unwrap_or(0)
        }

        pub fn clear_territory_code(&mut self) {
            self.territory_code = ::std::option::Option::None;
        }

        pub fn has_territory_code(&self) -> bool {
            self.territory_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_territory_code(&mut self, v: i32) {
            self.territory_code = ::std::option::Option::Some(v);
        }

        // optional int32 change_number = 11;

        pub fn get_change_number(&self) -> i32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: i32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 12;

        pub fn get_owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional uint32 initial_period = 13;

        pub fn get_initial_period(&self) -> u32 {
            self.initial_period.unwrap_or(0)
        }

        pub fn clear_initial_period(&mut self) {
            self.initial_period = ::std::option::Option::None;
        }

        pub fn has_initial_period(&self) -> bool {
            self.initial_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_initial_period(&mut self, v: u32) {
            self.initial_period = ::std::option::Option::Some(v);
        }

        // optional uint32 initial_time_unit = 14;

        pub fn get_initial_time_unit(&self) -> u32 {
            self.initial_time_unit.unwrap_or(0)
        }

        pub fn clear_initial_time_unit(&mut self) {
            self.initial_time_unit = ::std::option::Option::None;
        }

        pub fn has_initial_time_unit(&self) -> bool {
            self.initial_time_unit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_initial_time_unit(&mut self, v: u32) {
            self.initial_time_unit = ::std::option::Option::Some(v);
        }

        // optional uint32 renewal_period = 15;

        pub fn get_renewal_period(&self) -> u32 {
            self.renewal_period.unwrap_or(0)
        }

        pub fn clear_renewal_period(&mut self) {
            self.renewal_period = ::std::option::Option::None;
        }

        pub fn has_renewal_period(&self) -> bool {
            self.renewal_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_renewal_period(&mut self, v: u32) {
            self.renewal_period = ::std::option::Option::Some(v);
        }

        // optional uint32 renewal_time_unit = 16;

        pub fn get_renewal_time_unit(&self) -> u32 {
            self.renewal_time_unit.unwrap_or(0)
        }

        pub fn clear_renewal_time_unit(&mut self) {
            self.renewal_time_unit = ::std::option::Option::None;
        }

        pub fn has_renewal_time_unit(&self) -> bool {
            self.renewal_time_unit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_renewal_time_unit(&mut self, v: u32) {
            self.renewal_time_unit = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for License {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_created = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_next_process = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.minute_limit = ::std::option::Option::Some(is.read_int32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.minutes_used = ::std::option::Option::Some(is.read_int32()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.payment_method = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    8 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchase_country_code)?;
                    },
                    9 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.license_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    10 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.territory_code = ::std::option::Option::Some(is.read_int32()?);
                    },
                    11 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.change_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    12 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    13 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.initial_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    14 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.initial_time_unit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    15 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.renewal_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.renewal_time_unit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.package_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.time_created {
                my_size += 5;
            }
            if let Some(v) = self.time_next_process {
                my_size += 5;
            }
            if let Some(v) = self.minute_limit {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.minutes_used {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.payment_method {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.purchase_country_code.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.license_type {
                my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.territory_code {
                my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.initial_period {
                my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.initial_time_unit {
                my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.renewal_period {
                my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.renewal_time_unit {
                my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.package_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.time_created {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.time_next_process {
                os.write_fixed32(3, v)?;
            }
            if let Some(v) = self.minute_limit {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.minutes_used {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.payment_method {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.purchase_country_code.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.license_type {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.territory_code {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.initial_period {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.initial_time_unit {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.renewal_period {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.renewal_time_unit {
                os.write_uint32(16, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> License {
            License::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "package_id",
                    |m: &License| { &m.package_id },
                    |m: &mut License| { &mut m.package_id },
                    License::get_package_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                    "time_created",
                    |m: &License| { &m.time_created },
                    |m: &mut License| { &mut m.time_created },
                    License::get_time_created,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                    "time_next_process",
                    |m: &License| { &m.time_next_process },
                    |m: &mut License| { &mut m.time_next_process },
                    License::get_time_next_process,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "minute_limit",
                    |m: &License| { &m.minute_limit },
                    |m: &mut License| { &mut m.minute_limit },
                    License::get_minute_limit,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "minutes_used",
                    |m: &License| { &m.minutes_used },
                    |m: &mut License| { &mut m.minutes_used },
                    License::get_minutes_used,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "payment_method",
                    |m: &License| { &m.payment_method },
                    |m: &mut License| { &mut m.payment_method },
                    License::get_payment_method,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "flags",
                    |m: &License| { &m.flags },
                    |m: &mut License| { &mut m.flags },
                    License::get_flags,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "purchase_country_code",
                    |m: &License| { &m.purchase_country_code },
                    |m: &mut License| { &mut m.purchase_country_code },
                    License::get_purchase_country_code,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "license_type",
                    |m: &License| { &m.license_type },
                    |m: &mut License| { &mut m.license_type },
                    License::get_license_type,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "territory_code",
                    |m: &License| { &m.territory_code },
                    |m: &mut License| { &mut m.territory_code },
                    License::get_territory_code,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "change_number",
                    |m: &License| { &m.change_number },
                    |m: &mut License| { &mut m.change_number },
                    License::get_change_number,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "owner_id",
                    |m: &License| { &m.owner_id },
                    |m: &mut License| { &mut m.owner_id },
                    License::get_owner_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "initial_period",
                    |m: &License| { &m.initial_period },
                    |m: &mut License| { &mut m.initial_period },
                    License::get_initial_period,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "initial_time_unit",
                    |m: &License| { &m.initial_time_unit },
                    |m: &mut License| { &mut m.initial_time_unit },
                    License::get_initial_time_unit,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "renewal_period",
                    |m: &License| { &m.renewal_period },
                    |m: &mut License| { &mut m.renewal_period },
                    License::get_renewal_period,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "renewal_time_unit",
                    |m: &License| { &m.renewal_time_unit },
                    |m: &mut License| { &mut m.renewal_time_unit },
                    License::get_renewal_time_unit,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<License>(
                    "CMsgClientLicenseList.License",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static License {
            static instance: ::protobuf::rt::Lazy<License> = ::protobuf::rt::Lazy::INIT;
            instance.get(License::new)
        }
    }

    impl ::protobuf::Clear for License {
        fn clear(&mut self) {
            self.package_id = ::std::option::Option::None;
            self.time_created = ::std::option::Option::None;
            self.time_next_process = ::std::option::Option::None;
            self.minute_limit = ::std::option::Option::None;
            self.minutes_used = ::std::option::Option::None;
            self.payment_method = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.purchase_country_code.clear();
            self.license_type = ::std::option::Option::None;
            self.territory_code = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.initial_period = ::std::option::Option::None;
            self.initial_time_unit = ::std::option::Option::None;
            self.renewal_period = ::std::option::Option::None;
            self.renewal_time_unit = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for License {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for License {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSSetScore {
    // message fields
    app_id: ::std::option::Option<u32>,
    leaderboard_id: ::std::option::Option<i32>,
    score: ::std::option::Option<i32>,
    details: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    upload_score_method: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetScore {
    fn default() -> &'a CMsgClientLBSSetScore {
        <CMsgClientLBSSetScore as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetScore {
    pub fn new() -> CMsgClientLBSSetScore {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;

    pub fn get_leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional int32 score = 3;

    pub fn get_score(&self) -> i32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional bytes details = 4;

    pub fn get_details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details.set_default();
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 upload_score_method = 5;

    pub fn get_upload_score_method(&self) -> i32 {
        self.upload_score_method.unwrap_or(0)
    }

    pub fn clear_upload_score_method(&mut self) {
        self.upload_score_method = ::std::option::Option::None;
    }

    pub fn has_upload_score_method(&self) -> bool {
        self.upload_score_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_score_method(&mut self, v: i32) {
        self.upload_score_method = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSSetScore {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_id = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.score = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.details)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.upload_score_method = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.upload_score_method {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.score {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.upload_score_method {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSSetScore {
        CMsgClientLBSSetScore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientLBSSetScore| { &m.app_id },
                |m: &mut CMsgClientLBSSetScore| { &mut m.app_id },
                CMsgClientLBSSetScore::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_id",
                |m: &CMsgClientLBSSetScore| { &m.leaderboard_id },
                |m: &mut CMsgClientLBSSetScore| { &mut m.leaderboard_id },
                CMsgClientLBSSetScore::get_leaderboard_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "score",
                |m: &CMsgClientLBSSetScore| { &m.score },
                |m: &mut CMsgClientLBSSetScore| { &mut m.score },
                CMsgClientLBSSetScore::get_score,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "details",
                |m: &CMsgClientLBSSetScore| { &m.details },
                |m: &mut CMsgClientLBSSetScore| { &mut m.details },
                CMsgClientLBSSetScore::get_details,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "upload_score_method",
                |m: &CMsgClientLBSSetScore| { &m.upload_score_method },
                |m: &mut CMsgClientLBSSetScore| { &mut m.upload_score_method },
                CMsgClientLBSSetScore::get_upload_score_method,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSSetScore>(
                "CMsgClientLBSSetScore",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSSetScore {
        static instance: ::protobuf::rt::Lazy<CMsgClientLBSSetScore> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientLBSSetScore::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetScore {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.details.clear();
        self.upload_score_method = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetScore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetScore {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSSetScoreResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    leaderboard_entry_count: ::std::option::Option<i32>,
    score_changed: ::std::option::Option<bool>,
    global_rank_previous: ::std::option::Option<i32>,
    global_rank_new: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetScoreResponse {
    fn default() -> &'a CMsgClientLBSSetScoreResponse {
        <CMsgClientLBSSetScoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetScoreResponse {
    pub fn new() -> CMsgClientLBSSetScoreResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_entry_count = 2;

    pub fn get_leaderboard_entry_count(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }

    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    // optional bool score_changed = 3;

    pub fn get_score_changed(&self) -> bool {
        self.score_changed.unwrap_or(false)
    }

    pub fn clear_score_changed(&mut self) {
        self.score_changed = ::std::option::Option::None;
    }

    pub fn has_score_changed(&self) -> bool {
        self.score_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_changed(&mut self, v: bool) {
        self.score_changed = ::std::option::Option::Some(v);
    }

    // optional int32 global_rank_previous = 4;

    pub fn get_global_rank_previous(&self) -> i32 {
        self.global_rank_previous.unwrap_or(0)
    }

    pub fn clear_global_rank_previous(&mut self) {
        self.global_rank_previous = ::std::option::Option::None;
    }

    pub fn has_global_rank_previous(&self) -> bool {
        self.global_rank_previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_rank_previous(&mut self, v: i32) {
        self.global_rank_previous = ::std::option::Option::Some(v);
    }

    // optional int32 global_rank_new = 5;

    pub fn get_global_rank_new(&self) -> i32 {
        self.global_rank_new.unwrap_or(0)
    }

    pub fn clear_global_rank_new(&mut self) {
        self.global_rank_new = ::std::option::Option::None;
    }

    pub fn has_global_rank_new(&self) -> bool {
        self.global_rank_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_rank_new(&mut self, v: i32) {
        self.global_rank_new = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSSetScoreResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_entry_count = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.score_changed = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.global_rank_previous = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.global_rank_new = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_entry_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_changed {
            my_size += 2;
        }
        if let Some(v) = self.global_rank_previous {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.global_rank_new {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_entry_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.score_changed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.global_rank_previous {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.global_rank_new {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSSetScoreResponse {
        CMsgClientLBSSetScoreResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientLBSSetScoreResponse| { &m.eresult },
                |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.eresult },
                CMsgClientLBSSetScoreResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_entry_count",
                |m: &CMsgClientLBSSetScoreResponse| { &m.leaderboard_entry_count },
                |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.leaderboard_entry_count },
                CMsgClientLBSSetScoreResponse::get_leaderboard_entry_count,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "score_changed",
                |m: &CMsgClientLBSSetScoreResponse| { &m.score_changed },
                |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.score_changed },
                CMsgClientLBSSetScoreResponse::get_score_changed,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "global_rank_previous",
                |m: &CMsgClientLBSSetScoreResponse| { &m.global_rank_previous },
                |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.global_rank_previous },
                CMsgClientLBSSetScoreResponse::get_global_rank_previous,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "global_rank_new",
                |m: &CMsgClientLBSSetScoreResponse| { &m.global_rank_new },
                |m: &mut CMsgClientLBSSetScoreResponse| { &mut m.global_rank_new },
                CMsgClientLBSSetScoreResponse::get_global_rank_new,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSSetScoreResponse>(
                "CMsgClientLBSSetScoreResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSSetScoreResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientLBSSetScoreResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientLBSSetScoreResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetScoreResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.leaderboard_entry_count = ::std::option::Option::None;
        self.score_changed = ::std::option::Option::None;
        self.global_rank_previous = ::std::option::Option::None;
        self.global_rank_new = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetScoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetScoreResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSSetUGC {
    // message fields
    app_id: ::std::option::Option<u32>,
    leaderboard_id: ::std::option::Option<i32>,
    ugc_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetUGC {
    fn default() -> &'a CMsgClientLBSSetUGC {
        <CMsgClientLBSSetUGC as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetUGC {
    pub fn new() -> CMsgClientLBSSetUGC {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;

    pub fn get_leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 ugc_id = 3;

    pub fn get_ugc_id(&self) -> u64 {
        self.ugc_id.unwrap_or(0)
    }

    pub fn clear_ugc_id(&mut self) {
        self.ugc_id = ::std::option::Option::None;
    }

    pub fn has_ugc_id(&self) -> bool {
        self.ugc_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ugc_id(&mut self, v: u64) {
        self.ugc_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSSetUGC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_id = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ugc_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ugc_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ugc_id {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSSetUGC {
        CMsgClientLBSSetUGC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientLBSSetUGC| { &m.app_id },
                |m: &mut CMsgClientLBSSetUGC| { &mut m.app_id },
                CMsgClientLBSSetUGC::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_id",
                |m: &CMsgClientLBSSetUGC| { &m.leaderboard_id },
                |m: &mut CMsgClientLBSSetUGC| { &mut m.leaderboard_id },
                CMsgClientLBSSetUGC::get_leaderboard_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "ugc_id",
                |m: &CMsgClientLBSSetUGC| { &m.ugc_id },
                |m: &mut CMsgClientLBSSetUGC| { &mut m.ugc_id },
                CMsgClientLBSSetUGC::get_ugc_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSSetUGC>(
                "CMsgClientLBSSetUGC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSSetUGC {
        static instance: ::protobuf::rt::Lazy<CMsgClientLBSSetUGC> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientLBSSetUGC::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetUGC {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.ugc_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetUGC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetUGC {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSSetUGCResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSSetUGCResponse {
    fn default() -> &'a CMsgClientLBSSetUGCResponse {
        <CMsgClientLBSSetUGCResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSSetUGCResponse {
    pub fn new() -> CMsgClientLBSSetUGCResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSSetUGCResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSSetUGCResponse {
        CMsgClientLBSSetUGCResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientLBSSetUGCResponse| { &m.eresult },
                |m: &mut CMsgClientLBSSetUGCResponse| { &mut m.eresult },
                CMsgClientLBSSetUGCResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSSetUGCResponse>(
                "CMsgClientLBSSetUGCResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSSetUGCResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientLBSSetUGCResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientLBSSetUGCResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetUGCResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetUGCResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSSetUGCResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSFindOrCreateLB {
    // message fields
    app_id: ::std::option::Option<u32>,
    leaderboard_sort_method: ::std::option::Option<i32>,
    leaderboard_display_type: ::std::option::Option<i32>,
    create_if_not_found: ::std::option::Option<bool>,
    leaderboard_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSFindOrCreateLB {
    fn default() -> &'a CMsgClientLBSFindOrCreateLB {
        <CMsgClientLBSFindOrCreateLB as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSFindOrCreateLB {
    pub fn new() -> CMsgClientLBSFindOrCreateLB {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_sort_method = 2;

    pub fn get_leaderboard_sort_method(&self) -> i32 {
        self.leaderboard_sort_method.unwrap_or(0)
    }

    pub fn clear_leaderboard_sort_method(&mut self) {
        self.leaderboard_sort_method = ::std::option::Option::None;
    }

    pub fn has_leaderboard_sort_method(&self) -> bool {
        self.leaderboard_sort_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_sort_method(&mut self, v: i32) {
        self.leaderboard_sort_method = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_display_type = 3;

    pub fn get_leaderboard_display_type(&self) -> i32 {
        self.leaderboard_display_type.unwrap_or(0)
    }

    pub fn clear_leaderboard_display_type(&mut self) {
        self.leaderboard_display_type = ::std::option::Option::None;
    }

    pub fn has_leaderboard_display_type(&self) -> bool {
        self.leaderboard_display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_display_type(&mut self, v: i32) {
        self.leaderboard_display_type = ::std::option::Option::Some(v);
    }

    // optional bool create_if_not_found = 4;

    pub fn get_create_if_not_found(&self) -> bool {
        self.create_if_not_found.unwrap_or(false)
    }

    pub fn clear_create_if_not_found(&mut self) {
        self.create_if_not_found = ::std::option::Option::None;
    }

    pub fn has_create_if_not_found(&self) -> bool {
        self.create_if_not_found.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_if_not_found(&mut self, v: bool) {
        self.create_if_not_found = ::std::option::Option::Some(v);
    }

    // optional string leaderboard_name = 5;

    pub fn get_leaderboard_name(&self) -> &str {
        match self.leaderboard_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_leaderboard_name(&mut self) {
        self.leaderboard_name.clear();
    }

    pub fn has_leaderboard_name(&self) -> bool {
        self.leaderboard_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name(&mut self, v: ::std::string::String) {
        self.leaderboard_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_name(&mut self) -> &mut ::std::string::String {
        if self.leaderboard_name.is_none() {
            self.leaderboard_name.set_default();
        }
        self.leaderboard_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_name(&mut self) -> ::std::string::String {
        self.leaderboard_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientLBSFindOrCreateLB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_sort_method = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_display_type = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.create_if_not_found = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.leaderboard_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_sort_method {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_display_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.create_if_not_found {
            my_size += 2;
        }
        if let Some(v) = self.leaderboard_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leaderboard_sort_method {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.leaderboard_display_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.create_if_not_found {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.leaderboard_name.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSFindOrCreateLB {
        CMsgClientLBSFindOrCreateLB::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientLBSFindOrCreateLB| { &m.app_id },
                |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.app_id },
                CMsgClientLBSFindOrCreateLB::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_sort_method",
                |m: &CMsgClientLBSFindOrCreateLB| { &m.leaderboard_sort_method },
                |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.leaderboard_sort_method },
                CMsgClientLBSFindOrCreateLB::get_leaderboard_sort_method,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_display_type",
                |m: &CMsgClientLBSFindOrCreateLB| { &m.leaderboard_display_type },
                |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.leaderboard_display_type },
                CMsgClientLBSFindOrCreateLB::get_leaderboard_display_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "create_if_not_found",
                |m: &CMsgClientLBSFindOrCreateLB| { &m.create_if_not_found },
                |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.create_if_not_found },
                CMsgClientLBSFindOrCreateLB::get_create_if_not_found,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "leaderboard_name",
                |m: &CMsgClientLBSFindOrCreateLB| { &m.leaderboard_name },
                |m: &mut CMsgClientLBSFindOrCreateLB| { &mut m.leaderboard_name },
                CMsgClientLBSFindOrCreateLB::get_leaderboard_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSFindOrCreateLB>(
                "CMsgClientLBSFindOrCreateLB",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSFindOrCreateLB {
        static instance: ::protobuf::rt::Lazy<CMsgClientLBSFindOrCreateLB> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientLBSFindOrCreateLB::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSFindOrCreateLB {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_sort_method = ::std::option::Option::None;
        self.leaderboard_display_type = ::std::option::Option::None;
        self.create_if_not_found = ::std::option::Option::None;
        self.leaderboard_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSFindOrCreateLB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSFindOrCreateLB {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSFindOrCreateLBResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    leaderboard_id: ::std::option::Option<i32>,
    leaderboard_entry_count: ::std::option::Option<i32>,
    leaderboard_sort_method: ::std::option::Option<i32>,
    leaderboard_display_type: ::std::option::Option<i32>,
    leaderboard_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSFindOrCreateLBResponse {
    fn default() -> &'a CMsgClientLBSFindOrCreateLBResponse {
        <CMsgClientLBSFindOrCreateLBResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSFindOrCreateLBResponse {
    pub fn new() -> CMsgClientLBSFindOrCreateLBResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;

    pub fn get_leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_entry_count = 3;

    pub fn get_leaderboard_entry_count(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }

    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_sort_method = 4;

    pub fn get_leaderboard_sort_method(&self) -> i32 {
        self.leaderboard_sort_method.unwrap_or(0i32)
    }

    pub fn clear_leaderboard_sort_method(&mut self) {
        self.leaderboard_sort_method = ::std::option::Option::None;
    }

    pub fn has_leaderboard_sort_method(&self) -> bool {
        self.leaderboard_sort_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_sort_method(&mut self, v: i32) {
        self.leaderboard_sort_method = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_display_type = 5;

    pub fn get_leaderboard_display_type(&self) -> i32 {
        self.leaderboard_display_type.unwrap_or(0i32)
    }

    pub fn clear_leaderboard_display_type(&mut self) {
        self.leaderboard_display_type = ::std::option::Option::None;
    }

    pub fn has_leaderboard_display_type(&self) -> bool {
        self.leaderboard_display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_display_type(&mut self, v: i32) {
        self.leaderboard_display_type = ::std::option::Option::Some(v);
    }

    // optional string leaderboard_name = 6;

    pub fn get_leaderboard_name(&self) -> &str {
        match self.leaderboard_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_leaderboard_name(&mut self) {
        self.leaderboard_name.clear();
    }

    pub fn has_leaderboard_name(&self) -> bool {
        self.leaderboard_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name(&mut self, v: ::std::string::String) {
        self.leaderboard_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_name(&mut self) -> &mut ::std::string::String {
        if self.leaderboard_name.is_none() {
            self.leaderboard_name.set_default();
        }
        self.leaderboard_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_name(&mut self) -> ::std::string::String {
        self.leaderboard_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientLBSFindOrCreateLBResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_id = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_entry_count = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_sort_method = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_display_type = ::std::option::Option::Some(is.read_int32()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.leaderboard_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_entry_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_sort_method {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_display_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.leaderboard_entry_count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.leaderboard_sort_method {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.leaderboard_display_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.leaderboard_name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSFindOrCreateLBResponse {
        CMsgClientLBSFindOrCreateLBResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.eresult },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.eresult },
                CMsgClientLBSFindOrCreateLBResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_id",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_id },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_id },
                CMsgClientLBSFindOrCreateLBResponse::get_leaderboard_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_entry_count",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_entry_count },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_entry_count },
                CMsgClientLBSFindOrCreateLBResponse::get_leaderboard_entry_count,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_sort_method",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_sort_method },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_sort_method },
                CMsgClientLBSFindOrCreateLBResponse::get_leaderboard_sort_method,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_display_type",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_display_type },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_display_type },
                CMsgClientLBSFindOrCreateLBResponse::get_leaderboard_display_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "leaderboard_name",
                |m: &CMsgClientLBSFindOrCreateLBResponse| { &m.leaderboard_name },
                |m: &mut CMsgClientLBSFindOrCreateLBResponse| { &mut m.leaderboard_name },
                CMsgClientLBSFindOrCreateLBResponse::get_leaderboard_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSFindOrCreateLBResponse>(
                "CMsgClientLBSFindOrCreateLBResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSFindOrCreateLBResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientLBSFindOrCreateLBResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientLBSFindOrCreateLBResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSFindOrCreateLBResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.leaderboard_entry_count = ::std::option::Option::None;
        self.leaderboard_sort_method = ::std::option::Option::None;
        self.leaderboard_display_type = ::std::option::Option::None;
        self.leaderboard_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSFindOrCreateLBResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSFindOrCreateLBResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSGetLBEntries {
    // message fields
    app_id: ::std::option::Option<i32>,
    leaderboard_id: ::std::option::Option<i32>,
    range_start: ::std::option::Option<i32>,
    range_end: ::std::option::Option<i32>,
    leaderboard_data_request: ::std::option::Option<i32>,
    pub steamids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSGetLBEntries {
    fn default() -> &'a CMsgClientLBSGetLBEntries {
        <CMsgClientLBSGetLBEntries as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSGetLBEntries {
    pub fn new() -> CMsgClientLBSGetLBEntries {
        ::std::default::Default::default()
    }

    // optional int32 app_id = 1;

    pub fn get_app_id(&self) -> i32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: i32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_id = 2;

    pub fn get_leaderboard_id(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    // optional int32 range_start = 3;

    pub fn get_range_start(&self) -> i32 {
        self.range_start.unwrap_or(0)
    }

    pub fn clear_range_start(&mut self) {
        self.range_start = ::std::option::Option::None;
    }

    pub fn has_range_start(&self) -> bool {
        self.range_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_start(&mut self, v: i32) {
        self.range_start = ::std::option::Option::Some(v);
    }

    // optional int32 range_end = 4;

    pub fn get_range_end(&self) -> i32 {
        self.range_end.unwrap_or(0)
    }

    pub fn clear_range_end(&mut self) {
        self.range_end = ::std::option::Option::None;
    }

    pub fn has_range_end(&self) -> bool {
        self.range_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: i32) {
        self.range_end = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_data_request = 5;

    pub fn get_leaderboard_data_request(&self) -> i32 {
        self.leaderboard_data_request.unwrap_or(0)
    }

    pub fn clear_leaderboard_data_request(&mut self) {
        self.leaderboard_data_request = ::std::option::Option::None;
    }

    pub fn has_leaderboard_data_request(&self) -> bool {
        self.leaderboard_data_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_data_request(&mut self, v: i32) {
        self.leaderboard_data_request = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSGetLBEntries {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_id = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.range_start = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.range_end = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_data_request = ::std::option::Option::Some(is.read_int32()?);
                },
                6 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.range_start {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.range_end {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_data_request {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 9 * self.steamids.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.range_start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.range_end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.leaderboard_data_request {
            os.write_int32(5, v)?;
        }
        for v in &self.steamids {
            os.write_fixed64(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSGetLBEntries {
        CMsgClientLBSGetLBEntries::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "app_id",
                |m: &CMsgClientLBSGetLBEntries| { &m.app_id },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.app_id },
                CMsgClientLBSGetLBEntries::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_id",
                |m: &CMsgClientLBSGetLBEntries| { &m.leaderboard_id },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.leaderboard_id },
                CMsgClientLBSGetLBEntries::get_leaderboard_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "range_start",
                |m: &CMsgClientLBSGetLBEntries| { &m.range_start },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.range_start },
                CMsgClientLBSGetLBEntries::get_range_start,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "range_end",
                |m: &CMsgClientLBSGetLBEntries| { &m.range_end },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.range_end },
                CMsgClientLBSGetLBEntries::get_range_end,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_data_request",
                |m: &CMsgClientLBSGetLBEntries| { &m.leaderboard_data_request },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.leaderboard_data_request },
                CMsgClientLBSGetLBEntries::get_leaderboard_data_request,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "steamids",
                |m: &CMsgClientLBSGetLBEntries| { &m.steamids },
                |m: &mut CMsgClientLBSGetLBEntries| { &mut m.steamids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSGetLBEntries>(
                "CMsgClientLBSGetLBEntries",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSGetLBEntries {
        static instance: ::protobuf::rt::Lazy<CMsgClientLBSGetLBEntries> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientLBSGetLBEntries::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSGetLBEntries {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.leaderboard_id = ::std::option::Option::None;
        self.range_start = ::std::option::Option::None;
        self.range_end = ::std::option::Option::None;
        self.leaderboard_data_request = ::std::option::Option::None;
        self.steamids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSGetLBEntries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSGetLBEntries {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientLBSGetLBEntriesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    leaderboard_entry_count: ::std::option::Option<i32>,
    pub entries: ::protobuf::RepeatedField<cmsg_client_lbsget_lbentries_response::Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientLBSGetLBEntriesResponse {
    fn default() -> &'a CMsgClientLBSGetLBEntriesResponse {
        <CMsgClientLBSGetLBEntriesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLBSGetLBEntriesResponse {
    pub fn new() -> CMsgClientLBSGetLBEntriesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 leaderboard_entry_count = 2;

    pub fn get_leaderboard_entry_count(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }

    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLBSGetLBEntriesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaderboard_entry_count = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaderboard_entry_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.leaderboard_entry_count {
            os.write_int32(2, v)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientLBSGetLBEntriesResponse {
        CMsgClientLBSGetLBEntriesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientLBSGetLBEntriesResponse| { &m.eresult },
                |m: &mut CMsgClientLBSGetLBEntriesResponse| { &mut m.eresult },
                CMsgClientLBSGetLBEntriesResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "leaderboard_entry_count",
                |m: &CMsgClientLBSGetLBEntriesResponse| { &m.leaderboard_entry_count },
                |m: &mut CMsgClientLBSGetLBEntriesResponse| { &mut m.leaderboard_entry_count },
                CMsgClientLBSGetLBEntriesResponse::get_leaderboard_entry_count,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_lbsget_lbentries_response::Entry>>(
                "entries",
                |m: &CMsgClientLBSGetLBEntriesResponse| { &m.entries },
                |m: &mut CMsgClientLBSGetLBEntriesResponse| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSGetLBEntriesResponse>(
                "CMsgClientLBSGetLBEntriesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientLBSGetLBEntriesResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientLBSGetLBEntriesResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientLBSGetLBEntriesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientLBSGetLBEntriesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.leaderboard_entry_count = ::std::option::Option::None;
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientLBSGetLBEntriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientLBSGetLBEntriesResponse {
}

/// Nested message and enums of message `CMsgClientLBSGetLBEntriesResponse`
pub mod cmsg_client_lbsget_lbentries_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Entry {
        // message fields
        steam_id_user: ::std::option::Option<u64>,
        global_rank: ::std::option::Option<i32>,
        score: ::std::option::Option<i32>,
        details: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        ugc_id: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id_user = 1;

        pub fn get_steam_id_user(&self) -> u64 {
            self.steam_id_user.unwrap_or(0)
        }

        pub fn clear_steam_id_user(&mut self) {
            self.steam_id_user = ::std::option::Option::None;
        }

        pub fn has_steam_id_user(&self) -> bool {
            self.steam_id_user.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id_user(&mut self, v: u64) {
            self.steam_id_user = ::std::option::Option::Some(v);
        }

        // optional int32 global_rank = 2;

        pub fn get_global_rank(&self) -> i32 {
            self.global_rank.unwrap_or(0)
        }

        pub fn clear_global_rank(&mut self) {
            self.global_rank = ::std::option::Option::None;
        }

        pub fn has_global_rank(&self) -> bool {
            self.global_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_global_rank(&mut self, v: i32) {
            self.global_rank = ::std::option::Option::Some(v);
        }

        // optional int32 score = 3;

        pub fn get_score(&self) -> i32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: i32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional bytes details = 4;

        pub fn get_details(&self) -> &[u8] {
            match self.details.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_details(&mut self) {
            self.details.clear();
        }

        pub fn has_details(&self) -> bool {
            self.details.is_some()
        }

        // Param is passed by value, moved
        pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
            self.details = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.details.is_none() {
                self.details.set_default();
            }
            self.details.as_mut().unwrap()
        }

        // Take field
        pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
            self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional fixed64 ugc_id = 5;

        pub fn get_ugc_id(&self) -> u64 {
            self.ugc_id.unwrap_or(0)
        }

        pub fn clear_ugc_id(&mut self) {
            self.ugc_id = ::std::option::Option::None;
        }

        pub fn has_ugc_id(&self) -> bool {
            self.ugc_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ugc_id(&mut self, v: u64) {
            self.ugc_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Entry {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steam_id_user = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.global_rank = ::std::option::Option::Some(is.read_int32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.score = ::std::option::Option::Some(is.read_int32()?);
                    },
                    4 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.details)?;
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.ugc_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id_user {
                my_size += 9;
            }
            if let Some(v) = self.global_rank {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.details.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            if let Some(v) = self.ugc_id {
                my_size += 9;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steam_id_user {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.global_rank {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.score {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.details.as_ref() {
                os.write_bytes(4, v)?;
            }
            if let Some(v) = self.ugc_id {
                os.write_fixed64(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steam_id_user",
                    |m: &Entry| { &m.steam_id_user },
                    |m: &mut Entry| { &mut m.steam_id_user },
                    Entry::get_steam_id_user,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "global_rank",
                    |m: &Entry| { &m.global_rank },
                    |m: &mut Entry| { &mut m.global_rank },
                    Entry::get_global_rank,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "score",
                    |m: &Entry| { &m.score },
                    |m: &mut Entry| { &mut m.score },
                    Entry::get_score,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "details",
                    |m: &Entry| { &m.details },
                    |m: &mut Entry| { &mut m.details },
                    Entry::get_details,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "ugc_id",
                    |m: &Entry| { &m.ugc_id },
                    |m: &mut Entry| { &mut m.ugc_id },
                    Entry::get_ugc_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Entry>(
                    "CMsgClientLBSGetLBEntriesResponse.Entry",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Entry {
            static instance: ::protobuf::rt::Lazy<Entry> = ::protobuf::rt::Lazy::INIT;
            instance.get(Entry::new)
        }
    }

    impl ::protobuf::Clear for Entry {
        fn clear(&mut self) {
            self.steam_id_user = ::std::option::Option::None;
            self.global_rank = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.details.clear();
            self.ugc_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppMinutesPlayedData {
    // message fields
    pub minutes_played: ::protobuf::RepeatedField<cmsg_client_app_minutes_played_data::AppMinutesPlayedData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppMinutesPlayedData {
    fn default() -> &'a CMsgClientAppMinutesPlayedData {
        <CMsgClientAppMinutesPlayedData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppMinutesPlayedData {
    pub fn new() -> CMsgClientAppMinutesPlayedData {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientAppMinutesPlayedData {
    fn is_initialized(&self) -> bool {
        for v in &self.minutes_played {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.minutes_played)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.minutes_played {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.minutes_played {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppMinutesPlayedData {
        CMsgClientAppMinutesPlayedData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_app_minutes_played_data::AppMinutesPlayedData>>(
                "minutes_played",
                |m: &CMsgClientAppMinutesPlayedData| { &m.minutes_played },
                |m: &mut CMsgClientAppMinutesPlayedData| { &mut m.minutes_played },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppMinutesPlayedData>(
                "CMsgClientAppMinutesPlayedData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppMinutesPlayedData {
        static instance: ::protobuf::rt::Lazy<CMsgClientAppMinutesPlayedData> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAppMinutesPlayedData::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppMinutesPlayedData {
    fn clear(&mut self) {
        self.minutes_played.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppMinutesPlayedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppMinutesPlayedData {
}

/// Nested message and enums of message `CMsgClientAppMinutesPlayedData`
pub mod cmsg_client_app_minutes_played_data {
    #[derive(PartialEq,Clone,Default)]
    pub struct AppMinutesPlayedData {
        // message fields
        app_id: ::std::option::Option<u32>,
        forever: ::std::option::Option<i32>,
        last_two_weeks: ::std::option::Option<i32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a AppMinutesPlayedData {
        fn default() -> &'a AppMinutesPlayedData {
            <AppMinutesPlayedData as ::protobuf::Message>::default_instance()
        }
    }

    impl AppMinutesPlayedData {
        pub fn new() -> AppMinutesPlayedData {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn get_app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional int32 forever = 2;

        pub fn get_forever(&self) -> i32 {
            self.forever.unwrap_or(0)
        }

        pub fn clear_forever(&mut self) {
            self.forever = ::std::option::Option::None;
        }

        pub fn has_forever(&self) -> bool {
            self.forever.is_some()
        }

        // Param is passed by value, moved
        pub fn set_forever(&mut self, v: i32) {
            self.forever = ::std::option::Option::Some(v);
        }

        // optional int32 last_two_weeks = 3;

        pub fn get_last_two_weeks(&self) -> i32 {
            self.last_two_weeks.unwrap_or(0)
        }

        pub fn clear_last_two_weeks(&mut self) {
            self.last_two_weeks = ::std::option::Option::None;
        }

        pub fn has_last_two_weeks(&self) -> bool {
            self.last_two_weeks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_two_weeks(&mut self, v: i32) {
            self.last_two_weeks = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AppMinutesPlayedData {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.forever = ::std::option::Option::Some(is.read_int32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.last_two_weeks = ::std::option::Option::Some(is.read_int32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.forever {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.last_two_weeks {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.forever {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.last_two_weeks {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> AppMinutesPlayedData {
            AppMinutesPlayedData::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "app_id",
                    |m: &AppMinutesPlayedData| { &m.app_id },
                    |m: &mut AppMinutesPlayedData| { &mut m.app_id },
                    AppMinutesPlayedData::get_app_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "forever",
                    |m: &AppMinutesPlayedData| { &m.forever },
                    |m: &mut AppMinutesPlayedData| { &mut m.forever },
                    AppMinutesPlayedData::get_forever,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "last_two_weeks",
                    |m: &AppMinutesPlayedData| { &m.last_two_weeks },
                    |m: &mut AppMinutesPlayedData| { &mut m.last_two_weeks },
                    AppMinutesPlayedData::get_last_two_weeks,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppMinutesPlayedData>(
                    "CMsgClientAppMinutesPlayedData.AppMinutesPlayedData",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static AppMinutesPlayedData {
            static instance: ::protobuf::rt::Lazy<AppMinutesPlayedData> = ::protobuf::rt::Lazy::INIT;
            instance.get(AppMinutesPlayedData::new)
        }
    }

    impl ::protobuf::Clear for AppMinutesPlayedData {
        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.forever = ::std::option::Option::None;
            self.last_two_weeks = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for AppMinutesPlayedData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppMinutesPlayedData {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientIsLimitedAccount {
    // message fields
    bis_limited_account: ::std::option::Option<bool>,
    bis_community_banned: ::std::option::Option<bool>,
    bis_locked_account: ::std::option::Option<bool>,
    bis_limited_account_allowed_to_invite_friends: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientIsLimitedAccount {
    fn default() -> &'a CMsgClientIsLimitedAccount {
        <CMsgClientIsLimitedAccount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientIsLimitedAccount {
    pub fn new() -> CMsgClientIsLimitedAccount {
        ::std::default::Default::default()
    }

    // optional bool bis_limited_account = 1;

    pub fn get_bis_limited_account(&self) -> bool {
        self.bis_limited_account.unwrap_or(false)
    }

    pub fn clear_bis_limited_account(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account(&self) -> bool {
        self.bis_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account(&mut self, v: bool) {
        self.bis_limited_account = ::std::option::Option::Some(v);
    }

    // optional bool bis_community_banned = 2;

    pub fn get_bis_community_banned(&self) -> bool {
        self.bis_community_banned.unwrap_or(false)
    }

    pub fn clear_bis_community_banned(&mut self) {
        self.bis_community_banned = ::std::option::Option::None;
    }

    pub fn has_bis_community_banned(&self) -> bool {
        self.bis_community_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_community_banned(&mut self, v: bool) {
        self.bis_community_banned = ::std::option::Option::Some(v);
    }

    // optional bool bis_locked_account = 3;

    pub fn get_bis_locked_account(&self) -> bool {
        self.bis_locked_account.unwrap_or(false)
    }

    pub fn clear_bis_locked_account(&mut self) {
        self.bis_locked_account = ::std::option::Option::None;
    }

    pub fn has_bis_locked_account(&self) -> bool {
        self.bis_locked_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_locked_account(&mut self, v: bool) {
        self.bis_locked_account = ::std::option::Option::Some(v);
    }

    // optional bool bis_limited_account_allowed_to_invite_friends = 4;

    pub fn get_bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.unwrap_or(false)
    }

    pub fn clear_bis_limited_account_allowed_to_invite_friends(&mut self) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account_allowed_to_invite_friends(&mut self, v: bool) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientIsLimitedAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bis_limited_account = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bis_community_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bis_locked_account = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bis_limited_account {
            my_size += 2;
        }
        if let Some(v) = self.bis_community_banned {
            my_size += 2;
        }
        if let Some(v) = self.bis_locked_account {
            my_size += 2;
        }
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bis_limited_account {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bis_community_banned {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bis_locked_account {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientIsLimitedAccount {
        CMsgClientIsLimitedAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "bis_limited_account",
                |m: &CMsgClientIsLimitedAccount| { &m.bis_limited_account },
                |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_limited_account },
                CMsgClientIsLimitedAccount::get_bis_limited_account,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "bis_community_banned",
                |m: &CMsgClientIsLimitedAccount| { &m.bis_community_banned },
                |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_community_banned },
                CMsgClientIsLimitedAccount::get_bis_community_banned,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "bis_locked_account",
                |m: &CMsgClientIsLimitedAccount| { &m.bis_locked_account },
                |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_locked_account },
                CMsgClientIsLimitedAccount::get_bis_locked_account,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "bis_limited_account_allowed_to_invite_friends",
                |m: &CMsgClientIsLimitedAccount| { &m.bis_limited_account_allowed_to_invite_friends },
                |m: &mut CMsgClientIsLimitedAccount| { &mut m.bis_limited_account_allowed_to_invite_friends },
                CMsgClientIsLimitedAccount::get_bis_limited_account_allowed_to_invite_friends,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientIsLimitedAccount>(
                "CMsgClientIsLimitedAccount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientIsLimitedAccount {
        static instance: ::protobuf::rt::Lazy<CMsgClientIsLimitedAccount> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientIsLimitedAccount::new)
    }
}

impl ::protobuf::Clear for CMsgClientIsLimitedAccount {
    fn clear(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
        self.bis_community_banned = ::std::option::Option::None;
        self.bis_locked_account = ::std::option::Option::None;
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientIsLimitedAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientIsLimitedAccount {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestedClientStats {
    // message fields
    pub stats_to_send: ::protobuf::RepeatedField<cmsg_client_requested_client_stats::StatsToSend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestedClientStats {
    fn default() -> &'a CMsgClientRequestedClientStats {
        <CMsgClientRequestedClientStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestedClientStats {
    pub fn new() -> CMsgClientRequestedClientStats {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestedClientStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats_to_send {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.stats_to_send)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stats_to_send {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stats_to_send {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestedClientStats {
        CMsgClientRequestedClientStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_requested_client_stats::StatsToSend>>(
                "stats_to_send",
                |m: &CMsgClientRequestedClientStats| { &m.stats_to_send },
                |m: &mut CMsgClientRequestedClientStats| { &mut m.stats_to_send },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestedClientStats>(
                "CMsgClientRequestedClientStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestedClientStats {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestedClientStats> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestedClientStats::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestedClientStats {
    fn clear(&mut self) {
        self.stats_to_send.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestedClientStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestedClientStats {
}

/// Nested message and enums of message `CMsgClientRequestedClientStats`
pub mod cmsg_client_requested_client_stats {
    #[derive(PartialEq,Clone,Default)]
    pub struct StatsToSend {
        // message fields
        client_stat: ::std::option::Option<u32>,
        stat_aggregate_method: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a StatsToSend {
        fn default() -> &'a StatsToSend {
            <StatsToSend as ::protobuf::Message>::default_instance()
        }
    }

    impl StatsToSend {
        pub fn new() -> StatsToSend {
            ::std::default::Default::default()
        }

        // optional uint32 client_stat = 1;

        pub fn get_client_stat(&self) -> u32 {
            self.client_stat.unwrap_or(0)
        }

        pub fn clear_client_stat(&mut self) {
            self.client_stat = ::std::option::Option::None;
        }

        pub fn has_client_stat(&self) -> bool {
            self.client_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_stat(&mut self, v: u32) {
            self.client_stat = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_aggregate_method = 2;

        pub fn get_stat_aggregate_method(&self) -> u32 {
            self.stat_aggregate_method.unwrap_or(0)
        }

        pub fn clear_stat_aggregate_method(&mut self) {
            self.stat_aggregate_method = ::std::option::Option::None;
        }

        pub fn has_stat_aggregate_method(&self) -> bool {
            self.stat_aggregate_method.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_aggregate_method(&mut self, v: u32) {
            self.stat_aggregate_method = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for StatsToSend {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.client_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stat_aggregate_method = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.client_stat {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.stat_aggregate_method {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.client_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_aggregate_method {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> StatsToSend {
            StatsToSend::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "client_stat",
                    |m: &StatsToSend| { &m.client_stat },
                    |m: &mut StatsToSend| { &mut m.client_stat },
                    StatsToSend::get_client_stat,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stat_aggregate_method",
                    |m: &StatsToSend| { &m.stat_aggregate_method },
                    |m: &mut StatsToSend| { &mut m.stat_aggregate_method },
                    StatsToSend::get_stat_aggregate_method,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatsToSend>(
                    "CMsgClientRequestedClientStats.StatsToSend",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static StatsToSend {
            static instance: ::protobuf::rt::Lazy<StatsToSend> = ::protobuf::rt::Lazy::INIT;
            instance.get(StatsToSend::new)
        }
    }

    impl ::protobuf::Clear for StatsToSend {
        fn clear(&mut self) {
            self.client_stat = ::std::option::Option::None;
            self.stat_aggregate_method = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for StatsToSend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StatsToSend {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStat2 {
    // message fields
    pub stat_detail: ::protobuf::RepeatedField<cmsg_client_stat2::StatDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStat2 {
    fn default() -> &'a CMsgClientStat2 {
        <CMsgClientStat2 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStat2 {
    pub fn new() -> CMsgClientStat2 {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientStat2 {
    fn is_initialized(&self) -> bool {
        for v in &self.stat_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.stat_detail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stat_detail {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stat_detail {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStat2 {
        CMsgClientStat2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_stat2::StatDetail>>(
                "stat_detail",
                |m: &CMsgClientStat2| { &m.stat_detail },
                |m: &mut CMsgClientStat2| { &mut m.stat_detail },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStat2>(
                "CMsgClientStat2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStat2 {
        static instance: ::protobuf::rt::Lazy<CMsgClientStat2> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientStat2::new)
    }
}

impl ::protobuf::Clear for CMsgClientStat2 {
    fn clear(&mut self) {
        self.stat_detail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStat2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStat2 {
}

/// Nested message and enums of message `CMsgClientStat2`
pub mod cmsg_client_stat2 {
    #[derive(PartialEq,Clone,Default)]
    pub struct StatDetail {
        // message fields
        client_stat: ::std::option::Option<u32>,
        ll_value: ::std::option::Option<i64>,
        time_of_day: ::std::option::Option<u32>,
        cell_id: ::std::option::Option<u32>,
        depot_id: ::std::option::Option<u32>,
        app_id: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a StatDetail {
        fn default() -> &'a StatDetail {
            <StatDetail as ::protobuf::Message>::default_instance()
        }
    }

    impl StatDetail {
        pub fn new() -> StatDetail {
            ::std::default::Default::default()
        }

        // optional uint32 client_stat = 1;

        pub fn get_client_stat(&self) -> u32 {
            self.client_stat.unwrap_or(0)
        }

        pub fn clear_client_stat(&mut self) {
            self.client_stat = ::std::option::Option::None;
        }

        pub fn has_client_stat(&self) -> bool {
            self.client_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_stat(&mut self, v: u32) {
            self.client_stat = ::std::option::Option::Some(v);
        }

        // optional int64 ll_value = 2;

        pub fn get_ll_value(&self) -> i64 {
            self.ll_value.unwrap_or(0)
        }

        pub fn clear_ll_value(&mut self) {
            self.ll_value = ::std::option::Option::None;
        }

        pub fn has_ll_value(&self) -> bool {
            self.ll_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ll_value(&mut self, v: i64) {
            self.ll_value = ::std::option::Option::Some(v);
        }

        // optional uint32 time_of_day = 3;

        pub fn get_time_of_day(&self) -> u32 {
            self.time_of_day.unwrap_or(0)
        }

        pub fn clear_time_of_day(&mut self) {
            self.time_of_day = ::std::option::Option::None;
        }

        pub fn has_time_of_day(&self) -> bool {
            self.time_of_day.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_of_day(&mut self, v: u32) {
            self.time_of_day = ::std::option::Option::Some(v);
        }

        // optional uint32 cell_id = 4;

        pub fn get_cell_id(&self) -> u32 {
            self.cell_id.unwrap_or(0)
        }

        pub fn clear_cell_id(&mut self) {
            self.cell_id = ::std::option::Option::None;
        }

        pub fn has_cell_id(&self) -> bool {
            self.cell_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cell_id(&mut self, v: u32) {
            self.cell_id = ::std::option::Option::Some(v);
        }

        // optional uint32 depot_id = 5;

        pub fn get_depot_id(&self) -> u32 {
            self.depot_id.unwrap_or(0)
        }

        pub fn clear_depot_id(&mut self) {
            self.depot_id = ::std::option::Option::None;
        }

        pub fn has_depot_id(&self) -> bool {
            self.depot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_depot_id(&mut self, v: u32) {
            self.depot_id = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 6;

        pub fn get_app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for StatDetail {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.client_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.ll_value = ::std::option::Option::Some(is.read_int64()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_of_day = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.client_stat {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.ll_value {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.time_of_day {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.cell_id {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.depot_id {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.client_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ll_value {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.time_of_day {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.cell_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.depot_id {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> StatDetail {
            StatDetail::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "client_stat",
                    |m: &StatDetail| { &m.client_stat },
                    |m: &mut StatDetail| { &mut m.client_stat },
                    StatDetail::get_client_stat,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt64, _>(
                    "ll_value",
                    |m: &StatDetail| { &m.ll_value },
                    |m: &mut StatDetail| { &mut m.ll_value },
                    StatDetail::get_ll_value,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_of_day",
                    |m: &StatDetail| { &m.time_of_day },
                    |m: &mut StatDetail| { &mut m.time_of_day },
                    StatDetail::get_time_of_day,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "cell_id",
                    |m: &StatDetail| { &m.cell_id },
                    |m: &mut StatDetail| { &mut m.cell_id },
                    StatDetail::get_cell_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "depot_id",
                    |m: &StatDetail| { &m.depot_id },
                    |m: &mut StatDetail| { &mut m.depot_id },
                    StatDetail::get_depot_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "app_id",
                    |m: &StatDetail| { &m.app_id },
                    |m: &mut StatDetail| { &mut m.app_id },
                    StatDetail::get_app_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatDetail>(
                    "CMsgClientStat2.StatDetail",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static StatDetail {
            static instance: ::protobuf::rt::Lazy<StatDetail> = ::protobuf::rt::Lazy::INIT;
            instance.get(StatDetail::new)
        }
    }

    impl ::protobuf::Clear for StatDetail {
        fn clear(&mut self) {
            self.client_stat = ::std::option::Option::None;
            self.ll_value = ::std::option::Option::None;
            self.time_of_day = ::std::option::Option::None;
            self.cell_id = ::std::option::Option::None;
            self.depot_id = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for StatDetail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StatDetail {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetRatelimitPolicyOnClient {
    // message fields
    app_id: ::std::option::Option<u32>,
    enable_rate_limits: ::std::option::Option<bool>,
    seconds_per_message: ::std::option::Option<i32>,
    milliseconds_per_data_update: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetRatelimitPolicyOnClient {
    fn default() -> &'a CMsgClientMMSSetRatelimitPolicyOnClient {
        <CMsgClientMMSSetRatelimitPolicyOnClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetRatelimitPolicyOnClient {
    pub fn new() -> CMsgClientMMSSetRatelimitPolicyOnClient {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bool enable_rate_limits = 2;

    pub fn get_enable_rate_limits(&self) -> bool {
        self.enable_rate_limits.unwrap_or(false)
    }

    pub fn clear_enable_rate_limits(&mut self) {
        self.enable_rate_limits = ::std::option::Option::None;
    }

    pub fn has_enable_rate_limits(&self) -> bool {
        self.enable_rate_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_rate_limits(&mut self, v: bool) {
        self.enable_rate_limits = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_per_message = 3;

    pub fn get_seconds_per_message(&self) -> i32 {
        self.seconds_per_message.unwrap_or(0)
    }

    pub fn clear_seconds_per_message(&mut self) {
        self.seconds_per_message = ::std::option::Option::None;
    }

    pub fn has_seconds_per_message(&self) -> bool {
        self.seconds_per_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_per_message(&mut self, v: i32) {
        self.seconds_per_message = ::std::option::Option::Some(v);
    }

    // optional int32 milliseconds_per_data_update = 4;

    pub fn get_milliseconds_per_data_update(&self) -> i32 {
        self.milliseconds_per_data_update.unwrap_or(0)
    }

    pub fn clear_milliseconds_per_data_update(&mut self) {
        self.milliseconds_per_data_update = ::std::option::Option::None;
    }

    pub fn has_milliseconds_per_data_update(&self) -> bool {
        self.milliseconds_per_data_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_milliseconds_per_data_update(&mut self, v: i32) {
        self.milliseconds_per_data_update = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_rate_limits = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.seconds_per_message = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.milliseconds_per_data_update = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.enable_rate_limits {
            my_size += 2;
        }
        if let Some(v) = self.seconds_per_message {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.milliseconds_per_data_update {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.enable_rate_limits {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.seconds_per_message {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.milliseconds_per_data_update {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetRatelimitPolicyOnClient {
        CMsgClientMMSSetRatelimitPolicyOnClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.app_id },
                |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.app_id },
                CMsgClientMMSSetRatelimitPolicyOnClient::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_rate_limits",
                |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.enable_rate_limits },
                |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.enable_rate_limits },
                CMsgClientMMSSetRatelimitPolicyOnClient::get_enable_rate_limits,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "seconds_per_message",
                |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.seconds_per_message },
                |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.seconds_per_message },
                CMsgClientMMSSetRatelimitPolicyOnClient::get_seconds_per_message,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "milliseconds_per_data_update",
                |m: &CMsgClientMMSSetRatelimitPolicyOnClient| { &m.milliseconds_per_data_update },
                |m: &mut CMsgClientMMSSetRatelimitPolicyOnClient| { &mut m.milliseconds_per_data_update },
                CMsgClientMMSSetRatelimitPolicyOnClient::get_milliseconds_per_data_update,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetRatelimitPolicyOnClient>(
                "CMsgClientMMSSetRatelimitPolicyOnClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetRatelimitPolicyOnClient {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSSetRatelimitPolicyOnClient> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSSetRatelimitPolicyOnClient::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.enable_rate_limits = ::std::option::Option::None;
        self.seconds_per_message = ::std::option::Option::None;
        self.milliseconds_per_data_update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetRatelimitPolicyOnClient {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSCreateLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    cell_id: ::std::option::Option<u32>,
    deprecated_public_ip: ::std::option::Option<u32>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    persona_name_owner: ::protobuf::SingularField<::std::string::String>,
    pub public_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSCreateLobby {
    fn default() -> &'a CMsgClientMMSCreateLobby {
        <CMsgClientMMSCreateLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSCreateLobby {
    pub fn new() -> CMsgClientMMSCreateLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 2;

    pub fn get_max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 3;

    pub fn get_lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 4;

    pub fn get_lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 5;

    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 6;

    pub fn get_deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 7;

    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string persona_name_owner = 8;

    pub fn get_persona_name_owner(&self) -> &str {
        match self.persona_name_owner.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name_owner(&mut self) {
        self.persona_name_owner.clear();
    }

    pub fn has_persona_name_owner(&self) -> bool {
        self.persona_name_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_owner(&mut self, v: ::std::string::String) {
        self.persona_name_owner = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_owner(&mut self) -> &mut ::std::string::String {
        if self.persona_name_owner.is_none() {
            self.persona_name_owner.set_default();
        }
        self.persona_name_owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_owner(&mut self) -> ::std::string::String {
        self.persona_name_owner.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSCreateLobby {
    fn is_initialized(&self) -> bool {
        for v in &self.public_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name_owner)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into::<super::steammessages_base::CMsgIPAddress, _>(wire_type, is, &mut self.public_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.persona_name_owner.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.persona_name_owner.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.public_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSCreateLobby {
        CMsgClientMMSCreateLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSCreateLobby| { &m.app_id },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.app_id },
                CMsgClientMMSCreateLobby::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "max_members",
                |m: &CMsgClientMMSCreateLobby| { &m.max_members },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.max_members },
                CMsgClientMMSCreateLobby::get_max_members,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "lobby_type",
                |m: &CMsgClientMMSCreateLobby| { &m.lobby_type },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.lobby_type },
                CMsgClientMMSCreateLobby::get_lobby_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "lobby_flags",
                |m: &CMsgClientMMSCreateLobby| { &m.lobby_flags },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.lobby_flags },
                CMsgClientMMSCreateLobby::get_lobby_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cell_id",
                |m: &CMsgClientMMSCreateLobby| { &m.cell_id },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.cell_id },
                CMsgClientMMSCreateLobby::get_cell_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "deprecated_public_ip",
                |m: &CMsgClientMMSCreateLobby| { &m.deprecated_public_ip },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.deprecated_public_ip },
                CMsgClientMMSCreateLobby::get_deprecated_public_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "metadata",
                |m: &CMsgClientMMSCreateLobby| { &m.metadata },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.metadata },
                CMsgClientMMSCreateLobby::get_metadata,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "persona_name_owner",
                |m: &CMsgClientMMSCreateLobby| { &m.persona_name_owner },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.persona_name_owner },
                CMsgClientMMSCreateLobby::get_persona_name_owner,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>, _>(
                "public_ip",
                |m: &CMsgClientMMSCreateLobby| { &m.public_ip },
                |m: &mut CMsgClientMMSCreateLobby| { &mut m.public_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSCreateLobby>(
                "CMsgClientMMSCreateLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSCreateLobby {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSCreateLobby> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSCreateLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSCreateLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.metadata.clear();
        self.persona_name_owner.clear();
        self.public_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSCreateLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSCreateLobby {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSCreateLobbyResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSCreateLobbyResponse {
    fn default() -> &'a CMsgClientMMSCreateLobbyResponse {
        <CMsgClientMMSCreateLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSCreateLobbyResponse {
    pub fn new() -> CMsgClientMMSCreateLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSCreateLobbyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSCreateLobbyResponse {
        CMsgClientMMSCreateLobbyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSCreateLobbyResponse| { &m.app_id },
                |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.app_id },
                CMsgClientMMSCreateLobbyResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSCreateLobbyResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.steam_id_lobby },
                CMsgClientMMSCreateLobbyResponse::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientMMSCreateLobbyResponse| { &m.eresult },
                |m: &mut CMsgClientMMSCreateLobbyResponse| { &mut m.eresult },
                CMsgClientMMSCreateLobbyResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSCreateLobbyResponse>(
                "CMsgClientMMSCreateLobbyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSCreateLobbyResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSCreateLobbyResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSCreateLobbyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSCreateLobbyResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSCreateLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSCreateLobbyResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSJoinLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobby {
    fn default() -> &'a CMsgClientMMSJoinLobby {
        <CMsgClientMMSJoinLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobby {
    pub fn new() -> CMsgClientMMSJoinLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 3;

    pub fn get_persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSJoinLobby {
        CMsgClientMMSJoinLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSJoinLobby| { &m.app_id },
                |m: &mut CMsgClientMMSJoinLobby| { &mut m.app_id },
                CMsgClientMMSJoinLobby::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSJoinLobby| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSJoinLobby| { &mut m.steam_id_lobby },
                CMsgClientMMSJoinLobby::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "persona_name",
                |m: &CMsgClientMMSJoinLobby| { &m.persona_name },
                |m: &mut CMsgClientMMSJoinLobby| { &mut m.persona_name },
                CMsgClientMMSJoinLobby::get_persona_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSJoinLobby>(
                "CMsgClientMMSJoinLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobby {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSJoinLobby> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSJoinLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSJoinLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.persona_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSJoinLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSJoinLobby {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSJoinLobbyResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    chat_room_enter_response: ::std::option::Option<i32>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    steam_id_owner: ::std::option::Option<u64>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub members: ::protobuf::RepeatedField<cmsg_client_mmsjoin_lobby_response::Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobbyResponse {
    fn default() -> &'a CMsgClientMMSJoinLobbyResponse {
        <CMsgClientMMSJoinLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobbyResponse {
    pub fn new() -> CMsgClientMMSJoinLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 chat_room_enter_response = 3;

    pub fn get_chat_room_enter_response(&self) -> i32 {
        self.chat_room_enter_response.unwrap_or(0)
    }

    pub fn clear_chat_room_enter_response(&mut self) {
        self.chat_room_enter_response = ::std::option::Option::None;
    }

    pub fn has_chat_room_enter_response(&self) -> bool {
        self.chat_room_enter_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_enter_response(&mut self, v: i32) {
        self.chat_room_enter_response = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn get_max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn get_lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn get_lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_owner = 7;

    pub fn get_steam_id_owner(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 8;

    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobbyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chat_room_enter_response = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.chat_room_enter_response {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_owner {
            my_size += 9;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.chat_room_enter_response {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_id_owner {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(8, v)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSJoinLobbyResponse {
        CMsgClientMMSJoinLobbyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.app_id },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.app_id },
                CMsgClientMMSJoinLobbyResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.steam_id_lobby },
                CMsgClientMMSJoinLobbyResponse::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "chat_room_enter_response",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.chat_room_enter_response },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.chat_room_enter_response },
                CMsgClientMMSJoinLobbyResponse::get_chat_room_enter_response,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "max_members",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.max_members },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.max_members },
                CMsgClientMMSJoinLobbyResponse::get_max_members,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "lobby_type",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.lobby_type },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.lobby_type },
                CMsgClientMMSJoinLobbyResponse::get_lobby_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "lobby_flags",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.lobby_flags },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.lobby_flags },
                CMsgClientMMSJoinLobbyResponse::get_lobby_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_owner",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.steam_id_owner },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.steam_id_owner },
                CMsgClientMMSJoinLobbyResponse::get_steam_id_owner,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "metadata",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.metadata },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.metadata },
                CMsgClientMMSJoinLobbyResponse::get_metadata,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_mmsjoin_lobby_response::Member>>(
                "members",
                |m: &CMsgClientMMSJoinLobbyResponse| { &m.members },
                |m: &mut CMsgClientMMSJoinLobbyResponse| { &mut m.members },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSJoinLobbyResponse>(
                "CMsgClientMMSJoinLobbyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobbyResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSJoinLobbyResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSJoinLobbyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSJoinLobbyResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.chat_room_enter_response = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.steam_id_owner = ::std::option::Option::None;
        self.metadata.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSJoinLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSJoinLobbyResponse {
}

/// Nested message and enums of message `CMsgClientMMSJoinLobbyResponse`
pub mod cmsg_client_mmsjoin_lobby_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Member {
        // message fields
        steam_id: ::std::option::Option<u64>,
        persona_name: ::protobuf::SingularField<::std::string::String>,
        metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as ::protobuf::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn get_steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional string persona_name = 2;

        pub fn get_persona_name(&self) -> &str {
            match self.persona_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona_name(&mut self) {
            self.persona_name.clear();
        }

        pub fn has_persona_name(&self) -> bool {
            self.persona_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_name(&mut self, v: ::std::string::String) {
            self.persona_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
            if self.persona_name.is_none() {
                self.persona_name.set_default();
            }
            self.persona_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona_name(&mut self) -> ::std::string::String {
            self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes metadata = 3;

        pub fn get_metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata.clear();
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
            self.metadata = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.metadata.is_none() {
                self.metadata.set_default();
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
            self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for Member {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                    },
                    3 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 9;
            }
            if let Some(v) = self.persona_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Member {
            Member::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steam_id",
                    |m: &Member| { &m.steam_id },
                    |m: &mut Member| { &mut m.steam_id },
                    Member::get_steam_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "persona_name",
                    |m: &Member| { &m.persona_name },
                    |m: &mut Member| { &mut m.persona_name },
                    Member::get_persona_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "metadata",
                    |m: &Member| { &m.metadata },
                    |m: &mut Member| { &mut m.metadata },
                    Member::get_metadata,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Member>(
                    "CMsgClientMMSJoinLobbyResponse.Member",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Member {
            static instance: ::protobuf::rt::Lazy<Member> = ::protobuf::rt::Lazy::INIT;
            instance.get(Member::new)
        }
    }

    impl ::protobuf::Clear for Member {
        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.persona_name.clear();
            self.metadata.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Member {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Member {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLeaveLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLeaveLobby {
    fn default() -> &'a CMsgClientMMSLeaveLobby {
        <CMsgClientMMSLeaveLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLeaveLobby {
    pub fn new() -> CMsgClientMMSLeaveLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLeaveLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLeaveLobby {
        CMsgClientMMSLeaveLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSLeaveLobby| { &m.app_id },
                |m: &mut CMsgClientMMSLeaveLobby| { &mut m.app_id },
                CMsgClientMMSLeaveLobby::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSLeaveLobby| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSLeaveLobby| { &mut m.steam_id_lobby },
                CMsgClientMMSLeaveLobby::get_steam_id_lobby,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLeaveLobby>(
                "CMsgClientMMSLeaveLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLeaveLobby {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSLeaveLobby> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSLeaveLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLeaveLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLeaveLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLeaveLobby {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLeaveLobbyResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLeaveLobbyResponse {
    fn default() -> &'a CMsgClientMMSLeaveLobbyResponse {
        <CMsgClientMMSLeaveLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLeaveLobbyResponse {
    pub fn new() -> CMsgClientMMSLeaveLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLeaveLobbyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLeaveLobbyResponse {
        CMsgClientMMSLeaveLobbyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSLeaveLobbyResponse| { &m.app_id },
                |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.app_id },
                CMsgClientMMSLeaveLobbyResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSLeaveLobbyResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.steam_id_lobby },
                CMsgClientMMSLeaveLobbyResponse::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientMMSLeaveLobbyResponse| { &m.eresult },
                |m: &mut CMsgClientMMSLeaveLobbyResponse| { &mut m.eresult },
                CMsgClientMMSLeaveLobbyResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLeaveLobbyResponse>(
                "CMsgClientMMSLeaveLobbyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLeaveLobbyResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSLeaveLobbyResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSLeaveLobbyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLeaveLobbyResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLeaveLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLeaveLobbyResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyList {
    // message fields
    app_id: ::std::option::Option<u32>,
    num_lobbies_requested: ::std::option::Option<i32>,
    cell_id: ::std::option::Option<u32>,
    deprecated_public_ip: ::std::option::Option<u32>,
    pub filters: ::protobuf::RepeatedField<cmsg_client_mmsget_lobby_list::Filter>,
    pub public_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyList {
    fn default() -> &'a CMsgClientMMSGetLobbyList {
        <CMsgClientMMSGetLobbyList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyList {
    pub fn new() -> CMsgClientMMSGetLobbyList {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_lobbies_requested = 3;

    pub fn get_num_lobbies_requested(&self) -> i32 {
        self.num_lobbies_requested.unwrap_or(0)
    }

    pub fn clear_num_lobbies_requested(&mut self) {
        self.num_lobbies_requested = ::std::option::Option::None;
    }

    pub fn has_num_lobbies_requested(&self) -> bool {
        self.num_lobbies_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_lobbies_requested(&mut self, v: i32) {
        self.num_lobbies_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 4;

    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 5;

    pub fn get_deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyList {
    fn is_initialized(&self) -> bool {
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.public_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_lobbies_requested = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.filters)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into::<super::steammessages_base::CMsgIPAddress, _>(wire_type, is, &mut self.public_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_lobbies_requested {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_lobbies_requested {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(5, v)?;
        }
        for v in &self.filters {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.public_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyList {
        CMsgClientMMSGetLobbyList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSGetLobbyList| { &m.app_id },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.app_id },
                CMsgClientMMSGetLobbyList::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "num_lobbies_requested",
                |m: &CMsgClientMMSGetLobbyList| { &m.num_lobbies_requested },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.num_lobbies_requested },
                CMsgClientMMSGetLobbyList::get_num_lobbies_requested,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cell_id",
                |m: &CMsgClientMMSGetLobbyList| { &m.cell_id },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.cell_id },
                CMsgClientMMSGetLobbyList::get_cell_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "deprecated_public_ip",
                |m: &CMsgClientMMSGetLobbyList| { &m.deprecated_public_ip },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.deprecated_public_ip },
                CMsgClientMMSGetLobbyList::get_deprecated_public_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_mmsget_lobby_list::Filter>>(
                "filters",
                |m: &CMsgClientMMSGetLobbyList| { &m.filters },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.filters },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>, _>(
                "public_ip",
                |m: &CMsgClientMMSGetLobbyList| { &m.public_ip },
                |m: &mut CMsgClientMMSGetLobbyList| { &mut m.public_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSGetLobbyList>(
                "CMsgClientMMSGetLobbyList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyList {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSGetLobbyList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSGetLobbyList::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyList {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.num_lobbies_requested = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.filters.clear();
        self.public_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyList {
}

/// Nested message and enums of message `CMsgClientMMSGetLobbyList`
pub mod cmsg_client_mmsget_lobby_list {
    #[derive(PartialEq,Clone,Default)]
    pub struct Filter {
        // message fields
        key: ::protobuf::SingularField<::std::string::String>,
        value: ::protobuf::SingularField<::std::string::String>,
        comparision: ::std::option::Option<i32>,
        filter_type: ::std::option::Option<i32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as ::protobuf::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn get_key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key.clear();
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key.set_default();
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn get_value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value.clear();
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value.set_default();
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 comparision = 3;

        pub fn get_comparision(&self) -> i32 {
            self.comparision.unwrap_or(0)
        }

        pub fn clear_comparision(&mut self) {
            self.comparision = ::std::option::Option::None;
        }

        pub fn has_comparision(&self) -> bool {
            self.comparision.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comparision(&mut self, v: i32) {
            self.comparision = ::std::option::Option::Some(v);
        }

        // optional int32 filter_type = 4;

        pub fn get_filter_type(&self) -> i32 {
            self.filter_type.unwrap_or(0)
        }

        pub fn clear_filter_type(&mut self) {
            self.filter_type = ::std::option::Option::None;
        }

        pub fn has_filter_type(&self) -> bool {
            self.filter_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filter_type(&mut self, v: i32) {
            self.filter_type = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Filter {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.comparision = ::std::option::Option::Some(is.read_int32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.filter_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.comparision {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.filter_type {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.comparision {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.filter_type {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "key",
                    |m: &Filter| { &m.key },
                    |m: &mut Filter| { &mut m.key },
                    Filter::get_key,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "value",
                    |m: &Filter| { &m.value },
                    |m: &mut Filter| { &mut m.value },
                    Filter::get_value,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "comparision",
                    |m: &Filter| { &m.comparision },
                    |m: &mut Filter| { &mut m.comparision },
                    Filter::get_comparision,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "filter_type",
                    |m: &Filter| { &m.filter_type },
                    |m: &mut Filter| { &mut m.filter_type },
                    Filter::get_filter_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Filter>(
                    "CMsgClientMMSGetLobbyList.Filter",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Filter {
            static instance: ::protobuf::rt::Lazy<Filter> = ::protobuf::rt::Lazy::INIT;
            instance.get(Filter::new)
        }
    }

    impl ::protobuf::Clear for Filter {
        fn clear(&mut self) {
            self.key.clear();
            self.value.clear();
            self.comparision = ::std::option::Option::None;
            self.filter_type = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Filter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Filter {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyListResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    eresult: ::std::option::Option<i32>,
    pub lobbies: ::protobuf::RepeatedField<cmsg_client_mmsget_lobby_list_response::Lobby>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyListResponse {
    fn default() -> &'a CMsgClientMMSGetLobbyListResponse {
        <CMsgClientMMSGetLobbyListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyListResponse {
    pub fn new() -> CMsgClientMMSGetLobbyListResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.lobbies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.lobbies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        for v in &self.lobbies {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyListResponse {
        CMsgClientMMSGetLobbyListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSGetLobbyListResponse| { &m.app_id },
                |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.app_id },
                CMsgClientMMSGetLobbyListResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientMMSGetLobbyListResponse| { &m.eresult },
                |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.eresult },
                CMsgClientMMSGetLobbyListResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_mmsget_lobby_list_response::Lobby>>(
                "lobbies",
                |m: &CMsgClientMMSGetLobbyListResponse| { &m.lobbies },
                |m: &mut CMsgClientMMSGetLobbyListResponse| { &mut m.lobbies },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSGetLobbyListResponse>(
                "CMsgClientMMSGetLobbyListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyListResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSGetLobbyListResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSGetLobbyListResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyListResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.lobbies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyListResponse {
}

/// Nested message and enums of message `CMsgClientMMSGetLobbyListResponse`
pub mod cmsg_client_mmsget_lobby_list_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Lobby {
        // message fields
        steam_id: ::std::option::Option<u64>,
        max_members: ::std::option::Option<i32>,
        lobby_type: ::std::option::Option<i32>,
        lobby_flags: ::std::option::Option<i32>,
        metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        num_members: ::std::option::Option<i32>,
        distance: ::std::option::Option<f32>,
        weight: ::std::option::Option<i64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Lobby {
        fn default() -> &'a Lobby {
            <Lobby as ::protobuf::Message>::default_instance()
        }
    }

    impl Lobby {
        pub fn new() -> Lobby {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn get_steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional int32 max_members = 2;

        pub fn get_max_members(&self) -> i32 {
            self.max_members.unwrap_or(0)
        }

        pub fn clear_max_members(&mut self) {
            self.max_members = ::std::option::Option::None;
        }

        pub fn has_max_members(&self) -> bool {
            self.max_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_members(&mut self, v: i32) {
            self.max_members = ::std::option::Option::Some(v);
        }

        // optional int32 lobby_type = 3;

        pub fn get_lobby_type(&self) -> i32 {
            self.lobby_type.unwrap_or(0)
        }

        pub fn clear_lobby_type(&mut self) {
            self.lobby_type = ::std::option::Option::None;
        }

        pub fn has_lobby_type(&self) -> bool {
            self.lobby_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_type(&mut self, v: i32) {
            self.lobby_type = ::std::option::Option::Some(v);
        }

        // optional int32 lobby_flags = 4;

        pub fn get_lobby_flags(&self) -> i32 {
            self.lobby_flags.unwrap_or(0)
        }

        pub fn clear_lobby_flags(&mut self) {
            self.lobby_flags = ::std::option::Option::None;
        }

        pub fn has_lobby_flags(&self) -> bool {
            self.lobby_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_flags(&mut self, v: i32) {
            self.lobby_flags = ::std::option::Option::Some(v);
        }

        // optional bytes metadata = 5;

        pub fn get_metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata.clear();
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
            self.metadata = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.metadata.is_none() {
                self.metadata.set_default();
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
            self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional int32 num_members = 6;

        pub fn get_num_members(&self) -> i32 {
            self.num_members.unwrap_or(0)
        }

        pub fn clear_num_members(&mut self) {
            self.num_members = ::std::option::Option::None;
        }

        pub fn has_num_members(&self) -> bool {
            self.num_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_members(&mut self, v: i32) {
            self.num_members = ::std::option::Option::Some(v);
        }

        // optional float distance = 7;

        pub fn get_distance(&self) -> f32 {
            self.distance.unwrap_or(0.)
        }

        pub fn clear_distance(&mut self) {
            self.distance = ::std::option::Option::None;
        }

        pub fn has_distance(&self) -> bool {
            self.distance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_distance(&mut self, v: f32) {
            self.distance = ::std::option::Option::Some(v);
        }

        // optional int64 weight = 8;

        pub fn get_weight(&self) -> i64 {
            self.weight.unwrap_or(0)
        }

        pub fn clear_weight(&mut self) {
            self.weight = ::std::option::Option::None;
        }

        pub fn has_weight(&self) -> bool {
            self.weight.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weight(&mut self, v: i64) {
            self.weight = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Lobby {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.max_members = ::std::option::Option::Some(is.read_int32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    5 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.num_members = ::std::option::Option::Some(is.read_int32()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.distance = ::std::option::Option::Some(is.read_float()?);
                    },
                    8 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.weight = ::std::option::Option::Some(is.read_int64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 9;
            }
            if let Some(v) = self.max_members {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.lobby_type {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.lobby_flags {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += ::protobuf::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.num_members {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.distance {
                my_size += 5;
            }
            if let Some(v) = self.weight {
                my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.max_members {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.lobby_type {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.lobby_flags {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.num_members {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.distance {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.weight {
                os.write_int64(8, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Lobby {
            Lobby::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steam_id",
                    |m: &Lobby| { &m.steam_id },
                    |m: &mut Lobby| { &mut m.steam_id },
                    Lobby::get_steam_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "max_members",
                    |m: &Lobby| { &m.max_members },
                    |m: &mut Lobby| { &mut m.max_members },
                    Lobby::get_max_members,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "lobby_type",
                    |m: &Lobby| { &m.lobby_type },
                    |m: &mut Lobby| { &mut m.lobby_type },
                    Lobby::get_lobby_type,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "lobby_flags",
                    |m: &Lobby| { &m.lobby_flags },
                    |m: &mut Lobby| { &mut m.lobby_flags },
                    Lobby::get_lobby_flags,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "metadata",
                    |m: &Lobby| { &m.metadata },
                    |m: &mut Lobby| { &mut m.metadata },
                    Lobby::get_metadata,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "num_members",
                    |m: &Lobby| { &m.num_members },
                    |m: &mut Lobby| { &mut m.num_members },
                    Lobby::get_num_members,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                    "distance",
                    |m: &Lobby| { &m.distance },
                    |m: &mut Lobby| { &mut m.distance },
                    Lobby::get_distance,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt64, _>(
                    "weight",
                    |m: &Lobby| { &m.weight },
                    |m: &mut Lobby| { &mut m.weight },
                    Lobby::get_weight,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Lobby>(
                    "CMsgClientMMSGetLobbyListResponse.Lobby",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Lobby {
            static instance: ::protobuf::rt::Lazy<Lobby> = ::protobuf::rt::Lazy::INIT;
            instance.get(Lobby::new)
        }
    }

    impl ::protobuf::Clear for Lobby {
        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.max_members = ::std::option::Option::None;
            self.lobby_type = ::std::option::Option::None;
            self.lobby_flags = ::std::option::Option::None;
            self.metadata.clear();
            self.num_members = ::std::option::Option::None;
            self.distance = ::std::option::Option::None;
            self.weight = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Lobby {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Lobby {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyData {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_member: ::std::option::Option<u64>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyData {
    fn default() -> &'a CMsgClientMMSSetLobbyData {
        <CMsgClientMMSSetLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyData {
    pub fn new() -> CMsgClientMMSSetLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_member = 3;

    pub fn get_steam_id_member(&self) -> u64 {
        self.steam_id_member.unwrap_or(0)
    }

    pub fn clear_steam_id_member(&mut self) {
        self.steam_id_member = ::std::option::Option::None;
    }

    pub fn has_steam_id_member(&self) -> bool {
        self.steam_id_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_member(&mut self, v: u64) {
        self.steam_id_member = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn get_max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn get_lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn get_lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 7;

    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_member = ::std::option::Option::Some(is.read_fixed64()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_member {
            my_size += 9;
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_member {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyData {
        CMsgClientMMSSetLobbyData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyData| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.app_id },
                CMsgClientMMSSetLobbyData::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyData| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.steam_id_lobby },
                CMsgClientMMSSetLobbyData::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_member",
                |m: &CMsgClientMMSSetLobbyData| { &m.steam_id_member },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.steam_id_member },
                CMsgClientMMSSetLobbyData::get_steam_id_member,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "max_members",
                |m: &CMsgClientMMSSetLobbyData| { &m.max_members },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.max_members },
                CMsgClientMMSSetLobbyData::get_max_members,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "lobby_type",
                |m: &CMsgClientMMSSetLobbyData| { &m.lobby_type },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.lobby_type },
                CMsgClientMMSSetLobbyData::get_lobby_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "lobby_flags",
                |m: &CMsgClientMMSSetLobbyData| { &m.lobby_flags },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.lobby_flags },
                CMsgClientMMSSetLobbyData::get_lobby_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "metadata",
                |m: &CMsgClientMMSSetLobbyData| { &m.metadata },
                |m: &mut CMsgClientMMSSetLobbyData| { &mut m.metadata },
                CMsgClientMMSSetLobbyData::get_metadata,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyData>(
                "CMsgClientMMSSetLobbyData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyData {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSSetLobbyData> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSSetLobbyData::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyData {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_member = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyData {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyDataResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyDataResponse {
    fn default() -> &'a CMsgClientMMSSetLobbyDataResponse {
        <CMsgClientMMSSetLobbyDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyDataResponse {
    pub fn new() -> CMsgClientMMSSetLobbyDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyDataResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyDataResponse {
        CMsgClientMMSSetLobbyDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyDataResponse| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.app_id },
                CMsgClientMMSSetLobbyDataResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyDataResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.steam_id_lobby },
                CMsgClientMMSSetLobbyDataResponse::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientMMSSetLobbyDataResponse| { &m.eresult },
                |m: &mut CMsgClientMMSSetLobbyDataResponse| { &mut m.eresult },
                CMsgClientMMSSetLobbyDataResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyDataResponse>(
                "CMsgClientMMSSetLobbyDataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyDataResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSSetLobbyDataResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSSetLobbyDataResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyDataResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyDataResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyData {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyData {
    fn default() -> &'a CMsgClientMMSGetLobbyData {
        <CMsgClientMMSGetLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyData {
    pub fn new() -> CMsgClientMMSGetLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyData {
        CMsgClientMMSGetLobbyData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSGetLobbyData| { &m.app_id },
                |m: &mut CMsgClientMMSGetLobbyData| { &mut m.app_id },
                CMsgClientMMSGetLobbyData::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSGetLobbyData| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSGetLobbyData| { &mut m.steam_id_lobby },
                CMsgClientMMSGetLobbyData::get_steam_id_lobby,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSGetLobbyData>(
                "CMsgClientMMSGetLobbyData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyData {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSGetLobbyData> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSGetLobbyData::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyData {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyData {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLobbyData {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    num_members: ::std::option::Option<i32>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    steam_id_owner: ::std::option::Option<u64>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub members: ::protobuf::RepeatedField<cmsg_client_mmslobby_data::Member>,
    lobby_cellid: ::std::option::Option<u32>,
    owner_should_accept_changes: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyData {
    fn default() -> &'a CMsgClientMMSLobbyData {
        <CMsgClientMMSLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyData {
    pub fn new() -> CMsgClientMMSLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 num_members = 3;

    pub fn get_num_members(&self) -> i32 {
        self.num_members.unwrap_or(0)
    }

    pub fn clear_num_members(&mut self) {
        self.num_members = ::std::option::Option::None;
    }

    pub fn has_num_members(&self) -> bool {
        self.num_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_members(&mut self, v: i32) {
        self.num_members = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn get_max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn get_lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn get_lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_owner = 7;

    pub fn get_steam_id_owner(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 8;

    pub fn get_metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 lobby_cellid = 10;

    pub fn get_lobby_cellid(&self) -> u32 {
        self.lobby_cellid.unwrap_or(0)
    }

    pub fn clear_lobby_cellid(&mut self) {
        self.lobby_cellid = ::std::option::Option::None;
    }

    pub fn has_lobby_cellid(&self) -> bool {
        self.lobby_cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_cellid(&mut self, v: u32) {
        self.lobby_cellid = ::std::option::Option::Some(v);
    }

    // optional bool owner_should_accept_changes = 11;

    pub fn get_owner_should_accept_changes(&self) -> bool {
        self.owner_should_accept_changes.unwrap_or(false)
    }

    pub fn clear_owner_should_accept_changes(&mut self) {
        self.owner_should_accept_changes = ::std::option::Option::None;
    }

    pub fn has_owner_should_accept_changes(&self) -> bool {
        self.owner_should_accept_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_should_accept_changes(&mut self, v: bool) {
        self.owner_should_accept_changes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyData {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_members = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.members)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lobby_cellid = ::std::option::Option::Some(is.read_uint32()?);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.owner_should_accept_changes = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.num_members {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_owner {
            my_size += 9;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.lobby_cellid {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_should_accept_changes {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.num_members {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_id_owner {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(8, v)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.lobby_cellid {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.owner_should_accept_changes {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLobbyData {
        CMsgClientMMSLobbyData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSLobbyData| { &m.app_id },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.app_id },
                CMsgClientMMSLobbyData::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSLobbyData| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.steam_id_lobby },
                CMsgClientMMSLobbyData::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "num_members",
                |m: &CMsgClientMMSLobbyData| { &m.num_members },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.num_members },
                CMsgClientMMSLobbyData::get_num_members,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "max_members",
                |m: &CMsgClientMMSLobbyData| { &m.max_members },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.max_members },
                CMsgClientMMSLobbyData::get_max_members,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "lobby_type",
                |m: &CMsgClientMMSLobbyData| { &m.lobby_type },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_type },
                CMsgClientMMSLobbyData::get_lobby_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "lobby_flags",
                |m: &CMsgClientMMSLobbyData| { &m.lobby_flags },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_flags },
                CMsgClientMMSLobbyData::get_lobby_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_owner",
                |m: &CMsgClientMMSLobbyData| { &m.steam_id_owner },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.steam_id_owner },
                CMsgClientMMSLobbyData::get_steam_id_owner,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "metadata",
                |m: &CMsgClientMMSLobbyData| { &m.metadata },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.metadata },
                CMsgClientMMSLobbyData::get_metadata,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_mmslobby_data::Member>>(
                "members",
                |m: &CMsgClientMMSLobbyData| { &m.members },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "lobby_cellid",
                |m: &CMsgClientMMSLobbyData| { &m.lobby_cellid },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.lobby_cellid },
                CMsgClientMMSLobbyData::get_lobby_cellid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "owner_should_accept_changes",
                |m: &CMsgClientMMSLobbyData| { &m.owner_should_accept_changes },
                |m: &mut CMsgClientMMSLobbyData| { &mut m.owner_should_accept_changes },
                CMsgClientMMSLobbyData::get_owner_should_accept_changes,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLobbyData>(
                "CMsgClientMMSLobbyData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyData {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSLobbyData> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSLobbyData::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyData {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.num_members = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.steam_id_owner = ::std::option::Option::None;
        self.metadata.clear();
        self.members.clear();
        self.lobby_cellid = ::std::option::Option::None;
        self.owner_should_accept_changes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLobbyData {
}

/// Nested message and enums of message `CMsgClientMMSLobbyData`
pub mod cmsg_client_mmslobby_data {
    #[derive(PartialEq,Clone,Default)]
    pub struct Member {
        // message fields
        steam_id: ::std::option::Option<u64>,
        persona_name: ::protobuf::SingularField<::std::string::String>,
        metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as ::protobuf::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn get_steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional string persona_name = 2;

        pub fn get_persona_name(&self) -> &str {
            match self.persona_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona_name(&mut self) {
            self.persona_name.clear();
        }

        pub fn has_persona_name(&self) -> bool {
            self.persona_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_name(&mut self, v: ::std::string::String) {
            self.persona_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
            if self.persona_name.is_none() {
                self.persona_name.set_default();
            }
            self.persona_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona_name(&mut self) -> ::std::string::String {
            self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes metadata = 3;

        pub fn get_metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata.clear();
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
            self.metadata = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.metadata.is_none() {
                self.metadata.set_default();
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
            self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for Member {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                    },
                    3 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 9;
            }
            if let Some(v) = self.persona_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Member {
            Member::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steam_id",
                    |m: &Member| { &m.steam_id },
                    |m: &mut Member| { &mut m.steam_id },
                    Member::get_steam_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "persona_name",
                    |m: &Member| { &m.persona_name },
                    |m: &mut Member| { &mut m.persona_name },
                    Member::get_persona_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "metadata",
                    |m: &Member| { &m.metadata },
                    |m: &mut Member| { &mut m.metadata },
                    Member::get_metadata,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Member>(
                    "CMsgClientMMSLobbyData.Member",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Member {
            static instance: ::protobuf::rt::Lazy<Member> = ::protobuf::rt::Lazy::INIT;
            instance.get(Member::new)
        }
    }

    impl ::protobuf::Clear for Member {
        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.persona_name.clear();
            self.metadata.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Member {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Member {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSendLobbyChatMsg {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_target: ::std::option::Option<u64>,
    lobby_message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSendLobbyChatMsg {
    fn default() -> &'a CMsgClientMMSSendLobbyChatMsg {
        <CMsgClientMMSSendLobbyChatMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSendLobbyChatMsg {
    pub fn new() -> CMsgClientMMSSendLobbyChatMsg {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_target = 3;

    pub fn get_steam_id_target(&self) -> u64 {
        self.steam_id_target.unwrap_or(0)
    }

    pub fn clear_steam_id_target(&mut self) {
        self.steam_id_target = ::std::option::Option::None;
    }

    pub fn has_steam_id_target(&self) -> bool {
        self.steam_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_target(&mut self, v: u64) {
        self.steam_id_target = ::std::option::Option::Some(v);
    }

    // optional bytes lobby_message = 4;

    pub fn get_lobby_message(&self) -> &[u8] {
        match self.lobby_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_lobby_message(&mut self) {
        self.lobby_message.clear();
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.lobby_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lobby_message.is_none() {
            self.lobby_message.set_default();
        }
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::std::vec::Vec<u8> {
        self.lobby_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSSendLobbyChatMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_target = ::std::option::Option::Some(is.read_fixed64()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.lobby_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_target {
            my_size += 9;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_target {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSendLobbyChatMsg {
        CMsgClientMMSSendLobbyChatMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSSendLobbyChatMsg| { &m.app_id },
                |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.app_id },
                CMsgClientMMSSendLobbyChatMsg::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSendLobbyChatMsg| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.steam_id_lobby },
                CMsgClientMMSSendLobbyChatMsg::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_target",
                |m: &CMsgClientMMSSendLobbyChatMsg| { &m.steam_id_target },
                |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.steam_id_target },
                CMsgClientMMSSendLobbyChatMsg::get_steam_id_target,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "lobby_message",
                |m: &CMsgClientMMSSendLobbyChatMsg| { &m.lobby_message },
                |m: &mut CMsgClientMMSSendLobbyChatMsg| { &mut m.lobby_message },
                CMsgClientMMSSendLobbyChatMsg::get_lobby_message,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSendLobbyChatMsg>(
                "CMsgClientMMSSendLobbyChatMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSendLobbyChatMsg {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSSendLobbyChatMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSSendLobbyChatMsg::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSendLobbyChatMsg {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_target = ::std::option::Option::None;
        self.lobby_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSendLobbyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSendLobbyChatMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLobbyChatMsg {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_sender: ::std::option::Option<u64>,
    lobby_message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyChatMsg {
    fn default() -> &'a CMsgClientMMSLobbyChatMsg {
        <CMsgClientMMSLobbyChatMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyChatMsg {
    pub fn new() -> CMsgClientMMSLobbyChatMsg {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_sender = 3;

    pub fn get_steam_id_sender(&self) -> u64 {
        self.steam_id_sender.unwrap_or(0)
    }

    pub fn clear_steam_id_sender(&mut self) {
        self.steam_id_sender = ::std::option::Option::None;
    }

    pub fn has_steam_id_sender(&self) -> bool {
        self.steam_id_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_sender(&mut self, v: u64) {
        self.steam_id_sender = ::std::option::Option::Some(v);
    }

    // optional bytes lobby_message = 4;

    pub fn get_lobby_message(&self) -> &[u8] {
        match self.lobby_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_lobby_message(&mut self) {
        self.lobby_message.clear();
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.lobby_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lobby_message.is_none() {
            self.lobby_message.set_default();
        }
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::std::vec::Vec<u8> {
        self.lobby_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyChatMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_sender = ::std::option::Option::Some(is.read_fixed64()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.lobby_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_sender {
            my_size += 9;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLobbyChatMsg {
        CMsgClientMMSLobbyChatMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSLobbyChatMsg| { &m.app_id },
                |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.app_id },
                CMsgClientMMSLobbyChatMsg::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSLobbyChatMsg| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.steam_id_lobby },
                CMsgClientMMSLobbyChatMsg::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_sender",
                |m: &CMsgClientMMSLobbyChatMsg| { &m.steam_id_sender },
                |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.steam_id_sender },
                CMsgClientMMSLobbyChatMsg::get_steam_id_sender,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "lobby_message",
                |m: &CMsgClientMMSLobbyChatMsg| { &m.lobby_message },
                |m: &mut CMsgClientMMSLobbyChatMsg| { &mut m.lobby_message },
                CMsgClientMMSLobbyChatMsg::get_lobby_message,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLobbyChatMsg>(
                "CMsgClientMMSLobbyChatMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyChatMsg {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSLobbyChatMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSLobbyChatMsg::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyChatMsg {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_sender = ::std::option::Option::None;
        self.lobby_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLobbyChatMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyOwner {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_new_owner: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyOwner {
    fn default() -> &'a CMsgClientMMSSetLobbyOwner {
        <CMsgClientMMSSetLobbyOwner as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyOwner {
    pub fn new() -> CMsgClientMMSSetLobbyOwner {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_new_owner = 3;

    pub fn get_steam_id_new_owner(&self) -> u64 {
        self.steam_id_new_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_new_owner(&mut self) {
        self.steam_id_new_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_new_owner(&self) -> bool {
        self.steam_id_new_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_new_owner(&mut self, v: u64) {
        self.steam_id_new_owner = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyOwner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_new_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_new_owner {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_new_owner {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyOwner {
        CMsgClientMMSSetLobbyOwner::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyOwner| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.app_id },
                CMsgClientMMSSetLobbyOwner::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyOwner| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.steam_id_lobby },
                CMsgClientMMSSetLobbyOwner::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_new_owner",
                |m: &CMsgClientMMSSetLobbyOwner| { &m.steam_id_new_owner },
                |m: &mut CMsgClientMMSSetLobbyOwner| { &mut m.steam_id_new_owner },
                CMsgClientMMSSetLobbyOwner::get_steam_id_new_owner,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyOwner>(
                "CMsgClientMMSSetLobbyOwner",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyOwner {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSSetLobbyOwner> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSSetLobbyOwner::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyOwner {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_new_owner = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyOwner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyOwner {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyOwnerResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyOwnerResponse {
    fn default() -> &'a CMsgClientMMSSetLobbyOwnerResponse {
        <CMsgClientMMSSetLobbyOwnerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyOwnerResponse {
    pub fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyOwnerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        CMsgClientMMSSetLobbyOwnerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.app_id },
                CMsgClientMMSSetLobbyOwnerResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.steam_id_lobby },
                CMsgClientMMSSetLobbyOwnerResponse::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientMMSSetLobbyOwnerResponse| { &m.eresult },
                |m: &mut CMsgClientMMSSetLobbyOwnerResponse| { &mut m.eresult },
                CMsgClientMMSSetLobbyOwnerResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyOwnerResponse>(
                "CMsgClientMMSSetLobbyOwnerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyOwnerResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSSetLobbyOwnerResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSSetLobbyOwnerResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyOwnerResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyOwnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyOwnerResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyLinked {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_lobby2: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyLinked {
    fn default() -> &'a CMsgClientMMSSetLobbyLinked {
        <CMsgClientMMSSetLobbyLinked as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyLinked {
    pub fn new() -> CMsgClientMMSSetLobbyLinked {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby2 = 3;

    pub fn get_steam_id_lobby2(&self) -> u64 {
        self.steam_id_lobby2.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby2(&mut self) {
        self.steam_id_lobby2 = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby2(&self) -> bool {
        self.steam_id_lobby2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby2(&mut self, v: u64) {
        self.steam_id_lobby2 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyLinked {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby2 = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_lobby2 {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_lobby2 {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyLinked {
        CMsgClientMMSSetLobbyLinked::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyLinked| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.app_id },
                CMsgClientMMSSetLobbyLinked::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyLinked| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.steam_id_lobby },
                CMsgClientMMSSetLobbyLinked::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby2",
                |m: &CMsgClientMMSSetLobbyLinked| { &m.steam_id_lobby2 },
                |m: &mut CMsgClientMMSSetLobbyLinked| { &mut m.steam_id_lobby2 },
                CMsgClientMMSSetLobbyLinked::get_steam_id_lobby2,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyLinked>(
                "CMsgClientMMSSetLobbyLinked",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyLinked {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSSetLobbyLinked> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSSetLobbyLinked::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyLinked {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_lobby2 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyLinked {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyLinked {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSSetLobbyGameServer {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    deprecated_game_server_ip: ::std::option::Option<u32>,
    game_server_port: ::std::option::Option<u32>,
    game_server_steam_id: ::std::option::Option<u64>,
    pub game_server_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyGameServer {
    fn default() -> &'a CMsgClientMMSSetLobbyGameServer {
        <CMsgClientMMSSetLobbyGameServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyGameServer {
    pub fn new() -> CMsgClientMMSSetLobbyGameServer {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_server_ip = 3;

    pub fn get_deprecated_game_server_ip(&self) -> u32 {
        self.deprecated_game_server_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_game_server_ip(&mut self) {
        self.deprecated_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_server_ip(&self) -> bool {
        self.deprecated_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_server_ip(&mut self, v: u32) {
        self.deprecated_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 4;

    pub fn get_game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_server_steam_id = 5;

    pub fn get_game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyGameServer {
    fn is_initialized(&self) -> bool {
        for v in &self.game_server_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deprecated_game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<super::steammessages_base::CMsgIPAddress, _>(wire_type, is, &mut self.game_server_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSSetLobbyGameServer {
        CMsgClientMMSSetLobbyGameServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.app_id },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.app_id },
                CMsgClientMMSSetLobbyGameServer::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.steam_id_lobby },
                CMsgClientMMSSetLobbyGameServer::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "deprecated_game_server_ip",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.deprecated_game_server_ip },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.deprecated_game_server_ip },
                CMsgClientMMSSetLobbyGameServer::get_deprecated_game_server_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "game_server_port",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_port },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_port },
                CMsgClientMMSSetLobbyGameServer::get_game_server_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "game_server_steam_id",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_steam_id },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_steam_id },
                CMsgClientMMSSetLobbyGameServer::get_game_server_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>, _>(
                "game_server_ip",
                |m: &CMsgClientMMSSetLobbyGameServer| { &m.game_server_ip },
                |m: &mut CMsgClientMMSSetLobbyGameServer| { &mut m.game_server_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyGameServer>(
                "CMsgClientMMSSetLobbyGameServer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyGameServer {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSSetLobbyGameServer> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSSetLobbyGameServer::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyGameServer {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.deprecated_game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.game_server_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyGameServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSSetLobbyGameServer {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSLobbyGameServerSet {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    deprecated_game_server_ip: ::std::option::Option<u32>,
    game_server_port: ::std::option::Option<u32>,
    game_server_steam_id: ::std::option::Option<u64>,
    pub game_server_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyGameServerSet {
    fn default() -> &'a CMsgClientMMSLobbyGameServerSet {
        <CMsgClientMMSLobbyGameServerSet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyGameServerSet {
    pub fn new() -> CMsgClientMMSLobbyGameServerSet {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_server_ip = 3;

    pub fn get_deprecated_game_server_ip(&self) -> u32 {
        self.deprecated_game_server_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_game_server_ip(&mut self) {
        self.deprecated_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_server_ip(&self) -> bool {
        self.deprecated_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_server_ip(&mut self, v: u32) {
        self.deprecated_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 4;

    pub fn get_game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_server_steam_id = 5;

    pub fn get_game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyGameServerSet {
    fn is_initialized(&self) -> bool {
        for v in &self.game_server_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deprecated_game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into::<super::steammessages_base::CMsgIPAddress, _>(wire_type, is, &mut self.game_server_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSLobbyGameServerSet {
        CMsgClientMMSLobbyGameServerSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.app_id },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.app_id },
                CMsgClientMMSLobbyGameServerSet::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.steam_id_lobby },
                CMsgClientMMSLobbyGameServerSet::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "deprecated_game_server_ip",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.deprecated_game_server_ip },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.deprecated_game_server_ip },
                CMsgClientMMSLobbyGameServerSet::get_deprecated_game_server_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "game_server_port",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_port },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_port },
                CMsgClientMMSLobbyGameServerSet::get_game_server_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "game_server_steam_id",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_steam_id },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_steam_id },
                CMsgClientMMSLobbyGameServerSet::get_game_server_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>, _>(
                "game_server_ip",
                |m: &CMsgClientMMSLobbyGameServerSet| { &m.game_server_ip },
                |m: &mut CMsgClientMMSLobbyGameServerSet| { &mut m.game_server_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLobbyGameServerSet>(
                "CMsgClientMMSLobbyGameServerSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyGameServerSet {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSLobbyGameServerSet> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSLobbyGameServerSet::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyGameServerSet {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.deprecated_game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.game_server_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyGameServerSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSLobbyGameServerSet {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSUserJoinedLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_user: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSUserJoinedLobby {
    fn default() -> &'a CMsgClientMMSUserJoinedLobby {
        <CMsgClientMMSUserJoinedLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSUserJoinedLobby {
    pub fn new() -> CMsgClientMMSUserJoinedLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user = 3;

    pub fn get_steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 4;

    pub fn get_persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSUserJoinedLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_user = ::std::option::Option::Some(is.read_fixed64()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_user {
            my_size += 9;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSUserJoinedLobby {
        CMsgClientMMSUserJoinedLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSUserJoinedLobby| { &m.app_id },
                |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.app_id },
                CMsgClientMMSUserJoinedLobby::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSUserJoinedLobby| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.steam_id_lobby },
                CMsgClientMMSUserJoinedLobby::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_user",
                |m: &CMsgClientMMSUserJoinedLobby| { &m.steam_id_user },
                |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.steam_id_user },
                CMsgClientMMSUserJoinedLobby::get_steam_id_user,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "persona_name",
                |m: &CMsgClientMMSUserJoinedLobby| { &m.persona_name },
                |m: &mut CMsgClientMMSUserJoinedLobby| { &mut m.persona_name },
                CMsgClientMMSUserJoinedLobby::get_persona_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSUserJoinedLobby>(
                "CMsgClientMMSUserJoinedLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSUserJoinedLobby {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSUserJoinedLobby> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSUserJoinedLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSUserJoinedLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user = ::std::option::Option::None;
        self.persona_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSUserJoinedLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSUserJoinedLobby {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSUserLeftLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_user: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSUserLeftLobby {
    fn default() -> &'a CMsgClientMMSUserLeftLobby {
        <CMsgClientMMSUserLeftLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSUserLeftLobby {
    pub fn new() -> CMsgClientMMSUserLeftLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user = 3;

    pub fn get_steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 4;

    pub fn get_persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSUserLeftLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_user = ::std::option::Option::Some(is.read_fixed64()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_user {
            my_size += 9;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSUserLeftLobby {
        CMsgClientMMSUserLeftLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSUserLeftLobby| { &m.app_id },
                |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.app_id },
                CMsgClientMMSUserLeftLobby::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSUserLeftLobby| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.steam_id_lobby },
                CMsgClientMMSUserLeftLobby::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_user",
                |m: &CMsgClientMMSUserLeftLobby| { &m.steam_id_user },
                |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.steam_id_user },
                CMsgClientMMSUserLeftLobby::get_steam_id_user,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "persona_name",
                |m: &CMsgClientMMSUserLeftLobby| { &m.persona_name },
                |m: &mut CMsgClientMMSUserLeftLobby| { &mut m.persona_name },
                CMsgClientMMSUserLeftLobby::get_persona_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSUserLeftLobby>(
                "CMsgClientMMSUserLeftLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSUserLeftLobby {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSUserLeftLobby> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSUserLeftLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSUserLeftLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user = ::std::option::Option::None;
        self.persona_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSUserLeftLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSUserLeftLobby {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSInviteToLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_user_invited: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSInviteToLobby {
    fn default() -> &'a CMsgClientMMSInviteToLobby {
        <CMsgClientMMSInviteToLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSInviteToLobby {
    pub fn new() -> CMsgClientMMSInviteToLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user_invited = 3;

    pub fn get_steam_id_user_invited(&self) -> u64 {
        self.steam_id_user_invited.unwrap_or(0)
    }

    pub fn clear_steam_id_user_invited(&mut self) {
        self.steam_id_user_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_user_invited(&self) -> bool {
        self.steam_id_user_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user_invited(&mut self, v: u64) {
        self.steam_id_user_invited = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSInviteToLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_user_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_user_invited {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user_invited {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSInviteToLobby {
        CMsgClientMMSInviteToLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSInviteToLobby| { &m.app_id },
                |m: &mut CMsgClientMMSInviteToLobby| { &mut m.app_id },
                CMsgClientMMSInviteToLobby::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSInviteToLobby| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSInviteToLobby| { &mut m.steam_id_lobby },
                CMsgClientMMSInviteToLobby::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_user_invited",
                |m: &CMsgClientMMSInviteToLobby| { &m.steam_id_user_invited },
                |m: &mut CMsgClientMMSInviteToLobby| { &mut m.steam_id_user_invited },
                CMsgClientMMSInviteToLobby::get_steam_id_user_invited,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSInviteToLobby>(
                "CMsgClientMMSInviteToLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSInviteToLobby {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSInviteToLobby> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSInviteToLobby::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSInviteToLobby {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user_invited = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSInviteToLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSInviteToLobby {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyStatus {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    claim_membership: ::std::option::Option<bool>,
    claim_ownership: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyStatus {
    fn default() -> &'a CMsgClientMMSGetLobbyStatus {
        <CMsgClientMMSGetLobbyStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyStatus {
    pub fn new() -> CMsgClientMMSGetLobbyStatus {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional bool claim_membership = 3;

    pub fn get_claim_membership(&self) -> bool {
        self.claim_membership.unwrap_or(false)
    }

    pub fn clear_claim_membership(&mut self) {
        self.claim_membership = ::std::option::Option::None;
    }

    pub fn has_claim_membership(&self) -> bool {
        self.claim_membership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_membership(&mut self, v: bool) {
        self.claim_membership = ::std::option::Option::Some(v);
    }

    // optional bool claim_ownership = 4;

    pub fn get_claim_ownership(&self) -> bool {
        self.claim_ownership.unwrap_or(false)
    }

    pub fn clear_claim_ownership(&mut self) {
        self.claim_ownership = ::std::option::Option::None;
    }

    pub fn has_claim_ownership(&self) -> bool {
        self.claim_ownership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_ownership(&mut self, v: bool) {
        self.claim_ownership = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.claim_membership = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.claim_ownership = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.claim_membership {
            my_size += 2;
        }
        if let Some(v) = self.claim_ownership {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.claim_membership {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.claim_ownership {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyStatus {
        CMsgClientMMSGetLobbyStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSGetLobbyStatus| { &m.app_id },
                |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.app_id },
                CMsgClientMMSGetLobbyStatus::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSGetLobbyStatus| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.steam_id_lobby },
                CMsgClientMMSGetLobbyStatus::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "claim_membership",
                |m: &CMsgClientMMSGetLobbyStatus| { &m.claim_membership },
                |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.claim_membership },
                CMsgClientMMSGetLobbyStatus::get_claim_membership,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "claim_ownership",
                |m: &CMsgClientMMSGetLobbyStatus| { &m.claim_ownership },
                |m: &mut CMsgClientMMSGetLobbyStatus| { &mut m.claim_ownership },
                CMsgClientMMSGetLobbyStatus::get_claim_ownership,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSGetLobbyStatus>(
                "CMsgClientMMSGetLobbyStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyStatus {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSGetLobbyStatus> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSGetLobbyStatus::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyStatus {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.claim_membership = ::std::option::Option::None;
        self.claim_ownership = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyStatus {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientMMSGetLobbyStatusResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    lobby_status: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EMMSLobbyStatus>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyStatusResponse {
    fn default() -> &'a CMsgClientMMSGetLobbyStatusResponse {
        <CMsgClientMMSGetLobbyStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyStatusResponse {
    pub fn new() -> CMsgClientMMSGetLobbyStatusResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn get_steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional .EMMSLobbyStatus lobby_status = 3;

    pub fn get_lobby_status(&self) -> EMMSLobbyStatus {
        match self.lobby_status {
            Some(e) => e.enum_value_or(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            None => EMMSLobbyStatus::k_EMMSLobbyStatusInvalid,
        }
    }

    pub fn clear_lobby_status(&mut self) {
        self.lobby_status = ::std::option::Option::None;
    }

    pub fn has_lobby_status(&self) -> bool {
        self.lobby_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_status(&mut self, v: EMMSLobbyStatus) {
        self.lobby_status = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lobby_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 9;
        }
        if let Some(v) = self.lobby_status {
            my_size += ::protobuf::rt::enum_or_unknown_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.lobby_status {
            os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientMMSGetLobbyStatusResponse {
        CMsgClientMMSGetLobbyStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.app_id },
                |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.app_id },
                CMsgClientMMSGetLobbyStatusResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_lobby",
                |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.steam_id_lobby },
                |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.steam_id_lobby },
                CMsgClientMMSGetLobbyStatusResponse::get_steam_id_lobby,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EMMSLobbyStatus>(
                "lobby_status",
                |m: &CMsgClientMMSGetLobbyStatusResponse| { &m.lobby_status },
                |m: &mut CMsgClientMMSGetLobbyStatusResponse| { &mut m.lobby_status },
                EMMSLobbyStatus::k_EMMSLobbyStatusInvalid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSGetLobbyStatusResponse>(
                "CMsgClientMMSGetLobbyStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyStatusResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientMMSGetLobbyStatusResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientMMSGetLobbyStatusResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyStatusResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.lobby_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientMMSGetLobbyStatusResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientInviteToGame {
    // message fields
    steam_id_dest: ::std::option::Option<u64>,
    steam_id_src: ::std::option::Option<u64>,
    connect_string: ::protobuf::SingularField<::std::string::String>,
    remote_play: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientInviteToGame {
    fn default() -> &'a CMsgClientInviteToGame {
        <CMsgClientInviteToGame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInviteToGame {
    pub fn new() -> CMsgClientInviteToGame {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn get_steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn get_steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional string connect_string = 3;

    pub fn get_connect_string(&self) -> &str {
        match self.connect_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connect_string(&mut self) {
        self.connect_string.clear();
    }

    pub fn has_connect_string(&self) -> bool {
        self.connect_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_string(&mut self, v: ::std::string::String) {
        self.connect_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_string(&mut self) -> &mut ::std::string::String {
        if self.connect_string.is_none() {
            self.connect_string.set_default();
        }
        self.connect_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_string(&mut self) -> ::std::string::String {
        self.connect_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string remote_play = 4;

    pub fn get_remote_play(&self) -> &str {
        match self.remote_play.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_remote_play(&mut self) {
        self.remote_play.clear();
    }

    pub fn has_remote_play(&self) -> bool {
        self.remote_play.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_play(&mut self, v: ::std::string::String) {
        self.remote_play = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_play(&mut self) -> &mut ::std::string::String {
        if self.remote_play.is_none() {
            self.remote_play.set_default();
        }
        self.remote_play.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_play(&mut self) -> ::std::string::String {
        self.remote_play.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientInviteToGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.connect_string)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.remote_play)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 9;
        }
        if let Some(v) = self.connect_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.remote_play.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.connect_string.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.remote_play.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientInviteToGame {
        CMsgClientInviteToGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_dest",
                |m: &CMsgClientInviteToGame| { &m.steam_id_dest },
                |m: &mut CMsgClientInviteToGame| { &mut m.steam_id_dest },
                CMsgClientInviteToGame::get_steam_id_dest,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_src",
                |m: &CMsgClientInviteToGame| { &m.steam_id_src },
                |m: &mut CMsgClientInviteToGame| { &mut m.steam_id_src },
                CMsgClientInviteToGame::get_steam_id_src,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "connect_string",
                |m: &CMsgClientInviteToGame| { &m.connect_string },
                |m: &mut CMsgClientInviteToGame| { &mut m.connect_string },
                CMsgClientInviteToGame::get_connect_string,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "remote_play",
                |m: &CMsgClientInviteToGame| { &m.remote_play },
                |m: &mut CMsgClientInviteToGame| { &mut m.remote_play },
                CMsgClientInviteToGame::get_remote_play,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientInviteToGame>(
                "CMsgClientInviteToGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientInviteToGame {
        static instance: ::protobuf::rt::Lazy<CMsgClientInviteToGame> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientInviteToGame::new)
    }
}

impl ::protobuf::Clear for CMsgClientInviteToGame {
    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.connect_string.clear();
        self.remote_play.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientInviteToGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientInviteToGame {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientChatInvite {
    // message fields
    steam_id_invited: ::std::option::Option<u64>,
    steam_id_chat: ::std::option::Option<u64>,
    steam_id_patron: ::std::option::Option<u64>,
    chatroom_type: ::std::option::Option<i32>,
    steam_id_friend_chat: ::std::option::Option<u64>,
    chat_name: ::protobuf::SingularField<::std::string::String>,
    game_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatInvite {
    fn default() -> &'a CMsgClientChatInvite {
        <CMsgClientChatInvite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatInvite {
    pub fn new() -> CMsgClientChatInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_invited = 1;

    pub fn get_steam_id_invited(&self) -> u64 {
        self.steam_id_invited.unwrap_or(0)
    }

    pub fn clear_steam_id_invited(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_invited(&self) -> bool {
        self.steam_id_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_invited(&mut self, v: u64) {
        self.steam_id_invited = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_chat = 2;

    pub fn get_steam_id_chat(&self) -> u64 {
        self.steam_id_chat.unwrap_or(0)
    }

    pub fn clear_steam_id_chat(&mut self) {
        self.steam_id_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_chat(&self) -> bool {
        self.steam_id_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_chat(&mut self, v: u64) {
        self.steam_id_chat = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_patron = 3;

    pub fn get_steam_id_patron(&self) -> u64 {
        self.steam_id_patron.unwrap_or(0)
    }

    pub fn clear_steam_id_patron(&mut self) {
        self.steam_id_patron = ::std::option::Option::None;
    }

    pub fn has_steam_id_patron(&self) -> bool {
        self.steam_id_patron.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_patron(&mut self, v: u64) {
        self.steam_id_patron = ::std::option::Option::Some(v);
    }

    // optional int32 chatroom_type = 4;

    pub fn get_chatroom_type(&self) -> i32 {
        self.chatroom_type.unwrap_or(0)
    }

    pub fn clear_chatroom_type(&mut self) {
        self.chatroom_type = ::std::option::Option::None;
    }

    pub fn has_chatroom_type(&self) -> bool {
        self.chatroom_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatroom_type(&mut self, v: i32) {
        self.chatroom_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_friend_chat = 5;

    pub fn get_steam_id_friend_chat(&self) -> u64 {
        self.steam_id_friend_chat.unwrap_or(0)
    }

    pub fn clear_steam_id_friend_chat(&mut self) {
        self.steam_id_friend_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_friend_chat(&self) -> bool {
        self.steam_id_friend_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_friend_chat(&mut self, v: u64) {
        self.steam_id_friend_chat = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 6;

    pub fn get_chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name.clear();
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name.set_default();
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 game_id = 7;

    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChatInvite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_chat = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_patron = ::std::option::Option::Some(is.read_fixed64()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chatroom_type = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_friend_chat = ::std::option::Option::Some(is.read_fixed64()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_invited {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_chat {
            my_size += 9;
        }
        if let Some(v) = self.steam_id_patron {
            my_size += 9;
        }
        if let Some(v) = self.chatroom_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_friend_chat {
            my_size += 9;
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_invited {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_chat {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_patron {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.chatroom_type {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.steam_id_friend_chat {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChatInvite {
        CMsgClientChatInvite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_invited",
                |m: &CMsgClientChatInvite| { &m.steam_id_invited },
                |m: &mut CMsgClientChatInvite| { &mut m.steam_id_invited },
                CMsgClientChatInvite::get_steam_id_invited,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_chat",
                |m: &CMsgClientChatInvite| { &m.steam_id_chat },
                |m: &mut CMsgClientChatInvite| { &mut m.steam_id_chat },
                CMsgClientChatInvite::get_steam_id_chat,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_patron",
                |m: &CMsgClientChatInvite| { &m.steam_id_patron },
                |m: &mut CMsgClientChatInvite| { &mut m.steam_id_patron },
                CMsgClientChatInvite::get_steam_id_patron,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "chatroom_type",
                |m: &CMsgClientChatInvite| { &m.chatroom_type },
                |m: &mut CMsgClientChatInvite| { &mut m.chatroom_type },
                CMsgClientChatInvite::get_chatroom_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_friend_chat",
                |m: &CMsgClientChatInvite| { &m.steam_id_friend_chat },
                |m: &mut CMsgClientChatInvite| { &mut m.steam_id_friend_chat },
                CMsgClientChatInvite::get_steam_id_friend_chat,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "chat_name",
                |m: &CMsgClientChatInvite| { &m.chat_name },
                |m: &mut CMsgClientChatInvite| { &mut m.chat_name },
                CMsgClientChatInvite::get_chat_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "game_id",
                |m: &CMsgClientChatInvite| { &m.game_id },
                |m: &mut CMsgClientChatInvite| { &mut m.game_id },
                CMsgClientChatInvite::get_game_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientChatInvite>(
                "CMsgClientChatInvite",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChatInvite {
        static instance: ::protobuf::rt::Lazy<CMsgClientChatInvite> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientChatInvite::new)
    }
}

impl ::protobuf::Clear for CMsgClientChatInvite {
    fn clear(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
        self.steam_id_chat = ::std::option::Option::None;
        self.steam_id_patron = ::std::option::Option::None;
        self.chatroom_type = ::std::option::Option::None;
        self.steam_id_friend_chat = ::std::option::Option::None;
        self.chat_name.clear();
        self.game_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChatInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatInvite {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientConnectionStats {
    // message fields
    pub stats_logon: ::protobuf::SingularPtrField<cmsg_client_connection_stats::Stats_Logon>,
    pub stats_vconn: ::protobuf::SingularPtrField<cmsg_client_connection_stats::Stats_VConn>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientConnectionStats {
    fn default() -> &'a CMsgClientConnectionStats {
        <CMsgClientConnectionStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientConnectionStats {
    pub fn new() -> CMsgClientConnectionStats {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats_logon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_vconn {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<cmsg_client_connection_stats::Stats_Logon, _>(wire_type, is, &mut self.stats_logon)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<cmsg_client_connection_stats::Stats_VConn, _>(wire_type, is, &mut self.stats_vconn)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stats_logon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stats_vconn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stats_logon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.stats_vconn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientConnectionStats {
        CMsgClientConnectionStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_connection_stats::Stats_Logon>, _>(
                "stats_logon",
                |m: &CMsgClientConnectionStats| { &m.stats_logon },
                |m: &mut CMsgClientConnectionStats| { &mut m.stats_logon },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_connection_stats::Stats_VConn>, _>(
                "stats_vconn",
                |m: &CMsgClientConnectionStats| { &m.stats_vconn },
                |m: &mut CMsgClientConnectionStats| { &mut m.stats_vconn },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientConnectionStats>(
                "CMsgClientConnectionStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientConnectionStats {
        static instance: ::protobuf::rt::Lazy<CMsgClientConnectionStats> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientConnectionStats::new)
    }
}

impl ::protobuf::Clear for CMsgClientConnectionStats {
    fn clear(&mut self) {
        self.stats_logon.clear();
        self.stats_vconn.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientConnectionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientConnectionStats {
}

/// Nested message and enums of message `CMsgClientConnectionStats`
pub mod cmsg_client_connection_stats {
    #[derive(PartialEq,Clone,Default)]
    pub struct Stats_Logon {
        // message fields
        connect_attempts: ::std::option::Option<i32>,
        connect_successes: ::std::option::Option<i32>,
        connect_failures: ::std::option::Option<i32>,
        connections_dropped: ::std::option::Option<i32>,
        seconds_running: ::std::option::Option<u32>,
        msec_tologonthistime: ::std::option::Option<u32>,
        count_bad_cms: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Stats_Logon {
        fn default() -> &'a Stats_Logon {
            <Stats_Logon as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_Logon {
        pub fn new() -> Stats_Logon {
            ::std::default::Default::default()
        }

        // optional int32 connect_attempts = 1;

        pub fn get_connect_attempts(&self) -> i32 {
            self.connect_attempts.unwrap_or(0)
        }

        pub fn clear_connect_attempts(&mut self) {
            self.connect_attempts = ::std::option::Option::None;
        }

        pub fn has_connect_attempts(&self) -> bool {
            self.connect_attempts.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_attempts(&mut self, v: i32) {
            self.connect_attempts = ::std::option::Option::Some(v);
        }

        // optional int32 connect_successes = 2;

        pub fn get_connect_successes(&self) -> i32 {
            self.connect_successes.unwrap_or(0)
        }

        pub fn clear_connect_successes(&mut self) {
            self.connect_successes = ::std::option::Option::None;
        }

        pub fn has_connect_successes(&self) -> bool {
            self.connect_successes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_successes(&mut self, v: i32) {
            self.connect_successes = ::std::option::Option::Some(v);
        }

        // optional int32 connect_failures = 3;

        pub fn get_connect_failures(&self) -> i32 {
            self.connect_failures.unwrap_or(0)
        }

        pub fn clear_connect_failures(&mut self) {
            self.connect_failures = ::std::option::Option::None;
        }

        pub fn has_connect_failures(&self) -> bool {
            self.connect_failures.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_failures(&mut self, v: i32) {
            self.connect_failures = ::std::option::Option::Some(v);
        }

        // optional int32 connections_dropped = 4;

        pub fn get_connections_dropped(&self) -> i32 {
            self.connections_dropped.unwrap_or(0)
        }

        pub fn clear_connections_dropped(&mut self) {
            self.connections_dropped = ::std::option::Option::None;
        }

        pub fn has_connections_dropped(&self) -> bool {
            self.connections_dropped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_dropped(&mut self, v: i32) {
            self.connections_dropped = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds_running = 5;

        pub fn get_seconds_running(&self) -> u32 {
            self.seconds_running.unwrap_or(0)
        }

        pub fn clear_seconds_running(&mut self) {
            self.seconds_running = ::std::option::Option::None;
        }

        pub fn has_seconds_running(&self) -> bool {
            self.seconds_running.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_running(&mut self, v: u32) {
            self.seconds_running = ::std::option::Option::Some(v);
        }

        // optional uint32 msec_tologonthistime = 6;

        pub fn get_msec_tologonthistime(&self) -> u32 {
            self.msec_tologonthistime.unwrap_or(0)
        }

        pub fn clear_msec_tologonthistime(&mut self) {
            self.msec_tologonthistime = ::std::option::Option::None;
        }

        pub fn has_msec_tologonthistime(&self) -> bool {
            self.msec_tologonthistime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msec_tologonthistime(&mut self, v: u32) {
            self.msec_tologonthistime = ::std::option::Option::Some(v);
        }

        // optional uint32 count_bad_cms = 7;

        pub fn get_count_bad_cms(&self) -> u32 {
            self.count_bad_cms.unwrap_or(0)
        }

        pub fn clear_count_bad_cms(&mut self) {
            self.count_bad_cms = ::std::option::Option::None;
        }

        pub fn has_count_bad_cms(&self) -> bool {
            self.count_bad_cms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count_bad_cms(&mut self, v: u32) {
            self.count_bad_cms = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Stats_Logon {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.connect_attempts = ::std::option::Option::Some(is.read_int32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.connect_successes = ::std::option::Option::Some(is.read_int32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.connect_failures = ::std::option::Option::Some(is.read_int32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.connections_dropped = ::std::option::Option::Some(is.read_int32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.seconds_running = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.msec_tologonthistime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.count_bad_cms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.connect_attempts {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.connect_successes {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.connect_failures {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.connections_dropped {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.seconds_running {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.msec_tologonthistime {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.count_bad_cms {
                my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.connect_attempts {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.connect_successes {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.connect_failures {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.connections_dropped {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.seconds_running {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.msec_tologonthistime {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.count_bad_cms {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Stats_Logon {
            Stats_Logon::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "connect_attempts",
                    |m: &Stats_Logon| { &m.connect_attempts },
                    |m: &mut Stats_Logon| { &mut m.connect_attempts },
                    Stats_Logon::get_connect_attempts,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "connect_successes",
                    |m: &Stats_Logon| { &m.connect_successes },
                    |m: &mut Stats_Logon| { &mut m.connect_successes },
                    Stats_Logon::get_connect_successes,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "connect_failures",
                    |m: &Stats_Logon| { &m.connect_failures },
                    |m: &mut Stats_Logon| { &mut m.connect_failures },
                    Stats_Logon::get_connect_failures,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "connections_dropped",
                    |m: &Stats_Logon| { &m.connections_dropped },
                    |m: &mut Stats_Logon| { &mut m.connections_dropped },
                    Stats_Logon::get_connections_dropped,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "seconds_running",
                    |m: &Stats_Logon| { &m.seconds_running },
                    |m: &mut Stats_Logon| { &mut m.seconds_running },
                    Stats_Logon::get_seconds_running,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "msec_tologonthistime",
                    |m: &Stats_Logon| { &m.msec_tologonthistime },
                    |m: &mut Stats_Logon| { &mut m.msec_tologonthistime },
                    Stats_Logon::get_msec_tologonthistime,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "count_bad_cms",
                    |m: &Stats_Logon| { &m.count_bad_cms },
                    |m: &mut Stats_Logon| { &mut m.count_bad_cms },
                    Stats_Logon::get_count_bad_cms,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stats_Logon>(
                    "CMsgClientConnectionStats.Stats_Logon",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Stats_Logon {
            static instance: ::protobuf::rt::Lazy<Stats_Logon> = ::protobuf::rt::Lazy::INIT;
            instance.get(Stats_Logon::new)
        }
    }

    impl ::protobuf::Clear for Stats_Logon {
        fn clear(&mut self) {
            self.connect_attempts = ::std::option::Option::None;
            self.connect_successes = ::std::option::Option::None;
            self.connect_failures = ::std::option::Option::None;
            self.connections_dropped = ::std::option::Option::None;
            self.seconds_running = ::std::option::Option::None;
            self.msec_tologonthistime = ::std::option::Option::None;
            self.count_bad_cms = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Stats_Logon {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats_Logon {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct Stats_UDP {
        // message fields
        pkts_sent: ::std::option::Option<u64>,
        bytes_sent: ::std::option::Option<u64>,
        pkts_recv: ::std::option::Option<u64>,
        pkts_processed: ::std::option::Option<u64>,
        bytes_recv: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Stats_UDP {
        fn default() -> &'a Stats_UDP {
            <Stats_UDP as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_UDP {
        pub fn new() -> Stats_UDP {
            ::std::default::Default::default()
        }

        // optional uint64 pkts_sent = 1;

        pub fn get_pkts_sent(&self) -> u64 {
            self.pkts_sent.unwrap_or(0)
        }

        pub fn clear_pkts_sent(&mut self) {
            self.pkts_sent = ::std::option::Option::None;
        }

        pub fn has_pkts_sent(&self) -> bool {
            self.pkts_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_sent(&mut self, v: u64) {
            self.pkts_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_sent = 2;

        pub fn get_bytes_sent(&self) -> u64 {
            self.bytes_sent.unwrap_or(0)
        }

        pub fn clear_bytes_sent(&mut self) {
            self.bytes_sent = ::std::option::Option::None;
        }

        pub fn has_bytes_sent(&self) -> bool {
            self.bytes_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_sent(&mut self, v: u64) {
            self.bytes_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_recv = 3;

        pub fn get_pkts_recv(&self) -> u64 {
            self.pkts_recv.unwrap_or(0)
        }

        pub fn clear_pkts_recv(&mut self) {
            self.pkts_recv = ::std::option::Option::None;
        }

        pub fn has_pkts_recv(&self) -> bool {
            self.pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_recv(&mut self, v: u64) {
            self.pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_processed = 4;

        pub fn get_pkts_processed(&self) -> u64 {
            self.pkts_processed.unwrap_or(0)
        }

        pub fn clear_pkts_processed(&mut self) {
            self.pkts_processed = ::std::option::Option::None;
        }

        pub fn has_pkts_processed(&self) -> bool {
            self.pkts_processed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_processed(&mut self, v: u64) {
            self.pkts_processed = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_recv = 5;

        pub fn get_bytes_recv(&self) -> u64 {
            self.bytes_recv.unwrap_or(0)
        }

        pub fn clear_bytes_recv(&mut self) {
            self.bytes_recv = ::std::option::Option::None;
        }

        pub fn has_bytes_recv(&self) -> bool {
            self.bytes_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_recv(&mut self, v: u64) {
            self.bytes_recv = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Stats_UDP {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.pkts_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.bytes_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.pkts_processed = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.bytes_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.pkts_sent {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.bytes_sent {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.pkts_recv {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.pkts_processed {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.bytes_recv {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.pkts_sent {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.bytes_sent {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.pkts_recv {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.pkts_processed {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.bytes_recv {
                os.write_uint64(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Stats_UDP {
            Stats_UDP::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "pkts_sent",
                    |m: &Stats_UDP| { &m.pkts_sent },
                    |m: &mut Stats_UDP| { &mut m.pkts_sent },
                    Stats_UDP::get_pkts_sent,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "bytes_sent",
                    |m: &Stats_UDP| { &m.bytes_sent },
                    |m: &mut Stats_UDP| { &mut m.bytes_sent },
                    Stats_UDP::get_bytes_sent,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "pkts_recv",
                    |m: &Stats_UDP| { &m.pkts_recv },
                    |m: &mut Stats_UDP| { &mut m.pkts_recv },
                    Stats_UDP::get_pkts_recv,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "pkts_processed",
                    |m: &Stats_UDP| { &m.pkts_processed },
                    |m: &mut Stats_UDP| { &mut m.pkts_processed },
                    Stats_UDP::get_pkts_processed,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "bytes_recv",
                    |m: &Stats_UDP| { &m.bytes_recv },
                    |m: &mut Stats_UDP| { &mut m.bytes_recv },
                    Stats_UDP::get_bytes_recv,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stats_UDP>(
                    "CMsgClientConnectionStats.Stats_UDP",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Stats_UDP {
            static instance: ::protobuf::rt::Lazy<Stats_UDP> = ::protobuf::rt::Lazy::INIT;
            instance.get(Stats_UDP::new)
        }
    }

    impl ::protobuf::Clear for Stats_UDP {
        fn clear(&mut self) {
            self.pkts_sent = ::std::option::Option::None;
            self.bytes_sent = ::std::option::Option::None;
            self.pkts_recv = ::std::option::Option::None;
            self.pkts_processed = ::std::option::Option::None;
            self.bytes_recv = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Stats_UDP {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats_UDP {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct Stats_VConn {
        // message fields
        connections_udp: ::std::option::Option<u32>,
        connections_tcp: ::std::option::Option<u32>,
        pub stats_udp: ::protobuf::SingularPtrField<Stats_UDP>,
        pkts_abandoned: ::std::option::Option<u64>,
        conn_req_received: ::std::option::Option<u64>,
        pkts_resent: ::std::option::Option<u64>,
        msgs_sent: ::std::option::Option<u64>,
        msgs_sent_failed: ::std::option::Option<u64>,
        msgs_recv: ::std::option::Option<u64>,
        datagrams_sent: ::std::option::Option<u64>,
        datagrams_recv: ::std::option::Option<u64>,
        bad_pkts_recv: ::std::option::Option<u64>,
        unknown_conn_pkts_recv: ::std::option::Option<u64>,
        missed_pkts_recv: ::std::option::Option<u64>,
        dup_pkts_recv: ::std::option::Option<u64>,
        failed_connect_challenges: ::std::option::Option<u64>,
        micro_sec_avg_latency: ::std::option::Option<u32>,
        micro_sec_min_latency: ::std::option::Option<u32>,
        micro_sec_max_latency: ::std::option::Option<u32>,
        mem_pool_msg_in_use: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Stats_VConn {
        fn default() -> &'a Stats_VConn {
            <Stats_VConn as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_VConn {
        pub fn new() -> Stats_VConn {
            ::std::default::Default::default()
        }

        // optional uint32 connections_udp = 1;

        pub fn get_connections_udp(&self) -> u32 {
            self.connections_udp.unwrap_or(0)
        }

        pub fn clear_connections_udp(&mut self) {
            self.connections_udp = ::std::option::Option::None;
        }

        pub fn has_connections_udp(&self) -> bool {
            self.connections_udp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_udp(&mut self, v: u32) {
            self.connections_udp = ::std::option::Option::Some(v);
        }

        // optional uint32 connections_tcp = 2;

        pub fn get_connections_tcp(&self) -> u32 {
            self.connections_tcp.unwrap_or(0)
        }

        pub fn clear_connections_tcp(&mut self) {
            self.connections_tcp = ::std::option::Option::None;
        }

        pub fn has_connections_tcp(&self) -> bool {
            self.connections_tcp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_tcp(&mut self, v: u32) {
            self.connections_tcp = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_abandoned = 4;

        pub fn get_pkts_abandoned(&self) -> u64 {
            self.pkts_abandoned.unwrap_or(0)
        }

        pub fn clear_pkts_abandoned(&mut self) {
            self.pkts_abandoned = ::std::option::Option::None;
        }

        pub fn has_pkts_abandoned(&self) -> bool {
            self.pkts_abandoned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_abandoned(&mut self, v: u64) {
            self.pkts_abandoned = ::std::option::Option::Some(v);
        }

        // optional uint64 conn_req_received = 5;

        pub fn get_conn_req_received(&self) -> u64 {
            self.conn_req_received.unwrap_or(0)
        }

        pub fn clear_conn_req_received(&mut self) {
            self.conn_req_received = ::std::option::Option::None;
        }

        pub fn has_conn_req_received(&self) -> bool {
            self.conn_req_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_conn_req_received(&mut self, v: u64) {
            self.conn_req_received = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_resent = 6;

        pub fn get_pkts_resent(&self) -> u64 {
            self.pkts_resent.unwrap_or(0)
        }

        pub fn clear_pkts_resent(&mut self) {
            self.pkts_resent = ::std::option::Option::None;
        }

        pub fn has_pkts_resent(&self) -> bool {
            self.pkts_resent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_resent(&mut self, v: u64) {
            self.pkts_resent = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_sent = 7;

        pub fn get_msgs_sent(&self) -> u64 {
            self.msgs_sent.unwrap_or(0)
        }

        pub fn clear_msgs_sent(&mut self) {
            self.msgs_sent = ::std::option::Option::None;
        }

        pub fn has_msgs_sent(&self) -> bool {
            self.msgs_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_sent(&mut self, v: u64) {
            self.msgs_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_sent_failed = 8;

        pub fn get_msgs_sent_failed(&self) -> u64 {
            self.msgs_sent_failed.unwrap_or(0)
        }

        pub fn clear_msgs_sent_failed(&mut self) {
            self.msgs_sent_failed = ::std::option::Option::None;
        }

        pub fn has_msgs_sent_failed(&self) -> bool {
            self.msgs_sent_failed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_sent_failed(&mut self, v: u64) {
            self.msgs_sent_failed = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_recv = 9;

        pub fn get_msgs_recv(&self) -> u64 {
            self.msgs_recv.unwrap_or(0)
        }

        pub fn clear_msgs_recv(&mut self) {
            self.msgs_recv = ::std::option::Option::None;
        }

        pub fn has_msgs_recv(&self) -> bool {
            self.msgs_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_recv(&mut self, v: u64) {
            self.msgs_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 datagrams_sent = 10;

        pub fn get_datagrams_sent(&self) -> u64 {
            self.datagrams_sent.unwrap_or(0)
        }

        pub fn clear_datagrams_sent(&mut self) {
            self.datagrams_sent = ::std::option::Option::None;
        }

        pub fn has_datagrams_sent(&self) -> bool {
            self.datagrams_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datagrams_sent(&mut self, v: u64) {
            self.datagrams_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 datagrams_recv = 11;

        pub fn get_datagrams_recv(&self) -> u64 {
            self.datagrams_recv.unwrap_or(0)
        }

        pub fn clear_datagrams_recv(&mut self) {
            self.datagrams_recv = ::std::option::Option::None;
        }

        pub fn has_datagrams_recv(&self) -> bool {
            self.datagrams_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datagrams_recv(&mut self, v: u64) {
            self.datagrams_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 bad_pkts_recv = 12;

        pub fn get_bad_pkts_recv(&self) -> u64 {
            self.bad_pkts_recv.unwrap_or(0)
        }

        pub fn clear_bad_pkts_recv(&mut self) {
            self.bad_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_bad_pkts_recv(&self) -> bool {
            self.bad_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bad_pkts_recv(&mut self, v: u64) {
            self.bad_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 unknown_conn_pkts_recv = 13;

        pub fn get_unknown_conn_pkts_recv(&self) -> u64 {
            self.unknown_conn_pkts_recv.unwrap_or(0)
        }

        pub fn clear_unknown_conn_pkts_recv(&mut self) {
            self.unknown_conn_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_unknown_conn_pkts_recv(&self) -> bool {
            self.unknown_conn_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unknown_conn_pkts_recv(&mut self, v: u64) {
            self.unknown_conn_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 missed_pkts_recv = 14;

        pub fn get_missed_pkts_recv(&self) -> u64 {
            self.missed_pkts_recv.unwrap_or(0)
        }

        pub fn clear_missed_pkts_recv(&mut self) {
            self.missed_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_missed_pkts_recv(&self) -> bool {
            self.missed_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_missed_pkts_recv(&mut self, v: u64) {
            self.missed_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 dup_pkts_recv = 15;

        pub fn get_dup_pkts_recv(&self) -> u64 {
            self.dup_pkts_recv.unwrap_or(0)
        }

        pub fn clear_dup_pkts_recv(&mut self) {
            self.dup_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_dup_pkts_recv(&self) -> bool {
            self.dup_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dup_pkts_recv(&mut self, v: u64) {
            self.dup_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 failed_connect_challenges = 16;

        pub fn get_failed_connect_challenges(&self) -> u64 {
            self.failed_connect_challenges.unwrap_or(0)
        }

        pub fn clear_failed_connect_challenges(&mut self) {
            self.failed_connect_challenges = ::std::option::Option::None;
        }

        pub fn has_failed_connect_challenges(&self) -> bool {
            self.failed_connect_challenges.is_some()
        }

        // Param is passed by value, moved
        pub fn set_failed_connect_challenges(&mut self, v: u64) {
            self.failed_connect_challenges = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_avg_latency = 17;

        pub fn get_micro_sec_avg_latency(&self) -> u32 {
            self.micro_sec_avg_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_avg_latency(&mut self) {
            self.micro_sec_avg_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_avg_latency(&self) -> bool {
            self.micro_sec_avg_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_avg_latency(&mut self, v: u32) {
            self.micro_sec_avg_latency = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_min_latency = 18;

        pub fn get_micro_sec_min_latency(&self) -> u32 {
            self.micro_sec_min_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_min_latency(&mut self) {
            self.micro_sec_min_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_min_latency(&self) -> bool {
            self.micro_sec_min_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_min_latency(&mut self, v: u32) {
            self.micro_sec_min_latency = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_max_latency = 19;

        pub fn get_micro_sec_max_latency(&self) -> u32 {
            self.micro_sec_max_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_max_latency(&mut self) {
            self.micro_sec_max_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_max_latency(&self) -> bool {
            self.micro_sec_max_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_max_latency(&mut self, v: u32) {
            self.micro_sec_max_latency = ::std::option::Option::Some(v);
        }

        // optional uint32 mem_pool_msg_in_use = 20;

        pub fn get_mem_pool_msg_in_use(&self) -> u32 {
            self.mem_pool_msg_in_use.unwrap_or(0)
        }

        pub fn clear_mem_pool_msg_in_use(&mut self) {
            self.mem_pool_msg_in_use = ::std::option::Option::None;
        }

        pub fn has_mem_pool_msg_in_use(&self) -> bool {
            self.mem_pool_msg_in_use.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mem_pool_msg_in_use(&mut self, v: u32) {
            self.mem_pool_msg_in_use = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Stats_VConn {
        fn is_initialized(&self) -> bool {
            for v in &self.stats_udp {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.connections_udp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.connections_tcp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        ::protobuf::rt::read_singular_message_into::<Stats_UDP, _>(wire_type, is, &mut self.stats_udp)?;
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.pkts_abandoned = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.conn_req_received = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.pkts_resent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.msgs_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    8 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.msgs_sent_failed = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    9 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.msgs_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    10 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.datagrams_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    11 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.datagrams_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    12 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.bad_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    13 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.unknown_conn_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    14 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.missed_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    15 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.dup_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.failed_connect_challenges = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    17 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.micro_sec_avg_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.micro_sec_min_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    19 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.micro_sec_max_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    20 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.mem_pool_msg_in_use = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.connections_udp {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.connections_tcp {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.stats_udp.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            }
            if let Some(v) = self.pkts_abandoned {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.conn_req_received {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.pkts_resent {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.msgs_sent {
                my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.msgs_sent_failed {
                my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.msgs_recv {
                my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.datagrams_sent {
                my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.datagrams_recv {
                my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.bad_pkts_recv {
                my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.unknown_conn_pkts_recv {
                my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.missed_pkts_recv {
                my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.dup_pkts_recv {
                my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.failed_connect_challenges {
                my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.micro_sec_avg_latency {
                my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.micro_sec_min_latency {
                my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.micro_sec_max_latency {
                my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.mem_pool_msg_in_use {
                my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.connections_udp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.connections_tcp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.stats_udp.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.pkts_abandoned {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.conn_req_received {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.pkts_resent {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.msgs_sent {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.msgs_sent_failed {
                os.write_uint64(8, v)?;
            }
            if let Some(v) = self.msgs_recv {
                os.write_uint64(9, v)?;
            }
            if let Some(v) = self.datagrams_sent {
                os.write_uint64(10, v)?;
            }
            if let Some(v) = self.datagrams_recv {
                os.write_uint64(11, v)?;
            }
            if let Some(v) = self.bad_pkts_recv {
                os.write_uint64(12, v)?;
            }
            if let Some(v) = self.unknown_conn_pkts_recv {
                os.write_uint64(13, v)?;
            }
            if let Some(v) = self.missed_pkts_recv {
                os.write_uint64(14, v)?;
            }
            if let Some(v) = self.dup_pkts_recv {
                os.write_uint64(15, v)?;
            }
            if let Some(v) = self.failed_connect_challenges {
                os.write_uint64(16, v)?;
            }
            if let Some(v) = self.micro_sec_avg_latency {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.micro_sec_min_latency {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.micro_sec_max_latency {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.mem_pool_msg_in_use {
                os.write_uint32(20, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Stats_VConn {
            Stats_VConn::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "connections_udp",
                    |m: &Stats_VConn| { &m.connections_udp },
                    |m: &mut Stats_VConn| { &mut m.connections_udp },
                    Stats_VConn::get_connections_udp,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "connections_tcp",
                    |m: &Stats_VConn| { &m.connections_tcp },
                    |m: &mut Stats_VConn| { &mut m.connections_tcp },
                    Stats_VConn::get_connections_tcp,
                ));
                fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<Stats_UDP>, _>(
                    "stats_udp",
                    |m: &Stats_VConn| { &m.stats_udp },
                    |m: &mut Stats_VConn| { &mut m.stats_udp },
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "pkts_abandoned",
                    |m: &Stats_VConn| { &m.pkts_abandoned },
                    |m: &mut Stats_VConn| { &mut m.pkts_abandoned },
                    Stats_VConn::get_pkts_abandoned,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "conn_req_received",
                    |m: &Stats_VConn| { &m.conn_req_received },
                    |m: &mut Stats_VConn| { &mut m.conn_req_received },
                    Stats_VConn::get_conn_req_received,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "pkts_resent",
                    |m: &Stats_VConn| { &m.pkts_resent },
                    |m: &mut Stats_VConn| { &mut m.pkts_resent },
                    Stats_VConn::get_pkts_resent,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "msgs_sent",
                    |m: &Stats_VConn| { &m.msgs_sent },
                    |m: &mut Stats_VConn| { &mut m.msgs_sent },
                    Stats_VConn::get_msgs_sent,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "msgs_sent_failed",
                    |m: &Stats_VConn| { &m.msgs_sent_failed },
                    |m: &mut Stats_VConn| { &mut m.msgs_sent_failed },
                    Stats_VConn::get_msgs_sent_failed,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "msgs_recv",
                    |m: &Stats_VConn| { &m.msgs_recv },
                    |m: &mut Stats_VConn| { &mut m.msgs_recv },
                    Stats_VConn::get_msgs_recv,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "datagrams_sent",
                    |m: &Stats_VConn| { &m.datagrams_sent },
                    |m: &mut Stats_VConn| { &mut m.datagrams_sent },
                    Stats_VConn::get_datagrams_sent,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "datagrams_recv",
                    |m: &Stats_VConn| { &m.datagrams_recv },
                    |m: &mut Stats_VConn| { &mut m.datagrams_recv },
                    Stats_VConn::get_datagrams_recv,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "bad_pkts_recv",
                    |m: &Stats_VConn| { &m.bad_pkts_recv },
                    |m: &mut Stats_VConn| { &mut m.bad_pkts_recv },
                    Stats_VConn::get_bad_pkts_recv,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "unknown_conn_pkts_recv",
                    |m: &Stats_VConn| { &m.unknown_conn_pkts_recv },
                    |m: &mut Stats_VConn| { &mut m.unknown_conn_pkts_recv },
                    Stats_VConn::get_unknown_conn_pkts_recv,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "missed_pkts_recv",
                    |m: &Stats_VConn| { &m.missed_pkts_recv },
                    |m: &mut Stats_VConn| { &mut m.missed_pkts_recv },
                    Stats_VConn::get_missed_pkts_recv,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "dup_pkts_recv",
                    |m: &Stats_VConn| { &m.dup_pkts_recv },
                    |m: &mut Stats_VConn| { &mut m.dup_pkts_recv },
                    Stats_VConn::get_dup_pkts_recv,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "failed_connect_challenges",
                    |m: &Stats_VConn| { &m.failed_connect_challenges },
                    |m: &mut Stats_VConn| { &mut m.failed_connect_challenges },
                    Stats_VConn::get_failed_connect_challenges,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "micro_sec_avg_latency",
                    |m: &Stats_VConn| { &m.micro_sec_avg_latency },
                    |m: &mut Stats_VConn| { &mut m.micro_sec_avg_latency },
                    Stats_VConn::get_micro_sec_avg_latency,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "micro_sec_min_latency",
                    |m: &Stats_VConn| { &m.micro_sec_min_latency },
                    |m: &mut Stats_VConn| { &mut m.micro_sec_min_latency },
                    Stats_VConn::get_micro_sec_min_latency,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "micro_sec_max_latency",
                    |m: &Stats_VConn| { &m.micro_sec_max_latency },
                    |m: &mut Stats_VConn| { &mut m.micro_sec_max_latency },
                    Stats_VConn::get_micro_sec_max_latency,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "mem_pool_msg_in_use",
                    |m: &Stats_VConn| { &m.mem_pool_msg_in_use },
                    |m: &mut Stats_VConn| { &mut m.mem_pool_msg_in_use },
                    Stats_VConn::get_mem_pool_msg_in_use,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stats_VConn>(
                    "CMsgClientConnectionStats.Stats_VConn",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Stats_VConn {
            static instance: ::protobuf::rt::Lazy<Stats_VConn> = ::protobuf::rt::Lazy::INIT;
            instance.get(Stats_VConn::new)
        }
    }

    impl ::protobuf::Clear for Stats_VConn {
        fn clear(&mut self) {
            self.connections_udp = ::std::option::Option::None;
            self.connections_tcp = ::std::option::Option::None;
            self.stats_udp.clear();
            self.pkts_abandoned = ::std::option::Option::None;
            self.conn_req_received = ::std::option::Option::None;
            self.pkts_resent = ::std::option::Option::None;
            self.msgs_sent = ::std::option::Option::None;
            self.msgs_sent_failed = ::std::option::Option::None;
            self.msgs_recv = ::std::option::Option::None;
            self.datagrams_sent = ::std::option::Option::None;
            self.datagrams_recv = ::std::option::Option::None;
            self.bad_pkts_recv = ::std::option::Option::None;
            self.unknown_conn_pkts_recv = ::std::option::Option::None;
            self.missed_pkts_recv = ::std::option::Option::None;
            self.dup_pkts_recv = ::std::option::Option::None;
            self.failed_connect_challenges = ::std::option::Option::None;
            self.micro_sec_avg_latency = ::std::option::Option::None;
            self.micro_sec_min_latency = ::std::option::Option::None;
            self.micro_sec_max_latency = ::std::option::Option::None;
            self.mem_pool_msg_in_use = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Stats_VConn {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats_VConn {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServersAvailable {
    // message fields
    pub server_types_available: ::protobuf::RepeatedField<cmsg_client_servers_available::Server_Types_Available>,
    server_type_for_auth_services: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServersAvailable {
    fn default() -> &'a CMsgClientServersAvailable {
        <CMsgClientServersAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServersAvailable {
    pub fn new() -> CMsgClientServersAvailable {
        ::std::default::Default::default()
    }

    // optional uint32 server_type_for_auth_services = 2;

    pub fn get_server_type_for_auth_services(&self) -> u32 {
        self.server_type_for_auth_services.unwrap_or(0)
    }

    pub fn clear_server_type_for_auth_services(&mut self) {
        self.server_type_for_auth_services = ::std::option::Option::None;
    }

    pub fn has_server_type_for_auth_services(&self) -> bool {
        self.server_type_for_auth_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type_for_auth_services(&mut self, v: u32) {
        self.server_type_for_auth_services = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServersAvailable {
    fn is_initialized(&self) -> bool {
        for v in &self.server_types_available {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.server_types_available)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.server_type_for_auth_services = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.server_types_available {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.server_type_for_auth_services {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.server_types_available {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.server_type_for_auth_services {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServersAvailable {
        CMsgClientServersAvailable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_servers_available::Server_Types_Available>>(
                "server_types_available",
                |m: &CMsgClientServersAvailable| { &m.server_types_available },
                |m: &mut CMsgClientServersAvailable| { &mut m.server_types_available },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "server_type_for_auth_services",
                |m: &CMsgClientServersAvailable| { &m.server_type_for_auth_services },
                |m: &mut CMsgClientServersAvailable| { &mut m.server_type_for_auth_services },
                CMsgClientServersAvailable::get_server_type_for_auth_services,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientServersAvailable>(
                "CMsgClientServersAvailable",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServersAvailable {
        static instance: ::protobuf::rt::Lazy<CMsgClientServersAvailable> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientServersAvailable::new)
    }
}

impl ::protobuf::Clear for CMsgClientServersAvailable {
    fn clear(&mut self) {
        self.server_types_available.clear();
        self.server_type_for_auth_services = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServersAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServersAvailable {
}

/// Nested message and enums of message `CMsgClientServersAvailable`
pub mod cmsg_client_servers_available {
    #[derive(PartialEq,Clone,Default)]
    pub struct Server_Types_Available {
        // message fields
        server: ::std::option::Option<u32>,
        changed: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Server_Types_Available {
        fn default() -> &'a Server_Types_Available {
            <Server_Types_Available as ::protobuf::Message>::default_instance()
        }
    }

    impl Server_Types_Available {
        pub fn new() -> Server_Types_Available {
            ::std::default::Default::default()
        }

        // optional uint32 server = 1;

        pub fn get_server(&self) -> u32 {
            self.server.unwrap_or(0)
        }

        pub fn clear_server(&mut self) {
            self.server = ::std::option::Option::None;
        }

        pub fn has_server(&self) -> bool {
            self.server.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server(&mut self, v: u32) {
            self.server = ::std::option::Option::Some(v);
        }

        // optional bool changed = 2;

        pub fn get_changed(&self) -> bool {
            self.changed.unwrap_or(false)
        }

        pub fn clear_changed(&mut self) {
            self.changed = ::std::option::Option::None;
        }

        pub fn has_changed(&self) -> bool {
            self.changed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_changed(&mut self, v: bool) {
            self.changed = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Server_Types_Available {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.server = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.changed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.server {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.changed {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.server {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.changed {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Server_Types_Available {
            Server_Types_Available::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "server",
                    |m: &Server_Types_Available| { &m.server },
                    |m: &mut Server_Types_Available| { &mut m.server },
                    Server_Types_Available::get_server,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "changed",
                    |m: &Server_Types_Available| { &m.changed },
                    |m: &mut Server_Types_Available| { &mut m.changed },
                    Server_Types_Available::get_changed,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Server_Types_Available>(
                    "CMsgClientServersAvailable.Server_Types_Available",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Server_Types_Available {
            static instance: ::protobuf::rt::Lazy<Server_Types_Available> = ::protobuf::rt::Lazy::INIT;
            instance.get(Server_Types_Available::new)
        }
    }

    impl ::protobuf::Clear for Server_Types_Available {
        fn clear(&mut self) {
            self.server = ::std::option::Option::None;
            self.changed = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Server_Types_Available {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Server_Types_Available {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetUserStats {
    // message fields
    game_id: ::std::option::Option<u64>,
    crc_stats: ::std::option::Option<u32>,
    schema_local_version: ::std::option::Option<i32>,
    steam_id_for_user: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetUserStats {
    fn default() -> &'a CMsgClientGetUserStats {
        <CMsgClientGetUserStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetUserStats {
    pub fn new() -> CMsgClientGetUserStats {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 2;

    pub fn get_crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional int32 schema_local_version = 3;

    pub fn get_schema_local_version(&self) -> i32 {
        self.schema_local_version.unwrap_or(0)
    }

    pub fn clear_schema_local_version(&mut self) {
        self.schema_local_version = ::std::option::Option::None;
    }

    pub fn has_schema_local_version(&self) -> bool {
        self.schema_local_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_local_version(&mut self, v: i32) {
        self.schema_local_version = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_for_user = 4;

    pub fn get_steam_id_for_user(&self) -> u64 {
        self.steam_id_for_user.unwrap_or(0)
    }

    pub fn clear_steam_id_for_user(&mut self) {
        self.steam_id_for_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_for_user(&self) -> bool {
        self.steam_id_for_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_for_user(&mut self, v: u64) {
        self.steam_id_for_user = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetUserStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.crc_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.schema_local_version = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_for_user = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.schema_local_version {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_for_user {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.schema_local_version {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.steam_id_for_user {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetUserStats {
        CMsgClientGetUserStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "game_id",
                |m: &CMsgClientGetUserStats| { &m.game_id },
                |m: &mut CMsgClientGetUserStats| { &mut m.game_id },
                CMsgClientGetUserStats::get_game_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "crc_stats",
                |m: &CMsgClientGetUserStats| { &m.crc_stats },
                |m: &mut CMsgClientGetUserStats| { &mut m.crc_stats },
                CMsgClientGetUserStats::get_crc_stats,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "schema_local_version",
                |m: &CMsgClientGetUserStats| { &m.schema_local_version },
                |m: &mut CMsgClientGetUserStats| { &mut m.schema_local_version },
                CMsgClientGetUserStats::get_schema_local_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_for_user",
                |m: &CMsgClientGetUserStats| { &m.steam_id_for_user },
                |m: &mut CMsgClientGetUserStats| { &mut m.steam_id_for_user },
                CMsgClientGetUserStats::get_steam_id_for_user,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetUserStats>(
                "CMsgClientGetUserStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetUserStats {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetUserStats> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetUserStats::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetUserStats {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.schema_local_version = ::std::option::Option::None;
        self.steam_id_for_user = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetUserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetUserStats {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetUserStatsResponse {
    // message fields
    game_id: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    crc_stats: ::std::option::Option<u32>,
    schema: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub stats: ::protobuf::RepeatedField<cmsg_client_get_user_stats_response::Stats>,
    pub achievement_blocks: ::protobuf::RepeatedField<cmsg_client_get_user_stats_response::Achievement_Blocks>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetUserStatsResponse {
    fn default() -> &'a CMsgClientGetUserStatsResponse {
        <CMsgClientGetUserStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetUserStatsResponse {
    pub fn new() -> CMsgClientGetUserStatsResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 3;

    pub fn get_crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional bytes schema = 4;

    pub fn get_schema(&self) -> &[u8] {
        match self.schema.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> ::std::vec::Vec<u8> {
        self.schema.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientGetUserStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.achievement_blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.crc_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.stats)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.achievement_blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.schema.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.achievement_blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.schema.as_ref() {
            os.write_bytes(4, v)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.achievement_blocks {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetUserStatsResponse {
        CMsgClientGetUserStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "game_id",
                |m: &CMsgClientGetUserStatsResponse| { &m.game_id },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.game_id },
                CMsgClientGetUserStatsResponse::get_game_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientGetUserStatsResponse| { &m.eresult },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.eresult },
                CMsgClientGetUserStatsResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "crc_stats",
                |m: &CMsgClientGetUserStatsResponse| { &m.crc_stats },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.crc_stats },
                CMsgClientGetUserStatsResponse::get_crc_stats,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "schema",
                |m: &CMsgClientGetUserStatsResponse| { &m.schema },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.schema },
                CMsgClientGetUserStatsResponse::get_schema,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_get_user_stats_response::Stats>>(
                "stats",
                |m: &CMsgClientGetUserStatsResponse| { &m.stats },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_get_user_stats_response::Achievement_Blocks>>(
                "achievement_blocks",
                |m: &CMsgClientGetUserStatsResponse| { &m.achievement_blocks },
                |m: &mut CMsgClientGetUserStatsResponse| { &mut m.achievement_blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetUserStatsResponse>(
                "CMsgClientGetUserStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetUserStatsResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetUserStatsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetUserStatsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetUserStatsResponse {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.schema.clear();
        self.stats.clear();
        self.achievement_blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetUserStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetUserStatsResponse {
}

/// Nested message and enums of message `CMsgClientGetUserStatsResponse`
pub mod cmsg_client_get_user_stats_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Stats {
        // message fields
        stat_id: ::std::option::Option<u32>,
        stat_value: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Stats {
        fn default() -> &'a Stats {
            <Stats as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats {
        pub fn new() -> Stats {
            ::std::default::Default::default()
        }

        // optional uint32 stat_id = 1;

        pub fn get_stat_id(&self) -> u32 {
            self.stat_id.unwrap_or(0)
        }

        pub fn clear_stat_id(&mut self) {
            self.stat_id = ::std::option::Option::None;
        }

        pub fn has_stat_id(&self) -> bool {
            self.stat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_id(&mut self, v: u32) {
            self.stat_id = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_value = 2;

        pub fn get_stat_value(&self) -> u32 {
            self.stat_value.unwrap_or(0)
        }

        pub fn clear_stat_value(&mut self) {
            self.stat_value = ::std::option::Option::None;
        }

        pub fn has_stat_value(&self) -> bool {
            self.stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_value(&mut self, v: u32) {
            self.stat_value = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Stats {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stat_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.stat_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.stat_value {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.stat_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Stats {
            Stats::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stat_id",
                    |m: &Stats| { &m.stat_id },
                    |m: &mut Stats| { &mut m.stat_id },
                    Stats::get_stat_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stat_value",
                    |m: &Stats| { &m.stat_value },
                    |m: &mut Stats| { &mut m.stat_value },
                    Stats::get_stat_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stats>(
                    "CMsgClientGetUserStatsResponse.Stats",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Stats {
            static instance: ::protobuf::rt::Lazy<Stats> = ::protobuf::rt::Lazy::INIT;
            instance.get(Stats::new)
        }
    }

    impl ::protobuf::Clear for Stats {
        fn clear(&mut self) {
            self.stat_id = ::std::option::Option::None;
            self.stat_value = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Stats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct Achievement_Blocks {
        // message fields
        achievement_id: ::std::option::Option<u32>,
        pub unlock_time: ::std::vec::Vec<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Achievement_Blocks {
        fn default() -> &'a Achievement_Blocks {
            <Achievement_Blocks as ::protobuf::Message>::default_instance()
        }
    }

    impl Achievement_Blocks {
        pub fn new() -> Achievement_Blocks {
            ::std::default::Default::default()
        }

        // optional uint32 achievement_id = 1;

        pub fn get_achievement_id(&self) -> u32 {
            self.achievement_id.unwrap_or(0)
        }

        pub fn clear_achievement_id(&mut self) {
            self.achievement_id = ::std::option::Option::None;
        }

        pub fn has_achievement_id(&self) -> bool {
            self.achievement_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_achievement_id(&mut self, v: u32) {
            self.achievement_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Achievement_Blocks {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.achievement_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.unlock_time)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.achievement_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += 5 * self.unlock_time.len() as u32;
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.achievement_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.unlock_time {
                os.write_fixed32(2, *v)?;
            };
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Achievement_Blocks {
            Achievement_Blocks::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "achievement_id",
                    |m: &Achievement_Blocks| { &m.achievement_id },
                    |m: &mut Achievement_Blocks| { &mut m.achievement_id },
                    Achievement_Blocks::get_achievement_id,
                ));
                fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32>(
                    "unlock_time",
                    |m: &Achievement_Blocks| { &m.unlock_time },
                    |m: &mut Achievement_Blocks| { &mut m.unlock_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Achievement_Blocks>(
                    "CMsgClientGetUserStatsResponse.Achievement_Blocks",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Achievement_Blocks {
            static instance: ::protobuf::rt::Lazy<Achievement_Blocks> = ::protobuf::rt::Lazy::INIT;
            instance.get(Achievement_Blocks::new)
        }
    }

    impl ::protobuf::Clear for Achievement_Blocks {
        fn clear(&mut self) {
            self.achievement_id = ::std::option::Option::None;
            self.unlock_time.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Achievement_Blocks {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Achievement_Blocks {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStoreUserStatsResponse {
    // message fields
    game_id: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    crc_stats: ::std::option::Option<u32>,
    pub stats_failed_validation: ::protobuf::RepeatedField<cmsg_client_store_user_stats_response::Stats_Failed_Validation>,
    stats_out_of_date: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStatsResponse {
    fn default() -> &'a CMsgClientStoreUserStatsResponse {
        <CMsgClientStoreUserStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStatsResponse {
    pub fn new() -> CMsgClientStoreUserStatsResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 3;

    pub fn get_crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional bool stats_out_of_date = 5;

    pub fn get_stats_out_of_date(&self) -> bool {
        self.stats_out_of_date.unwrap_or(false)
    }

    pub fn clear_stats_out_of_date(&mut self) {
        self.stats_out_of_date = ::std::option::Option::None;
    }

    pub fn has_stats_out_of_date(&self) -> bool {
        self.stats_out_of_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_out_of_date(&mut self, v: bool) {
        self.stats_out_of_date = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.stats_failed_validation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.crc_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.stats_failed_validation)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stats_out_of_date = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stats_failed_validation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.stats_out_of_date {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(3, v)?;
        }
        for v in &self.stats_failed_validation {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.stats_out_of_date {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStoreUserStatsResponse {
        CMsgClientStoreUserStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "game_id",
                |m: &CMsgClientStoreUserStatsResponse| { &m.game_id },
                |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.game_id },
                CMsgClientStoreUserStatsResponse::get_game_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientStoreUserStatsResponse| { &m.eresult },
                |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.eresult },
                CMsgClientStoreUserStatsResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "crc_stats",
                |m: &CMsgClientStoreUserStatsResponse| { &m.crc_stats },
                |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.crc_stats },
                CMsgClientStoreUserStatsResponse::get_crc_stats,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_store_user_stats_response::Stats_Failed_Validation>>(
                "stats_failed_validation",
                |m: &CMsgClientStoreUserStatsResponse| { &m.stats_failed_validation },
                |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.stats_failed_validation },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "stats_out_of_date",
                |m: &CMsgClientStoreUserStatsResponse| { &m.stats_out_of_date },
                |m: &mut CMsgClientStoreUserStatsResponse| { &mut m.stats_out_of_date },
                CMsgClientStoreUserStatsResponse::get_stats_out_of_date,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStoreUserStatsResponse>(
                "CMsgClientStoreUserStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStoreUserStatsResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientStoreUserStatsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientStoreUserStatsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStatsResponse {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.stats_failed_validation.clear();
        self.stats_out_of_date = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStatsResponse {
}

/// Nested message and enums of message `CMsgClientStoreUserStatsResponse`
pub mod cmsg_client_store_user_stats_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Stats_Failed_Validation {
        // message fields
        stat_id: ::std::option::Option<u32>,
        reverted_stat_value: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Stats_Failed_Validation {
        fn default() -> &'a Stats_Failed_Validation {
            <Stats_Failed_Validation as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_Failed_Validation {
        pub fn new() -> Stats_Failed_Validation {
            ::std::default::Default::default()
        }

        // optional uint32 stat_id = 1;

        pub fn get_stat_id(&self) -> u32 {
            self.stat_id.unwrap_or(0)
        }

        pub fn clear_stat_id(&mut self) {
            self.stat_id = ::std::option::Option::None;
        }

        pub fn has_stat_id(&self) -> bool {
            self.stat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_id(&mut self, v: u32) {
            self.stat_id = ::std::option::Option::Some(v);
        }

        // optional uint32 reverted_stat_value = 2;

        pub fn get_reverted_stat_value(&self) -> u32 {
            self.reverted_stat_value.unwrap_or(0)
        }

        pub fn clear_reverted_stat_value(&mut self) {
            self.reverted_stat_value = ::std::option::Option::None;
        }

        pub fn has_reverted_stat_value(&self) -> bool {
            self.reverted_stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reverted_stat_value(&mut self, v: u32) {
            self.reverted_stat_value = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Stats_Failed_Validation {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stat_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.reverted_stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.stat_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.reverted_stat_value {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.stat_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.reverted_stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Stats_Failed_Validation {
            Stats_Failed_Validation::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stat_id",
                    |m: &Stats_Failed_Validation| { &m.stat_id },
                    |m: &mut Stats_Failed_Validation| { &mut m.stat_id },
                    Stats_Failed_Validation::get_stat_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "reverted_stat_value",
                    |m: &Stats_Failed_Validation| { &m.reverted_stat_value },
                    |m: &mut Stats_Failed_Validation| { &mut m.reverted_stat_value },
                    Stats_Failed_Validation::get_reverted_stat_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stats_Failed_Validation>(
                    "CMsgClientStoreUserStatsResponse.Stats_Failed_Validation",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Stats_Failed_Validation {
            static instance: ::protobuf::rt::Lazy<Stats_Failed_Validation> = ::protobuf::rt::Lazy::INIT;
            instance.get(Stats_Failed_Validation::new)
        }
    }

    impl ::protobuf::Clear for Stats_Failed_Validation {
        fn clear(&mut self) {
            self.stat_id = ::std::option::Option::None;
            self.reverted_stat_value = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Stats_Failed_Validation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats_Failed_Validation {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStoreUserStats2 {
    // message fields
    game_id: ::std::option::Option<u64>,
    settor_steam_id: ::std::option::Option<u64>,
    settee_steam_id: ::std::option::Option<u64>,
    crc_stats: ::std::option::Option<u32>,
    explicit_reset: ::std::option::Option<bool>,
    pub stats: ::protobuf::RepeatedField<cmsg_client_store_user_stats2::Stats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStats2 {
    fn default() -> &'a CMsgClientStoreUserStats2 {
        <CMsgClientStoreUserStats2 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStats2 {
    pub fn new() -> CMsgClientStoreUserStats2 {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 settor_steam_id = 2;

    pub fn get_settor_steam_id(&self) -> u64 {
        self.settor_steam_id.unwrap_or(0)
    }

    pub fn clear_settor_steam_id(&mut self) {
        self.settor_steam_id = ::std::option::Option::None;
    }

    pub fn has_settor_steam_id(&self) -> bool {
        self.settor_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settor_steam_id(&mut self, v: u64) {
        self.settor_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 settee_steam_id = 3;

    pub fn get_settee_steam_id(&self) -> u64 {
        self.settee_steam_id.unwrap_or(0)
    }

    pub fn clear_settee_steam_id(&mut self) {
        self.settee_steam_id = ::std::option::Option::None;
    }

    pub fn has_settee_steam_id(&self) -> bool {
        self.settee_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settee_steam_id(&mut self, v: u64) {
        self.settee_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 4;

    pub fn get_crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    // optional bool explicit_reset = 5;

    pub fn get_explicit_reset(&self) -> bool {
        self.explicit_reset.unwrap_or(false)
    }

    pub fn clear_explicit_reset(&mut self) {
        self.explicit_reset = ::std::option::Option::None;
    }

    pub fn has_explicit_reset(&self) -> bool {
        self.explicit_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_reset(&mut self, v: bool) {
        self.explicit_reset = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats2 {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.settor_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.settee_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.crc_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.explicit_reset = ::std::option::Option::Some(is.read_bool()?);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.settor_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.settee_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.explicit_reset {
            my_size += 2;
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.settor_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.settee_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.explicit_reset {
            os.write_bool(5, v)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStoreUserStats2 {
        CMsgClientStoreUserStats2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "game_id",
                |m: &CMsgClientStoreUserStats2| { &m.game_id },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.game_id },
                CMsgClientStoreUserStats2::get_game_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "settor_steam_id",
                |m: &CMsgClientStoreUserStats2| { &m.settor_steam_id },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.settor_steam_id },
                CMsgClientStoreUserStats2::get_settor_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "settee_steam_id",
                |m: &CMsgClientStoreUserStats2| { &m.settee_steam_id },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.settee_steam_id },
                CMsgClientStoreUserStats2::get_settee_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "crc_stats",
                |m: &CMsgClientStoreUserStats2| { &m.crc_stats },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.crc_stats },
                CMsgClientStoreUserStats2::get_crc_stats,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "explicit_reset",
                |m: &CMsgClientStoreUserStats2| { &m.explicit_reset },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.explicit_reset },
                CMsgClientStoreUserStats2::get_explicit_reset,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_store_user_stats2::Stats>>(
                "stats",
                |m: &CMsgClientStoreUserStats2| { &m.stats },
                |m: &mut CMsgClientStoreUserStats2| { &mut m.stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStoreUserStats2>(
                "CMsgClientStoreUserStats2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStoreUserStats2 {
        static instance: ::protobuf::rt::Lazy<CMsgClientStoreUserStats2> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientStoreUserStats2::new)
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStats2 {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.settor_steam_id = ::std::option::Option::None;
        self.settee_steam_id = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.explicit_reset = ::std::option::Option::None;
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStats2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStats2 {
}

/// Nested message and enums of message `CMsgClientStoreUserStats2`
pub mod cmsg_client_store_user_stats2 {
    #[derive(PartialEq,Clone,Default)]
    pub struct Stats {
        // message fields
        stat_id: ::std::option::Option<u32>,
        stat_value: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Stats {
        fn default() -> &'a Stats {
            <Stats as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats {
        pub fn new() -> Stats {
            ::std::default::Default::default()
        }

        // optional uint32 stat_id = 1;

        pub fn get_stat_id(&self) -> u32 {
            self.stat_id.unwrap_or(0)
        }

        pub fn clear_stat_id(&mut self) {
            self.stat_id = ::std::option::Option::None;
        }

        pub fn has_stat_id(&self) -> bool {
            self.stat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_id(&mut self, v: u32) {
            self.stat_id = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_value = 2;

        pub fn get_stat_value(&self) -> u32 {
            self.stat_value.unwrap_or(0)
        }

        pub fn clear_stat_value(&mut self) {
            self.stat_value = ::std::option::Option::None;
        }

        pub fn has_stat_value(&self) -> bool {
            self.stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_value(&mut self, v: u32) {
            self.stat_value = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Stats {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stat_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.stat_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.stat_value {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.stat_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Stats {
            Stats::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stat_id",
                    |m: &Stats| { &m.stat_id },
                    |m: &mut Stats| { &mut m.stat_id },
                    Stats::get_stat_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stat_value",
                    |m: &Stats| { &m.stat_value },
                    |m: &mut Stats| { &mut m.stat_value },
                    Stats::get_stat_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stats>(
                    "CMsgClientStoreUserStats2.Stats",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Stats {
            static instance: ::protobuf::rt::Lazy<Stats> = ::protobuf::rt::Lazy::INIT;
            instance.get(Stats::new)
        }
    }

    impl ::protobuf::Clear for Stats {
        fn clear(&mut self) {
            self.stat_id = ::std::option::Option::None;
            self.stat_value = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Stats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStatsUpdated {
    // message fields
    steam_id: ::std::option::Option<u64>,
    game_id: ::std::option::Option<u64>,
    crc_stats: ::std::option::Option<u32>,
    pub updated_stats: ::protobuf::RepeatedField<cmsg_client_stats_updated::Updated_Stats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStatsUpdated {
    fn default() -> &'a CMsgClientStatsUpdated {
        <CMsgClientStatsUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStatsUpdated {
    pub fn new() -> CMsgClientStatsUpdated {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_id = 2;

    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 crc_stats = 3;

    pub fn get_crc_stats(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStatsUpdated {
    fn is_initialized(&self) -> bool {
        for v in &self.updated_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.crc_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.updated_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.crc_stats {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.updated_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.crc_stats {
            os.write_uint32(3, v)?;
        }
        for v in &self.updated_stats {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStatsUpdated {
        CMsgClientStatsUpdated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id",
                |m: &CMsgClientStatsUpdated| { &m.steam_id },
                |m: &mut CMsgClientStatsUpdated| { &mut m.steam_id },
                CMsgClientStatsUpdated::get_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "game_id",
                |m: &CMsgClientStatsUpdated| { &m.game_id },
                |m: &mut CMsgClientStatsUpdated| { &mut m.game_id },
                CMsgClientStatsUpdated::get_game_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "crc_stats",
                |m: &CMsgClientStatsUpdated| { &m.crc_stats },
                |m: &mut CMsgClientStatsUpdated| { &mut m.crc_stats },
                CMsgClientStatsUpdated::get_crc_stats,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_stats_updated::Updated_Stats>>(
                "updated_stats",
                |m: &CMsgClientStatsUpdated| { &m.updated_stats },
                |m: &mut CMsgClientStatsUpdated| { &mut m.updated_stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStatsUpdated>(
                "CMsgClientStatsUpdated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStatsUpdated {
        static instance: ::protobuf::rt::Lazy<CMsgClientStatsUpdated> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientStatsUpdated::new)
    }
}

impl ::protobuf::Clear for CMsgClientStatsUpdated {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.crc_stats = ::std::option::Option::None;
        self.updated_stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStatsUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStatsUpdated {
}

/// Nested message and enums of message `CMsgClientStatsUpdated`
pub mod cmsg_client_stats_updated {
    #[derive(PartialEq,Clone,Default)]
    pub struct Updated_Stats {
        // message fields
        stat_id: ::std::option::Option<u32>,
        stat_value: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Updated_Stats {
        fn default() -> &'a Updated_Stats {
            <Updated_Stats as ::protobuf::Message>::default_instance()
        }
    }

    impl Updated_Stats {
        pub fn new() -> Updated_Stats {
            ::std::default::Default::default()
        }

        // optional uint32 stat_id = 1;

        pub fn get_stat_id(&self) -> u32 {
            self.stat_id.unwrap_or(0)
        }

        pub fn clear_stat_id(&mut self) {
            self.stat_id = ::std::option::Option::None;
        }

        pub fn has_stat_id(&self) -> bool {
            self.stat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_id(&mut self, v: u32) {
            self.stat_id = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_value = 2;

        pub fn get_stat_value(&self) -> u32 {
            self.stat_value.unwrap_or(0)
        }

        pub fn clear_stat_value(&mut self) {
            self.stat_value = ::std::option::Option::None;
        }

        pub fn has_stat_value(&self) -> bool {
            self.stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_value(&mut self, v: u32) {
            self.stat_value = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Updated_Stats {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stat_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.stat_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.stat_value {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.stat_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Updated_Stats {
            Updated_Stats::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stat_id",
                    |m: &Updated_Stats| { &m.stat_id },
                    |m: &mut Updated_Stats| { &mut m.stat_id },
                    Updated_Stats::get_stat_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stat_value",
                    |m: &Updated_Stats| { &m.stat_value },
                    |m: &mut Updated_Stats| { &mut m.stat_value },
                    Updated_Stats::get_stat_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Updated_Stats>(
                    "CMsgClientStatsUpdated.Updated_Stats",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Updated_Stats {
            static instance: ::protobuf::rt::Lazy<Updated_Stats> = ::protobuf::rt::Lazy::INIT;
            instance.get(Updated_Stats::new)
        }
    }

    impl ::protobuf::Clear for Updated_Stats {
        fn clear(&mut self) {
            self.stat_id = ::std::option::Option::None;
            self.stat_value = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Updated_Stats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Updated_Stats {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientStoreUserStats {
    // message fields
    game_id: ::std::option::Option<u64>,
    explicit_reset: ::std::option::Option<bool>,
    pub stats_to_store: ::protobuf::RepeatedField<cmsg_client_store_user_stats::Stats_To_Store>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientStoreUserStats {
    fn default() -> &'a CMsgClientStoreUserStats {
        <CMsgClientStoreUserStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStoreUserStats {
    pub fn new() -> CMsgClientStoreUserStats {
        ::std::default::Default::default()
    }

    // optional fixed64 game_id = 1;

    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional bool explicit_reset = 2;

    pub fn get_explicit_reset(&self) -> bool {
        self.explicit_reset.unwrap_or(false)
    }

    pub fn clear_explicit_reset(&mut self) {
        self.explicit_reset = ::std::option::Option::None;
    }

    pub fn has_explicit_reset(&self) -> bool {
        self.explicit_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_reset(&mut self, v: bool) {
        self.explicit_reset = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats_to_store {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.explicit_reset = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.stats_to_store)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += 9;
        }
        if let Some(v) = self.explicit_reset {
            my_size += 2;
        }
        for value in &self.stats_to_store {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.explicit_reset {
            os.write_bool(2, v)?;
        }
        for v in &self.stats_to_store {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientStoreUserStats {
        CMsgClientStoreUserStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "game_id",
                |m: &CMsgClientStoreUserStats| { &m.game_id },
                |m: &mut CMsgClientStoreUserStats| { &mut m.game_id },
                CMsgClientStoreUserStats::get_game_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "explicit_reset",
                |m: &CMsgClientStoreUserStats| { &m.explicit_reset },
                |m: &mut CMsgClientStoreUserStats| { &mut m.explicit_reset },
                CMsgClientStoreUserStats::get_explicit_reset,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_store_user_stats::Stats_To_Store>>(
                "stats_to_store",
                |m: &CMsgClientStoreUserStats| { &m.stats_to_store },
                |m: &mut CMsgClientStoreUserStats| { &mut m.stats_to_store },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStoreUserStats>(
                "CMsgClientStoreUserStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientStoreUserStats {
        static instance: ::protobuf::rt::Lazy<CMsgClientStoreUserStats> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientStoreUserStats::new)
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStats {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.explicit_reset = ::std::option::Option::None;
        self.stats_to_store.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientStoreUserStats {
}

/// Nested message and enums of message `CMsgClientStoreUserStats`
pub mod cmsg_client_store_user_stats {
    #[derive(PartialEq,Clone,Default)]
    pub struct Stats_To_Store {
        // message fields
        stat_id: ::std::option::Option<u32>,
        stat_value: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Stats_To_Store {
        fn default() -> &'a Stats_To_Store {
            <Stats_To_Store as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_To_Store {
        pub fn new() -> Stats_To_Store {
            ::std::default::Default::default()
        }

        // optional uint32 stat_id = 1;

        pub fn get_stat_id(&self) -> u32 {
            self.stat_id.unwrap_or(0)
        }

        pub fn clear_stat_id(&mut self) {
            self.stat_id = ::std::option::Option::None;
        }

        pub fn has_stat_id(&self) -> bool {
            self.stat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_id(&mut self, v: u32) {
            self.stat_id = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_value = 2;

        pub fn get_stat_value(&self) -> u32 {
            self.stat_value.unwrap_or(0)
        }

        pub fn clear_stat_value(&mut self) {
            self.stat_value = ::std::option::Option::None;
        }

        pub fn has_stat_value(&self) -> bool {
            self.stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_value(&mut self, v: u32) {
            self.stat_value = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Stats_To_Store {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stat_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.stat_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.stat_value {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.stat_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Stats_To_Store {
            Stats_To_Store::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stat_id",
                    |m: &Stats_To_Store| { &m.stat_id },
                    |m: &mut Stats_To_Store| { &mut m.stat_id },
                    Stats_To_Store::get_stat_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stat_value",
                    |m: &Stats_To_Store| { &m.stat_value },
                    |m: &mut Stats_To_Store| { &mut m.stat_value },
                    Stats_To_Store::get_stat_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stats_To_Store>(
                    "CMsgClientStoreUserStats.Stats_To_Store",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Stats_To_Store {
            static instance: ::protobuf::rt::Lazy<Stats_To_Store> = ::protobuf::rt::Lazy::INIT;
            instance.get(Stats_To_Store::new)
        }
    }

    impl ::protobuf::Clear for Stats_To_Store {
        fn clear(&mut self) {
            self.stat_id = ::std::option::Option::None;
            self.stat_value = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Stats_To_Store {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stats_To_Store {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientDetails {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetails {
    fn default() -> &'a CMsgClientGetClientDetails {
        <CMsgClientGetClientDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetails {
    pub fn new() -> CMsgClientGetClientDetails {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientDetails {
        CMsgClientGetClientDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientDetails>(
                "CMsgClientGetClientDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientDetails {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetClientDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetClientDetails::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientDetails {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientDetails {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientReportOverlayDetourFailure {
    // message fields
    pub failure_strings: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientReportOverlayDetourFailure {
    fn default() -> &'a CMsgClientReportOverlayDetourFailure {
        <CMsgClientReportOverlayDetourFailure as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReportOverlayDetourFailure {
    pub fn new() -> CMsgClientReportOverlayDetourFailure {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientReportOverlayDetourFailure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.failure_strings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.failure_strings {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.failure_strings {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientReportOverlayDetourFailure {
        CMsgClientReportOverlayDetourFailure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "failure_strings",
                |m: &CMsgClientReportOverlayDetourFailure| { &m.failure_strings },
                |m: &mut CMsgClientReportOverlayDetourFailure| { &mut m.failure_strings },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientReportOverlayDetourFailure>(
                "CMsgClientReportOverlayDetourFailure",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientReportOverlayDetourFailure {
        static instance: ::protobuf::rt::Lazy<CMsgClientReportOverlayDetourFailure> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientReportOverlayDetourFailure::new)
    }
}

impl ::protobuf::Clear for CMsgClientReportOverlayDetourFailure {
    fn clear(&mut self) {
        self.failure_strings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientReportOverlayDetourFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientReportOverlayDetourFailure {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientDetailsResponse {
    // message fields
    package_version: ::std::option::Option<u32>,
    protocol_version: ::std::option::Option<u32>,
    os: ::protobuf::SingularField<::std::string::String>,
    machine_name: ::protobuf::SingularField<::std::string::String>,
    ip_public: ::protobuf::SingularField<::std::string::String>,
    ip_private: ::protobuf::SingularField<::std::string::String>,
    bytes_available: ::std::option::Option<u64>,
    pub games_running: ::protobuf::RepeatedField<cmsg_client_get_client_details_response::Game>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientDetailsResponse {
    fn default() -> &'a CMsgClientGetClientDetailsResponse {
        <CMsgClientGetClientDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientDetailsResponse {
    pub fn new() -> CMsgClientGetClientDetailsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 package_version = 1;

    pub fn get_package_version(&self) -> u32 {
        self.package_version.unwrap_or(0)
    }

    pub fn clear_package_version(&mut self) {
        self.package_version = ::std::option::Option::None;
    }

    pub fn has_package_version(&self) -> bool {
        self.package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_version(&mut self, v: u32) {
        self.package_version = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;

    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional string os = 2;

    pub fn get_os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os.set_default();
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_name = 3;

    pub fn get_machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name.clear();
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name.set_default();
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ip_public = 4;

    pub fn get_ip_public(&self) -> &str {
        match self.ip_public.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip_public(&mut self) {
        self.ip_public.clear();
    }

    pub fn has_ip_public(&self) -> bool {
        self.ip_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_public(&mut self, v: ::std::string::String) {
        self.ip_public = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_public(&mut self) -> &mut ::std::string::String {
        if self.ip_public.is_none() {
            self.ip_public.set_default();
        }
        self.ip_public.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_public(&mut self) -> ::std::string::String {
        self.ip_public.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ip_private = 5;

    pub fn get_ip_private(&self) -> &str {
        match self.ip_private.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip_private(&mut self) {
        self.ip_private.clear();
    }

    pub fn has_ip_private(&self) -> bool {
        self.ip_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_private(&mut self, v: ::std::string::String) {
        self.ip_private = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_private(&mut self) -> &mut ::std::string::String {
        if self.ip_private.is_none() {
            self.ip_private.set_default();
        }
        self.ip_private.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_private(&mut self) -> ::std::string::String {
        self.ip_private.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 bytes_available = 7;

    pub fn get_bytes_available(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }

    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.games_running {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.package_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_public)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_private)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bytes_available = ::std::option::Option::Some(is.read_uint64()?);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.games_running)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.package_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ip_public.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.ip_private.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.bytes_available {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.games_running {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.package_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ip_public.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.ip_private.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.bytes_available {
            os.write_uint64(7, v)?;
        }
        for v in &self.games_running {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientDetailsResponse {
        CMsgClientGetClientDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "package_version",
                |m: &CMsgClientGetClientDetailsResponse| { &m.package_version },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.package_version },
                CMsgClientGetClientDetailsResponse::get_package_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "protocol_version",
                |m: &CMsgClientGetClientDetailsResponse| { &m.protocol_version },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.protocol_version },
                CMsgClientGetClientDetailsResponse::get_protocol_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "os",
                |m: &CMsgClientGetClientDetailsResponse| { &m.os },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.os },
                CMsgClientGetClientDetailsResponse::get_os,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "machine_name",
                |m: &CMsgClientGetClientDetailsResponse| { &m.machine_name },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.machine_name },
                CMsgClientGetClientDetailsResponse::get_machine_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "ip_public",
                |m: &CMsgClientGetClientDetailsResponse| { &m.ip_public },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.ip_public },
                CMsgClientGetClientDetailsResponse::get_ip_public,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "ip_private",
                |m: &CMsgClientGetClientDetailsResponse| { &m.ip_private },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.ip_private },
                CMsgClientGetClientDetailsResponse::get_ip_private,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "bytes_available",
                |m: &CMsgClientGetClientDetailsResponse| { &m.bytes_available },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.bytes_available },
                CMsgClientGetClientDetailsResponse::get_bytes_available,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_get_client_details_response::Game>>(
                "games_running",
                |m: &CMsgClientGetClientDetailsResponse| { &m.games_running },
                |m: &mut CMsgClientGetClientDetailsResponse| { &mut m.games_running },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientDetailsResponse>(
                "CMsgClientGetClientDetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientDetailsResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetClientDetailsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetClientDetailsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientDetailsResponse {
    fn clear(&mut self) {
        self.package_version = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.os.clear();
        self.machine_name.clear();
        self.ip_public.clear();
        self.ip_private.clear();
        self.bytes_available = ::std::option::Option::None;
        self.games_running.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientDetailsResponse {
}

/// Nested message and enums of message `CMsgClientGetClientDetailsResponse`
pub mod cmsg_client_get_client_details_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Game {
        // message fields
        appid: ::std::option::Option<u32>,
        extra_info: ::protobuf::SingularField<::std::string::String>,
        time_running_sec: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Game {
        fn default() -> &'a Game {
            <Game as ::protobuf::Message>::default_instance()
        }
    }

    impl Game {
        pub fn new() -> Game {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string extra_info = 2;

        pub fn get_extra_info(&self) -> &str {
            match self.extra_info.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_extra_info(&mut self) {
            self.extra_info.clear();
        }

        pub fn has_extra_info(&self) -> bool {
            self.extra_info.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_info(&mut self, v: ::std::string::String) {
            self.extra_info = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_extra_info(&mut self) -> &mut ::std::string::String {
            if self.extra_info.is_none() {
                self.extra_info.set_default();
            }
            self.extra_info.as_mut().unwrap()
        }

        // Take field
        pub fn take_extra_info(&mut self) -> ::std::string::String {
            self.extra_info.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 time_running_sec = 3;

        pub fn get_time_running_sec(&self) -> u32 {
            self.time_running_sec.unwrap_or(0)
        }

        pub fn clear_time_running_sec(&mut self) {
            self.time_running_sec = ::std::option::Option::None;
        }

        pub fn has_time_running_sec(&self) -> bool {
            self.time_running_sec.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_running_sec(&mut self, v: u32) {
            self.time_running_sec = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Game {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.extra_info)?;
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_running_sec = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.extra_info.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.time_running_sec {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.extra_info.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.time_running_sec {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Game {
            Game::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &Game| { &m.appid },
                    |m: &mut Game| { &mut m.appid },
                    Game::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "extra_info",
                    |m: &Game| { &m.extra_info },
                    |m: &mut Game| { &mut m.extra_info },
                    Game::get_extra_info,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_running_sec",
                    |m: &Game| { &m.time_running_sec },
                    |m: &mut Game| { &mut m.time_running_sec },
                    Game::get_time_running_sec,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Game>(
                    "CMsgClientGetClientDetailsResponse.Game",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Game {
            static instance: ::protobuf::rt::Lazy<Game> = ::protobuf::rt::Lazy::INIT;
            instance.get(Game::new)
        }
    }

    impl ::protobuf::Clear for Game {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.extra_info.clear();
            self.time_running_sec = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Game {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Game {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientAppList {
    // message fields
    media: ::std::option::Option<bool>,
    tools: ::std::option::Option<bool>,
    games: ::std::option::Option<bool>,
    only_installed: ::std::option::Option<bool>,
    only_changing: ::std::option::Option<bool>,
    comics: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppList {
    fn default() -> &'a CMsgClientGetClientAppList {
        <CMsgClientGetClientAppList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppList {
    pub fn new() -> CMsgClientGetClientAppList {
        ::std::default::Default::default()
    }

    // optional bool media = 1;

    pub fn get_media(&self) -> bool {
        self.media.unwrap_or(false)
    }

    pub fn clear_media(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: bool) {
        self.media = ::std::option::Option::Some(v);
    }

    // optional bool tools = 2;

    pub fn get_tools(&self) -> bool {
        self.tools.unwrap_or(false)
    }

    pub fn clear_tools(&mut self) {
        self.tools = ::std::option::Option::None;
    }

    pub fn has_tools(&self) -> bool {
        self.tools.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tools(&mut self, v: bool) {
        self.tools = ::std::option::Option::Some(v);
    }

    // optional bool games = 3;

    pub fn get_games(&self) -> bool {
        self.games.unwrap_or(false)
    }

    pub fn clear_games(&mut self) {
        self.games = ::std::option::Option::None;
    }

    pub fn has_games(&self) -> bool {
        self.games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: bool) {
        self.games = ::std::option::Option::Some(v);
    }

    // optional bool only_installed = 4;

    pub fn get_only_installed(&self) -> bool {
        self.only_installed.unwrap_or(false)
    }

    pub fn clear_only_installed(&mut self) {
        self.only_installed = ::std::option::Option::None;
    }

    pub fn has_only_installed(&self) -> bool {
        self.only_installed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_installed(&mut self, v: bool) {
        self.only_installed = ::std::option::Option::Some(v);
    }

    // optional bool only_changing = 5;

    pub fn get_only_changing(&self) -> bool {
        self.only_changing.unwrap_or(false)
    }

    pub fn clear_only_changing(&mut self) {
        self.only_changing = ::std::option::Option::None;
    }

    pub fn has_only_changing(&self) -> bool {
        self.only_changing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_changing(&mut self, v: bool) {
        self.only_changing = ::std::option::Option::Some(v);
    }

    // optional bool comics = 6;

    pub fn get_comics(&self) -> bool {
        self.comics.unwrap_or(false)
    }

    pub fn clear_comics(&mut self) {
        self.comics = ::std::option::Option::None;
    }

    pub fn has_comics(&self) -> bool {
        self.comics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comics(&mut self, v: bool) {
        self.comics = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.media = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.tools = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.games = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.only_installed = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.only_changing = ::std::option::Option::Some(is.read_bool()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.comics = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.media {
            my_size += 2;
        }
        if let Some(v) = self.tools {
            my_size += 2;
        }
        if let Some(v) = self.games {
            my_size += 2;
        }
        if let Some(v) = self.only_installed {
            my_size += 2;
        }
        if let Some(v) = self.only_changing {
            my_size += 2;
        }
        if let Some(v) = self.comics {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.media {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.tools {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.games {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.only_installed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.only_changing {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.comics {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientAppList {
        CMsgClientGetClientAppList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "media",
                |m: &CMsgClientGetClientAppList| { &m.media },
                |m: &mut CMsgClientGetClientAppList| { &mut m.media },
                CMsgClientGetClientAppList::get_media,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "tools",
                |m: &CMsgClientGetClientAppList| { &m.tools },
                |m: &mut CMsgClientGetClientAppList| { &mut m.tools },
                CMsgClientGetClientAppList::get_tools,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "games",
                |m: &CMsgClientGetClientAppList| { &m.games },
                |m: &mut CMsgClientGetClientAppList| { &mut m.games },
                CMsgClientGetClientAppList::get_games,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "only_installed",
                |m: &CMsgClientGetClientAppList| { &m.only_installed },
                |m: &mut CMsgClientGetClientAppList| { &mut m.only_installed },
                CMsgClientGetClientAppList::get_only_installed,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "only_changing",
                |m: &CMsgClientGetClientAppList| { &m.only_changing },
                |m: &mut CMsgClientGetClientAppList| { &mut m.only_changing },
                CMsgClientGetClientAppList::get_only_changing,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "comics",
                |m: &CMsgClientGetClientAppList| { &m.comics },
                |m: &mut CMsgClientGetClientAppList| { &mut m.comics },
                CMsgClientGetClientAppList::get_comics,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientAppList>(
                "CMsgClientGetClientAppList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientAppList {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetClientAppList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetClientAppList::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientAppList {
    fn clear(&mut self) {
        self.media = ::std::option::Option::None;
        self.tools = ::std::option::Option::None;
        self.games = ::std::option::Option::None;
        self.only_installed = ::std::option::Option::None;
        self.only_changing = ::std::option::Option::None;
        self.comics = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientAppList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientAppList {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClientAppListResponse {
    // message fields
    pub apps: ::protobuf::RepeatedField<cmsg_client_get_client_app_list_response::App>,
    bytes_available: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClientAppListResponse {
    fn default() -> &'a CMsgClientGetClientAppListResponse {
        <CMsgClientGetClientAppListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClientAppListResponse {
    pub fn new() -> CMsgClientGetClientAppListResponse {
        ::std::default::Default::default()
    }

    // optional uint64 bytes_available = 2;

    pub fn get_bytes_available(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }

    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.apps)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bytes_available = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.bytes_available {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.bytes_available {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClientAppListResponse {
        CMsgClientGetClientAppListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_get_client_app_list_response::App>>(
                "apps",
                |m: &CMsgClientGetClientAppListResponse| { &m.apps },
                |m: &mut CMsgClientGetClientAppListResponse| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "bytes_available",
                |m: &CMsgClientGetClientAppListResponse| { &m.bytes_available },
                |m: &mut CMsgClientGetClientAppListResponse| { &mut m.bytes_available },
                CMsgClientGetClientAppListResponse::get_bytes_available,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientAppListResponse>(
                "CMsgClientGetClientAppListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClientAppListResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetClientAppListResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetClientAppListResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClientAppListResponse {
    fn clear(&mut self) {
        self.apps.clear();
        self.bytes_available = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientAppListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClientAppListResponse {
}

/// Nested message and enums of message `CMsgClientGetClientAppListResponse`
pub mod cmsg_client_get_client_app_list_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct App {
        // message fields
        appid: ::std::option::Option<u32>,
        category: ::protobuf::SingularField<::std::string::String>,
        app_type: ::protobuf::SingularField<::std::string::String>,
        favorite: ::std::option::Option<bool>,
        installed: ::std::option::Option<bool>,
        auto_update: ::std::option::Option<bool>,
        bytes_downloaded: ::std::option::Option<u64>,
        bytes_needed: ::std::option::Option<u64>,
        bytes_download_rate: ::std::option::Option<u32>,
        download_paused: ::std::option::Option<bool>,
        num_downloading: ::std::option::Option<u32>,
        num_paused: ::std::option::Option<u32>,
        changing: ::std::option::Option<bool>,
        available_on_platform: ::std::option::Option<bool>,
        pub dlcs: ::protobuf::RepeatedField<app::DLC>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string category = 2;

        pub fn get_category(&self) -> &str {
            match self.category.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_category(&mut self) {
            self.category.clear();
        }

        pub fn has_category(&self) -> bool {
            self.category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category(&mut self, v: ::std::string::String) {
            self.category = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_category(&mut self) -> &mut ::std::string::String {
            if self.category.is_none() {
                self.category.set_default();
            }
            self.category.as_mut().unwrap()
        }

        // Take field
        pub fn take_category(&mut self) -> ::std::string::String {
            self.category.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string app_type = 10;

        pub fn get_app_type(&self) -> &str {
            match self.app_type.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_app_type(&mut self) {
            self.app_type.clear();
        }

        pub fn has_app_type(&self) -> bool {
            self.app_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_type(&mut self, v: ::std::string::String) {
            self.app_type = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_app_type(&mut self) -> &mut ::std::string::String {
            if self.app_type.is_none() {
                self.app_type.set_default();
            }
            self.app_type.as_mut().unwrap()
        }

        // Take field
        pub fn take_app_type(&mut self) -> ::std::string::String {
            self.app_type.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool favorite = 3;

        pub fn get_favorite(&self) -> bool {
            self.favorite.unwrap_or(false)
        }

        pub fn clear_favorite(&mut self) {
            self.favorite = ::std::option::Option::None;
        }

        pub fn has_favorite(&self) -> bool {
            self.favorite.is_some()
        }

        // Param is passed by value, moved
        pub fn set_favorite(&mut self, v: bool) {
            self.favorite = ::std::option::Option::Some(v);
        }

        // optional bool installed = 4;

        pub fn get_installed(&self) -> bool {
            self.installed.unwrap_or(false)
        }

        pub fn clear_installed(&mut self) {
            self.installed = ::std::option::Option::None;
        }

        pub fn has_installed(&self) -> bool {
            self.installed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_installed(&mut self, v: bool) {
            self.installed = ::std::option::Option::Some(v);
        }

        // optional bool auto_update = 5;

        pub fn get_auto_update(&self) -> bool {
            self.auto_update.unwrap_or(false)
        }

        pub fn clear_auto_update(&mut self) {
            self.auto_update = ::std::option::Option::None;
        }

        pub fn has_auto_update(&self) -> bool {
            self.auto_update.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auto_update(&mut self, v: bool) {
            self.auto_update = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_downloaded = 6;

        pub fn get_bytes_downloaded(&self) -> u64 {
            self.bytes_downloaded.unwrap_or(0)
        }

        pub fn clear_bytes_downloaded(&mut self) {
            self.bytes_downloaded = ::std::option::Option::None;
        }

        pub fn has_bytes_downloaded(&self) -> bool {
            self.bytes_downloaded.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_downloaded(&mut self, v: u64) {
            self.bytes_downloaded = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_needed = 7;

        pub fn get_bytes_needed(&self) -> u64 {
            self.bytes_needed.unwrap_or(0)
        }

        pub fn clear_bytes_needed(&mut self) {
            self.bytes_needed = ::std::option::Option::None;
        }

        pub fn has_bytes_needed(&self) -> bool {
            self.bytes_needed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_needed(&mut self, v: u64) {
            self.bytes_needed = ::std::option::Option::Some(v);
        }

        // optional uint32 bytes_download_rate = 8;

        pub fn get_bytes_download_rate(&self) -> u32 {
            self.bytes_download_rate.unwrap_or(0)
        }

        pub fn clear_bytes_download_rate(&mut self) {
            self.bytes_download_rate = ::std::option::Option::None;
        }

        pub fn has_bytes_download_rate(&self) -> bool {
            self.bytes_download_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_download_rate(&mut self, v: u32) {
            self.bytes_download_rate = ::std::option::Option::Some(v);
        }

        // optional bool download_paused = 11;

        pub fn get_download_paused(&self) -> bool {
            self.download_paused.unwrap_or(false)
        }

        pub fn clear_download_paused(&mut self) {
            self.download_paused = ::std::option::Option::None;
        }

        pub fn has_download_paused(&self) -> bool {
            self.download_paused.is_some()
        }

        // Param is passed by value, moved
        pub fn set_download_paused(&mut self, v: bool) {
            self.download_paused = ::std::option::Option::Some(v);
        }

        // optional uint32 num_downloading = 12;

        pub fn get_num_downloading(&self) -> u32 {
            self.num_downloading.unwrap_or(0)
        }

        pub fn clear_num_downloading(&mut self) {
            self.num_downloading = ::std::option::Option::None;
        }

        pub fn has_num_downloading(&self) -> bool {
            self.num_downloading.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_downloading(&mut self, v: u32) {
            self.num_downloading = ::std::option::Option::Some(v);
        }

        // optional uint32 num_paused = 13;

        pub fn get_num_paused(&self) -> u32 {
            self.num_paused.unwrap_or(0)
        }

        pub fn clear_num_paused(&mut self) {
            self.num_paused = ::std::option::Option::None;
        }

        pub fn has_num_paused(&self) -> bool {
            self.num_paused.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_paused(&mut self, v: u32) {
            self.num_paused = ::std::option::Option::Some(v);
        }

        // optional bool changing = 14;

        pub fn get_changing(&self) -> bool {
            self.changing.unwrap_or(false)
        }

        pub fn clear_changing(&mut self) {
            self.changing = ::std::option::Option::None;
        }

        pub fn has_changing(&self) -> bool {
            self.changing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_changing(&mut self, v: bool) {
            self.changing = ::std::option::Option::Some(v);
        }

        // optional bool available_on_platform = 15;

        pub fn get_available_on_platform(&self) -> bool {
            self.available_on_platform.unwrap_or(false)
        }

        pub fn clear_available_on_platform(&mut self) {
            self.available_on_platform = ::std::option::Option::None;
        }

        pub fn has_available_on_platform(&self) -> bool {
            self.available_on_platform.is_some()
        }

        // Param is passed by value, moved
        pub fn set_available_on_platform(&mut self, v: bool) {
            self.available_on_platform = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for App {
        fn is_initialized(&self) -> bool {
            for v in &self.dlcs {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.category)?;
                    },
                    10 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.app_type)?;
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.favorite = ::std::option::Option::Some(is.read_bool()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.installed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.auto_update = ::std::option::Option::Some(is.read_bool()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.bytes_downloaded = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.bytes_needed = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    8 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.bytes_download_rate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    11 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.download_paused = ::std::option::Option::Some(is.read_bool()?);
                    },
                    12 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.num_downloading = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    13 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.num_paused = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    14 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.changing = ::std::option::Option::Some(is.read_bool()?);
                    },
                    15 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.available_on_platform = ::std::option::Option::Some(is.read_bool()?);
                    },
                    9 => {
                        ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.dlcs)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.category.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.app_type.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.favorite {
                my_size += 2;
            }
            if let Some(v) = self.installed {
                my_size += 2;
            }
            if let Some(v) = self.auto_update {
                my_size += 2;
            }
            if let Some(v) = self.bytes_downloaded {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.bytes_needed {
                my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.bytes_download_rate {
                my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.download_paused {
                my_size += 2;
            }
            if let Some(v) = self.num_downloading {
                my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.num_paused {
                my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.changing {
                my_size += 2;
            }
            if let Some(v) = self.available_on_platform {
                my_size += 2;
            }
            for value in &self.dlcs {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.category.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.app_type.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.favorite {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.installed {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.auto_update {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.bytes_downloaded {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.bytes_needed {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.bytes_download_rate {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.download_paused {
                os.write_bool(11, v)?;
            }
            if let Some(v) = self.num_downloading {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.num_paused {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.changing {
                os.write_bool(14, v)?;
            }
            if let Some(v) = self.available_on_platform {
                os.write_bool(15, v)?;
            }
            for v in &self.dlcs {
                ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
            };
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> App {
            App::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &App| { &m.appid },
                    |m: &mut App| { &mut m.appid },
                    App::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "category",
                    |m: &App| { &m.category },
                    |m: &mut App| { &mut m.category },
                    App::get_category,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "app_type",
                    |m: &App| { &m.app_type },
                    |m: &mut App| { &mut m.app_type },
                    App::get_app_type,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "favorite",
                    |m: &App| { &m.favorite },
                    |m: &mut App| { &mut m.favorite },
                    App::get_favorite,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "installed",
                    |m: &App| { &m.installed },
                    |m: &mut App| { &mut m.installed },
                    App::get_installed,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "auto_update",
                    |m: &App| { &m.auto_update },
                    |m: &mut App| { &mut m.auto_update },
                    App::get_auto_update,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "bytes_downloaded",
                    |m: &App| { &m.bytes_downloaded },
                    |m: &mut App| { &mut m.bytes_downloaded },
                    App::get_bytes_downloaded,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "bytes_needed",
                    |m: &App| { &m.bytes_needed },
                    |m: &mut App| { &mut m.bytes_needed },
                    App::get_bytes_needed,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "bytes_download_rate",
                    |m: &App| { &m.bytes_download_rate },
                    |m: &mut App| { &mut m.bytes_download_rate },
                    App::get_bytes_download_rate,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "download_paused",
                    |m: &App| { &m.download_paused },
                    |m: &mut App| { &mut m.download_paused },
                    App::get_download_paused,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "num_downloading",
                    |m: &App| { &m.num_downloading },
                    |m: &mut App| { &mut m.num_downloading },
                    App::get_num_downloading,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "num_paused",
                    |m: &App| { &m.num_paused },
                    |m: &mut App| { &mut m.num_paused },
                    App::get_num_paused,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "changing",
                    |m: &App| { &m.changing },
                    |m: &mut App| { &mut m.changing },
                    App::get_changing,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "available_on_platform",
                    |m: &App| { &m.available_on_platform },
                    |m: &mut App| { &mut m.available_on_platform },
                    App::get_available_on_platform,
                ));
                fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<app::DLC>>(
                    "dlcs",
                    |m: &App| { &m.dlcs },
                    |m: &mut App| { &mut m.dlcs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<App>(
                    "CMsgClientGetClientAppListResponse.App",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static App {
            static instance: ::protobuf::rt::Lazy<App> = ::protobuf::rt::Lazy::INIT;
            instance.get(App::new)
        }
    }

    impl ::protobuf::Clear for App {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.category.clear();
            self.app_type.clear();
            self.favorite = ::std::option::Option::None;
            self.installed = ::std::option::Option::None;
            self.auto_update = ::std::option::Option::None;
            self.bytes_downloaded = ::std::option::Option::None;
            self.bytes_needed = ::std::option::Option::None;
            self.bytes_download_rate = ::std::option::Option::None;
            self.download_paused = ::std::option::Option::None;
            self.num_downloading = ::std::option::Option::None;
            self.num_paused = ::std::option::Option::None;
            self.changing = ::std::option::Option::None;
            self.available_on_platform = ::std::option::Option::None;
            self.dlcs.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for App {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for App {
    }

    /// Nested message and enums of message `App`
    pub mod app {
        #[derive(PartialEq,Clone,Default)]
        pub struct DLC {
            // message fields
            appid: ::std::option::Option<u32>,
            installed: ::std::option::Option<bool>,
            // special fields
            pub unknown_fields: ::protobuf::UnknownFields,
            pub cached_size: ::protobuf::rt::CachedSize,
        }

        impl<'a> ::std::default::Default for &'a DLC {
            fn default() -> &'a DLC {
                <DLC as ::protobuf::Message>::default_instance()
            }
        }

        impl DLC {
            pub fn new() -> DLC {
                ::std::default::Default::default()
            }

            // optional uint32 appid = 1;

            pub fn get_appid(&self) -> u32 {
                self.appid.unwrap_or(0)
            }

            pub fn clear_appid(&mut self) {
                self.appid = ::std::option::Option::None;
            }

            pub fn has_appid(&self) -> bool {
                self.appid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_appid(&mut self, v: u32) {
                self.appid = ::std::option::Option::Some(v);
            }

            // optional bool installed = 2;

            pub fn get_installed(&self) -> bool {
                self.installed.unwrap_or(false)
            }

            pub fn clear_installed(&mut self) {
                self.installed = ::std::option::Option::None;
            }

            pub fn has_installed(&self) -> bool {
                self.installed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_installed(&mut self, v: bool) {
                self.installed = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for DLC {
            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                while !is.eof()? {
                    let (field_number, wire_type) = is.read_tag_unpack()?;
                    match field_number {
                        1 => {
                            if wire_type != ::protobuf::wire_format::WireTypeVarint {
                                return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                            }
                            self.appid = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        2 => {
                            if wire_type != ::protobuf::wire_format::WireTypeVarint {
                                return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                            }
                            self.installed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        _ => {
                            ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u32 {
                let mut my_size = 0;
                if let Some(v) = self.appid {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                }
                if let Some(v) = self.installed {
                    my_size += 2;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
                self.cached_size.set(my_size);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                if let Some(v) = self.appid {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.installed {
                    os.write_bool(2, v)?;
                }
                os.write_unknown_fields(self.get_unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn get_cached_size(&self) -> u32 {
                self.cached_size.get()
            }

            fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
                &self.unknown_fields
            }

            fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
                &mut self.unknown_fields
            }

            fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
                Self::descriptor_static()
            }

            fn new() -> DLC {
                DLC::new()
            }

            fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
                descriptor.get(|| {
                    let mut fields = ::std::vec::Vec::new();
                    fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                        "appid",
                        |m: &DLC| { &m.appid },
                        |m: &mut DLC| { &mut m.appid },
                        DLC::get_appid,
                    ));
                    fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                        "installed",
                        |m: &DLC| { &m.installed },
                        |m: &mut DLC| { &mut m.installed },
                        DLC::get_installed,
                    ));
                    ::protobuf::reflect::MessageDescriptor::new::<DLC>(
                        "CMsgClientGetClientAppListResponse.App.DLC",
                        fields,
                        super::super::file_descriptor_proto()
                    )
                })
            }

            fn default_instance() -> &'static DLC {
                static instance: ::protobuf::rt::Lazy<DLC> = ::protobuf::rt::Lazy::INIT;
                instance.get(DLC::new)
            }
        }

        impl ::protobuf::Clear for DLC {
            fn clear(&mut self) {
                self.appid = ::std::option::Option::None;
                self.installed = ::std::option::Option::None;
                self.unknown_fields.clear();
            }
        }

        impl ::std::fmt::Debug for DLC {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DLC {
        }
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientInstallClientApp {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientInstallClientApp {
    fn default() -> &'a CMsgClientInstallClientApp {
        <CMsgClientInstallClientApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInstallClientApp {
    pub fn new() -> CMsgClientInstallClientApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientInstallClientApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientInstallClientApp {
        CMsgClientInstallClientApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CMsgClientInstallClientApp| { &m.appid },
                |m: &mut CMsgClientInstallClientApp| { &mut m.appid },
                CMsgClientInstallClientApp::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientInstallClientApp>(
                "CMsgClientInstallClientApp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientInstallClientApp {
        static instance: ::protobuf::rt::Lazy<CMsgClientInstallClientApp> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientInstallClientApp::new)
    }
}

impl ::protobuf::Clear for CMsgClientInstallClientApp {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientInstallClientApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientInstallClientApp {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientInstallClientAppResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientInstallClientAppResponse {
    fn default() -> &'a CMsgClientInstallClientAppResponse {
        <CMsgClientInstallClientAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInstallClientAppResponse {
    pub fn new() -> CMsgClientInstallClientAppResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientInstallClientAppResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientInstallClientAppResponse {
        CMsgClientInstallClientAppResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "result",
                |m: &CMsgClientInstallClientAppResponse| { &m.result },
                |m: &mut CMsgClientInstallClientAppResponse| { &mut m.result },
                CMsgClientInstallClientAppResponse::get_result,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientInstallClientAppResponse>(
                "CMsgClientInstallClientAppResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientInstallClientAppResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientInstallClientAppResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientInstallClientAppResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientInstallClientAppResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientInstallClientAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientInstallClientAppResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUninstallClientApp {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUninstallClientApp {
    fn default() -> &'a CMsgClientUninstallClientApp {
        <CMsgClientUninstallClientApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUninstallClientApp {
    pub fn new() -> CMsgClientUninstallClientApp {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUninstallClientApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUninstallClientApp {
        CMsgClientUninstallClientApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CMsgClientUninstallClientApp| { &m.appid },
                |m: &mut CMsgClientUninstallClientApp| { &mut m.appid },
                CMsgClientUninstallClientApp::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUninstallClientApp>(
                "CMsgClientUninstallClientApp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUninstallClientApp {
        static instance: ::protobuf::rt::Lazy<CMsgClientUninstallClientApp> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUninstallClientApp::new)
    }
}

impl ::protobuf::Clear for CMsgClientUninstallClientApp {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUninstallClientApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUninstallClientApp {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUninstallClientAppResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUninstallClientAppResponse {
    fn default() -> &'a CMsgClientUninstallClientAppResponse {
        <CMsgClientUninstallClientAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUninstallClientAppResponse {
    pub fn new() -> CMsgClientUninstallClientAppResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUninstallClientAppResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUninstallClientAppResponse {
        CMsgClientUninstallClientAppResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "result",
                |m: &CMsgClientUninstallClientAppResponse| { &m.result },
                |m: &mut CMsgClientUninstallClientAppResponse| { &mut m.result },
                CMsgClientUninstallClientAppResponse::get_result,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUninstallClientAppResponse>(
                "CMsgClientUninstallClientAppResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUninstallClientAppResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUninstallClientAppResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUninstallClientAppResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUninstallClientAppResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUninstallClientAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUninstallClientAppResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSetClientAppUpdateState {
    // message fields
    appid: ::std::option::Option<u32>,
    update: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetClientAppUpdateState {
    fn default() -> &'a CMsgClientSetClientAppUpdateState {
        <CMsgClientSetClientAppUpdateState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetClientAppUpdateState {
    pub fn new() -> CMsgClientSetClientAppUpdateState {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool update = 2;

    pub fn get_update(&self) -> bool {
        self.update.unwrap_or(false)
    }

    pub fn clear_update(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSetClientAppUpdateState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.update {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSetClientAppUpdateState {
        CMsgClientSetClientAppUpdateState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CMsgClientSetClientAppUpdateState| { &m.appid },
                |m: &mut CMsgClientSetClientAppUpdateState| { &mut m.appid },
                CMsgClientSetClientAppUpdateState::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "update",
                |m: &CMsgClientSetClientAppUpdateState| { &m.update },
                |m: &mut CMsgClientSetClientAppUpdateState| { &mut m.update },
                CMsgClientSetClientAppUpdateState::get_update,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSetClientAppUpdateState>(
                "CMsgClientSetClientAppUpdateState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSetClientAppUpdateState {
        static instance: ::protobuf::rt::Lazy<CMsgClientSetClientAppUpdateState> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientSetClientAppUpdateState::new)
    }
}

impl ::protobuf::Clear for CMsgClientSetClientAppUpdateState {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSetClientAppUpdateState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSetClientAppUpdateState {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSetClientAppUpdateStateResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetClientAppUpdateStateResponse {
    fn default() -> &'a CMsgClientSetClientAppUpdateStateResponse {
        <CMsgClientSetClientAppUpdateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetClientAppUpdateStateResponse {
    pub fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSetClientAppUpdateStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        CMsgClientSetClientAppUpdateStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "result",
                |m: &CMsgClientSetClientAppUpdateStateResponse| { &m.result },
                |m: &mut CMsgClientSetClientAppUpdateStateResponse| { &mut m.result },
                CMsgClientSetClientAppUpdateStateResponse::get_result,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSetClientAppUpdateStateResponse>(
                "CMsgClientSetClientAppUpdateStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSetClientAppUpdateStateResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientSetClientAppUpdateStateResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientSetClientAppUpdateStateResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientSetClientAppUpdateStateResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSetClientAppUpdateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSetClientAppUpdateStateResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadFileRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_size: ::std::option::Option<u32>,
    raw_file_size: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    platforms_to_sync_deprecated: ::std::option::Option<u32>,
    platforms_to_sync: ::std::option::Option<u32>,
    cell_id: ::std::option::Option<u32>,
    can_encrypt: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadFileRequest {
    fn default() -> &'a CMsgClientUFSUploadFileRequest {
        <CMsgClientUFSUploadFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadFileRequest {
    pub fn new() -> CMsgClientUFSUploadFileRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 2;

    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_file_size = 3;

    pub fn get_raw_file_size(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }

    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;

    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 time_stamp = 5;

    pub fn get_time_stamp(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional string file_name = 6;

    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 platforms_to_sync_deprecated = 7;

    pub fn get_platforms_to_sync_deprecated(&self) -> u32 {
        self.platforms_to_sync_deprecated.unwrap_or(0)
    }

    pub fn clear_platforms_to_sync_deprecated(&mut self) {
        self.platforms_to_sync_deprecated = ::std::option::Option::None;
    }

    pub fn has_platforms_to_sync_deprecated(&self) -> bool {
        self.platforms_to_sync_deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms_to_sync_deprecated(&mut self, v: u32) {
        self.platforms_to_sync_deprecated = ::std::option::Option::Some(v);
    }

    // optional uint32 platforms_to_sync = 8;

    pub fn get_platforms_to_sync(&self) -> u32 {
        self.platforms_to_sync.unwrap_or(4294967295u32)
    }

    pub fn clear_platforms_to_sync(&mut self) {
        self.platforms_to_sync = ::std::option::Option::None;
    }

    pub fn has_platforms_to_sync(&self) -> bool {
        self.platforms_to_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms_to_sync(&mut self, v: u32) {
        self.platforms_to_sync = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 9;

    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional bool can_encrypt = 10;

    pub fn get_can_encrypt(&self) -> bool {
        self.can_encrypt.unwrap_or(false)
    }

    pub fn clear_can_encrypt(&mut self) {
        self.can_encrypt = ::std::option::Option::None;
    }

    pub fn has_can_encrypt(&self) -> bool {
        self.can_encrypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_encrypt(&mut self, v: bool) {
        self.can_encrypt = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.raw_file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_stamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.platforms_to_sync_deprecated = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.platforms_to_sync = ::std::option::Option::Some(is.read_uint32()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.can_encrypt = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.raw_file_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.platforms_to_sync_deprecated {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.platforms_to_sync {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.can_encrypt {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.raw_file_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.platforms_to_sync_deprecated {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.platforms_to_sync {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.can_encrypt {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadFileRequest {
        CMsgClientUFSUploadFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUFSUploadFileRequest| { &m.app_id },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.app_id },
                CMsgClientUFSUploadFileRequest::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "file_size",
                |m: &CMsgClientUFSUploadFileRequest| { &m.file_size },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.file_size },
                CMsgClientUFSUploadFileRequest::get_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "raw_file_size",
                |m: &CMsgClientUFSUploadFileRequest| { &m.raw_file_size },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.raw_file_size },
                CMsgClientUFSUploadFileRequest::get_raw_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sha_file",
                |m: &CMsgClientUFSUploadFileRequest| { &m.sha_file },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.sha_file },
                CMsgClientUFSUploadFileRequest::get_sha_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "time_stamp",
                |m: &CMsgClientUFSUploadFileRequest| { &m.time_stamp },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.time_stamp },
                CMsgClientUFSUploadFileRequest::get_time_stamp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_name",
                |m: &CMsgClientUFSUploadFileRequest| { &m.file_name },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.file_name },
                CMsgClientUFSUploadFileRequest::get_file_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "platforms_to_sync_deprecated",
                |m: &CMsgClientUFSUploadFileRequest| { &m.platforms_to_sync_deprecated },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.platforms_to_sync_deprecated },
                CMsgClientUFSUploadFileRequest::get_platforms_to_sync_deprecated,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "platforms_to_sync",
                |m: &CMsgClientUFSUploadFileRequest| { &m.platforms_to_sync },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.platforms_to_sync },
                CMsgClientUFSUploadFileRequest::get_platforms_to_sync,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cell_id",
                |m: &CMsgClientUFSUploadFileRequest| { &m.cell_id },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.cell_id },
                CMsgClientUFSUploadFileRequest::get_cell_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "can_encrypt",
                |m: &CMsgClientUFSUploadFileRequest| { &m.can_encrypt },
                |m: &mut CMsgClientUFSUploadFileRequest| { &mut m.can_encrypt },
                CMsgClientUFSUploadFileRequest::get_can_encrypt,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadFileRequest>(
                "CMsgClientUFSUploadFileRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadFileRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSUploadFileRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSUploadFileRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadFileRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.raw_file_size = ::std::option::Option::None;
        self.sha_file.clear();
        self.time_stamp = ::std::option::Option::None;
        self.file_name.clear();
        self.platforms_to_sync_deprecated = ::std::option::Option::None;
        self.platforms_to_sync = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.can_encrypt = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadFileRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    use_http: ::std::option::Option<bool>,
    http_host: ::protobuf::SingularField<::std::string::String>,
    http_url: ::protobuf::SingularField<::std::string::String>,
    kv_headers: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    use_https: ::std::option::Option<bool>,
    encrypt_file: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadFileResponse {
    fn default() -> &'a CMsgClientUFSUploadFileResponse {
        <CMsgClientUFSUploadFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadFileResponse {
    pub fn new() -> CMsgClientUFSUploadFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 2;

    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool use_http = 3;

    pub fn get_use_http(&self) -> bool {
        self.use_http.unwrap_or(false)
    }

    pub fn clear_use_http(&mut self) {
        self.use_http = ::std::option::Option::None;
    }

    pub fn has_use_http(&self) -> bool {
        self.use_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_http(&mut self, v: bool) {
        self.use_http = ::std::option::Option::Some(v);
    }

    // optional string http_host = 4;

    pub fn get_http_host(&self) -> &str {
        match self.http_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_host(&mut self) {
        self.http_host.clear();
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host(&mut self) -> &mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host.set_default();
        }
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string http_url = 5;

    pub fn get_http_url(&self) -> &str {
        match self.http_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_url(&mut self) {
        self.http_url.clear();
    }

    pub fn has_http_url(&self) -> bool {
        self.http_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_url(&mut self, v: ::std::string::String) {
        self.http_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_url(&mut self) -> &mut ::std::string::String {
        if self.http_url.is_none() {
            self.http_url.set_default();
        }
        self.http_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_url(&mut self) -> ::std::string::String {
        self.http_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes kv_headers = 6;

    pub fn get_kv_headers(&self) -> &[u8] {
        match self.kv_headers.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_kv_headers(&mut self) {
        self.kv_headers.clear();
    }

    pub fn has_kv_headers(&self) -> bool {
        self.kv_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kv_headers(&mut self, v: ::std::vec::Vec<u8>) {
        self.kv_headers = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kv_headers(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.kv_headers.is_none() {
            self.kv_headers.set_default();
        }
        self.kv_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_kv_headers(&mut self) -> ::std::vec::Vec<u8> {
        self.kv_headers.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool use_https = 7;

    pub fn get_use_https(&self) -> bool {
        self.use_https.unwrap_or(false)
    }

    pub fn clear_use_https(&mut self) {
        self.use_https = ::std::option::Option::None;
    }

    pub fn has_use_https(&self) -> bool {
        self.use_https.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_https(&mut self, v: bool) {
        self.use_https = ::std::option::Option::Some(v);
    }

    // optional bool encrypt_file = 8;

    pub fn get_encrypt_file(&self) -> bool {
        self.encrypt_file.unwrap_or(false)
    }

    pub fn clear_encrypt_file(&mut self) {
        self.encrypt_file = ::std::option::Option::None;
    }

    pub fn has_encrypt_file(&self) -> bool {
        self.encrypt_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypt_file(&mut self, v: bool) {
        self.encrypt_file = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.use_http = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_host)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_url)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.kv_headers)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.use_https = ::std::option::Option::Some(is.read_bool()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.encrypt_file = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.use_http {
            my_size += 2;
        }
        if let Some(v) = self.http_host.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.http_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.kv_headers.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.use_https {
            my_size += 2;
        }
        if let Some(v) = self.encrypt_file {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.use_http {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.http_host.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.http_url.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.kv_headers.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.use_https {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.encrypt_file {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadFileResponse {
        CMsgClientUFSUploadFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUFSUploadFileResponse| { &m.eresult },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.eresult },
                CMsgClientUFSUploadFileResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sha_file",
                |m: &CMsgClientUFSUploadFileResponse| { &m.sha_file },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.sha_file },
                CMsgClientUFSUploadFileResponse::get_sha_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "use_http",
                |m: &CMsgClientUFSUploadFileResponse| { &m.use_http },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.use_http },
                CMsgClientUFSUploadFileResponse::get_use_http,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "http_host",
                |m: &CMsgClientUFSUploadFileResponse| { &m.http_host },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.http_host },
                CMsgClientUFSUploadFileResponse::get_http_host,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "http_url",
                |m: &CMsgClientUFSUploadFileResponse| { &m.http_url },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.http_url },
                CMsgClientUFSUploadFileResponse::get_http_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "kv_headers",
                |m: &CMsgClientUFSUploadFileResponse| { &m.kv_headers },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.kv_headers },
                CMsgClientUFSUploadFileResponse::get_kv_headers,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "use_https",
                |m: &CMsgClientUFSUploadFileResponse| { &m.use_https },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.use_https },
                CMsgClientUFSUploadFileResponse::get_use_https,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "encrypt_file",
                |m: &CMsgClientUFSUploadFileResponse| { &m.encrypt_file },
                |m: &mut CMsgClientUFSUploadFileResponse| { &mut m.encrypt_file },
                CMsgClientUFSUploadFileResponse::get_encrypt_file,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadFileResponse>(
                "CMsgClientUFSUploadFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadFileResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSUploadFileResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSUploadFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.sha_file.clear();
        self.use_http = ::std::option::Option::None;
        self.http_host.clear();
        self.http_url.clear();
        self.kv_headers.clear();
        self.use_https = ::std::option::Option::None;
        self.encrypt_file = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadFileResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadCommit {
    // message fields
    pub files: ::protobuf::RepeatedField<cmsg_client_ufsupload_commit::File>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadCommit {
    fn default() -> &'a CMsgClientUFSUploadCommit {
        <CMsgClientUFSUploadCommit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadCommit {
    pub fn new() -> CMsgClientUFSUploadCommit {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommit {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadCommit {
        CMsgClientUFSUploadCommit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ufsupload_commit::File>>(
                "files",
                |m: &CMsgClientUFSUploadCommit| { &m.files },
                |m: &mut CMsgClientUFSUploadCommit| { &mut m.files },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadCommit>(
                "CMsgClientUFSUploadCommit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadCommit {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSUploadCommit> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSUploadCommit::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadCommit {
    fn clear(&mut self) {
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadCommit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadCommit {
}

/// Nested message and enums of message `CMsgClientUFSUploadCommit`
pub mod cmsg_client_ufsupload_commit {
    #[derive(PartialEq,Clone,Default)]
    pub struct File {
        // message fields
        eresult: ::std::option::Option<i32>,
        app_id: ::std::option::Option<u32>,
        sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        cub_file: ::std::option::Option<u32>,
        file_name: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a File {
        fn default() -> &'a File {
            <File as ::protobuf::Message>::default_instance()
        }
    }

    impl File {
        pub fn new() -> File {
            ::std::default::Default::default()
        }

        // optional int32 eresult = 1;

        pub fn get_eresult(&self) -> i32 {
            self.eresult.unwrap_or(2i32)
        }

        pub fn clear_eresult(&mut self) {
            self.eresult = ::std::option::Option::None;
        }

        pub fn has_eresult(&self) -> bool {
            self.eresult.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eresult(&mut self, v: i32) {
            self.eresult = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 2;

        pub fn get_app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional bytes sha_file = 3;

        pub fn get_sha_file(&self) -> &[u8] {
            match self.sha_file.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha_file(&mut self) {
            self.sha_file.clear();
        }

        pub fn has_sha_file(&self) -> bool {
            self.sha_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha_file = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha_file.is_none() {
                self.sha_file.set_default();
            }
            self.sha_file.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
            self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 cub_file = 4;

        pub fn get_cub_file(&self) -> u32 {
            self.cub_file.unwrap_or(0)
        }

        pub fn clear_cub_file(&mut self) {
            self.cub_file = ::std::option::Option::None;
        }

        pub fn has_cub_file(&self) -> bool {
            self.cub_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cub_file(&mut self, v: u32) {
            self.cub_file = ::std::option::Option::Some(v);
        }

        // optional string file_name = 5;

        pub fn get_file_name(&self) -> &str {
            match self.file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_file_name(&mut self) {
            self.file_name.clear();
        }

        pub fn has_file_name(&self) -> bool {
            self.file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_name(&mut self, v: ::std::string::String) {
            self.file_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
            if self.file_name.is_none() {
                self.file_name.set_default();
            }
            self.file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_file_name(&mut self) -> ::std::string::String {
            self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for File {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.eresult = ::std::option::Option::Some(is.read_int32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.cub_file = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.eresult {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.sha_file.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.cub_file {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.file_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.eresult {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.sha_file.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.cub_file {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.file_name.as_ref() {
                os.write_string(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> File {
            File::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "eresult",
                    |m: &File| { &m.eresult },
                    |m: &mut File| { &mut m.eresult },
                    File::get_eresult,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "app_id",
                    |m: &File| { &m.app_id },
                    |m: &mut File| { &mut m.app_id },
                    File::get_app_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "sha_file",
                    |m: &File| { &m.sha_file },
                    |m: &mut File| { &mut m.sha_file },
                    File::get_sha_file,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "cub_file",
                    |m: &File| { &m.cub_file },
                    |m: &mut File| { &mut m.cub_file },
                    File::get_cub_file,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "file_name",
                    |m: &File| { &m.file_name },
                    |m: &mut File| { &mut m.file_name },
                    File::get_file_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<File>(
                    "CMsgClientUFSUploadCommit.File",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static File {
            static instance: ::protobuf::rt::Lazy<File> = ::protobuf::rt::Lazy::INIT;
            instance.get(File::new)
        }
    }

    impl ::protobuf::Clear for File {
        fn clear(&mut self) {
            self.eresult = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.sha_file.clear();
            self.cub_file = ::std::option::Option::None;
            self.file_name.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for File {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for File {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadCommitResponse {
    // message fields
    pub files: ::protobuf::RepeatedField<cmsg_client_ufsupload_commit_response::File>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadCommitResponse {
    fn default() -> &'a CMsgClientUFSUploadCommitResponse {
        <CMsgClientUFSUploadCommitResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadCommitResponse {
    pub fn new() -> CMsgClientUFSUploadCommitResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommitResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadCommitResponse {
        CMsgClientUFSUploadCommitResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ufsupload_commit_response::File>>(
                "files",
                |m: &CMsgClientUFSUploadCommitResponse| { &m.files },
                |m: &mut CMsgClientUFSUploadCommitResponse| { &mut m.files },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadCommitResponse>(
                "CMsgClientUFSUploadCommitResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadCommitResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSUploadCommitResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSUploadCommitResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadCommitResponse {
    fn clear(&mut self) {
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadCommitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadCommitResponse {
}

/// Nested message and enums of message `CMsgClientUFSUploadCommitResponse`
pub mod cmsg_client_ufsupload_commit_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct File {
        // message fields
        eresult: ::std::option::Option<i32>,
        app_id: ::std::option::Option<u32>,
        sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a File {
        fn default() -> &'a File {
            <File as ::protobuf::Message>::default_instance()
        }
    }

    impl File {
        pub fn new() -> File {
            ::std::default::Default::default()
        }

        // optional int32 eresult = 1;

        pub fn get_eresult(&self) -> i32 {
            self.eresult.unwrap_or(2i32)
        }

        pub fn clear_eresult(&mut self) {
            self.eresult = ::std::option::Option::None;
        }

        pub fn has_eresult(&self) -> bool {
            self.eresult.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eresult(&mut self, v: i32) {
            self.eresult = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 2;

        pub fn get_app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional bytes sha_file = 3;

        pub fn get_sha_file(&self) -> &[u8] {
            match self.sha_file.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha_file(&mut self) {
            self.sha_file.clear();
        }

        pub fn has_sha_file(&self) -> bool {
            self.sha_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha_file = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha_file.is_none() {
                self.sha_file.set_default();
            }
            self.sha_file.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
            self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for File {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.eresult = ::std::option::Option::Some(is.read_int32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.eresult {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.sha_file.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.eresult {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.sha_file.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> File {
            File::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "eresult",
                    |m: &File| { &m.eresult },
                    |m: &mut File| { &mut m.eresult },
                    File::get_eresult,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "app_id",
                    |m: &File| { &m.app_id },
                    |m: &mut File| { &mut m.app_id },
                    File::get_app_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "sha_file",
                    |m: &File| { &m.sha_file },
                    |m: &mut File| { &mut m.sha_file },
                    File::get_sha_file,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<File>(
                    "CMsgClientUFSUploadCommitResponse.File",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static File {
            static instance: ::protobuf::rt::Lazy<File> = ::protobuf::rt::Lazy::INIT;
            instance.get(File::new)
        }
    }

    impl ::protobuf::Clear for File {
        fn clear(&mut self) {
            self.eresult = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.sha_file.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for File {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for File {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSFileChunk {
    // message fields
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    file_start: ::std::option::Option<u32>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSFileChunk {
    fn default() -> &'a CMsgClientUFSFileChunk {
        <CMsgClientUFSFileChunk as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSFileChunk {
    pub fn new() -> CMsgClientUFSFileChunk {
        ::std::default::Default::default()
    }

    // optional bytes sha_file = 1;

    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 file_start = 2;

    pub fn get_file_start(&self) -> u32 {
        self.file_start.unwrap_or(0)
    }

    pub fn clear_file_start(&mut self) {
        self.file_start = ::std::option::Option::None;
    }

    pub fn has_file_start(&self) -> bool {
        self.file_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_start(&mut self, v: u32) {
        self.file_start = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSFileChunk {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.file_start {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.file_start {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSFileChunk {
        CMsgClientUFSFileChunk::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sha_file",
                |m: &CMsgClientUFSFileChunk| { &m.sha_file },
                |m: &mut CMsgClientUFSFileChunk| { &mut m.sha_file },
                CMsgClientUFSFileChunk::get_sha_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "file_start",
                |m: &CMsgClientUFSFileChunk| { &m.file_start },
                |m: &mut CMsgClientUFSFileChunk| { &mut m.file_start },
                CMsgClientUFSFileChunk::get_file_start,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "data",
                |m: &CMsgClientUFSFileChunk| { &m.data },
                |m: &mut CMsgClientUFSFileChunk| { &mut m.data },
                CMsgClientUFSFileChunk::get_data,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSFileChunk>(
                "CMsgClientUFSFileChunk",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSFileChunk {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSFileChunk> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSFileChunk::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSFileChunk {
    fn clear(&mut self) {
        self.sha_file.clear();
        self.file_start = ::std::option::Option::None;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSFileChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSFileChunk {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSTransferHeartbeat {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSTransferHeartbeat {
    fn default() -> &'a CMsgClientUFSTransferHeartbeat {
        <CMsgClientUFSTransferHeartbeat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSTransferHeartbeat {
    pub fn new() -> CMsgClientUFSTransferHeartbeat {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientUFSTransferHeartbeat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSTransferHeartbeat {
        CMsgClientUFSTransferHeartbeat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSTransferHeartbeat>(
                "CMsgClientUFSTransferHeartbeat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSTransferHeartbeat {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSTransferHeartbeat> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSTransferHeartbeat::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSTransferHeartbeat {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSTransferHeartbeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSTransferHeartbeat {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSUploadFileFinished {
    // message fields
    eresult: ::std::option::Option<i32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSUploadFileFinished {
    fn default() -> &'a CMsgClientUFSUploadFileFinished {
        <CMsgClientUFSUploadFileFinished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSUploadFileFinished {
    pub fn new() -> CMsgClientUFSUploadFileFinished {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 2;

    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileFinished {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSUploadFileFinished {
        CMsgClientUFSUploadFileFinished::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUFSUploadFileFinished| { &m.eresult },
                |m: &mut CMsgClientUFSUploadFileFinished| { &mut m.eresult },
                CMsgClientUFSUploadFileFinished::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sha_file",
                |m: &CMsgClientUFSUploadFileFinished| { &m.sha_file },
                |m: &mut CMsgClientUFSUploadFileFinished| { &mut m.sha_file },
                CMsgClientUFSUploadFileFinished::get_sha_file,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadFileFinished>(
                "CMsgClientUFSUploadFileFinished",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSUploadFileFinished {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSUploadFileFinished> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSUploadFileFinished::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadFileFinished {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.sha_file.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadFileFinished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSUploadFileFinished {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSDeleteFileRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    is_explicit_delete: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDeleteFileRequest {
    fn default() -> &'a CMsgClientUFSDeleteFileRequest {
        <CMsgClientUFSDeleteFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDeleteFileRequest {
    pub fn new() -> CMsgClientUFSDeleteFileRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_explicit_delete = 3;

    pub fn get_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }

    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSDeleteFileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_explicit_delete = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_explicit_delete {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_explicit_delete {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSDeleteFileRequest {
        CMsgClientUFSDeleteFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUFSDeleteFileRequest| { &m.app_id },
                |m: &mut CMsgClientUFSDeleteFileRequest| { &mut m.app_id },
                CMsgClientUFSDeleteFileRequest::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_name",
                |m: &CMsgClientUFSDeleteFileRequest| { &m.file_name },
                |m: &mut CMsgClientUFSDeleteFileRequest| { &mut m.file_name },
                CMsgClientUFSDeleteFileRequest::get_file_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_explicit_delete",
                |m: &CMsgClientUFSDeleteFileRequest| { &m.is_explicit_delete },
                |m: &mut CMsgClientUFSDeleteFileRequest| { &mut m.is_explicit_delete },
                CMsgClientUFSDeleteFileRequest::get_is_explicit_delete,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSDeleteFileRequest>(
                "CMsgClientUFSDeleteFileRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSDeleteFileRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSDeleteFileRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSDeleteFileRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSDeleteFileRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.is_explicit_delete = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDeleteFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDeleteFileRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSDeleteFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDeleteFileResponse {
    fn default() -> &'a CMsgClientUFSDeleteFileResponse {
        <CMsgClientUFSDeleteFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDeleteFileResponse {
    pub fn new() -> CMsgClientUFSDeleteFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSDeleteFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSDeleteFileResponse {
        CMsgClientUFSDeleteFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUFSDeleteFileResponse| { &m.eresult },
                |m: &mut CMsgClientUFSDeleteFileResponse| { &mut m.eresult },
                CMsgClientUFSDeleteFileResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_name",
                |m: &CMsgClientUFSDeleteFileResponse| { &m.file_name },
                |m: &mut CMsgClientUFSDeleteFileResponse| { &mut m.file_name },
                CMsgClientUFSDeleteFileResponse::get_file_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSDeleteFileResponse>(
                "CMsgClientUFSDeleteFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSDeleteFileResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSDeleteFileResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSDeleteFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSDeleteFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.file_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDeleteFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDeleteFileResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetFileListForApp {
    // message fields
    pub apps_to_query: ::std::vec::Vec<u32>,
    send_path_prefixes: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetFileListForApp {
    fn default() -> &'a CMsgClientUFSGetFileListForApp {
        <CMsgClientUFSGetFileListForApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetFileListForApp {
    pub fn new() -> CMsgClientUFSGetFileListForApp {
        ::std::default::Default::default()
    }

    // optional bool send_path_prefixes = 2;

    pub fn get_send_path_prefixes(&self) -> bool {
        self.send_path_prefixes.unwrap_or(false)
    }

    pub fn clear_send_path_prefixes(&mut self) {
        self.send_path_prefixes = ::std::option::Option::None;
    }

    pub fn has_send_path_prefixes(&self) -> bool {
        self.send_path_prefixes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_path_prefixes(&mut self, v: bool) {
        self.send_path_prefixes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSGetFileListForApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.apps_to_query)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.send_path_prefixes = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.apps_to_query {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.send_path_prefixes {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.apps_to_query {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.send_path_prefixes {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetFileListForApp {
        CMsgClientUFSGetFileListForApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "apps_to_query",
                |m: &CMsgClientUFSGetFileListForApp| { &m.apps_to_query },
                |m: &mut CMsgClientUFSGetFileListForApp| { &mut m.apps_to_query },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "send_path_prefixes",
                |m: &CMsgClientUFSGetFileListForApp| { &m.send_path_prefixes },
                |m: &mut CMsgClientUFSGetFileListForApp| { &mut m.send_path_prefixes },
                CMsgClientUFSGetFileListForApp::get_send_path_prefixes,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetFileListForApp>(
                "CMsgClientUFSGetFileListForApp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetFileListForApp {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSGetFileListForApp> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSGetFileListForApp::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetFileListForApp {
    fn clear(&mut self) {
        self.apps_to_query.clear();
        self.send_path_prefixes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetFileListForApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetFileListForApp {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetFileListForAppResponse {
    // message fields
    pub files: ::protobuf::RepeatedField<cmsg_client_ufsget_file_list_for_app_response::File>,
    pub path_prefixes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetFileListForAppResponse {
    fn default() -> &'a CMsgClientUFSGetFileListForAppResponse {
        <CMsgClientUFSGetFileListForAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetFileListForAppResponse {
    pub fn new() -> CMsgClientUFSGetFileListForAppResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientUFSGetFileListForAppResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.files)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.path_prefixes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.path_prefixes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.path_prefixes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetFileListForAppResponse {
        CMsgClientUFSGetFileListForAppResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ufsget_file_list_for_app_response::File>>(
                "files",
                |m: &CMsgClientUFSGetFileListForAppResponse| { &m.files },
                |m: &mut CMsgClientUFSGetFileListForAppResponse| { &mut m.files },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "path_prefixes",
                |m: &CMsgClientUFSGetFileListForAppResponse| { &m.path_prefixes },
                |m: &mut CMsgClientUFSGetFileListForAppResponse| { &mut m.path_prefixes },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetFileListForAppResponse>(
                "CMsgClientUFSGetFileListForAppResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetFileListForAppResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSGetFileListForAppResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSGetFileListForAppResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetFileListForAppResponse {
    fn clear(&mut self) {
        self.files.clear();
        self.path_prefixes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetFileListForAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetFileListForAppResponse {
}

/// Nested message and enums of message `CMsgClientUFSGetFileListForAppResponse`
pub mod cmsg_client_ufsget_file_list_for_app_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct File {
        // message fields
        app_id: ::std::option::Option<u32>,
        file_name: ::protobuf::SingularField<::std::string::String>,
        sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        time_stamp: ::std::option::Option<u64>,
        raw_file_size: ::std::option::Option<u32>,
        is_explicit_delete: ::std::option::Option<bool>,
        platforms_to_sync: ::std::option::Option<u32>,
        path_prefix_index: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a File {
        fn default() -> &'a File {
            <File as ::protobuf::Message>::default_instance()
        }
    }

    impl File {
        pub fn new() -> File {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn get_app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional string file_name = 2;

        pub fn get_file_name(&self) -> &str {
            match self.file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_file_name(&mut self) {
            self.file_name.clear();
        }

        pub fn has_file_name(&self) -> bool {
            self.file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_name(&mut self, v: ::std::string::String) {
            self.file_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
            if self.file_name.is_none() {
                self.file_name.set_default();
            }
            self.file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_file_name(&mut self) -> ::std::string::String {
            self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes sha_file = 3;

        pub fn get_sha_file(&self) -> &[u8] {
            match self.sha_file.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha_file(&mut self) {
            self.sha_file.clear();
        }

        pub fn has_sha_file(&self) -> bool {
            self.sha_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha_file = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha_file.is_none() {
                self.sha_file.set_default();
            }
            self.sha_file.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
            self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint64 time_stamp = 4;

        pub fn get_time_stamp(&self) -> u64 {
            self.time_stamp.unwrap_or(0)
        }

        pub fn clear_time_stamp(&mut self) {
            self.time_stamp = ::std::option::Option::None;
        }

        pub fn has_time_stamp(&self) -> bool {
            self.time_stamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_stamp(&mut self, v: u64) {
            self.time_stamp = ::std::option::Option::Some(v);
        }

        // optional uint32 raw_file_size = 5;

        pub fn get_raw_file_size(&self) -> u32 {
            self.raw_file_size.unwrap_or(0)
        }

        pub fn clear_raw_file_size(&mut self) {
            self.raw_file_size = ::std::option::Option::None;
        }

        pub fn has_raw_file_size(&self) -> bool {
            self.raw_file_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_raw_file_size(&mut self, v: u32) {
            self.raw_file_size = ::std::option::Option::Some(v);
        }

        // optional bool is_explicit_delete = 6;

        pub fn get_is_explicit_delete(&self) -> bool {
            self.is_explicit_delete.unwrap_or(false)
        }

        pub fn clear_is_explicit_delete(&mut self) {
            self.is_explicit_delete = ::std::option::Option::None;
        }

        pub fn has_is_explicit_delete(&self) -> bool {
            self.is_explicit_delete.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_explicit_delete(&mut self, v: bool) {
            self.is_explicit_delete = ::std::option::Option::Some(v);
        }

        // optional uint32 platforms_to_sync = 7;

        pub fn get_platforms_to_sync(&self) -> u32 {
            self.platforms_to_sync.unwrap_or(0)
        }

        pub fn clear_platforms_to_sync(&mut self) {
            self.platforms_to_sync = ::std::option::Option::None;
        }

        pub fn has_platforms_to_sync(&self) -> bool {
            self.platforms_to_sync.is_some()
        }

        // Param is passed by value, moved
        pub fn set_platforms_to_sync(&mut self, v: u32) {
            self.platforms_to_sync = ::std::option::Option::Some(v);
        }

        // optional uint32 path_prefix_index = 8;

        pub fn get_path_prefix_index(&self) -> u32 {
            self.path_prefix_index.unwrap_or(0)
        }

        pub fn clear_path_prefix_index(&mut self) {
            self.path_prefix_index = ::std::option::Option::None;
        }

        pub fn has_path_prefix_index(&self) -> bool {
            self.path_prefix_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path_prefix_index(&mut self, v: u32) {
            self.path_prefix_index = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for File {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                    },
                    3 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_stamp = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.raw_file_size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.is_explicit_delete = ::std::option::Option::Some(is.read_bool()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.platforms_to_sync = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    8 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.path_prefix_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.file_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.sha_file.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.time_stamp {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.raw_file_size {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.is_explicit_delete {
                my_size += 2;
            }
            if let Some(v) = self.platforms_to_sync {
                my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.path_prefix_index {
                my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.file_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.sha_file.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.time_stamp {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.raw_file_size {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.is_explicit_delete {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.platforms_to_sync {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.path_prefix_index {
                os.write_uint32(8, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> File {
            File::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "app_id",
                    |m: &File| { &m.app_id },
                    |m: &mut File| { &mut m.app_id },
                    File::get_app_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "file_name",
                    |m: &File| { &m.file_name },
                    |m: &mut File| { &mut m.file_name },
                    File::get_file_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "sha_file",
                    |m: &File| { &m.sha_file },
                    |m: &mut File| { &mut m.sha_file },
                    File::get_sha_file,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "time_stamp",
                    |m: &File| { &m.time_stamp },
                    |m: &mut File| { &mut m.time_stamp },
                    File::get_time_stamp,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "raw_file_size",
                    |m: &File| { &m.raw_file_size },
                    |m: &mut File| { &mut m.raw_file_size },
                    File::get_raw_file_size,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "is_explicit_delete",
                    |m: &File| { &m.is_explicit_delete },
                    |m: &mut File| { &mut m.is_explicit_delete },
                    File::get_is_explicit_delete,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "platforms_to_sync",
                    |m: &File| { &m.platforms_to_sync },
                    |m: &mut File| { &mut m.platforms_to_sync },
                    File::get_platforms_to_sync,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "path_prefix_index",
                    |m: &File| { &m.path_prefix_index },
                    |m: &mut File| { &mut m.path_prefix_index },
                    File::get_path_prefix_index,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<File>(
                    "CMsgClientUFSGetFileListForAppResponse.File",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static File {
            static instance: ::protobuf::rt::Lazy<File> = ::protobuf::rt::Lazy::INIT;
            instance.get(File::new)
        }
    }

    impl ::protobuf::Clear for File {
        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.file_name.clear();
            self.sha_file.clear();
            self.time_stamp = ::std::option::Option::None;
            self.raw_file_size = ::std::option::Option::None;
            self.is_explicit_delete = ::std::option::Option::None;
            self.platforms_to_sync = ::std::option::Option::None;
            self.path_prefix_index = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for File {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for File {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSDownloadRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    can_handle_http: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDownloadRequest {
    fn default() -> &'a CMsgClientUFSDownloadRequest {
        <CMsgClientUFSDownloadRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDownloadRequest {
    pub fn new() -> CMsgClientUFSDownloadRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool can_handle_http = 3;

    pub fn get_can_handle_http(&self) -> bool {
        self.can_handle_http.unwrap_or(false)
    }

    pub fn clear_can_handle_http(&mut self) {
        self.can_handle_http = ::std::option::Option::None;
    }

    pub fn has_can_handle_http(&self) -> bool {
        self.can_handle_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_handle_http(&mut self, v: bool) {
        self.can_handle_http = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSDownloadRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.can_handle_http = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.can_handle_http {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.can_handle_http {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSDownloadRequest {
        CMsgClientUFSDownloadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUFSDownloadRequest| { &m.app_id },
                |m: &mut CMsgClientUFSDownloadRequest| { &mut m.app_id },
                CMsgClientUFSDownloadRequest::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_name",
                |m: &CMsgClientUFSDownloadRequest| { &m.file_name },
                |m: &mut CMsgClientUFSDownloadRequest| { &mut m.file_name },
                CMsgClientUFSDownloadRequest::get_file_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "can_handle_http",
                |m: &CMsgClientUFSDownloadRequest| { &m.can_handle_http },
                |m: &mut CMsgClientUFSDownloadRequest| { &mut m.can_handle_http },
                CMsgClientUFSDownloadRequest::get_can_handle_http,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSDownloadRequest>(
                "CMsgClientUFSDownloadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSDownloadRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSDownloadRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSDownloadRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSDownloadRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.can_handle_http = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDownloadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDownloadRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSDownloadResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    file_size: ::std::option::Option<u32>,
    raw_file_size: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    is_explicit_delete: ::std::option::Option<bool>,
    use_http: ::std::option::Option<bool>,
    http_host: ::protobuf::SingularField<::std::string::String>,
    http_url: ::protobuf::SingularField<::std::string::String>,
    kv_headers: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    use_https: ::std::option::Option<bool>,
    encrypted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSDownloadResponse {
    fn default() -> &'a CMsgClientUFSDownloadResponse {
        <CMsgClientUFSDownloadResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSDownloadResponse {
    pub fn new() -> CMsgClientUFSDownloadResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 3;

    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_file_size = 4;

    pub fn get_raw_file_size(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }

    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 5;

    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 time_stamp = 6;

    pub fn get_time_stamp(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional bool is_explicit_delete = 7;

    pub fn get_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }

    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }

    // optional bool use_http = 8;

    pub fn get_use_http(&self) -> bool {
        self.use_http.unwrap_or(false)
    }

    pub fn clear_use_http(&mut self) {
        self.use_http = ::std::option::Option::None;
    }

    pub fn has_use_http(&self) -> bool {
        self.use_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_http(&mut self, v: bool) {
        self.use_http = ::std::option::Option::Some(v);
    }

    // optional string http_host = 9;

    pub fn get_http_host(&self) -> &str {
        match self.http_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_host(&mut self) {
        self.http_host.clear();
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host(&mut self) -> &mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host.set_default();
        }
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string http_url = 10;

    pub fn get_http_url(&self) -> &str {
        match self.http_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_url(&mut self) {
        self.http_url.clear();
    }

    pub fn has_http_url(&self) -> bool {
        self.http_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_url(&mut self, v: ::std::string::String) {
        self.http_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_url(&mut self) -> &mut ::std::string::String {
        if self.http_url.is_none() {
            self.http_url.set_default();
        }
        self.http_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_url(&mut self) -> ::std::string::String {
        self.http_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes kv_headers = 11;

    pub fn get_kv_headers(&self) -> &[u8] {
        match self.kv_headers.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_kv_headers(&mut self) {
        self.kv_headers.clear();
    }

    pub fn has_kv_headers(&self) -> bool {
        self.kv_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kv_headers(&mut self, v: ::std::vec::Vec<u8>) {
        self.kv_headers = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kv_headers(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.kv_headers.is_none() {
            self.kv_headers.set_default();
        }
        self.kv_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_kv_headers(&mut self) -> ::std::vec::Vec<u8> {
        self.kv_headers.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool use_https = 12;

    pub fn get_use_https(&self) -> bool {
        self.use_https.unwrap_or(false)
    }

    pub fn clear_use_https(&mut self) {
        self.use_https = ::std::option::Option::None;
    }

    pub fn has_use_https(&self) -> bool {
        self.use_https.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_https(&mut self, v: bool) {
        self.use_https = ::std::option::Option::Some(v);
    }

    // optional bool encrypted = 13;

    pub fn get_encrypted(&self) -> bool {
        self.encrypted.unwrap_or(false)
    }

    pub fn clear_encrypted(&mut self) {
        self.encrypted = ::std::option::Option::None;
    }

    pub fn has_encrypted(&self) -> bool {
        self.encrypted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted(&mut self, v: bool) {
        self.encrypted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSDownloadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.raw_file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_stamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_explicit_delete = ::std::option::Option::Some(is.read_bool()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.use_http = ::std::option::Option::Some(is.read_bool()?);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_host)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_url)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.kv_headers)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.use_https = ::std::option::Option::Some(is.read_bool()?);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.encrypted = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.raw_file_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_explicit_delete {
            my_size += 2;
        }
        if let Some(v) = self.use_http {
            my_size += 2;
        }
        if let Some(v) = self.http_host.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.http_url.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.kv_headers.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.use_https {
            my_size += 2;
        }
        if let Some(v) = self.encrypted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.raw_file_size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.is_explicit_delete {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.use_http {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.http_host.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.http_url.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.kv_headers.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.use_https {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.encrypted {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSDownloadResponse {
        CMsgClientUFSDownloadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUFSDownloadResponse| { &m.eresult },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.eresult },
                CMsgClientUFSDownloadResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUFSDownloadResponse| { &m.app_id },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.app_id },
                CMsgClientUFSDownloadResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "file_size",
                |m: &CMsgClientUFSDownloadResponse| { &m.file_size },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.file_size },
                CMsgClientUFSDownloadResponse::get_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "raw_file_size",
                |m: &CMsgClientUFSDownloadResponse| { &m.raw_file_size },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.raw_file_size },
                CMsgClientUFSDownloadResponse::get_raw_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sha_file",
                |m: &CMsgClientUFSDownloadResponse| { &m.sha_file },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.sha_file },
                CMsgClientUFSDownloadResponse::get_sha_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "time_stamp",
                |m: &CMsgClientUFSDownloadResponse| { &m.time_stamp },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.time_stamp },
                CMsgClientUFSDownloadResponse::get_time_stamp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_explicit_delete",
                |m: &CMsgClientUFSDownloadResponse| { &m.is_explicit_delete },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.is_explicit_delete },
                CMsgClientUFSDownloadResponse::get_is_explicit_delete,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "use_http",
                |m: &CMsgClientUFSDownloadResponse| { &m.use_http },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.use_http },
                CMsgClientUFSDownloadResponse::get_use_http,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "http_host",
                |m: &CMsgClientUFSDownloadResponse| { &m.http_host },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.http_host },
                CMsgClientUFSDownloadResponse::get_http_host,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "http_url",
                |m: &CMsgClientUFSDownloadResponse| { &m.http_url },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.http_url },
                CMsgClientUFSDownloadResponse::get_http_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "kv_headers",
                |m: &CMsgClientUFSDownloadResponse| { &m.kv_headers },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.kv_headers },
                CMsgClientUFSDownloadResponse::get_kv_headers,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "use_https",
                |m: &CMsgClientUFSDownloadResponse| { &m.use_https },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.use_https },
                CMsgClientUFSDownloadResponse::get_use_https,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "encrypted",
                |m: &CMsgClientUFSDownloadResponse| { &m.encrypted },
                |m: &mut CMsgClientUFSDownloadResponse| { &mut m.encrypted },
                CMsgClientUFSDownloadResponse::get_encrypted,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSDownloadResponse>(
                "CMsgClientUFSDownloadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSDownloadResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSDownloadResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSDownloadResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSDownloadResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.raw_file_size = ::std::option::Option::None;
        self.sha_file.clear();
        self.time_stamp = ::std::option::Option::None;
        self.is_explicit_delete = ::std::option::Option::None;
        self.use_http = ::std::option::Option::None;
        self.http_host.clear();
        self.http_url.clear();
        self.kv_headers.clear();
        self.use_https = ::std::option::Option::None;
        self.encrypted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSDownloadResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSLoginRequest {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    am_session_token: ::std::option::Option<u64>,
    pub apps: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSLoginRequest {
    fn default() -> &'a CMsgClientUFSLoginRequest {
        <CMsgClientUFSLoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSLoginRequest {
    pub fn new() -> CMsgClientUFSLoginRequest {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;

    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint64 am_session_token = 2;

    pub fn get_am_session_token(&self) -> u64 {
        self.am_session_token.unwrap_or(0)
    }

    pub fn clear_am_session_token(&mut self) {
        self.am_session_token = ::std::option::Option::None;
    }

    pub fn has_am_session_token(&self) -> bool {
        self.am_session_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_am_session_token(&mut self, v: u64) {
        self.am_session_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSLoginRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.am_session_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.apps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.am_session_token {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.apps {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.am_session_token {
            os.write_uint64(2, v)?;
        }
        for v in &self.apps {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSLoginRequest {
        CMsgClientUFSLoginRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "protocol_version",
                |m: &CMsgClientUFSLoginRequest| { &m.protocol_version },
                |m: &mut CMsgClientUFSLoginRequest| { &mut m.protocol_version },
                CMsgClientUFSLoginRequest::get_protocol_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "am_session_token",
                |m: &CMsgClientUFSLoginRequest| { &m.am_session_token },
                |m: &mut CMsgClientUFSLoginRequest| { &mut m.am_session_token },
                CMsgClientUFSLoginRequest::get_am_session_token,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "apps",
                |m: &CMsgClientUFSLoginRequest| { &m.apps },
                |m: &mut CMsgClientUFSLoginRequest| { &mut m.apps },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSLoginRequest>(
                "CMsgClientUFSLoginRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSLoginRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSLoginRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSLoginRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSLoginRequest {
    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.am_session_token = ::std::option::Option::None;
        self.apps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSLoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSLoginRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSLoginResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSLoginResponse {
    fn default() -> &'a CMsgClientUFSLoginResponse {
        <CMsgClientUFSLoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSLoginResponse {
    pub fn new() -> CMsgClientUFSLoginResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSLoginResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSLoginResponse {
        CMsgClientUFSLoginResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUFSLoginResponse| { &m.eresult },
                |m: &mut CMsgClientUFSLoginResponse| { &mut m.eresult },
                CMsgClientUFSLoginResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSLoginResponse>(
                "CMsgClientUFSLoginResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSLoginResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSLoginResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSLoginResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSLoginResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSLoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSLoginResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestEncryptedAppTicket {
    // message fields
    app_id: ::std::option::Option<u32>,
    userdata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestEncryptedAppTicket {
    fn default() -> &'a CMsgClientRequestEncryptedAppTicket {
        <CMsgClientRequestEncryptedAppTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestEncryptedAppTicket {
    pub fn new() -> CMsgClientRequestEncryptedAppTicket {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes userdata = 2;

    pub fn get_userdata(&self) -> &[u8] {
        match self.userdata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_userdata(&mut self) {
        self.userdata.clear();
    }

    pub fn has_userdata(&self) -> bool {
        self.userdata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userdata(&mut self, v: ::std::vec::Vec<u8>) {
        self.userdata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userdata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.userdata.is_none() {
            self.userdata.set_default();
        }
        self.userdata.as_mut().unwrap()
    }

    // Take field
    pub fn take_userdata(&mut self) -> ::std::vec::Vec<u8> {
        self.userdata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestEncryptedAppTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.userdata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.userdata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.userdata.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestEncryptedAppTicket {
        CMsgClientRequestEncryptedAppTicket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientRequestEncryptedAppTicket| { &m.app_id },
                |m: &mut CMsgClientRequestEncryptedAppTicket| { &mut m.app_id },
                CMsgClientRequestEncryptedAppTicket::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "userdata",
                |m: &CMsgClientRequestEncryptedAppTicket| { &m.userdata },
                |m: &mut CMsgClientRequestEncryptedAppTicket| { &mut m.userdata },
                CMsgClientRequestEncryptedAppTicket::get_userdata,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestEncryptedAppTicket>(
                "CMsgClientRequestEncryptedAppTicket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicket {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestEncryptedAppTicket> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestEncryptedAppTicket::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestEncryptedAppTicket {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.userdata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestEncryptedAppTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestEncryptedAppTicket {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestEncryptedAppTicketResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    eresult: ::std::option::Option<i32>,
    pub encrypted_app_ticket: ::protobuf::SingularPtrField<super::encrypted_app_ticket::EncryptedAppTicket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestEncryptedAppTicketResponse {
    fn default() -> &'a CMsgClientRequestEncryptedAppTicketResponse {
        <CMsgClientRequestEncryptedAppTicketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestEncryptedAppTicketResponse {
    pub fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestEncryptedAppTicketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.encrypted_app_ticket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<super::encrypted_app_ticket::EncryptedAppTicket, _>(wire_type, is, &mut self.encrypted_app_ticket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encrypted_app_ticket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.encrypted_app_ticket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        CMsgClientRequestEncryptedAppTicketResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.app_id },
                |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.app_id },
                CMsgClientRequestEncryptedAppTicketResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.eresult },
                |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.eresult },
                CMsgClientRequestEncryptedAppTicketResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::encrypted_app_ticket::EncryptedAppTicket>, _>(
                "encrypted_app_ticket",
                |m: &CMsgClientRequestEncryptedAppTicketResponse| { &m.encrypted_app_ticket },
                |m: &mut CMsgClientRequestEncryptedAppTicketResponse| { &mut m.encrypted_app_ticket },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestEncryptedAppTicketResponse>(
                "CMsgClientRequestEncryptedAppTicketResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicketResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestEncryptedAppTicketResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestEncryptedAppTicketResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestEncryptedAppTicketResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.encrypted_app_ticket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestEncryptedAppTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestEncryptedAppTicketResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWalletInfoUpdate {
    // message fields
    has_wallet: ::std::option::Option<bool>,
    balance: ::std::option::Option<i32>,
    currency: ::std::option::Option<i32>,
    balance_delayed: ::std::option::Option<i32>,
    balance64: ::std::option::Option<i64>,
    balance64_delayed: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWalletInfoUpdate {
    fn default() -> &'a CMsgClientWalletInfoUpdate {
        <CMsgClientWalletInfoUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWalletInfoUpdate {
    pub fn new() -> CMsgClientWalletInfoUpdate {
        ::std::default::Default::default()
    }

    // optional bool has_wallet = 1;

    pub fn get_has_wallet(&self) -> bool {
        self.has_wallet.unwrap_or(false)
    }

    pub fn clear_has_wallet(&mut self) {
        self.has_wallet = ::std::option::Option::None;
    }

    pub fn has_has_wallet(&self) -> bool {
        self.has_wallet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_wallet(&mut self, v: bool) {
        self.has_wallet = ::std::option::Option::Some(v);
    }

    // optional int32 balance = 2;

    pub fn get_balance(&self) -> i32 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;

    pub fn get_currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional int32 balance_delayed = 4;

    pub fn get_balance_delayed(&self) -> i32 {
        self.balance_delayed.unwrap_or(0)
    }

    pub fn clear_balance_delayed(&mut self) {
        self.balance_delayed = ::std::option::Option::None;
    }

    pub fn has_balance_delayed(&self) -> bool {
        self.balance_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_delayed(&mut self, v: i32) {
        self.balance_delayed = ::std::option::Option::Some(v);
    }

    // optional int64 balance64 = 5;

    pub fn get_balance64(&self) -> i64 {
        self.balance64.unwrap_or(0)
    }

    pub fn clear_balance64(&mut self) {
        self.balance64 = ::std::option::Option::None;
    }

    pub fn has_balance64(&self) -> bool {
        self.balance64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance64(&mut self, v: i64) {
        self.balance64 = ::std::option::Option::Some(v);
    }

    // optional int64 balance64_delayed = 6;

    pub fn get_balance64_delayed(&self) -> i64 {
        self.balance64_delayed.unwrap_or(0)
    }

    pub fn clear_balance64_delayed(&mut self) {
        self.balance64_delayed = ::std::option::Option::None;
    }

    pub fn has_balance64_delayed(&self) -> bool {
        self.balance64_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance64_delayed(&mut self, v: i64) {
        self.balance64_delayed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWalletInfoUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.has_wallet = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.balance = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.balance_delayed = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.balance64 = ::std::option::Option::Some(is.read_int64()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.balance64_delayed = ::std::option::Option::Some(is.read_int64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.has_wallet {
            my_size += 2;
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance_delayed {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance64 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance64_delayed {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.has_wallet {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.balance {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.balance_delayed {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.balance64 {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.balance64_delayed {
            os.write_int64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWalletInfoUpdate {
        CMsgClientWalletInfoUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "has_wallet",
                |m: &CMsgClientWalletInfoUpdate| { &m.has_wallet },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.has_wallet },
                CMsgClientWalletInfoUpdate::get_has_wallet,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "balance",
                |m: &CMsgClientWalletInfoUpdate| { &m.balance },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance },
                CMsgClientWalletInfoUpdate::get_balance,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "currency",
                |m: &CMsgClientWalletInfoUpdate| { &m.currency },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.currency },
                CMsgClientWalletInfoUpdate::get_currency,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "balance_delayed",
                |m: &CMsgClientWalletInfoUpdate| { &m.balance_delayed },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance_delayed },
                CMsgClientWalletInfoUpdate::get_balance_delayed,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt64, _>(
                "balance64",
                |m: &CMsgClientWalletInfoUpdate| { &m.balance64 },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance64 },
                CMsgClientWalletInfoUpdate::get_balance64,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt64, _>(
                "balance64_delayed",
                |m: &CMsgClientWalletInfoUpdate| { &m.balance64_delayed },
                |m: &mut CMsgClientWalletInfoUpdate| { &mut m.balance64_delayed },
                CMsgClientWalletInfoUpdate::get_balance64_delayed,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientWalletInfoUpdate>(
                "CMsgClientWalletInfoUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWalletInfoUpdate {
        static instance: ::protobuf::rt::Lazy<CMsgClientWalletInfoUpdate> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientWalletInfoUpdate::new)
    }
}

impl ::protobuf::Clear for CMsgClientWalletInfoUpdate {
    fn clear(&mut self) {
        self.has_wallet = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.balance_delayed = ::std::option::Option::None;
        self.balance64 = ::std::option::Option::None;
        self.balance64_delayed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWalletInfoUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWalletInfoUpdate {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoUpdate {
    // message fields
    last_changenumber: ::std::option::Option<u32>,
    send_changelist: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoUpdate {
    fn default() -> &'a CMsgClientAppInfoUpdate {
        <CMsgClientAppInfoUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoUpdate {
    pub fn new() -> CMsgClientAppInfoUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 last_changenumber = 1;

    pub fn get_last_changenumber(&self) -> u32 {
        self.last_changenumber.unwrap_or(0)
    }

    pub fn clear_last_changenumber(&mut self) {
        self.last_changenumber = ::std::option::Option::None;
    }

    pub fn has_last_changenumber(&self) -> bool {
        self.last_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_changenumber(&mut self, v: u32) {
        self.last_changenumber = ::std::option::Option::Some(v);
    }

    // optional bool send_changelist = 2;

    pub fn get_send_changelist(&self) -> bool {
        self.send_changelist.unwrap_or(false)
    }

    pub fn clear_send_changelist(&mut self) {
        self.send_changelist = ::std::option::Option::None;
    }

    pub fn has_send_changelist(&self) -> bool {
        self.send_changelist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_changelist(&mut self, v: bool) {
        self.send_changelist = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAppInfoUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_changenumber = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.send_changelist = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.last_changenumber {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.send_changelist {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.last_changenumber {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.send_changelist {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoUpdate {
        CMsgClientAppInfoUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_changenumber",
                |m: &CMsgClientAppInfoUpdate| { &m.last_changenumber },
                |m: &mut CMsgClientAppInfoUpdate| { &mut m.last_changenumber },
                CMsgClientAppInfoUpdate::get_last_changenumber,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "send_changelist",
                |m: &CMsgClientAppInfoUpdate| { &m.send_changelist },
                |m: &mut CMsgClientAppInfoUpdate| { &mut m.send_changelist },
                CMsgClientAppInfoUpdate::get_send_changelist,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoUpdate>(
                "CMsgClientAppInfoUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoUpdate {
        static instance: ::protobuf::rt::Lazy<CMsgClientAppInfoUpdate> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAppInfoUpdate::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoUpdate {
    fn clear(&mut self) {
        self.last_changenumber = ::std::option::Option::None;
        self.send_changelist = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoUpdate {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoChanges {
    // message fields
    current_change_number: ::std::option::Option<u32>,
    force_full_update: ::std::option::Option<bool>,
    pub appIDs: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoChanges {
    fn default() -> &'a CMsgClientAppInfoChanges {
        <CMsgClientAppInfoChanges as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoChanges {
    pub fn new() -> CMsgClientAppInfoChanges {
        ::std::default::Default::default()
    }

    // optional uint32 current_change_number = 1;

    pub fn get_current_change_number(&self) -> u32 {
        self.current_change_number.unwrap_or(0)
    }

    pub fn clear_current_change_number(&mut self) {
        self.current_change_number = ::std::option::Option::None;
    }

    pub fn has_current_change_number(&self) -> bool {
        self.current_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_change_number(&mut self, v: u32) {
        self.current_change_number = ::std::option::Option::Some(v);
    }

    // optional bool force_full_update = 2;

    pub fn get_force_full_update(&self) -> bool {
        self.force_full_update.unwrap_or(false)
    }

    pub fn clear_force_full_update(&mut self) {
        self.force_full_update = ::std::option::Option::None;
    }

    pub fn has_force_full_update(&self) -> bool {
        self.force_full_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_update(&mut self, v: bool) {
        self.force_full_update = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAppInfoChanges {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.current_change_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.force_full_update = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.current_change_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.force_full_update {
            my_size += 2;
        }
        for value in &self.appIDs {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.current_change_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.force_full_update {
            os.write_bool(2, v)?;
        }
        for v in &self.appIDs {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoChanges {
        CMsgClientAppInfoChanges::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "current_change_number",
                |m: &CMsgClientAppInfoChanges| { &m.current_change_number },
                |m: &mut CMsgClientAppInfoChanges| { &mut m.current_change_number },
                CMsgClientAppInfoChanges::get_current_change_number,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "force_full_update",
                |m: &CMsgClientAppInfoChanges| { &m.force_full_update },
                |m: &mut CMsgClientAppInfoChanges| { &mut m.force_full_update },
                CMsgClientAppInfoChanges::get_force_full_update,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "appIDs",
                |m: &CMsgClientAppInfoChanges| { &m.appIDs },
                |m: &mut CMsgClientAppInfoChanges| { &mut m.appIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoChanges>(
                "CMsgClientAppInfoChanges",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoChanges {
        static instance: ::protobuf::rt::Lazy<CMsgClientAppInfoChanges> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAppInfoChanges::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoChanges {
    fn clear(&mut self) {
        self.current_change_number = ::std::option::Option::None;
        self.force_full_update = ::std::option::Option::None;
        self.appIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoChanges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoChanges {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoRequest {
    // message fields
    pub apps: ::protobuf::RepeatedField<cmsg_client_app_info_request::App>,
    supports_batches: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoRequest {
    fn default() -> &'a CMsgClientAppInfoRequest {
        <CMsgClientAppInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoRequest {
    pub fn new() -> CMsgClientAppInfoRequest {
        ::std::default::Default::default()
    }

    // optional bool supports_batches = 2;

    pub fn get_supports_batches(&self) -> bool {
        self.supports_batches.unwrap_or(false)
    }

    pub fn clear_supports_batches(&mut self) {
        self.supports_batches = ::std::option::Option::None;
    }

    pub fn has_supports_batches(&self) -> bool {
        self.supports_batches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_batches(&mut self, v: bool) {
        self.supports_batches = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAppInfoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.apps)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.supports_batches = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.supports_batches {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.supports_batches {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoRequest {
        CMsgClientAppInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_app_info_request::App>>(
                "apps",
                |m: &CMsgClientAppInfoRequest| { &m.apps },
                |m: &mut CMsgClientAppInfoRequest| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "supports_batches",
                |m: &CMsgClientAppInfoRequest| { &m.supports_batches },
                |m: &mut CMsgClientAppInfoRequest| { &mut m.supports_batches },
                CMsgClientAppInfoRequest::get_supports_batches,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoRequest>(
                "CMsgClientAppInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientAppInfoRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAppInfoRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoRequest {
    fn clear(&mut self) {
        self.apps.clear();
        self.supports_batches = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoRequest {
}

/// Nested message and enums of message `CMsgClientAppInfoRequest`
pub mod cmsg_client_app_info_request {
    #[derive(PartialEq,Clone,Default)]
    pub struct App {
        // message fields
        app_id: ::std::option::Option<u32>,
        section_flags: ::std::option::Option<u32>,
        pub section_CRC: ::std::vec::Vec<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn get_app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 section_flags = 2;

        pub fn get_section_flags(&self) -> u32 {
            self.section_flags.unwrap_or(0)
        }

        pub fn clear_section_flags(&mut self) {
            self.section_flags = ::std::option::Option::None;
        }

        pub fn has_section_flags(&self) -> bool {
            self.section_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_section_flags(&mut self, v: u32) {
            self.section_flags = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for App {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.section_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.section_CRC)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.section_flags {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            for value in &self.section_CRC {
                my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.section_flags {
                os.write_uint32(2, v)?;
            }
            for v in &self.section_CRC {
                os.write_uint32(3, *v)?;
            };
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> App {
            App::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "app_id",
                    |m: &App| { &m.app_id },
                    |m: &mut App| { &mut m.app_id },
                    App::get_app_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "section_flags",
                    |m: &App| { &m.section_flags },
                    |m: &mut App| { &mut m.section_flags },
                    App::get_section_flags,
                ));
                fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                    "section_CRC",
                    |m: &App| { &m.section_CRC },
                    |m: &mut App| { &mut m.section_CRC },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<App>(
                    "CMsgClientAppInfoRequest.App",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static App {
            static instance: ::protobuf::rt::Lazy<App> = ::protobuf::rt::Lazy::INIT;
            instance.get(App::new)
        }
    }

    impl ::protobuf::Clear for App {
        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.section_flags = ::std::option::Option::None;
            self.section_CRC.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for App {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for App {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAppInfoResponse {
    // message fields
    pub apps: ::protobuf::RepeatedField<cmsg_client_app_info_response::App>,
    pub apps_unknown: ::std::vec::Vec<u32>,
    apps_pending: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAppInfoResponse {
    fn default() -> &'a CMsgClientAppInfoResponse {
        <CMsgClientAppInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAppInfoResponse {
    pub fn new() -> CMsgClientAppInfoResponse {
        ::std::default::Default::default()
    }

    // optional uint32 apps_pending = 3;

    pub fn get_apps_pending(&self) -> u32 {
        self.apps_pending.unwrap_or(0)
    }

    pub fn clear_apps_pending(&mut self) {
        self.apps_pending = ::std::option::Option::None;
    }

    pub fn has_apps_pending(&self) -> bool {
        self.apps_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apps_pending(&mut self, v: u32) {
        self.apps_pending = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAppInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.apps)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.apps_unknown)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.apps_pending = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.apps_unknown {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.apps_pending {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.apps_unknown {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.apps_pending {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAppInfoResponse {
        CMsgClientAppInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_app_info_response::App>>(
                "apps",
                |m: &CMsgClientAppInfoResponse| { &m.apps },
                |m: &mut CMsgClientAppInfoResponse| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "apps_unknown",
                |m: &CMsgClientAppInfoResponse| { &m.apps_unknown },
                |m: &mut CMsgClientAppInfoResponse| { &mut m.apps_unknown },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "apps_pending",
                |m: &CMsgClientAppInfoResponse| { &m.apps_pending },
                |m: &mut CMsgClientAppInfoResponse| { &mut m.apps_pending },
                CMsgClientAppInfoResponse::get_apps_pending,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoResponse>(
                "CMsgClientAppInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAppInfoResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientAppInfoResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAppInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoResponse {
    fn clear(&mut self) {
        self.apps.clear();
        self.apps_unknown.clear();
        self.apps_pending = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAppInfoResponse {
}

/// Nested message and enums of message `CMsgClientAppInfoResponse`
pub mod cmsg_client_app_info_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct App {
        // message fields
        app_id: ::std::option::Option<u32>,
        change_number: ::std::option::Option<u32>,
        pub sections: ::protobuf::RepeatedField<app::Section>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn get_app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn get_change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for App {
        fn is_initialized(&self) -> bool {
            for v in &self.sections {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.sections)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            for value in &self.sections {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            for v in &self.sections {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> App {
            App::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "app_id",
                    |m: &App| { &m.app_id },
                    |m: &mut App| { &mut m.app_id },
                    App::get_app_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "change_number",
                    |m: &App| { &m.change_number },
                    |m: &mut App| { &mut m.change_number },
                    App::get_change_number,
                ));
                fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<app::Section>>(
                    "sections",
                    |m: &App| { &m.sections },
                    |m: &mut App| { &mut m.sections },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<App>(
                    "CMsgClientAppInfoResponse.App",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static App {
            static instance: ::protobuf::rt::Lazy<App> = ::protobuf::rt::Lazy::INIT;
            instance.get(App::new)
        }
    }

    impl ::protobuf::Clear for App {
        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.sections.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for App {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for App {
    }

    /// Nested message and enums of message `App`
    pub mod app {
        #[derive(PartialEq,Clone,Default)]
        pub struct Section {
            // message fields
            section_id: ::std::option::Option<u32>,
            section_kv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
            // special fields
            pub unknown_fields: ::protobuf::UnknownFields,
            pub cached_size: ::protobuf::rt::CachedSize,
        }

        impl<'a> ::std::default::Default for &'a Section {
            fn default() -> &'a Section {
                <Section as ::protobuf::Message>::default_instance()
            }
        }

        impl Section {
            pub fn new() -> Section {
                ::std::default::Default::default()
            }

            // optional uint32 section_id = 1;

            pub fn get_section_id(&self) -> u32 {
                self.section_id.unwrap_or(0)
            }

            pub fn clear_section_id(&mut self) {
                self.section_id = ::std::option::Option::None;
            }

            pub fn has_section_id(&self) -> bool {
                self.section_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_section_id(&mut self, v: u32) {
                self.section_id = ::std::option::Option::Some(v);
            }

            // optional bytes section_kv = 2;

            pub fn get_section_kv(&self) -> &[u8] {
                match self.section_kv.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_section_kv(&mut self) {
                self.section_kv.clear();
            }

            pub fn has_section_kv(&self) -> bool {
                self.section_kv.is_some()
            }

            // Param is passed by value, moved
            pub fn set_section_kv(&mut self, v: ::std::vec::Vec<u8>) {
                self.section_kv = ::protobuf::SingularField::some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_section_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.section_kv.is_none() {
                    self.section_kv.set_default();
                }
                self.section_kv.as_mut().unwrap()
            }

            // Take field
            pub fn take_section_kv(&mut self) -> ::std::vec::Vec<u8> {
                self.section_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }
        }

        impl ::protobuf::Message for Section {
            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                while !is.eof()? {
                    let (field_number, wire_type) = is.read_tag_unpack()?;
                    match field_number {
                        1 => {
                            if wire_type != ::protobuf::wire_format::WireTypeVarint {
                                return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                            }
                            self.section_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        2 => {
                            ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.section_kv)?;
                        },
                        _ => {
                            ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u32 {
                let mut my_size = 0;
                if let Some(v) = self.section_id {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                }
                if let Some(v) = self.section_kv.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
                self.cached_size.set(my_size);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                if let Some(v) = self.section_id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.section_kv.as_ref() {
                    os.write_bytes(2, v)?;
                }
                os.write_unknown_fields(self.get_unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn get_cached_size(&self) -> u32 {
                self.cached_size.get()
            }

            fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
                &self.unknown_fields
            }

            fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
                &mut self.unknown_fields
            }

            fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
                Self::descriptor_static()
            }

            fn new() -> Section {
                Section::new()
            }

            fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
                descriptor.get(|| {
                    let mut fields = ::std::vec::Vec::new();
                    fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                        "section_id",
                        |m: &Section| { &m.section_id },
                        |m: &mut Section| { &mut m.section_id },
                        Section::get_section_id,
                    ));
                    fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                        "section_kv",
                        |m: &Section| { &m.section_kv },
                        |m: &mut Section| { &mut m.section_kv },
                        Section::get_section_kv,
                    ));
                    ::protobuf::reflect::MessageDescriptor::new::<Section>(
                        "CMsgClientAppInfoResponse.App.Section",
                        fields,
                        super::super::file_descriptor_proto()
                    )
                })
            }

            fn default_instance() -> &'static Section {
                static instance: ::protobuf::rt::Lazy<Section> = ::protobuf::rt::Lazy::INIT;
                instance.get(Section::new)
            }
        }

        impl ::protobuf::Clear for Section {
            fn clear(&mut self) {
                self.section_id = ::std::option::Option::None;
                self.section_kv.clear();
                self.unknown_fields.clear();
            }
        }

        impl ::std::fmt::Debug for Section {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Section {
        }
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPackageInfoRequest {
    // message fields
    pub package_ids: ::std::vec::Vec<u32>,
    meta_data_only: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPackageInfoRequest {
    fn default() -> &'a CMsgClientPackageInfoRequest {
        <CMsgClientPackageInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPackageInfoRequest {
    pub fn new() -> CMsgClientPackageInfoRequest {
        ::std::default::Default::default()
    }

    // optional bool meta_data_only = 2;

    pub fn get_meta_data_only(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }

    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPackageInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.package_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.meta_data_only = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.package_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.meta_data_only {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.package_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.meta_data_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPackageInfoRequest {
        CMsgClientPackageInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "package_ids",
                |m: &CMsgClientPackageInfoRequest| { &m.package_ids },
                |m: &mut CMsgClientPackageInfoRequest| { &mut m.package_ids },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "meta_data_only",
                |m: &CMsgClientPackageInfoRequest| { &m.meta_data_only },
                |m: &mut CMsgClientPackageInfoRequest| { &mut m.meta_data_only },
                CMsgClientPackageInfoRequest::get_meta_data_only,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPackageInfoRequest>(
                "CMsgClientPackageInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPackageInfoRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientPackageInfoRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPackageInfoRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientPackageInfoRequest {
    fn clear(&mut self) {
        self.package_ids.clear();
        self.meta_data_only = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPackageInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPackageInfoRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPackageInfoResponse {
    // message fields
    pub packages: ::protobuf::RepeatedField<cmsg_client_package_info_response::Package>,
    pub packages_unknown: ::std::vec::Vec<u32>,
    packages_pending: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPackageInfoResponse {
    fn default() -> &'a CMsgClientPackageInfoResponse {
        <CMsgClientPackageInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPackageInfoResponse {
    pub fn new() -> CMsgClientPackageInfoResponse {
        ::std::default::Default::default()
    }

    // optional uint32 packages_pending = 3;

    pub fn get_packages_pending(&self) -> u32 {
        self.packages_pending.unwrap_or(0)
    }

    pub fn clear_packages_pending(&mut self) {
        self.packages_pending = ::std::option::Option::None;
    }

    pub fn has_packages_pending(&self) -> bool {
        self.packages_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packages_pending(&mut self, v: u32) {
        self.packages_pending = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPackageInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.packages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.packages)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.packages_unknown)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.packages_pending = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.packages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.packages_unknown {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.packages_pending {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.packages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.packages_unknown {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.packages_pending {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPackageInfoResponse {
        CMsgClientPackageInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_package_info_response::Package>>(
                "packages",
                |m: &CMsgClientPackageInfoResponse| { &m.packages },
                |m: &mut CMsgClientPackageInfoResponse| { &mut m.packages },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "packages_unknown",
                |m: &CMsgClientPackageInfoResponse| { &m.packages_unknown },
                |m: &mut CMsgClientPackageInfoResponse| { &mut m.packages_unknown },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "packages_pending",
                |m: &CMsgClientPackageInfoResponse| { &m.packages_pending },
                |m: &mut CMsgClientPackageInfoResponse| { &mut m.packages_pending },
                CMsgClientPackageInfoResponse::get_packages_pending,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPackageInfoResponse>(
                "CMsgClientPackageInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPackageInfoResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientPackageInfoResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPackageInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientPackageInfoResponse {
    fn clear(&mut self) {
        self.packages.clear();
        self.packages_unknown.clear();
        self.packages_pending = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPackageInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPackageInfoResponse {
}

/// Nested message and enums of message `CMsgClientPackageInfoResponse`
pub mod cmsg_client_package_info_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Package {
        // message fields
        package_id: ::std::option::Option<u32>,
        change_number: ::std::option::Option<u32>,
        sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        buffer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Package {
        fn default() -> &'a Package {
            <Package as ::protobuf::Message>::default_instance()
        }
    }

    impl Package {
        pub fn new() -> Package {
            ::std::default::Default::default()
        }

        // optional uint32 package_id = 1;

        pub fn get_package_id(&self) -> u32 {
            self.package_id.unwrap_or(0)
        }

        pub fn clear_package_id(&mut self) {
            self.package_id = ::std::option::Option::None;
        }

        pub fn has_package_id(&self) -> bool {
            self.package_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_package_id(&mut self, v: u32) {
            self.package_id = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn get_change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional bytes sha = 3;

        pub fn get_sha(&self) -> &[u8] {
            match self.sha.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha(&mut self) {
            self.sha.clear();
        }

        pub fn has_sha(&self) -> bool {
            self.sha.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha.is_none() {
                self.sha.set_default();
            }
            self.sha.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
            self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes buffer = 4;

        pub fn get_buffer(&self) -> &[u8] {
            match self.buffer.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_buffer(&mut self) {
            self.buffer.clear();
        }

        pub fn has_buffer(&self) -> bool {
            self.buffer.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
            self.buffer = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.buffer.is_none() {
                self.buffer.set_default();
            }
            self.buffer.as_mut().unwrap()
        }

        // Take field
        pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
            self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for Package {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha)?;
                    },
                    4 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buffer)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.package_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.sha.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.buffer.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.package_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.sha.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.buffer.as_ref() {
                os.write_bytes(4, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Package {
            Package::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "package_id",
                    |m: &Package| { &m.package_id },
                    |m: &mut Package| { &mut m.package_id },
                    Package::get_package_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "change_number",
                    |m: &Package| { &m.change_number },
                    |m: &mut Package| { &mut m.change_number },
                    Package::get_change_number,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "sha",
                    |m: &Package| { &m.sha },
                    |m: &mut Package| { &mut m.sha },
                    Package::get_sha,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "buffer",
                    |m: &Package| { &m.buffer },
                    |m: &mut Package| { &mut m.buffer },
                    Package::get_buffer,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Package>(
                    "CMsgClientPackageInfoResponse.Package",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Package {
            static instance: ::protobuf::rt::Lazy<Package> = ::protobuf::rt::Lazy::INIT;
            instance.get(Package::new)
        }
    }

    impl ::protobuf::Clear for Package {
        fn clear(&mut self) {
            self.package_id = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.sha.clear();
            self.buffer.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Package {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Package {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSChangesSinceRequest {
    // message fields
    since_change_number: ::std::option::Option<u32>,
    send_app_info_changes: ::std::option::Option<bool>,
    send_package_info_changes: ::std::option::Option<bool>,
    num_app_info_cached: ::std::option::Option<u32>,
    num_package_info_cached: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSChangesSinceRequest {
    fn default() -> &'a CMsgClientPICSChangesSinceRequest {
        <CMsgClientPICSChangesSinceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSChangesSinceRequest {
    pub fn new() -> CMsgClientPICSChangesSinceRequest {
        ::std::default::Default::default()
    }

    // optional uint32 since_change_number = 1;

    pub fn get_since_change_number(&self) -> u32 {
        self.since_change_number.unwrap_or(0)
    }

    pub fn clear_since_change_number(&mut self) {
        self.since_change_number = ::std::option::Option::None;
    }

    pub fn has_since_change_number(&self) -> bool {
        self.since_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_since_change_number(&mut self, v: u32) {
        self.since_change_number = ::std::option::Option::Some(v);
    }

    // optional bool send_app_info_changes = 2;

    pub fn get_send_app_info_changes(&self) -> bool {
        self.send_app_info_changes.unwrap_or(false)
    }

    pub fn clear_send_app_info_changes(&mut self) {
        self.send_app_info_changes = ::std::option::Option::None;
    }

    pub fn has_send_app_info_changes(&self) -> bool {
        self.send_app_info_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_app_info_changes(&mut self, v: bool) {
        self.send_app_info_changes = ::std::option::Option::Some(v);
    }

    // optional bool send_package_info_changes = 3;

    pub fn get_send_package_info_changes(&self) -> bool {
        self.send_package_info_changes.unwrap_or(false)
    }

    pub fn clear_send_package_info_changes(&mut self) {
        self.send_package_info_changes = ::std::option::Option::None;
    }

    pub fn has_send_package_info_changes(&self) -> bool {
        self.send_package_info_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_package_info_changes(&mut self, v: bool) {
        self.send_package_info_changes = ::std::option::Option::Some(v);
    }

    // optional uint32 num_app_info_cached = 4;

    pub fn get_num_app_info_cached(&self) -> u32 {
        self.num_app_info_cached.unwrap_or(0)
    }

    pub fn clear_num_app_info_cached(&mut self) {
        self.num_app_info_cached = ::std::option::Option::None;
    }

    pub fn has_num_app_info_cached(&self) -> bool {
        self.num_app_info_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_app_info_cached(&mut self, v: u32) {
        self.num_app_info_cached = ::std::option::Option::Some(v);
    }

    // optional uint32 num_package_info_cached = 5;

    pub fn get_num_package_info_cached(&self) -> u32 {
        self.num_package_info_cached.unwrap_or(0)
    }

    pub fn clear_num_package_info_cached(&mut self) {
        self.num_package_info_cached = ::std::option::Option::None;
    }

    pub fn has_num_package_info_cached(&self) -> bool {
        self.num_package_info_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_package_info_cached(&mut self, v: u32) {
        self.num_package_info_cached = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.since_change_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.send_app_info_changes = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.send_package_info_changes = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_app_info_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_package_info_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.since_change_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.send_app_info_changes {
            my_size += 2;
        }
        if let Some(v) = self.send_package_info_changes {
            my_size += 2;
        }
        if let Some(v) = self.num_app_info_cached {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_package_info_cached {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.since_change_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.send_app_info_changes {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.send_package_info_changes {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.num_app_info_cached {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.num_package_info_cached {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSChangesSinceRequest {
        CMsgClientPICSChangesSinceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "since_change_number",
                |m: &CMsgClientPICSChangesSinceRequest| { &m.since_change_number },
                |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.since_change_number },
                CMsgClientPICSChangesSinceRequest::get_since_change_number,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "send_app_info_changes",
                |m: &CMsgClientPICSChangesSinceRequest| { &m.send_app_info_changes },
                |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.send_app_info_changes },
                CMsgClientPICSChangesSinceRequest::get_send_app_info_changes,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "send_package_info_changes",
                |m: &CMsgClientPICSChangesSinceRequest| { &m.send_package_info_changes },
                |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.send_package_info_changes },
                CMsgClientPICSChangesSinceRequest::get_send_package_info_changes,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "num_app_info_cached",
                |m: &CMsgClientPICSChangesSinceRequest| { &m.num_app_info_cached },
                |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.num_app_info_cached },
                CMsgClientPICSChangesSinceRequest::get_num_app_info_cached,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "num_package_info_cached",
                |m: &CMsgClientPICSChangesSinceRequest| { &m.num_package_info_cached },
                |m: &mut CMsgClientPICSChangesSinceRequest| { &mut m.num_package_info_cached },
                CMsgClientPICSChangesSinceRequest::get_num_package_info_cached,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSChangesSinceRequest>(
                "CMsgClientPICSChangesSinceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSChangesSinceRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientPICSChangesSinceRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPICSChangesSinceRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSChangesSinceRequest {
    fn clear(&mut self) {
        self.since_change_number = ::std::option::Option::None;
        self.send_app_info_changes = ::std::option::Option::None;
        self.send_package_info_changes = ::std::option::Option::None;
        self.num_app_info_cached = ::std::option::Option::None;
        self.num_package_info_cached = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSChangesSinceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSChangesSinceRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSChangesSinceResponse {
    // message fields
    current_change_number: ::std::option::Option<u32>,
    since_change_number: ::std::option::Option<u32>,
    force_full_update: ::std::option::Option<bool>,
    pub package_changes: ::protobuf::RepeatedField<cmsg_client_picschanges_since_response::PackageChange>,
    pub app_changes: ::protobuf::RepeatedField<cmsg_client_picschanges_since_response::AppChange>,
    force_full_app_update: ::std::option::Option<bool>,
    force_full_package_update: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSChangesSinceResponse {
    fn default() -> &'a CMsgClientPICSChangesSinceResponse {
        <CMsgClientPICSChangesSinceResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSChangesSinceResponse {
    pub fn new() -> CMsgClientPICSChangesSinceResponse {
        ::std::default::Default::default()
    }

    // optional uint32 current_change_number = 1;

    pub fn get_current_change_number(&self) -> u32 {
        self.current_change_number.unwrap_or(0)
    }

    pub fn clear_current_change_number(&mut self) {
        self.current_change_number = ::std::option::Option::None;
    }

    pub fn has_current_change_number(&self) -> bool {
        self.current_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_change_number(&mut self, v: u32) {
        self.current_change_number = ::std::option::Option::Some(v);
    }

    // optional uint32 since_change_number = 2;

    pub fn get_since_change_number(&self) -> u32 {
        self.since_change_number.unwrap_or(0)
    }

    pub fn clear_since_change_number(&mut self) {
        self.since_change_number = ::std::option::Option::None;
    }

    pub fn has_since_change_number(&self) -> bool {
        self.since_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_since_change_number(&mut self, v: u32) {
        self.since_change_number = ::std::option::Option::Some(v);
    }

    // optional bool force_full_update = 3;

    pub fn get_force_full_update(&self) -> bool {
        self.force_full_update.unwrap_or(false)
    }

    pub fn clear_force_full_update(&mut self) {
        self.force_full_update = ::std::option::Option::None;
    }

    pub fn has_force_full_update(&self) -> bool {
        self.force_full_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_update(&mut self, v: bool) {
        self.force_full_update = ::std::option::Option::Some(v);
    }

    // optional bool force_full_app_update = 6;

    pub fn get_force_full_app_update(&self) -> bool {
        self.force_full_app_update.unwrap_or(false)
    }

    pub fn clear_force_full_app_update(&mut self) {
        self.force_full_app_update = ::std::option::Option::None;
    }

    pub fn has_force_full_app_update(&self) -> bool {
        self.force_full_app_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_app_update(&mut self, v: bool) {
        self.force_full_app_update = ::std::option::Option::Some(v);
    }

    // optional bool force_full_package_update = 7;

    pub fn get_force_full_package_update(&self) -> bool {
        self.force_full_package_update.unwrap_or(false)
    }

    pub fn clear_force_full_package_update(&mut self) {
        self.force_full_package_update = ::std::option::Option::None;
    }

    pub fn has_force_full_package_update(&self) -> bool {
        self.force_full_package_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_package_update(&mut self, v: bool) {
        self.force_full_package_update = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.package_changes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_changes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.current_change_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.since_change_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.force_full_update = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.package_changes)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.app_changes)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.force_full_app_update = ::std::option::Option::Some(is.read_bool()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.force_full_package_update = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.current_change_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.since_change_number {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.force_full_update {
            my_size += 2;
        }
        for value in &self.package_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.app_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.force_full_app_update {
            my_size += 2;
        }
        if let Some(v) = self.force_full_package_update {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.current_change_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.since_change_number {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.force_full_update {
            os.write_bool(3, v)?;
        }
        for v in &self.package_changes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.app_changes {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.force_full_app_update {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.force_full_package_update {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSChangesSinceResponse {
        CMsgClientPICSChangesSinceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "current_change_number",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.current_change_number },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.current_change_number },
                CMsgClientPICSChangesSinceResponse::get_current_change_number,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "since_change_number",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.since_change_number },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.since_change_number },
                CMsgClientPICSChangesSinceResponse::get_since_change_number,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "force_full_update",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.force_full_update },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.force_full_update },
                CMsgClientPICSChangesSinceResponse::get_force_full_update,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_picschanges_since_response::PackageChange>>(
                "package_changes",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.package_changes },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.package_changes },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_picschanges_since_response::AppChange>>(
                "app_changes",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.app_changes },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.app_changes },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "force_full_app_update",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.force_full_app_update },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.force_full_app_update },
                CMsgClientPICSChangesSinceResponse::get_force_full_app_update,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "force_full_package_update",
                |m: &CMsgClientPICSChangesSinceResponse| { &m.force_full_package_update },
                |m: &mut CMsgClientPICSChangesSinceResponse| { &mut m.force_full_package_update },
                CMsgClientPICSChangesSinceResponse::get_force_full_package_update,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSChangesSinceResponse>(
                "CMsgClientPICSChangesSinceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSChangesSinceResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientPICSChangesSinceResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPICSChangesSinceResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSChangesSinceResponse {
    fn clear(&mut self) {
        self.current_change_number = ::std::option::Option::None;
        self.since_change_number = ::std::option::Option::None;
        self.force_full_update = ::std::option::Option::None;
        self.package_changes.clear();
        self.app_changes.clear();
        self.force_full_app_update = ::std::option::Option::None;
        self.force_full_package_update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSChangesSinceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSChangesSinceResponse {
}

/// Nested message and enums of message `CMsgClientPICSChangesSinceResponse`
pub mod cmsg_client_picschanges_since_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct PackageChange {
        // message fields
        packageid: ::std::option::Option<u32>,
        change_number: ::std::option::Option<u32>,
        needs_token: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PackageChange {
        fn default() -> &'a PackageChange {
            <PackageChange as ::protobuf::Message>::default_instance()
        }
    }

    impl PackageChange {
        pub fn new() -> PackageChange {
            ::std::default::Default::default()
        }

        // optional uint32 packageid = 1;

        pub fn get_packageid(&self) -> u32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: u32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn get_change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional bool needs_token = 3;

        pub fn get_needs_token(&self) -> bool {
            self.needs_token.unwrap_or(false)
        }

        pub fn clear_needs_token(&mut self) {
            self.needs_token = ::std::option::Option::None;
        }

        pub fn has_needs_token(&self) -> bool {
            self.needs_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_needs_token(&mut self, v: bool) {
            self.needs_token = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PackageChange {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.needs_token = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.needs_token {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.packageid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.needs_token {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PackageChange {
            PackageChange::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "packageid",
                    |m: &PackageChange| { &m.packageid },
                    |m: &mut PackageChange| { &mut m.packageid },
                    PackageChange::get_packageid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "change_number",
                    |m: &PackageChange| { &m.change_number },
                    |m: &mut PackageChange| { &mut m.change_number },
                    PackageChange::get_change_number,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "needs_token",
                    |m: &PackageChange| { &m.needs_token },
                    |m: &mut PackageChange| { &mut m.needs_token },
                    PackageChange::get_needs_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PackageChange>(
                    "CMsgClientPICSChangesSinceResponse.PackageChange",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PackageChange {
            static instance: ::protobuf::rt::Lazy<PackageChange> = ::protobuf::rt::Lazy::INIT;
            instance.get(PackageChange::new)
        }
    }

    impl ::protobuf::Clear for PackageChange {
        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.needs_token = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PackageChange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PackageChange {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct AppChange {
        // message fields
        appid: ::std::option::Option<u32>,
        change_number: ::std::option::Option<u32>,
        needs_token: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a AppChange {
        fn default() -> &'a AppChange {
            <AppChange as ::protobuf::Message>::default_instance()
        }
    }

    impl AppChange {
        pub fn new() -> AppChange {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn get_change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional bool needs_token = 3;

        pub fn get_needs_token(&self) -> bool {
            self.needs_token.unwrap_or(false)
        }

        pub fn clear_needs_token(&mut self) {
            self.needs_token = ::std::option::Option::None;
        }

        pub fn has_needs_token(&self) -> bool {
            self.needs_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_needs_token(&mut self, v: bool) {
            self.needs_token = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AppChange {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.needs_token = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.needs_token {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.needs_token {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> AppChange {
            AppChange::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &AppChange| { &m.appid },
                    |m: &mut AppChange| { &mut m.appid },
                    AppChange::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "change_number",
                    |m: &AppChange| { &m.change_number },
                    |m: &mut AppChange| { &mut m.change_number },
                    AppChange::get_change_number,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "needs_token",
                    |m: &AppChange| { &m.needs_token },
                    |m: &mut AppChange| { &mut m.needs_token },
                    AppChange::get_needs_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppChange>(
                    "CMsgClientPICSChangesSinceResponse.AppChange",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static AppChange {
            static instance: ::protobuf::rt::Lazy<AppChange> = ::protobuf::rt::Lazy::INIT;
            instance.get(AppChange::new)
        }
    }

    impl ::protobuf::Clear for AppChange {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.needs_token = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for AppChange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppChange {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSProductInfoRequest {
    // message fields
    pub packages: ::protobuf::RepeatedField<cmsg_client_picsproduct_info_request::PackageInfo>,
    pub apps: ::protobuf::RepeatedField<cmsg_client_picsproduct_info_request::AppInfo>,
    meta_data_only: ::std::option::Option<bool>,
    num_prev_failed: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSProductInfoRequest {
    fn default() -> &'a CMsgClientPICSProductInfoRequest {
        <CMsgClientPICSProductInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSProductInfoRequest {
    pub fn new() -> CMsgClientPICSProductInfoRequest {
        ::std::default::Default::default()
    }

    // optional bool meta_data_only = 3;

    pub fn get_meta_data_only(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }

    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }

    // optional uint32 num_prev_failed = 4;

    pub fn get_num_prev_failed(&self) -> u32 {
        self.num_prev_failed.unwrap_or(0)
    }

    pub fn clear_num_prev_failed(&mut self) {
        self.num_prev_failed = ::std::option::Option::None;
    }

    pub fn has_num_prev_failed(&self) -> bool {
        self.num_prev_failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_prev_failed(&mut self, v: u32) {
        self.num_prev_failed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.packages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.packages)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.apps)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.meta_data_only = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_prev_failed = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.packages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.meta_data_only {
            my_size += 2;
        }
        if let Some(v) = self.num_prev_failed {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.packages {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.meta_data_only {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.num_prev_failed {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSProductInfoRequest {
        CMsgClientPICSProductInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_picsproduct_info_request::PackageInfo>>(
                "packages",
                |m: &CMsgClientPICSProductInfoRequest| { &m.packages },
                |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.packages },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_picsproduct_info_request::AppInfo>>(
                "apps",
                |m: &CMsgClientPICSProductInfoRequest| { &m.apps },
                |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "meta_data_only",
                |m: &CMsgClientPICSProductInfoRequest| { &m.meta_data_only },
                |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.meta_data_only },
                CMsgClientPICSProductInfoRequest::get_meta_data_only,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "num_prev_failed",
                |m: &CMsgClientPICSProductInfoRequest| { &m.num_prev_failed },
                |m: &mut CMsgClientPICSProductInfoRequest| { &mut m.num_prev_failed },
                CMsgClientPICSProductInfoRequest::get_num_prev_failed,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSProductInfoRequest>(
                "CMsgClientPICSProductInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSProductInfoRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientPICSProductInfoRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPICSProductInfoRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoRequest {
    fn clear(&mut self) {
        self.packages.clear();
        self.apps.clear();
        self.meta_data_only = ::std::option::Option::None;
        self.num_prev_failed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSProductInfoRequest {
}

/// Nested message and enums of message `CMsgClientPICSProductInfoRequest`
pub mod cmsg_client_picsproduct_info_request {
    #[derive(PartialEq,Clone,Default)]
    pub struct AppInfo {
        // message fields
        appid: ::std::option::Option<u32>,
        access_token: ::std::option::Option<u64>,
        only_public: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a AppInfo {
        fn default() -> &'a AppInfo {
            <AppInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl AppInfo {
        pub fn new() -> AppInfo {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 2;

        pub fn get_access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }

        // optional bool only_public = 3;

        pub fn get_only_public(&self) -> bool {
            self.only_public.unwrap_or(false)
        }

        pub fn clear_only_public(&mut self) {
            self.only_public = ::std::option::Option::None;
        }

        pub fn has_only_public(&self) -> bool {
            self.only_public.is_some()
        }

        // Param is passed by value, moved
        pub fn set_only_public(&mut self, v: bool) {
            self.only_public = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AppInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.only_public = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.access_token {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.only_public {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.only_public {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> AppInfo {
            AppInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &AppInfo| { &m.appid },
                    |m: &mut AppInfo| { &mut m.appid },
                    AppInfo::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "access_token",
                    |m: &AppInfo| { &m.access_token },
                    |m: &mut AppInfo| { &mut m.access_token },
                    AppInfo::get_access_token,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "only_public",
                    |m: &AppInfo| { &m.only_public },
                    |m: &mut AppInfo| { &mut m.only_public },
                    AppInfo::get_only_public,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppInfo>(
                    "CMsgClientPICSProductInfoRequest.AppInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static AppInfo {
            static instance: ::protobuf::rt::Lazy<AppInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(AppInfo::new)
        }
    }

    impl ::protobuf::Clear for AppInfo {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.only_public = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for AppInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppInfo {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct PackageInfo {
        // message fields
        packageid: ::std::option::Option<u32>,
        access_token: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PackageInfo {
        fn default() -> &'a PackageInfo {
            <PackageInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl PackageInfo {
        pub fn new() -> PackageInfo {
            ::std::default::Default::default()
        }

        // optional uint32 packageid = 1;

        pub fn get_packageid(&self) -> u32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: u32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 2;

        pub fn get_access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PackageInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.access_token {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.packageid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PackageInfo {
            PackageInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "packageid",
                    |m: &PackageInfo| { &m.packageid },
                    |m: &mut PackageInfo| { &mut m.packageid },
                    PackageInfo::get_packageid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "access_token",
                    |m: &PackageInfo| { &m.access_token },
                    |m: &mut PackageInfo| { &mut m.access_token },
                    PackageInfo::get_access_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PackageInfo>(
                    "CMsgClientPICSProductInfoRequest.PackageInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PackageInfo {
            static instance: ::protobuf::rt::Lazy<PackageInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(PackageInfo::new)
        }
    }

    impl ::protobuf::Clear for PackageInfo {
        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PackageInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PackageInfo {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSProductInfoResponse {
    // message fields
    pub apps: ::protobuf::RepeatedField<cmsg_client_picsproduct_info_response::AppInfo>,
    pub unknown_appids: ::std::vec::Vec<u32>,
    pub packages: ::protobuf::RepeatedField<cmsg_client_picsproduct_info_response::PackageInfo>,
    pub unknown_packageids: ::std::vec::Vec<u32>,
    meta_data_only: ::std::option::Option<bool>,
    response_pending: ::std::option::Option<bool>,
    http_min_size: ::std::option::Option<u32>,
    http_host: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSProductInfoResponse {
    fn default() -> &'a CMsgClientPICSProductInfoResponse {
        <CMsgClientPICSProductInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSProductInfoResponse {
    pub fn new() -> CMsgClientPICSProductInfoResponse {
        ::std::default::Default::default()
    }

    // optional bool meta_data_only = 5;

    pub fn get_meta_data_only(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }

    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }

    // optional bool response_pending = 6;

    pub fn get_response_pending(&self) -> bool {
        self.response_pending.unwrap_or(false)
    }

    pub fn clear_response_pending(&mut self) {
        self.response_pending = ::std::option::Option::None;
    }

    pub fn has_response_pending(&self) -> bool {
        self.response_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_pending(&mut self, v: bool) {
        self.response_pending = ::std::option::Option::Some(v);
    }

    // optional uint32 http_min_size = 7;

    pub fn get_http_min_size(&self) -> u32 {
        self.http_min_size.unwrap_or(0)
    }

    pub fn clear_http_min_size(&mut self) {
        self.http_min_size = ::std::option::Option::None;
    }

    pub fn has_http_min_size(&self) -> bool {
        self.http_min_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_min_size(&mut self, v: u32) {
        self.http_min_size = ::std::option::Option::Some(v);
    }

    // optional string http_host = 8;

    pub fn get_http_host(&self) -> &str {
        match self.http_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_http_host(&mut self) {
        self.http_host.clear();
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host(&mut self) -> &mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host.set_default();
        }
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.packages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.apps)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.unknown_appids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.packages)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.unknown_packageids)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.meta_data_only = ::std::option::Option::Some(is.read_bool()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response_pending = ::std::option::Option::Some(is.read_bool()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.http_min_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unknown_appids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.packages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unknown_packageids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.meta_data_only {
            my_size += 2;
        }
        if let Some(v) = self.response_pending {
            my_size += 2;
        }
        if let Some(v) = self.http_min_size {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.http_host.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.unknown_appids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.packages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.unknown_packageids {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.meta_data_only {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.response_pending {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.http_min_size {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.http_host.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSProductInfoResponse {
        CMsgClientPICSProductInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_picsproduct_info_response::AppInfo>>(
                "apps",
                |m: &CMsgClientPICSProductInfoResponse| { &m.apps },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "unknown_appids",
                |m: &CMsgClientPICSProductInfoResponse| { &m.unknown_appids },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.unknown_appids },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_picsproduct_info_response::PackageInfo>>(
                "packages",
                |m: &CMsgClientPICSProductInfoResponse| { &m.packages },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.packages },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "unknown_packageids",
                |m: &CMsgClientPICSProductInfoResponse| { &m.unknown_packageids },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.unknown_packageids },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "meta_data_only",
                |m: &CMsgClientPICSProductInfoResponse| { &m.meta_data_only },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.meta_data_only },
                CMsgClientPICSProductInfoResponse::get_meta_data_only,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "response_pending",
                |m: &CMsgClientPICSProductInfoResponse| { &m.response_pending },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.response_pending },
                CMsgClientPICSProductInfoResponse::get_response_pending,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "http_min_size",
                |m: &CMsgClientPICSProductInfoResponse| { &m.http_min_size },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.http_min_size },
                CMsgClientPICSProductInfoResponse::get_http_min_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "http_host",
                |m: &CMsgClientPICSProductInfoResponse| { &m.http_host },
                |m: &mut CMsgClientPICSProductInfoResponse| { &mut m.http_host },
                CMsgClientPICSProductInfoResponse::get_http_host,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSProductInfoResponse>(
                "CMsgClientPICSProductInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSProductInfoResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientPICSProductInfoResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPICSProductInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoResponse {
    fn clear(&mut self) {
        self.apps.clear();
        self.unknown_appids.clear();
        self.packages.clear();
        self.unknown_packageids.clear();
        self.meta_data_only = ::std::option::Option::None;
        self.response_pending = ::std::option::Option::None;
        self.http_min_size = ::std::option::Option::None;
        self.http_host.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSProductInfoResponse {
}

/// Nested message and enums of message `CMsgClientPICSProductInfoResponse`
pub mod cmsg_client_picsproduct_info_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct AppInfo {
        // message fields
        appid: ::std::option::Option<u32>,
        change_number: ::std::option::Option<u32>,
        missing_token: ::std::option::Option<bool>,
        sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        buffer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        only_public: ::std::option::Option<bool>,
        size: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a AppInfo {
        fn default() -> &'a AppInfo {
            <AppInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl AppInfo {
        pub fn new() -> AppInfo {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn get_change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional bool missing_token = 3;

        pub fn get_missing_token(&self) -> bool {
            self.missing_token.unwrap_or(false)
        }

        pub fn clear_missing_token(&mut self) {
            self.missing_token = ::std::option::Option::None;
        }

        pub fn has_missing_token(&self) -> bool {
            self.missing_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_missing_token(&mut self, v: bool) {
            self.missing_token = ::std::option::Option::Some(v);
        }

        // optional bytes sha = 4;

        pub fn get_sha(&self) -> &[u8] {
            match self.sha.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha(&mut self) {
            self.sha.clear();
        }

        pub fn has_sha(&self) -> bool {
            self.sha.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha.is_none() {
                self.sha.set_default();
            }
            self.sha.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
            self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes buffer = 5;

        pub fn get_buffer(&self) -> &[u8] {
            match self.buffer.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_buffer(&mut self) {
            self.buffer.clear();
        }

        pub fn has_buffer(&self) -> bool {
            self.buffer.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
            self.buffer = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.buffer.is_none() {
                self.buffer.set_default();
            }
            self.buffer.as_mut().unwrap()
        }

        // Take field
        pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
            self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bool only_public = 6;

        pub fn get_only_public(&self) -> bool {
            self.only_public.unwrap_or(false)
        }

        pub fn clear_only_public(&mut self) {
            self.only_public = ::std::option::Option::None;
        }

        pub fn has_only_public(&self) -> bool {
            self.only_public.is_some()
        }

        // Param is passed by value, moved
        pub fn set_only_public(&mut self, v: bool) {
            self.only_public = ::std::option::Option::Some(v);
        }

        // optional uint32 size = 7;

        pub fn get_size(&self) -> u32 {
            self.size.unwrap_or(0)
        }

        pub fn clear_size(&mut self) {
            self.size = ::std::option::Option::None;
        }

        pub fn has_size(&self) -> bool {
            self.size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size(&mut self, v: u32) {
            self.size = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AppInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.missing_token = ::std::option::Option::Some(is.read_bool()?);
                    },
                    4 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha)?;
                    },
                    5 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buffer)?;
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.only_public = ::std::option::Option::Some(is.read_bool()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.missing_token {
                my_size += 2;
            }
            if let Some(v) = self.sha.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            if let Some(v) = self.buffer.as_ref() {
                my_size += ::protobuf::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.only_public {
                my_size += 2;
            }
            if let Some(v) = self.size {
                my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.missing_token {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.sha.as_ref() {
                os.write_bytes(4, v)?;
            }
            if let Some(v) = self.buffer.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.only_public {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.size {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> AppInfo {
            AppInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &AppInfo| { &m.appid },
                    |m: &mut AppInfo| { &mut m.appid },
                    AppInfo::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "change_number",
                    |m: &AppInfo| { &m.change_number },
                    |m: &mut AppInfo| { &mut m.change_number },
                    AppInfo::get_change_number,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "missing_token",
                    |m: &AppInfo| { &m.missing_token },
                    |m: &mut AppInfo| { &mut m.missing_token },
                    AppInfo::get_missing_token,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "sha",
                    |m: &AppInfo| { &m.sha },
                    |m: &mut AppInfo| { &mut m.sha },
                    AppInfo::get_sha,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "buffer",
                    |m: &AppInfo| { &m.buffer },
                    |m: &mut AppInfo| { &mut m.buffer },
                    AppInfo::get_buffer,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "only_public",
                    |m: &AppInfo| { &m.only_public },
                    |m: &mut AppInfo| { &mut m.only_public },
                    AppInfo::get_only_public,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "size",
                    |m: &AppInfo| { &m.size },
                    |m: &mut AppInfo| { &mut m.size },
                    AppInfo::get_size,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppInfo>(
                    "CMsgClientPICSProductInfoResponse.AppInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static AppInfo {
            static instance: ::protobuf::rt::Lazy<AppInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(AppInfo::new)
        }
    }

    impl ::protobuf::Clear for AppInfo {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.missing_token = ::std::option::Option::None;
            self.sha.clear();
            self.buffer.clear();
            self.only_public = ::std::option::Option::None;
            self.size = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for AppInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppInfo {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct PackageInfo {
        // message fields
        packageid: ::std::option::Option<u32>,
        change_number: ::std::option::Option<u32>,
        missing_token: ::std::option::Option<bool>,
        sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        buffer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        size: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PackageInfo {
        fn default() -> &'a PackageInfo {
            <PackageInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl PackageInfo {
        pub fn new() -> PackageInfo {
            ::std::default::Default::default()
        }

        // optional uint32 packageid = 1;

        pub fn get_packageid(&self) -> u32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: u32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional uint32 change_number = 2;

        pub fn get_change_number(&self) -> u32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: u32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional bool missing_token = 3;

        pub fn get_missing_token(&self) -> bool {
            self.missing_token.unwrap_or(false)
        }

        pub fn clear_missing_token(&mut self) {
            self.missing_token = ::std::option::Option::None;
        }

        pub fn has_missing_token(&self) -> bool {
            self.missing_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_missing_token(&mut self, v: bool) {
            self.missing_token = ::std::option::Option::Some(v);
        }

        // optional bytes sha = 4;

        pub fn get_sha(&self) -> &[u8] {
            match self.sha.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha(&mut self) {
            self.sha.clear();
        }

        pub fn has_sha(&self) -> bool {
            self.sha.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha.is_none() {
                self.sha.set_default();
            }
            self.sha.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
            self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes buffer = 5;

        pub fn get_buffer(&self) -> &[u8] {
            match self.buffer.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_buffer(&mut self) {
            self.buffer.clear();
        }

        pub fn has_buffer(&self) -> bool {
            self.buffer.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
            self.buffer = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_buffer(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.buffer.is_none() {
                self.buffer.set_default();
            }
            self.buffer.as_mut().unwrap()
        }

        // Take field
        pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
            self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 size = 6;

        pub fn get_size(&self) -> u32 {
            self.size.unwrap_or(0)
        }

        pub fn clear_size(&mut self) {
            self.size = ::std::option::Option::None;
        }

        pub fn has_size(&self) -> bool {
            self.size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size(&mut self, v: u32) {
            self.size = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PackageInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.change_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.missing_token = ::std::option::Option::Some(is.read_bool()?);
                    },
                    4 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha)?;
                    },
                    5 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buffer)?;
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.missing_token {
                my_size += 2;
            }
            if let Some(v) = self.sha.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            if let Some(v) = self.buffer.as_ref() {
                my_size += ::protobuf::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.size {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.packageid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.missing_token {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.sha.as_ref() {
                os.write_bytes(4, v)?;
            }
            if let Some(v) = self.buffer.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.size {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PackageInfo {
            PackageInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "packageid",
                    |m: &PackageInfo| { &m.packageid },
                    |m: &mut PackageInfo| { &mut m.packageid },
                    PackageInfo::get_packageid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "change_number",
                    |m: &PackageInfo| { &m.change_number },
                    |m: &mut PackageInfo| { &mut m.change_number },
                    PackageInfo::get_change_number,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "missing_token",
                    |m: &PackageInfo| { &m.missing_token },
                    |m: &mut PackageInfo| { &mut m.missing_token },
                    PackageInfo::get_missing_token,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "sha",
                    |m: &PackageInfo| { &m.sha },
                    |m: &mut PackageInfo| { &mut m.sha },
                    PackageInfo::get_sha,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "buffer",
                    |m: &PackageInfo| { &m.buffer },
                    |m: &mut PackageInfo| { &mut m.buffer },
                    PackageInfo::get_buffer,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "size",
                    |m: &PackageInfo| { &m.size },
                    |m: &mut PackageInfo| { &mut m.size },
                    PackageInfo::get_size,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PackageInfo>(
                    "CMsgClientPICSProductInfoResponse.PackageInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PackageInfo {
            static instance: ::protobuf::rt::Lazy<PackageInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(PackageInfo::new)
        }
    }

    impl ::protobuf::Clear for PackageInfo {
        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.missing_token = ::std::option::Option::None;
            self.sha.clear();
            self.buffer.clear();
            self.size = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PackageInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PackageInfo {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSAccessTokenRequest {
    // message fields
    pub packageids: ::std::vec::Vec<u32>,
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSAccessTokenRequest {
    fn default() -> &'a CMsgClientPICSAccessTokenRequest {
        <CMsgClientPICSAccessTokenRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSAccessTokenRequest {
    pub fn new() -> CMsgClientPICSAccessTokenRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.packageids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.packageids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.appids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.packageids {
            os.write_uint32(1, *v)?;
        };
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSAccessTokenRequest {
        CMsgClientPICSAccessTokenRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "packageids",
                |m: &CMsgClientPICSAccessTokenRequest| { &m.packageids },
                |m: &mut CMsgClientPICSAccessTokenRequest| { &mut m.packageids },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "appids",
                |m: &CMsgClientPICSAccessTokenRequest| { &m.appids },
                |m: &mut CMsgClientPICSAccessTokenRequest| { &mut m.appids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSAccessTokenRequest>(
                "CMsgClientPICSAccessTokenRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSAccessTokenRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientPICSAccessTokenRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPICSAccessTokenRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSAccessTokenRequest {
    fn clear(&mut self) {
        self.packageids.clear();
        self.appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSAccessTokenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSAccessTokenRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPICSAccessTokenResponse {
    // message fields
    pub package_access_tokens: ::protobuf::RepeatedField<cmsg_client_picsaccess_token_response::PackageToken>,
    pub package_denied_tokens: ::std::vec::Vec<u32>,
    pub app_access_tokens: ::protobuf::RepeatedField<cmsg_client_picsaccess_token_response::AppToken>,
    pub app_denied_tokens: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPICSAccessTokenResponse {
    fn default() -> &'a CMsgClientPICSAccessTokenResponse {
        <CMsgClientPICSAccessTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPICSAccessTokenResponse {
    pub fn new() -> CMsgClientPICSAccessTokenResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.package_access_tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_access_tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.package_access_tokens)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.package_denied_tokens)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.app_access_tokens)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.app_denied_tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.package_access_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.package_denied_tokens {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.app_access_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.app_denied_tokens {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.package_access_tokens {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.package_denied_tokens {
            os.write_uint32(2, *v)?;
        };
        for v in &self.app_access_tokens {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.app_denied_tokens {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPICSAccessTokenResponse {
        CMsgClientPICSAccessTokenResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_picsaccess_token_response::PackageToken>>(
                "package_access_tokens",
                |m: &CMsgClientPICSAccessTokenResponse| { &m.package_access_tokens },
                |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.package_access_tokens },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "package_denied_tokens",
                |m: &CMsgClientPICSAccessTokenResponse| { &m.package_denied_tokens },
                |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.package_denied_tokens },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_picsaccess_token_response::AppToken>>(
                "app_access_tokens",
                |m: &CMsgClientPICSAccessTokenResponse| { &m.app_access_tokens },
                |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.app_access_tokens },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "app_denied_tokens",
                |m: &CMsgClientPICSAccessTokenResponse| { &m.app_denied_tokens },
                |m: &mut CMsgClientPICSAccessTokenResponse| { &mut m.app_denied_tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSAccessTokenResponse>(
                "CMsgClientPICSAccessTokenResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPICSAccessTokenResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientPICSAccessTokenResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPICSAccessTokenResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientPICSAccessTokenResponse {
    fn clear(&mut self) {
        self.package_access_tokens.clear();
        self.package_denied_tokens.clear();
        self.app_access_tokens.clear();
        self.app_denied_tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPICSAccessTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPICSAccessTokenResponse {
}

/// Nested message and enums of message `CMsgClientPICSAccessTokenResponse`
pub mod cmsg_client_picsaccess_token_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct PackageToken {
        // message fields
        packageid: ::std::option::Option<u32>,
        access_token: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PackageToken {
        fn default() -> &'a PackageToken {
            <PackageToken as ::protobuf::Message>::default_instance()
        }
    }

    impl PackageToken {
        pub fn new() -> PackageToken {
            ::std::default::Default::default()
        }

        // optional uint32 packageid = 1;

        pub fn get_packageid(&self) -> u32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: u32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 2;

        pub fn get_access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PackageToken {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.access_token {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.packageid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PackageToken {
            PackageToken::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "packageid",
                    |m: &PackageToken| { &m.packageid },
                    |m: &mut PackageToken| { &mut m.packageid },
                    PackageToken::get_packageid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "access_token",
                    |m: &PackageToken| { &m.access_token },
                    |m: &mut PackageToken| { &mut m.access_token },
                    PackageToken::get_access_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PackageToken>(
                    "CMsgClientPICSAccessTokenResponse.PackageToken",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PackageToken {
            static instance: ::protobuf::rt::Lazy<PackageToken> = ::protobuf::rt::Lazy::INIT;
            instance.get(PackageToken::new)
        }
    }

    impl ::protobuf::Clear for PackageToken {
        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PackageToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PackageToken {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct AppToken {
        // message fields
        appid: ::std::option::Option<u32>,
        access_token: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a AppToken {
        fn default() -> &'a AppToken {
            <AppToken as ::protobuf::Message>::default_instance()
        }
    }

    impl AppToken {
        pub fn new() -> AppToken {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 2;

        pub fn get_access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AppToken {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.access_token {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> AppToken {
            AppToken::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &AppToken| { &m.appid },
                    |m: &mut AppToken| { &mut m.appid },
                    AppToken::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "access_token",
                    |m: &AppToken| { &m.access_token },
                    |m: &mut AppToken| { &mut m.access_token },
                    AppToken::get_access_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppToken>(
                    "CMsgClientPICSAccessTokenResponse.AppToken",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static AppToken {
            static instance: ::protobuf::rt::Lazy<AppToken> = ::protobuf::rt::Lazy::INIT;
            instance.get(AppToken::new)
        }
    }

    impl ::protobuf::Clear for AppToken {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for AppToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppToken {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetUGCDetails {
    // message fields
    hcontent: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetUGCDetails {
    fn default() -> &'a CMsgClientUFSGetUGCDetails {
        <CMsgClientUFSGetUGCDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetUGCDetails {
    pub fn new() -> CMsgClientUFSGetUGCDetails {
        ::std::default::Default::default()
    }

    // optional fixed64 hcontent = 1;

    pub fn get_hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSGetUGCDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hcontent {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hcontent {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetUGCDetails {
        CMsgClientUFSGetUGCDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "hcontent",
                |m: &CMsgClientUFSGetUGCDetails| { &m.hcontent },
                |m: &mut CMsgClientUFSGetUGCDetails| { &mut m.hcontent },
                CMsgClientUFSGetUGCDetails::get_hcontent,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetUGCDetails>(
                "CMsgClientUFSGetUGCDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetUGCDetails {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSGetUGCDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSGetUGCDetails::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetUGCDetails {
    fn clear(&mut self) {
        self.hcontent = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetUGCDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetUGCDetails {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetUGCDetailsResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    url: ::protobuf::SingularField<::std::string::String>,
    app_id: ::std::option::Option<u32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    steamid_creator: ::std::option::Option<u64>,
    file_size: ::std::option::Option<u32>,
    compressed_file_size: ::std::option::Option<u32>,
    rangecheck_host: ::protobuf::SingularField<::std::string::String>,
    file_encoded_sha1: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetUGCDetailsResponse {
    fn default() -> &'a CMsgClientUFSGetUGCDetailsResponse {
        <CMsgClientUFSGetUGCDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetUGCDetailsResponse {
    pub fn new() -> CMsgClientUFSGetUGCDetailsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 3;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 steamid_creator = 5;

    pub fn get_steamid_creator(&self) -> u64 {
        self.steamid_creator.unwrap_or(0)
    }

    pub fn clear_steamid_creator(&mut self) {
        self.steamid_creator = ::std::option::Option::None;
    }

    pub fn has_steamid_creator(&self) -> bool {
        self.steamid_creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_creator(&mut self, v: u64) {
        self.steamid_creator = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 6;

    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 compressed_file_size = 7;

    pub fn get_compressed_file_size(&self) -> u32 {
        self.compressed_file_size.unwrap_or(0)
    }

    pub fn clear_compressed_file_size(&mut self) {
        self.compressed_file_size = ::std::option::Option::None;
    }

    pub fn has_compressed_file_size(&self) -> bool {
        self.compressed_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressed_file_size(&mut self, v: u32) {
        self.compressed_file_size = ::std::option::Option::Some(v);
    }

    // optional string rangecheck_host = 8;

    pub fn get_rangecheck_host(&self) -> &str {
        match self.rangecheck_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rangecheck_host(&mut self) {
        self.rangecheck_host.clear();
    }

    pub fn has_rangecheck_host(&self) -> bool {
        self.rangecheck_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rangecheck_host(&mut self, v: ::std::string::String) {
        self.rangecheck_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rangecheck_host(&mut self) -> &mut ::std::string::String {
        if self.rangecheck_host.is_none() {
            self.rangecheck_host.set_default();
        }
        self.rangecheck_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_rangecheck_host(&mut self) -> ::std::string::String {
        self.rangecheck_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_encoded_sha1 = 9;

    pub fn get_file_encoded_sha1(&self) -> &str {
        match self.file_encoded_sha1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_encoded_sha1(&mut self) {
        self.file_encoded_sha1.clear();
    }

    pub fn has_file_encoded_sha1(&self) -> bool {
        self.file_encoded_sha1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_encoded_sha1(&mut self, v: ::std::string::String) {
        self.file_encoded_sha1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_encoded_sha1(&mut self) -> &mut ::std::string::String {
        if self.file_encoded_sha1.is_none() {
            self.file_encoded_sha1.set_default();
        }
        self.file_encoded_sha1.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_encoded_sha1(&mut self) -> ::std::string::String {
        self.file_encoded_sha1.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSGetUGCDetailsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_creator = ::std::option::Option::Some(is.read_fixed64()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.compressed_file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rangecheck_host)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_encoded_sha1)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.steamid_creator {
            my_size += 9;
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.compressed_file_size {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rangecheck_host.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.file_encoded_sha1.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.steamid_creator {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.compressed_file_size {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.rangecheck_host.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.file_encoded_sha1.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetUGCDetailsResponse {
        CMsgClientUFSGetUGCDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.eresult },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.eresult },
                CMsgClientUFSGetUGCDetailsResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "url",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.url },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.url },
                CMsgClientUFSGetUGCDetailsResponse::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.app_id },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.app_id },
                CMsgClientUFSGetUGCDetailsResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.filename },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.filename },
                CMsgClientUFSGetUGCDetailsResponse::get_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_creator",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.steamid_creator },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.steamid_creator },
                CMsgClientUFSGetUGCDetailsResponse::get_steamid_creator,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "file_size",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.file_size },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.file_size },
                CMsgClientUFSGetUGCDetailsResponse::get_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "compressed_file_size",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.compressed_file_size },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.compressed_file_size },
                CMsgClientUFSGetUGCDetailsResponse::get_compressed_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "rangecheck_host",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.rangecheck_host },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.rangecheck_host },
                CMsgClientUFSGetUGCDetailsResponse::get_rangecheck_host,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_encoded_sha1",
                |m: &CMsgClientUFSGetUGCDetailsResponse| { &m.file_encoded_sha1 },
                |m: &mut CMsgClientUFSGetUGCDetailsResponse| { &mut m.file_encoded_sha1 },
                CMsgClientUFSGetUGCDetailsResponse::get_file_encoded_sha1,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetUGCDetailsResponse>(
                "CMsgClientUFSGetUGCDetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetUGCDetailsResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSGetUGCDetailsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSGetUGCDetailsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetUGCDetailsResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.url.clear();
        self.app_id = ::std::option::Option::None;
        self.filename.clear();
        self.steamid_creator = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.compressed_file_size = ::std::option::Option::None;
        self.rangecheck_host.clear();
        self.file_encoded_sha1.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetUGCDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetUGCDetailsResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetSingleFileInfo {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetSingleFileInfo {
    fn default() -> &'a CMsgClientUFSGetSingleFileInfo {
        <CMsgClientUFSGetSingleFileInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetSingleFileInfo {
    pub fn new() -> CMsgClientUFSGetSingleFileInfo {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSGetSingleFileInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetSingleFileInfo {
        CMsgClientUFSGetSingleFileInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUFSGetSingleFileInfo| { &m.app_id },
                |m: &mut CMsgClientUFSGetSingleFileInfo| { &mut m.app_id },
                CMsgClientUFSGetSingleFileInfo::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_name",
                |m: &CMsgClientUFSGetSingleFileInfo| { &m.file_name },
                |m: &mut CMsgClientUFSGetSingleFileInfo| { &mut m.file_name },
                CMsgClientUFSGetSingleFileInfo::get_file_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetSingleFileInfo>(
                "CMsgClientUFSGetSingleFileInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetSingleFileInfo {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSGetSingleFileInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSGetSingleFileInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetSingleFileInfo {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetSingleFileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetSingleFileInfo {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSGetSingleFileInfoResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    raw_file_size: ::std::option::Option<u32>,
    is_explicit_delete: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSGetSingleFileInfoResponse {
    fn default() -> &'a CMsgClientUFSGetSingleFileInfoResponse {
        <CMsgClientUFSGetSingleFileInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSGetSingleFileInfoResponse {
    pub fn new() -> CMsgClientUFSGetSingleFileInfoResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 3;

    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes sha_file = 4;

    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 time_stamp = 5;

    pub fn get_time_stamp(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_file_size = 6;

    pub fn get_raw_file_size(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }

    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    // optional bool is_explicit_delete = 7;

    pub fn get_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }

    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSGetSingleFileInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_stamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.raw_file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_explicit_delete = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.raw_file_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_explicit_delete {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.raw_file_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_explicit_delete {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSGetSingleFileInfoResponse {
        CMsgClientUFSGetSingleFileInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.eresult },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.eresult },
                CMsgClientUFSGetSingleFileInfoResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.app_id },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.app_id },
                CMsgClientUFSGetSingleFileInfoResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_name",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.file_name },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.file_name },
                CMsgClientUFSGetSingleFileInfoResponse::get_file_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sha_file",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.sha_file },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.sha_file },
                CMsgClientUFSGetSingleFileInfoResponse::get_sha_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "time_stamp",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.time_stamp },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.time_stamp },
                CMsgClientUFSGetSingleFileInfoResponse::get_time_stamp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "raw_file_size",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.raw_file_size },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.raw_file_size },
                CMsgClientUFSGetSingleFileInfoResponse::get_raw_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_explicit_delete",
                |m: &CMsgClientUFSGetSingleFileInfoResponse| { &m.is_explicit_delete },
                |m: &mut CMsgClientUFSGetSingleFileInfoResponse| { &mut m.is_explicit_delete },
                CMsgClientUFSGetSingleFileInfoResponse::get_is_explicit_delete,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetSingleFileInfoResponse>(
                "CMsgClientUFSGetSingleFileInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSGetSingleFileInfoResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSGetSingleFileInfoResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSGetSingleFileInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetSingleFileInfoResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.sha_file.clear();
        self.time_stamp = ::std::option::Option::None;
        self.raw_file_size = ::std::option::Option::None;
        self.is_explicit_delete = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetSingleFileInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSGetSingleFileInfoResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSShareFile {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSShareFile {
    fn default() -> &'a CMsgClientUFSShareFile {
        <CMsgClientUFSShareFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSShareFile {
    pub fn new() -> CMsgClientUFSShareFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUFSShareFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSShareFile {
        CMsgClientUFSShareFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUFSShareFile| { &m.app_id },
                |m: &mut CMsgClientUFSShareFile| { &mut m.app_id },
                CMsgClientUFSShareFile::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_name",
                |m: &CMsgClientUFSShareFile| { &m.file_name },
                |m: &mut CMsgClientUFSShareFile| { &mut m.file_name },
                CMsgClientUFSShareFile::get_file_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSShareFile>(
                "CMsgClientUFSShareFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSShareFile {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSShareFile> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSShareFile::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSShareFile {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSShareFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSShareFile {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUFSShareFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    hcontent: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUFSShareFileResponse {
    fn default() -> &'a CMsgClientUFSShareFileResponse {
        <CMsgClientUFSShareFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUFSShareFileResponse {
    pub fn new() -> CMsgClientUFSShareFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 hcontent = 2;

    pub fn get_hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUFSShareFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hcontent {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hcontent {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUFSShareFileResponse {
        CMsgClientUFSShareFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUFSShareFileResponse| { &m.eresult },
                |m: &mut CMsgClientUFSShareFileResponse| { &mut m.eresult },
                CMsgClientUFSShareFileResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "hcontent",
                |m: &CMsgClientUFSShareFileResponse| { &m.hcontent },
                |m: &mut CMsgClientUFSShareFileResponse| { &mut m.hcontent },
                CMsgClientUFSShareFileResponse::get_hcontent,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSShareFileResponse>(
                "CMsgClientUFSShareFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUFSShareFileResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUFSShareFileResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUFSShareFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUFSShareFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.hcontent = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUFSShareFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUFSShareFileResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetClanOfficers {
    // message fields
    steamid_clan: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetClanOfficers {
    fn default() -> &'a CMsgClientAMGetClanOfficers {
        <CMsgClientAMGetClanOfficers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetClanOfficers {
    pub fn new() -> CMsgClientAMGetClanOfficers {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_clan = 1;

    pub fn get_steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAMGetClanOfficers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_clan {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetClanOfficers {
        CMsgClientAMGetClanOfficers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_clan",
                |m: &CMsgClientAMGetClanOfficers| { &m.steamid_clan },
                |m: &mut CMsgClientAMGetClanOfficers| { &mut m.steamid_clan },
                CMsgClientAMGetClanOfficers::get_steamid_clan,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetClanOfficers>(
                "CMsgClientAMGetClanOfficers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetClanOfficers {
        static instance: ::protobuf::rt::Lazy<CMsgClientAMGetClanOfficers> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAMGetClanOfficers::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetClanOfficers {
    fn clear(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetClanOfficers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetClanOfficers {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetClanOfficersResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    steamid_clan: ::std::option::Option<u64>,
    officer_count: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetClanOfficersResponse {
    fn default() -> &'a CMsgClientAMGetClanOfficersResponse {
        <CMsgClientAMGetClanOfficersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetClanOfficersResponse {
    pub fn new() -> CMsgClientAMGetClanOfficersResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_clan = 2;

    pub fn get_steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    // optional int32 officer_count = 3;

    pub fn get_officer_count(&self) -> i32 {
        self.officer_count.unwrap_or(0)
    }

    pub fn clear_officer_count(&mut self) {
        self.officer_count = ::std::option::Option::None;
    }

    pub fn has_officer_count(&self) -> bool {
        self.officer_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_officer_count(&mut self, v: i32) {
        self.officer_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAMGetClanOfficersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.officer_count = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid_clan {
            my_size += 9;
        }
        if let Some(v) = self.officer_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.officer_count {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetClanOfficersResponse {
        CMsgClientAMGetClanOfficersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientAMGetClanOfficersResponse| { &m.eresult },
                |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.eresult },
                CMsgClientAMGetClanOfficersResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_clan",
                |m: &CMsgClientAMGetClanOfficersResponse| { &m.steamid_clan },
                |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.steamid_clan },
                CMsgClientAMGetClanOfficersResponse::get_steamid_clan,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "officer_count",
                |m: &CMsgClientAMGetClanOfficersResponse| { &m.officer_count },
                |m: &mut CMsgClientAMGetClanOfficersResponse| { &mut m.officer_count },
                CMsgClientAMGetClanOfficersResponse::get_officer_count,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetClanOfficersResponse>(
                "CMsgClientAMGetClanOfficersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetClanOfficersResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientAMGetClanOfficersResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAMGetClanOfficersResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetClanOfficersResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steamid_clan = ::std::option::Option::None;
        self.officer_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetClanOfficersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetClanOfficersResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistory {
    // message fields
    id_count: ::std::option::Option<i32>,
    pub Ids: ::protobuf::RepeatedField<cmsg_client_amget_persona_name_history::IdInstance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistory {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistory {
        <CMsgClientAMGetPersonaNameHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistory {
    pub fn new() -> CMsgClientAMGetPersonaNameHistory {
        ::std::default::Default::default()
    }

    // optional int32 id_count = 1;

    pub fn get_id_count(&self) -> i32 {
        self.id_count.unwrap_or(0)
    }

    pub fn clear_id_count(&mut self) {
        self.id_count = ::std::option::Option::None;
    }

    pub fn has_id_count(&self) -> bool {
        self.id_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id_count(&mut self, v: i32) {
        self.id_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistory {
    fn is_initialized(&self) -> bool {
        for v in &self.Ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.id_count = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.Ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.Ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id_count {
            os.write_int32(1, v)?;
        }
        for v in &self.Ids {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetPersonaNameHistory {
        CMsgClientAMGetPersonaNameHistory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "id_count",
                |m: &CMsgClientAMGetPersonaNameHistory| { &m.id_count },
                |m: &mut CMsgClientAMGetPersonaNameHistory| { &mut m.id_count },
                CMsgClientAMGetPersonaNameHistory::get_id_count,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_amget_persona_name_history::IdInstance>>(
                "Ids",
                |m: &CMsgClientAMGetPersonaNameHistory| { &m.Ids },
                |m: &mut CMsgClientAMGetPersonaNameHistory| { &mut m.Ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetPersonaNameHistory>(
                "CMsgClientAMGetPersonaNameHistory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistory {
        static instance: ::protobuf::rt::Lazy<CMsgClientAMGetPersonaNameHistory> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAMGetPersonaNameHistory::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistory {
    fn clear(&mut self) {
        self.id_count = ::std::option::Option::None;
        self.Ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistory {
}

/// Nested message and enums of message `CMsgClientAMGetPersonaNameHistory`
pub mod cmsg_client_amget_persona_name_history {
    #[derive(PartialEq,Clone,Default)]
    pub struct IdInstance {
        // message fields
        steamid: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a IdInstance {
        fn default() -> &'a IdInstance {
            <IdInstance as ::protobuf::Message>::default_instance()
        }
    }

    impl IdInstance {
        pub fn new() -> IdInstance {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn get_steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for IdInstance {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 9;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> IdInstance {
            IdInstance::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steamid",
                    |m: &IdInstance| { &m.steamid },
                    |m: &mut IdInstance| { &mut m.steamid },
                    IdInstance::get_steamid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IdInstance>(
                    "CMsgClientAMGetPersonaNameHistory.IdInstance",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static IdInstance {
            static instance: ::protobuf::rt::Lazy<IdInstance> = ::protobuf::rt::Lazy::INIT;
            instance.get(IdInstance::new)
        }
    }

    impl ::protobuf::Clear for IdInstance {
        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for IdInstance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for IdInstance {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistoryResponse {
    // message fields
    pub responses: ::protobuf::RepeatedField<cmsg_client_amget_persona_name_history_response::NameTableInstance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistoryResponse {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistoryResponse {
        <CMsgClientAMGetPersonaNameHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistoryResponse {
    pub fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.responses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.responses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        CMsgClientAMGetPersonaNameHistoryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_amget_persona_name_history_response::NameTableInstance>>(
                "responses",
                |m: &CMsgClientAMGetPersonaNameHistoryResponse| { &m.responses },
                |m: &mut CMsgClientAMGetPersonaNameHistoryResponse| { &mut m.responses },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetPersonaNameHistoryResponse>(
                "CMsgClientAMGetPersonaNameHistoryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistoryResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientAMGetPersonaNameHistoryResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAMGetPersonaNameHistoryResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistoryResponse {
    fn clear(&mut self) {
        self.responses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAMGetPersonaNameHistoryResponse {
}

/// Nested message and enums of message `CMsgClientAMGetPersonaNameHistoryResponse`
pub mod cmsg_client_amget_persona_name_history_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct NameTableInstance {
        // message fields
        eresult: ::std::option::Option<i32>,
        steamid: ::std::option::Option<u64>,
        pub names: ::protobuf::RepeatedField<name_table_instance::NameInstance>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a NameTableInstance {
        fn default() -> &'a NameTableInstance {
            <NameTableInstance as ::protobuf::Message>::default_instance()
        }
    }

    impl NameTableInstance {
        pub fn new() -> NameTableInstance {
            ::std::default::Default::default()
        }

        // optional int32 eresult = 1;

        pub fn get_eresult(&self) -> i32 {
            self.eresult.unwrap_or(2i32)
        }

        pub fn clear_eresult(&mut self) {
            self.eresult = ::std::option::Option::None;
        }

        pub fn has_eresult(&self) -> bool {
            self.eresult.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eresult(&mut self, v: i32) {
            self.eresult = ::std::option::Option::Some(v);
        }

        // optional fixed64 steamid = 2;

        pub fn get_steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for NameTableInstance {
        fn is_initialized(&self) -> bool {
            for v in &self.names {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.eresult = ::std::option::Option::Some(is.read_int32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    3 => {
                        ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.names)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.eresult {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.steamid {
                my_size += 9;
            }
            for value in &self.names {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.eresult {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.steamid {
                os.write_fixed64(2, v)?;
            }
            for v in &self.names {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> NameTableInstance {
            NameTableInstance::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "eresult",
                    |m: &NameTableInstance| { &m.eresult },
                    |m: &mut NameTableInstance| { &mut m.eresult },
                    NameTableInstance::get_eresult,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steamid",
                    |m: &NameTableInstance| { &m.steamid },
                    |m: &mut NameTableInstance| { &mut m.steamid },
                    NameTableInstance::get_steamid,
                ));
                fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<name_table_instance::NameInstance>>(
                    "names",
                    |m: &NameTableInstance| { &m.names },
                    |m: &mut NameTableInstance| { &mut m.names },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NameTableInstance>(
                    "CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static NameTableInstance {
            static instance: ::protobuf::rt::Lazy<NameTableInstance> = ::protobuf::rt::Lazy::INIT;
            instance.get(NameTableInstance::new)
        }
    }

    impl ::protobuf::Clear for NameTableInstance {
        fn clear(&mut self) {
            self.eresult = ::std::option::Option::None;
            self.steamid = ::std::option::Option::None;
            self.names.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for NameTableInstance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NameTableInstance {
    }

    /// Nested message and enums of message `NameTableInstance`
    pub mod name_table_instance {
        #[derive(PartialEq,Clone,Default)]
        pub struct NameInstance {
            // message fields
            name_since: ::std::option::Option<u32>,
            name: ::protobuf::SingularField<::std::string::String>,
            // special fields
            pub unknown_fields: ::protobuf::UnknownFields,
            pub cached_size: ::protobuf::rt::CachedSize,
        }

        impl<'a> ::std::default::Default for &'a NameInstance {
            fn default() -> &'a NameInstance {
                <NameInstance as ::protobuf::Message>::default_instance()
            }
        }

        impl NameInstance {
            pub fn new() -> NameInstance {
                ::std::default::Default::default()
            }

            // optional fixed32 name_since = 1;

            pub fn get_name_since(&self) -> u32 {
                self.name_since.unwrap_or(0)
            }

            pub fn clear_name_since(&mut self) {
                self.name_since = ::std::option::Option::None;
            }

            pub fn has_name_since(&self) -> bool {
                self.name_since.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name_since(&mut self, v: u32) {
                self.name_since = ::std::option::Option::Some(v);
            }

            // optional string name = 2;

            pub fn get_name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name.clear();
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::protobuf::SingularField::some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name.set_default();
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::protobuf::Message for NameInstance {
            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                while !is.eof()? {
                    let (field_number, wire_type) = is.read_tag_unpack()?;
                    match field_number {
                        1 => {
                            if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                                return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                            }
                            self.name_since = ::std::option::Option::Some(is.read_fixed32()?);
                        },
                        2 => {
                            ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                        },
                        _ => {
                            ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u32 {
                let mut my_size = 0;
                if let Some(v) = self.name_since {
                    my_size += 5;
                }
                if let Some(v) = self.name.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
                self.cached_size.set(my_size);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                if let Some(v) = self.name_since {
                    os.write_fixed32(1, v)?;
                }
                if let Some(v) = self.name.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.get_unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn get_cached_size(&self) -> u32 {
                self.cached_size.get()
            }

            fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
                &self.unknown_fields
            }

            fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
                &mut self.unknown_fields
            }

            fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
                Self::descriptor_static()
            }

            fn new() -> NameInstance {
                NameInstance::new()
            }

            fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
                descriptor.get(|| {
                    let mut fields = ::std::vec::Vec::new();
                    fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                        "name_since",
                        |m: &NameInstance| { &m.name_since },
                        |m: &mut NameInstance| { &mut m.name_since },
                        NameInstance::get_name_since,
                    ));
                    fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                        "name",
                        |m: &NameInstance| { &m.name },
                        |m: &mut NameInstance| { &mut m.name },
                        NameInstance::get_name,
                    ));
                    ::protobuf::reflect::MessageDescriptor::new::<NameInstance>(
                        "CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance",
                        fields,
                        super::super::file_descriptor_proto()
                    )
                })
            }

            fn default_instance() -> &'static NameInstance {
                static instance: ::protobuf::rt::Lazy<NameInstance> = ::protobuf::rt::Lazy::INIT;
                instance.get(NameInstance::new)
            }
        }

        impl ::protobuf::Clear for NameInstance {
            fn clear(&mut self) {
                self.name_since = ::std::option::Option::None;
                self.name.clear();
                self.unknown_fields.clear();
            }
        }

        impl ::std::fmt::Debug for NameInstance {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for NameInstance {
        }
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDeregisterWithServer {
    // message fields
    eservertype: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeregisterWithServer {
    fn default() -> &'a CMsgClientDeregisterWithServer {
        <CMsgClientDeregisterWithServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeregisterWithServer {
    pub fn new() -> CMsgClientDeregisterWithServer {
        ::std::default::Default::default()
    }

    // optional uint32 eservertype = 1;

    pub fn get_eservertype(&self) -> u32 {
        self.eservertype.unwrap_or(0)
    }

    pub fn clear_eservertype(&mut self) {
        self.eservertype = ::std::option::Option::None;
    }

    pub fn has_eservertype(&self) -> bool {
        self.eservertype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eservertype(&mut self, v: u32) {
        self.eservertype = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeregisterWithServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eservertype = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eservertype {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eservertype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDeregisterWithServer {
        CMsgClientDeregisterWithServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eservertype",
                |m: &CMsgClientDeregisterWithServer| { &m.eservertype },
                |m: &mut CMsgClientDeregisterWithServer| { &mut m.eservertype },
                CMsgClientDeregisterWithServer::get_eservertype,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientDeregisterWithServer| { &m.app_id },
                |m: &mut CMsgClientDeregisterWithServer| { &mut m.app_id },
                CMsgClientDeregisterWithServer::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDeregisterWithServer>(
                "CMsgClientDeregisterWithServer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDeregisterWithServer {
        static instance: ::protobuf::rt::Lazy<CMsgClientDeregisterWithServer> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientDeregisterWithServer::new)
    }
}

impl ::protobuf::Clear for CMsgClientDeregisterWithServer {
    fn clear(&mut self) {
        self.eservertype = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDeregisterWithServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeregisterWithServer {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientClanState {
    // message fields
    steamid_clan: ::std::option::Option<u64>,
    clan_account_flags: ::std::option::Option<u32>,
    pub name_info: ::protobuf::SingularPtrField<cmsg_client_clan_state::NameInfo>,
    pub user_counts: ::protobuf::SingularPtrField<cmsg_client_clan_state::UserCounts>,
    pub events: ::protobuf::RepeatedField<cmsg_client_clan_state::Event>,
    pub announcements: ::protobuf::RepeatedField<cmsg_client_clan_state::Event>,
    chat_room_private: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientClanState {
    fn default() -> &'a CMsgClientClanState {
        <CMsgClientClanState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientClanState {
    pub fn new() -> CMsgClientClanState {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_clan = 1;

    pub fn get_steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    // optional uint32 clan_account_flags = 3;

    pub fn get_clan_account_flags(&self) -> u32 {
        self.clan_account_flags.unwrap_or(0)
    }

    pub fn clear_clan_account_flags(&mut self) {
        self.clan_account_flags = ::std::option::Option::None;
    }

    pub fn has_clan_account_flags(&self) -> bool {
        self.clan_account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_account_flags(&mut self, v: u32) {
        self.clan_account_flags = ::std::option::Option::Some(v);
    }

    // optional bool chat_room_private = 8;

    pub fn get_chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }

    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientClanState {
    fn is_initialized(&self) -> bool {
        for v in &self.name_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_counts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.announcements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.clan_account_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<cmsg_client_clan_state::NameInfo, _>(wire_type, is, &mut self.name_info)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<cmsg_client_clan_state::UserCounts, _>(wire_type, is, &mut self.user_counts)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.events)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.announcements)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chat_room_private = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_clan {
            my_size += 9;
        }
        if let Some(v) = self.clan_account_flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.name_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.user_counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.announcements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.chat_room_private {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.clan_account_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.name_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.user_counts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.announcements {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.chat_room_private {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientClanState {
        CMsgClientClanState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_clan",
                |m: &CMsgClientClanState| { &m.steamid_clan },
                |m: &mut CMsgClientClanState| { &mut m.steamid_clan },
                CMsgClientClanState::get_steamid_clan,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "clan_account_flags",
                |m: &CMsgClientClanState| { &m.clan_account_flags },
                |m: &mut CMsgClientClanState| { &mut m.clan_account_flags },
                CMsgClientClanState::get_clan_account_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_clan_state::NameInfo>, _>(
                "name_info",
                |m: &CMsgClientClanState| { &m.name_info },
                |m: &mut CMsgClientClanState| { &mut m.name_info },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_clan_state::UserCounts>, _>(
                "user_counts",
                |m: &CMsgClientClanState| { &m.user_counts },
                |m: &mut CMsgClientClanState| { &mut m.user_counts },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_clan_state::Event>>(
                "events",
                |m: &CMsgClientClanState| { &m.events },
                |m: &mut CMsgClientClanState| { &mut m.events },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_clan_state::Event>>(
                "announcements",
                |m: &CMsgClientClanState| { &m.announcements },
                |m: &mut CMsgClientClanState| { &mut m.announcements },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "chat_room_private",
                |m: &CMsgClientClanState| { &m.chat_room_private },
                |m: &mut CMsgClientClanState| { &mut m.chat_room_private },
                CMsgClientClanState::get_chat_room_private,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientClanState>(
                "CMsgClientClanState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientClanState {
        static instance: ::protobuf::rt::Lazy<CMsgClientClanState> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientClanState::new)
    }
}

impl ::protobuf::Clear for CMsgClientClanState {
    fn clear(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
        self.clan_account_flags = ::std::option::Option::None;
        self.name_info.clear();
        self.user_counts.clear();
        self.events.clear();
        self.announcements.clear();
        self.chat_room_private = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientClanState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientClanState {
}

/// Nested message and enums of message `CMsgClientClanState`
pub mod cmsg_client_clan_state {
    #[derive(PartialEq,Clone,Default)]
    pub struct NameInfo {
        // message fields
        clan_name: ::protobuf::SingularField<::std::string::String>,
        sha_avatar: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a NameInfo {
        fn default() -> &'a NameInfo {
            <NameInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl NameInfo {
        pub fn new() -> NameInfo {
            ::std::default::Default::default()
        }

        // optional string clan_name = 1;

        pub fn get_clan_name(&self) -> &str {
            match self.clan_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_clan_name(&mut self) {
            self.clan_name.clear();
        }

        pub fn has_clan_name(&self) -> bool {
            self.clan_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_name(&mut self, v: ::std::string::String) {
            self.clan_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_clan_name(&mut self) -> &mut ::std::string::String {
            if self.clan_name.is_none() {
                self.clan_name.set_default();
            }
            self.clan_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_clan_name(&mut self) -> ::std::string::String {
            self.clan_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes sha_avatar = 2;

        pub fn get_sha_avatar(&self) -> &[u8] {
            match self.sha_avatar.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha_avatar(&mut self) {
            self.sha_avatar.clear();
        }

        pub fn has_sha_avatar(&self) -> bool {
            self.sha_avatar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha_avatar(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha_avatar = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha_avatar(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha_avatar.is_none() {
                self.sha_avatar.set_default();
            }
            self.sha_avatar.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha_avatar(&mut self) -> ::std::vec::Vec<u8> {
            self.sha_avatar.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for NameInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clan_name)?;
                    },
                    2 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_avatar)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.clan_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.sha_avatar.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.clan_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.sha_avatar.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> NameInfo {
            NameInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "clan_name",
                    |m: &NameInfo| { &m.clan_name },
                    |m: &mut NameInfo| { &mut m.clan_name },
                    NameInfo::get_clan_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "sha_avatar",
                    |m: &NameInfo| { &m.sha_avatar },
                    |m: &mut NameInfo| { &mut m.sha_avatar },
                    NameInfo::get_sha_avatar,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NameInfo>(
                    "CMsgClientClanState.NameInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static NameInfo {
            static instance: ::protobuf::rt::Lazy<NameInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(NameInfo::new)
        }
    }

    impl ::protobuf::Clear for NameInfo {
        fn clear(&mut self) {
            self.clan_name.clear();
            self.sha_avatar.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for NameInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NameInfo {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct UserCounts {
        // message fields
        members: ::std::option::Option<u32>,
        online: ::std::option::Option<u32>,
        chatting: ::std::option::Option<u32>,
        in_game: ::std::option::Option<u32>,
        chat_room_members: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a UserCounts {
        fn default() -> &'a UserCounts {
            <UserCounts as ::protobuf::Message>::default_instance()
        }
    }

    impl UserCounts {
        pub fn new() -> UserCounts {
            ::std::default::Default::default()
        }

        // optional uint32 members = 1;

        pub fn get_members(&self) -> u32 {
            self.members.unwrap_or(0)
        }

        pub fn clear_members(&mut self) {
            self.members = ::std::option::Option::None;
        }

        pub fn has_members(&self) -> bool {
            self.members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_members(&mut self, v: u32) {
            self.members = ::std::option::Option::Some(v);
        }

        // optional uint32 online = 2;

        pub fn get_online(&self) -> u32 {
            self.online.unwrap_or(0)
        }

        pub fn clear_online(&mut self) {
            self.online = ::std::option::Option::None;
        }

        pub fn has_online(&self) -> bool {
            self.online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_online(&mut self, v: u32) {
            self.online = ::std::option::Option::Some(v);
        }

        // optional uint32 chatting = 3;

        pub fn get_chatting(&self) -> u32 {
            self.chatting.unwrap_or(0)
        }

        pub fn clear_chatting(&mut self) {
            self.chatting = ::std::option::Option::None;
        }

        pub fn has_chatting(&self) -> bool {
            self.chatting.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chatting(&mut self, v: u32) {
            self.chatting = ::std::option::Option::Some(v);
        }

        // optional uint32 in_game = 4;

        pub fn get_in_game(&self) -> u32 {
            self.in_game.unwrap_or(0)
        }

        pub fn clear_in_game(&mut self) {
            self.in_game = ::std::option::Option::None;
        }

        pub fn has_in_game(&self) -> bool {
            self.in_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_game(&mut self, v: u32) {
            self.in_game = ::std::option::Option::Some(v);
        }

        // optional uint32 chat_room_members = 5;

        pub fn get_chat_room_members(&self) -> u32 {
            self.chat_room_members.unwrap_or(0)
        }

        pub fn clear_chat_room_members(&mut self) {
            self.chat_room_members = ::std::option::Option::None;
        }

        pub fn has_chat_room_members(&self) -> bool {
            self.chat_room_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_room_members(&mut self, v: u32) {
            self.chat_room_members = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for UserCounts {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.members = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.online = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.chatting = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.in_game = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.chat_room_members = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.members {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.online {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.chatting {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.in_game {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.chat_room_members {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.members {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.online {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.chatting {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.in_game {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.chat_room_members {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> UserCounts {
            UserCounts::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "members",
                    |m: &UserCounts| { &m.members },
                    |m: &mut UserCounts| { &mut m.members },
                    UserCounts::get_members,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "online",
                    |m: &UserCounts| { &m.online },
                    |m: &mut UserCounts| { &mut m.online },
                    UserCounts::get_online,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "chatting",
                    |m: &UserCounts| { &m.chatting },
                    |m: &mut UserCounts| { &mut m.chatting },
                    UserCounts::get_chatting,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "in_game",
                    |m: &UserCounts| { &m.in_game },
                    |m: &mut UserCounts| { &mut m.in_game },
                    UserCounts::get_in_game,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "chat_room_members",
                    |m: &UserCounts| { &m.chat_room_members },
                    |m: &mut UserCounts| { &mut m.chat_room_members },
                    UserCounts::get_chat_room_members,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserCounts>(
                    "CMsgClientClanState.UserCounts",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static UserCounts {
            static instance: ::protobuf::rt::Lazy<UserCounts> = ::protobuf::rt::Lazy::INIT;
            instance.get(UserCounts::new)
        }
    }

    impl ::protobuf::Clear for UserCounts {
        fn clear(&mut self) {
            self.members = ::std::option::Option::None;
            self.online = ::std::option::Option::None;
            self.chatting = ::std::option::Option::None;
            self.in_game = ::std::option::Option::None;
            self.chat_room_members = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for UserCounts {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserCounts {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct Event {
        // message fields
        gid: ::std::option::Option<u64>,
        event_time: ::std::option::Option<u32>,
        headline: ::protobuf::SingularField<::std::string::String>,
        game_id: ::std::option::Option<u64>,
        just_posted: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Event {
        fn default() -> &'a Event {
            <Event as ::protobuf::Message>::default_instance()
        }
    }

    impl Event {
        pub fn new() -> Event {
            ::std::default::Default::default()
        }

        // optional fixed64 gid = 1;

        pub fn get_gid(&self) -> u64 {
            self.gid.unwrap_or(0)
        }

        pub fn clear_gid(&mut self) {
            self.gid = ::std::option::Option::None;
        }

        pub fn has_gid(&self) -> bool {
            self.gid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gid(&mut self, v: u64) {
            self.gid = ::std::option::Option::Some(v);
        }

        // optional uint32 event_time = 2;

        pub fn get_event_time(&self) -> u32 {
            self.event_time.unwrap_or(0)
        }

        pub fn clear_event_time(&mut self) {
            self.event_time = ::std::option::Option::None;
        }

        pub fn has_event_time(&self) -> bool {
            self.event_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_time(&mut self, v: u32) {
            self.event_time = ::std::option::Option::Some(v);
        }

        // optional string headline = 3;

        pub fn get_headline(&self) -> &str {
            match self.headline.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_headline(&mut self) {
            self.headline.clear();
        }

        pub fn has_headline(&self) -> bool {
            self.headline.is_some()
        }

        // Param is passed by value, moved
        pub fn set_headline(&mut self, v: ::std::string::String) {
            self.headline = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_headline(&mut self) -> &mut ::std::string::String {
            if self.headline.is_none() {
                self.headline.set_default();
            }
            self.headline.as_mut().unwrap()
        }

        // Take field
        pub fn take_headline(&mut self) -> ::std::string::String {
            self.headline.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 game_id = 4;

        pub fn get_game_id(&self) -> u64 {
            self.game_id.unwrap_or(0)
        }

        pub fn clear_game_id(&mut self) {
            self.game_id = ::std::option::Option::None;
        }

        pub fn has_game_id(&self) -> bool {
            self.game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_id(&mut self, v: u64) {
            self.game_id = ::std::option::Option::Some(v);
        }

        // optional bool just_posted = 5;

        pub fn get_just_posted(&self) -> bool {
            self.just_posted.unwrap_or(false)
        }

        pub fn clear_just_posted(&mut self) {
            self.just_posted = ::std::option::Option::None;
        }

        pub fn has_just_posted(&self) -> bool {
            self.just_posted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_just_posted(&mut self, v: bool) {
            self.just_posted = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Event {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.event_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headline)?;
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.just_posted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.gid {
                my_size += 9;
            }
            if let Some(v) = self.event_time {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.headline.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.game_id {
                my_size += 9;
            }
            if let Some(v) = self.just_posted {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.gid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.event_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.headline.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.game_id {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.just_posted {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Event {
            Event::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "gid",
                    |m: &Event| { &m.gid },
                    |m: &mut Event| { &mut m.gid },
                    Event::get_gid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "event_time",
                    |m: &Event| { &m.event_time },
                    |m: &mut Event| { &mut m.event_time },
                    Event::get_event_time,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "headline",
                    |m: &Event| { &m.headline },
                    |m: &mut Event| { &mut m.headline },
                    Event::get_headline,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "game_id",
                    |m: &Event| { &m.game_id },
                    |m: &mut Event| { &mut m.game_id },
                    Event::get_game_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "just_posted",
                    |m: &Event| { &m.just_posted },
                    |m: &mut Event| { &mut m.just_posted },
                    Event::get_just_posted,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event>(
                    "CMsgClientClanState.Event",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Event {
            static instance: ::protobuf::rt::Lazy<Event> = ::protobuf::rt::Lazy::INIT;
            instance.get(Event::new)
        }
    }

    impl ::protobuf::Clear for Event {
        fn clear(&mut self) {
            self.gid = ::std::option::Option::None;
            self.event_time = ::std::option::Option::None;
            self.headline.clear();
            self.game_id = ::std::option::Option::None;
            self.just_posted = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Event {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Event {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUnsignedInstallScript {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    file_size: ::std::option::Option<u32>,
    signature_broken: ::std::option::Option<bool>,
    depot_id: ::std::option::Option<u32>,
    manifest_id: ::std::option::Option<u64>,
    file_flags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUnsignedInstallScript {
    fn default() -> &'a CMsgClientUnsignedInstallScript {
        <CMsgClientUnsignedInstallScript as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUnsignedInstallScript {
    pub fn new() -> CMsgClientUnsignedInstallScript {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 file_size = 3;

    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional bool signature_broken = 4;

    pub fn get_signature_broken(&self) -> bool {
        self.signature_broken.unwrap_or(false)
    }

    pub fn clear_signature_broken(&mut self) {
        self.signature_broken = ::std::option::Option::None;
    }

    pub fn has_signature_broken(&self) -> bool {
        self.signature_broken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature_broken(&mut self, v: bool) {
        self.signature_broken = ::std::option::Option::Some(v);
    }

    // optional uint32 depot_id = 5;

    pub fn get_depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 manifest_id = 6;

    pub fn get_manifest_id(&self) -> u64 {
        self.manifest_id.unwrap_or(0)
    }

    pub fn clear_manifest_id(&mut self) {
        self.manifest_id = ::std::option::Option::None;
    }

    pub fn has_manifest_id(&self) -> bool {
        self.manifest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest_id(&mut self, v: u64) {
        self.manifest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_flags = 7;

    pub fn get_file_flags(&self) -> u32 {
        self.file_flags.unwrap_or(0)
    }

    pub fn clear_file_flags(&mut self) {
        self.file_flags = ::std::option::Option::None;
    }

    pub fn has_file_flags(&self) -> bool {
        self.file_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_flags(&mut self, v: u32) {
        self.file_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUnsignedInstallScript {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signature_broken = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.manifest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signature_broken {
            my_size += 2;
        }
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.manifest_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_flags {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.signature_broken {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.depot_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.manifest_id {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.file_flags {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUnsignedInstallScript {
        CMsgClientUnsignedInstallScript::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUnsignedInstallScript| { &m.app_id },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.app_id },
                CMsgClientUnsignedInstallScript::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_name",
                |m: &CMsgClientUnsignedInstallScript| { &m.file_name },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.file_name },
                CMsgClientUnsignedInstallScript::get_file_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "file_size",
                |m: &CMsgClientUnsignedInstallScript| { &m.file_size },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.file_size },
                CMsgClientUnsignedInstallScript::get_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "signature_broken",
                |m: &CMsgClientUnsignedInstallScript| { &m.signature_broken },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.signature_broken },
                CMsgClientUnsignedInstallScript::get_signature_broken,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "depot_id",
                |m: &CMsgClientUnsignedInstallScript| { &m.depot_id },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.depot_id },
                CMsgClientUnsignedInstallScript::get_depot_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "manifest_id",
                |m: &CMsgClientUnsignedInstallScript| { &m.manifest_id },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.manifest_id },
                CMsgClientUnsignedInstallScript::get_manifest_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "file_flags",
                |m: &CMsgClientUnsignedInstallScript| { &m.file_flags },
                |m: &mut CMsgClientUnsignedInstallScript| { &mut m.file_flags },
                CMsgClientUnsignedInstallScript::get_file_flags,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUnsignedInstallScript>(
                "CMsgClientUnsignedInstallScript",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUnsignedInstallScript {
        static instance: ::protobuf::rt::Lazy<CMsgClientUnsignedInstallScript> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUnsignedInstallScript::new)
    }
}

impl ::protobuf::Clear for CMsgClientUnsignedInstallScript {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.file_size = ::std::option::Option::None;
        self.signature_broken = ::std::option::Option::None;
        self.depot_id = ::std::option::Option::None;
        self.manifest_id = ::std::option::Option::None;
        self.file_flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUnsignedInstallScript {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUnsignedInstallScript {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EMMSLobbyStatus {
    k_EMMSLobbyStatusInvalid = 0,
    k_EMMSLobbyStatusExists = 1,
    k_EMMSLobbyStatusDoesNotExist = 2,
    k_EMMSLobbyStatusNotAMember = 3,
}

impl ::protobuf::ProtobufEnum for EMMSLobbyStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMMSLobbyStatus> {
        match value {
            0 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            1 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusExists),
            2 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist),
            3 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EMMSLobbyStatus] = &[
            EMMSLobbyStatus::k_EMMSLobbyStatusInvalid,
            EMMSLobbyStatus::k_EMMSLobbyStatusExists,
            EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist,
            EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EMMSLobbyStatus>("EMMSLobbyStatus", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EMMSLobbyStatus {
    fn default() -> Self {
        EMMSLobbyStatus::k_EMMSLobbyStatusInvalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EMMSLobbyStatus {
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20steammessages_clientserver.proto\x1a\x18steammessages_base.proto\
    \x1a\x1aencrypted_app_ticket.proto\"]\n\x1eCMsgClientUDSP2PSessionStarte\
    d\x12%\n\x0esteamid_remote\x18\x01\x20\x01(\x06R\rsteamidRemote\x12\x14\
    \n\x05appid\x18\x02\x20\x01(\x05R\x05appid\"\x87\x03\n\x1cCMsgClientUDSP\
    2PSessionEnded\x12%\n\x0esteamid_remote\x18\x01\x20\x01(\x06R\rsteamidRe\
    mote\x12\x14\n\x05appid\x18\x02\x20\x01(\x05R\x05appid\x12,\n\x12session\
    _length_sec\x18\x03\x20\x01(\x05R\x10sessionLengthSec\x12#\n\rsession_er\
    ror\x18\x04\x20\x01(\x05R\x0csessionError\x12\x18\n\x07nattype\x18\x05\
    \x20\x01(\x05R\x07nattype\x12\x1d\n\nbytes_recv\x18\x06\x20\x01(\x05R\tb\
    ytesRecv\x12\x1d\n\nbytes_sent\x18\x07\x20\x01(\x05R\tbytesSent\x12(\n\
    \x10bytes_sent_relay\x18\x08\x20\x01(\x05R\x0ebytesSentRelay\x12(\n\x10b\
    ytes_recv_relay\x18\t\x20\x01(\x05R\x0ebytesRecvRelay\x12+\n\x12time_to_\
    connect_ms\x18\n\x20\x01(\x05R\x0ftimeToConnectMs\"\x95\x01\n\"CMsgClien\
    tRegisterAuthTicketWithCM\x12)\n\x10protocol_version\x18\x01\x20\x01(\rR\
    \x0fprotocolVersion\x12\x16\n\x06ticket\x18\x03\x20\x01(\x0cR\x06ticket\
    \x12,\n\x12client_instance_id\x18\x04\x20\x01(\x04R\x10clientInstanceId\
    \"\xbb\x02\n\x1cCMsgClientTicketAuthComplete\x12\x19\n\x08steam_id\x18\
    \x01\x20\x01(\x06R\x07steamId\x12\x17\n\x07game_id\x18\x02\x20\x01(\x06R\
    \x06gameId\x12\x16\n\x06estate\x18\x03\x20\x01(\rR\x06estate\x124\n\x16e\
    auth_session_response\x18\x04\x20\x01(\rR\x14eauthSessionResponse\x12+\n\
    \x11DEPRECATED_ticket\x18\x05\x20\x01(\x0cR\x10DEPRECATEDTicket\x12\x1d\
    \n\nticket_crc\x18\x06\x20\x01(\rR\tticketCrc\x12'\n\x0fticket_sequence\
    \x18\x07\x20\x01(\rR\x0eticketSequence\x12$\n\x0eowner_steam_id\x18\x08\
    \x20\x01(\x06R\x0cownerSteamId\"\xc7\x01\n\x10CMsgClientCMList\x12!\n\
    \x0ccm_addresses\x18\x01\x20\x03(\rR\x0bcmAddresses\x12\x19\n\x08cm_port\
    s\x18\x02\x20\x03(\rR\x07cmPorts\x124\n\x16cm_websocket_addresses\x18\
    \x03\x20\x03(\tR\x14cmWebsocketAddresses\x12?\n\x1cpercent_default_to_we\
    bsocket\x18\x04\x20\x01(\rR\x19percentDefaultToWebsocket\"\xe4\x01\n\x1b\
    CMsgClientP2PConnectionInfo\x12\"\n\rsteam_id_dest\x18\x01\x20\x01(\x06R\
    \x0bsteamIdDest\x12\x20\n\x0csteam_id_src\x18\x02\x20\x01(\x06R\nsteamId\
    Src\x12\x15\n\x06app_id\x18\x03\x20\x01(\rR\x05appId\x12\x1c\n\tcandidat\
    e\x18\x04\x20\x01(\x0cR\tcandidate\x12*\n\x11connection_id_src\x18\x05\
    \x20\x01(\x06R\x0fconnectionIdSrc\x12\x1e\n\nrendezvous\x18\x06\x20\x01(\
    \x0cR\nrendezvous\"\xa2\x02\n\x1fCMsgClientP2PConnectionFailInfo\x12\"\n\
    \rsteam_id_dest\x18\x01\x20\x01(\x06R\x0bsteamIdDest\x12\x20\n\x0csteam_\
    id_src\x18\x02\x20\x01(\x06R\nsteamIdSrc\x12\x15\n\x06app_id\x18\x03\x20\
    \x01(\rR\x05appId\x12,\n\x12ep2p_session_error\x18\x04\x20\x01(\rR\x10ep\
    2pSessionError\x12,\n\x12connection_id_dest\x18\x05\x20\x01(\x06R\x10con\
    nectionIdDest\x12!\n\x0cclose_reason\x18\x07\x20\x01(\rR\x0bcloseReason\
    \x12#\n\rclose_message\x18\x08\x20\x01(\tR\x0ccloseMessage\"S\n\x1fCMsgC\
    lientNetworkingCertRequest\x12\x19\n\x08key_data\x18\x02\x20\x01(\x0cR\
    \x07keyData\x12\x15\n\x06app_id\x18\x03\x20\x01(\rR\x05appId\"r\n\x1dCMs\
    gClientNetworkingCertReply\x12\x12\n\x04cert\x18\x04\x20\x01(\x0cR\x04ce\
    rt\x12\x1a\n\tca_key_id\x18\x05\x20\x01(\x06R\x07caKeyId\x12!\n\x0cca_si\
    gnature\x18\x06\x20\x01(\x0cR\x0bcaSignature\">\n%CMsgClientNetworkingMo\
    bileCertRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\"H\n#CM\
    sgClientNetworkingMobileCertReply\x12!\n\x0cencoded_cert\x18\x01\x20\x01\
    (\tR\x0bencodedCert\"8\n\x1fCMsgClientGetAppOwnershipTicket\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\"u\n'CMsgClientGetAppOwnershipTi\
    cketResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\
    \x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12\x16\n\x06ticket\
    \x18\x03\x20\x01(\x0cR\x06ticket\".\n\x16CMsgClientSessionToken\x12\x14\
    \n\x05token\x18\x01\x20\x01(\x04R\x05token\"f\n\x1bCMsgClientGameConnect\
    Tokens\x12/\n\x12max_tokens_to_keep\x18\x01\x20\x01(\r:\x0210R\x0fmaxTok\
    ensToKeep\x12\x16\n\x06tokens\x18\x02\x20\x03(\x0cR\x06tokens\"\x8c\x02\
    \n\x10CMsgGSServerType\x12\"\n\rapp_id_served\x18\x01\x20\x01(\rR\x0bapp\
    IdServed\x12\x14\n\x05flags\x18\x02\x20\x01(\rR\x05flags\x12;\n\x1adepre\
    cated_game_ip_address\x18\x03\x20\x01(\rR\x17deprecatedGameIpAddress\x12\
    \x1b\n\tgame_port\x18\x04\x20\x01(\rR\x08gamePort\x12\x19\n\x08game_dir\
    \x18\x05\x20\x01(\tR\x07gameDir\x12!\n\x0cgame_version\x18\x06\x20\x01(\
    \tR\x0bgameVersion\x12&\n\x0fgame_query_port\x18\x07\x20\x01(\rR\rgameQu\
    eryPort\"0\n\x11CMsgGSStatusReply\x12\x1b\n\tis_secure\x18\x01\x20\x01(\
    \x08R\x08isSecure\"\xe1\x01\n\x10CMsgGSPlayerList\x122\n\x07players\x18\
    \x01\x20\x03(\x0b2\x18.CMsgGSPlayerList.PlayerR\x07players\x1a\x98\x01\n\
    \x06Player\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x04R\x07steamId\x120\n\
    \x14deprecated_public_ip\x18\x02\x20\x01(\rR\x12deprecatedPublicIp\x12\
    \x14\n\x05token\x18\x03\x20\x01(\x0cR\x05token\x12+\n\tpublic_ip\x18\x04\
    \x20\x01(\x0b2\x0e.CMsgIPAddressR\x08publicIp\"\xa3\x01\n\x11CMsgGSUserP\
    laying\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x120\n\x14\
    deprecated_public_ip\x18\x02\x20\x01(\rR\x12deprecatedPublicIp\x12\x14\n\
    \x05token\x18\x03\x20\x01(\x0cR\x05token\x12+\n\tpublic_ip\x18\x04\x20\
    \x01(\x0b2\x0e.CMsgIPAddressR\x08publicIp\"3\n\x16CMsgGSDisconnectNotice\
    \x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"\xc5\t\n\x15CMs\
    gClientGamesPlayed\x12D\n\x0cgames_played\x18\x01\x20\x03(\x0b2!.CMsgCli\
    entGamesPlayed.GamePlayedR\x0bgamesPlayed\x12$\n\x0eclient_os_type\x18\
    \x02\x20\x01(\rR\x0cclientOsType\x1a\xbf\x08\n\nGamePlayed\x12\x1e\n\x0b\
    steam_id_gs\x18\x01\x20\x01(\x04R\tsteamIdGs\x12\x17\n\x07game_id\x18\
    \x02\x20\x01(\x06R\x06gameId\x12;\n\x1adeprecated_game_ip_address\x18\
    \x03\x20\x01(\rR\x17deprecatedGameIpAddress\x12\x1b\n\tgame_port\x18\x04\
    \x20\x01(\rR\x08gamePort\x12\x1b\n\tis_secure\x18\x05\x20\x01(\x08R\x08i\
    sSecure\x12\x14\n\x05token\x18\x06\x20\x01(\x0cR\x05token\x12&\n\x0fgame\
    _extra_info\x18\x07\x20\x01(\tR\rgameExtraInfo\x12$\n\x0egame_data_blob\
    \x18\x08\x20\x01(\x0cR\x0cgameDataBlob\x12\x1d\n\nprocess_id\x18\t\x20\
    \x01(\rR\tprocessId\x122\n\x15streaming_provider_id\x18\n\x20\x01(\rR\
    \x13streamingProviderId\x12\x1d\n\ngame_flags\x18\x0b\x20\x01(\rR\tgameF\
    lags\x12\x19\n\x08owner_id\x18\x0c\x20\x01(\rR\x07ownerId\x12\"\n\rvr_hm\
    d_vendor\x18\r\x20\x01(\tR\x0bvrHmdVendor\x12\x20\n\x0cvr_hmd_model\x18\
    \x0e\x20\x01(\tR\nvrHmdModel\x12/\n\x12launch_option_type\x18\x0f\x20\
    \x01(\r:\x010R\x10launchOptionType\x12:\n\x17primary_controller_type\x18\
    \x10\x20\x01(\x05:\x02-1R\x15primaryControllerType\x12E\n\x1fprimary_ste\
    am_controller_serial\x18\x11\x20\x01(\tR\x1cprimarySteamControllerSerial\
    \x12B\n\x1ctotal_steam_controller_count\x18\x12\x20\x01(\r:\x010R\x19tot\
    alSteamControllerCount\x12I\n\x20total_non_steam_controller_count\x18\
    \x13\x20\x01(\r:\x010R\x1ctotalNonSteamControllerCount\x12@\n\x1bcontrol\
    ler_workshop_file_id\x18\x14\x20\x01(\x04:\x010R\x18controllerWorkshopFi\
    leId\x12&\n\rlaunch_source\x18\x15\x20\x01(\r:\x010R\x0claunchSource\x12\
    $\n\x0evr_hmd_runtime\x18\x16\x20\x01(\rR\x0cvrHmdRuntime\x126\n\x0fgame\
    _ip_address\x18\x17\x20\x01(\x0b2\x0e.CMsgIPAddressR\rgameIpAddress\x12?\
    \n\x1acontroller_connection_type\x18\x18\x20\x01(\r:\x010R\x18controller\
    ConnectionType\"P\n\rCMsgGSApprove\x12\x19\n\x08steam_id\x18\x01\x20\x01\
    (\x06R\x07steamId\x12$\n\x0eowner_steam_id\x18\x02\x20\x01(\x06R\x0cowne\
    rSteamId\"k\n\nCMsgGSDeny\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\
    \x07steamId\x12!\n\x0cedeny_reason\x18\x02\x20\x01(\x05R\x0bedenyReason\
    \x12\x1f\n\x0bdeny_string\x18\x03\x20\x01(\tR\ndenyString\"J\n\nCMsgGSKi\
    ck\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12!\n\x0ceden\
    y_reason\x18\x02\x20\x01(\x05R\x0bedenyReason\"\x8e\x02\n\x12CMsgClientA\
    uthList\x12\x1f\n\x0btokens_left\x18\x01\x20\x01(\rR\ntokensLeft\x12(\n\
    \x10last_request_seq\x18\x02\x20\x01(\rR\x0elastRequestSeq\x12>\n\x1clas\
    t_request_seq_from_server\x18\x03\x20\x01(\rR\x18lastRequestSeqFromServe\
    r\x12)\n\x07tickets\x18\x04\x20\x03(\x0b2\x0f.CMsgAuthTicketR\x07tickets\
    \x12\x17\n\x07app_ids\x18\x05\x20\x03(\rR\x06appIds\x12)\n\x10message_se\
    quence\x18\x06\x20\x01(\rR\x0fmessageSequence\"z\n\x15CMsgClientAuthList\
    Ack\x12\x1d\n\nticket_crc\x18\x01\x20\x03(\rR\tticketCrc\x12\x17\n\x07ap\
    p_ids\x18\x02\x20\x03(\rR\x06appIds\x12)\n\x10message_sequence\x18\x03\
    \x20\x01(\rR\x0fmessageSequence\"\xd1\x05\n\x15CMsgClientLicenseList\x12\
    \x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12:\n\x08licen\
    ses\x18\x02\x20\x03(\x0b2\x1e.CMsgClientLicenseList.LicenseR\x08licenses\
    \x1a\xde\x04\n\x07License\x12\x1d\n\npackage_id\x18\x01\x20\x01(\rR\tpac\
    kageId\x12!\n\x0ctime_created\x18\x02\x20\x01(\x07R\x0btimeCreated\x12*\
    \n\x11time_next_process\x18\x03\x20\x01(\x07R\x0ftimeNextProcess\x12!\n\
    \x0cminute_limit\x18\x04\x20\x01(\x05R\x0bminuteLimit\x12!\n\x0cminutes_\
    used\x18\x05\x20\x01(\x05R\x0bminutesUsed\x12%\n\x0epayment_method\x18\
    \x06\x20\x01(\rR\rpaymentMethod\x12\x14\n\x05flags\x18\x07\x20\x01(\rR\
    \x05flags\x122\n\x15purchase_country_code\x18\x08\x20\x01(\tR\x13purchas\
    eCountryCode\x12!\n\x0clicense_type\x18\t\x20\x01(\rR\x0blicenseType\x12\
    %\n\x0eterritory_code\x18\n\x20\x01(\x05R\rterritoryCode\x12#\n\rchange_\
    number\x18\x0b\x20\x01(\x05R\x0cchangeNumber\x12\x19\n\x08owner_id\x18\
    \x0c\x20\x01(\rR\x07ownerId\x12%\n\x0einitial_period\x18\r\x20\x01(\rR\r\
    initialPeriod\x12*\n\x11initial_time_unit\x18\x0e\x20\x01(\rR\x0finitial\
    TimeUnit\x12%\n\x0erenewal_period\x18\x0f\x20\x01(\rR\rrenewalPeriod\x12\
    *\n\x11renewal_time_unit\x18\x10\x20\x01(\rR\x0frenewalTimeUnit\"\xb5\
    \x01\n\x15CMsgClientLBSSetScore\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12%\n\x0eleaderboard_id\x18\x02\x20\x01(\x05R\rleaderboardId\
    \x12\x14\n\x05score\x18\x03\x20\x01(\x05R\x05score\x12\x18\n\x07details\
    \x18\x04\x20\x01(\x0cR\x07details\x12.\n\x13upload_score_method\x18\x05\
    \x20\x01(\x05R\x11uploadScoreMethod\"\xf3\x01\n\x1dCMsgClientLBSSetScore\
    Response\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\
    6\n\x17leaderboard_entry_count\x18\x02\x20\x01(\x05R\x15leaderboardEntry\
    Count\x12#\n\rscore_changed\x18\x03\x20\x01(\x08R\x0cscoreChanged\x120\n\
    \x14global_rank_previous\x18\x04\x20\x01(\x05R\x12globalRankPrevious\x12\
    &\n\x0fglobal_rank_new\x18\x05\x20\x01(\x05R\rglobalRankNew\"j\n\x13CMsg\
    ClientLBSSetUGC\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12%\n\
    \x0eleaderboard_id\x18\x02\x20\x01(\x05R\rleaderboardId\x12\x15\n\x06ugc\
    _id\x18\x03\x20\x01(\x06R\x05ugcId\":\n\x1bCMsgClientLBSSetUGCResponse\
    \x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\"\x80\x02\n\
    \x1bCMsgClientLBSFindOrCreateLB\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x126\n\x17leaderboard_sort_method\x18\x02\x20\x01(\x05R\x15lea\
    derboardSortMethod\x128\n\x18leaderboard_display_type\x18\x03\x20\x01(\
    \x05R\x16leaderboardDisplayType\x12-\n\x13create_if_not_found\x18\x04\
    \x20\x01(\x08R\x10createIfNotFound\x12)\n\x10leaderboard_name\x18\x05\
    \x20\x01(\tR\x0fleaderboardName\"\xc4\x02\n#CMsgClientLBSFindOrCreateLBR\
    esponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12%\
    \n\x0eleaderboard_id\x18\x02\x20\x01(\x05R\rleaderboardId\x126\n\x17lead\
    erboard_entry_count\x18\x03\x20\x01(\x05R\x15leaderboardEntryCount\x129\
    \n\x17leaderboard_sort_method\x18\x04\x20\x01(\x05:\x010R\x15leaderboard\
    SortMethod\x12;\n\x18leaderboard_display_type\x18\x05\x20\x01(\x05:\x010\
    R\x16leaderboardDisplayType\x12)\n\x10leaderboard_name\x18\x06\x20\x01(\
    \tR\x0fleaderboardName\"\xed\x01\n\x19CMsgClientLBSGetLBEntries\x12\x15\
    \n\x06app_id\x18\x01\x20\x01(\x05R\x05appId\x12%\n\x0eleaderboard_id\x18\
    \x02\x20\x01(\x05R\rleaderboardId\x12\x1f\n\x0brange_start\x18\x03\x20\
    \x01(\x05R\nrangeStart\x12\x1b\n\trange_end\x18\x04\x20\x01(\x05R\x08ran\
    geEnd\x128\n\x18leaderboard_data_request\x18\x05\x20\x01(\x05R\x16leader\
    boardDataRequest\x12\x1a\n\x08steamids\x18\x06\x20\x03(\x06R\x08steamids\
    \"\xd2\x02\n!CMsgClientLBSGetLBEntriesResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x126\n\x17leaderboard_entry_count\
    \x18\x02\x20\x01(\x05R\x15leaderboardEntryCount\x12B\n\x07entries\x18\
    \x03\x20\x03(\x0b2(.CMsgClientLBSGetLBEntriesResponse.EntryR\x07entries\
    \x1a\x93\x01\n\x05Entry\x12\"\n\rsteam_id_user\x18\x01\x20\x01(\x06R\x0b\
    steamIdUser\x12\x1f\n\x0bglobal_rank\x18\x02\x20\x01(\x05R\nglobalRank\
    \x12\x14\n\x05score\x18\x03\x20\x01(\x05R\x05score\x12\x18\n\x07details\
    \x18\x04\x20\x01(\x0cR\x07details\x12\x15\n\x06ugc_id\x18\x05\x20\x01(\
    \x06R\x05ugcId\"\xec\x01\n\x1eCMsgClientAppMinutesPlayedData\x12[\n\x0em\
    inutes_played\x18\x01\x20\x03(\x0b24.CMsgClientAppMinutesPlayedData.AppM\
    inutesPlayedDataR\rminutesPlayed\x1am\n\x14AppMinutesPlayedData\x12\x15\
    \n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x18\n\x07forever\x18\x02\
    \x20\x01(\x05R\x07forever\x12$\n\x0elast_two_weeks\x18\x03\x20\x01(\x05R\
    \x0clastTwoWeeks\"\x8c\x02\n\x1aCMsgClientIsLimitedAccount\x12.\n\x13bis\
    _limited_account\x18\x01\x20\x01(\x08R\x11bisLimitedAccount\x120\n\x14bi\
    s_community_banned\x18\x02\x20\x01(\x08R\x12bisCommunityBanned\x12,\n\
    \x12bis_locked_account\x18\x03\x20\x01(\x08R\x10bisLockedAccount\x12^\n-\
    bis_limited_account_allowed_to_invite_friends\x18\x04\x20\x01(\x08R'bisL\
    imitedAccountAllowedToInviteFriends\"\xd5\x01\n\x1eCMsgClientRequestedCl\
    ientStats\x12O\n\rstats_to_send\x18\x01\x20\x03(\x0b2+.CMsgClientRequest\
    edClientStats.StatsToSendR\x0bstatsToSend\x1ab\n\x0bStatsToSend\x12\x1f\
    \n\x0bclient_stat\x18\x01\x20\x01(\rR\nclientStat\x122\n\x15stat_aggrega\
    te_method\x18\x02\x20\x01(\rR\x13statAggregateMethod\"\x85\x02\n\x0fCMsg\
    ClientStat2\x12<\n\x0bstat_detail\x18\x01\x20\x03(\x0b2\x1b.CMsgClientSt\
    at2.StatDetailR\nstatDetail\x1a\xb3\x01\n\nStatDetail\x12\x1f\n\x0bclien\
    t_stat\x18\x01\x20\x01(\rR\nclientStat\x12\x19\n\x08ll_value\x18\x02\x20\
    \x01(\x03R\x07llValue\x12\x1e\n\x0btime_of_day\x18\x03\x20\x01(\rR\ttime\
    OfDay\x12\x17\n\x07cell_id\x18\x04\x20\x01(\rR\x06cellId\x12\x19\n\x08de\
    pot_id\x18\x05\x20\x01(\rR\x07depotId\x12\x15\n\x06app_id\x18\x06\x20\
    \x01(\rR\x05appId\"\xdf\x01\n'CMsgClientMMSSetRatelimitPolicyOnClient\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12,\n\x12enable_rate_\
    limits\x18\x02\x20\x01(\x08R\x10enableRateLimits\x12.\n\x13seconds_per_m\
    essage\x18\x03\x20\x01(\x05R\x11secondsPerMessage\x12?\n\x1cmilliseconds\
    _per_data_update\x18\x04\x20\x01(\x05R\x19millisecondsPerDataUpdate\"\
    \xd4\x02\n\x18CMsgClientMMSCreateLobby\x12\x15\n\x06app_id\x18\x01\x20\
    \x01(\rR\x05appId\x12\x1f\n\x0bmax_members\x18\x02\x20\x01(\x05R\nmaxMem\
    bers\x12\x1d\n\nlobby_type\x18\x03\x20\x01(\x05R\tlobbyType\x12\x1f\n\
    \x0blobby_flags\x18\x04\x20\x01(\x05R\nlobbyFlags\x12\x17\n\x07cell_id\
    \x18\x05\x20\x01(\rR\x06cellId\x120\n\x14deprecated_public_ip\x18\x06\
    \x20\x01(\rR\x12deprecatedPublicIp\x12\x1a\n\x08metadata\x18\x07\x20\x01\
    (\x0cR\x08metadata\x12,\n\x12persona_name_owner\x18\x08\x20\x01(\tR\x10p\
    ersonaNameOwner\x12+\n\tpublic_ip\x18\t\x20\x01(\x0b2\x0e.CMsgIPAddressR\
    \x08publicIp\"|\n\x20CMsgClientMMSCreateLobbyResponse\x12\x15\n\x06app_i\
    d\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\
    \x06R\x0csteamIdLobby\x12\x1b\n\x07eresult\x18\x03\x20\x01(\x05:\x012R\
    \x07eresult\"x\n\x16CMsgClientMMSJoinLobby\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0c\
    steamIdLobby\x12!\n\x0cpersona_name\x18\x03\x20\x01(\tR\x0bpersonaName\"\
    \xdf\x03\n\x1eCMsgClientMMSJoinLobbyResponse\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0c\
    steamIdLobby\x127\n\x18chat_room_enter_response\x18\x03\x20\x01(\x05R\
    \x15chatRoomEnterResponse\x12\x1f\n\x0bmax_members\x18\x04\x20\x01(\x05R\
    \nmaxMembers\x12\x1d\n\nlobby_type\x18\x05\x20\x01(\x05R\tlobbyType\x12\
    \x1f\n\x0blobby_flags\x18\x06\x20\x01(\x05R\nlobbyFlags\x12$\n\x0esteam_\
    id_owner\x18\x07\x20\x01(\x06R\x0csteamIdOwner\x12\x1a\n\x08metadata\x18\
    \x08\x20\x01(\x0cR\x08metadata\x12@\n\x07members\x18\t\x20\x03(\x0b2&.CM\
    sgClientMMSJoinLobbyResponse.MemberR\x07members\x1ab\n\x06Member\x12\x19\
    \n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12!\n\x0cpersona_name\
    \x18\x02\x20\x01(\tR\x0bpersonaName\x12\x1a\n\x08metadata\x18\x03\x20\
    \x01(\x0cR\x08metadata\"V\n\x17CMsgClientMMSLeaveLobby\x12\x15\n\x06app_\
    id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01\
    (\x06R\x0csteamIdLobby\"{\n\x1fCMsgClientMMSLeaveLobbyResponse\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\
    \x20\x01(\x06R\x0csteamIdLobby\x12\x1b\n\x07eresult\x18\x03\x20\x01(\x05\
    :\x012R\x07eresult\"\x90\x03\n\x19CMsgClientMMSGetLobbyList\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x122\n\x15num_lobbies_requested\
    \x18\x03\x20\x01(\x05R\x13numLobbiesRequested\x12\x17\n\x07cell_id\x18\
    \x04\x20\x01(\rR\x06cellId\x120\n\x14deprecated_public_ip\x18\x05\x20\
    \x01(\rR\x12deprecatedPublicIp\x12;\n\x07filters\x18\x06\x20\x03(\x0b2!.\
    CMsgClientMMSGetLobbyList.FilterR\x07filters\x12+\n\tpublic_ip\x18\x07\
    \x20\x01(\x0b2\x0e.CMsgIPAddressR\x08publicIp\x1as\n\x06Filter\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value\x12\x20\n\x0bcomparision\x18\x03\x20\x01(\x05R\x0bcomparision\
    \x12\x1f\n\x0bfilter_type\x18\x04\x20\x01(\x05R\nfilterType\"\x92\x03\n!\
    CMsgClientMMSGetLobbyListResponse\x12\x15\n\x06app_id\x18\x01\x20\x01(\r\
    R\x05appId\x12\x1b\n\x07eresult\x18\x03\x20\x01(\x05:\x012R\x07eresult\
    \x12B\n\x07lobbies\x18\x04\x20\x03(\x0b2(.CMsgClientMMSGetLobbyListRespo\
    nse.LobbyR\x07lobbies\x1a\xf4\x01\n\x05Lobby\x12\x19\n\x08steam_id\x18\
    \x01\x20\x01(\x06R\x07steamId\x12\x1f\n\x0bmax_members\x18\x02\x20\x01(\
    \x05R\nmaxMembers\x12\x1d\n\nlobby_type\x18\x03\x20\x01(\x05R\tlobbyType\
    \x12\x1f\n\x0blobby_flags\x18\x04\x20\x01(\x05R\nlobbyFlags\x12\x1a\n\
    \x08metadata\x18\x05\x20\x01(\x0cR\x08metadata\x12\x1f\n\x0bnum_members\
    \x18\x06\x20\x01(\x05R\nnumMembers\x12\x1a\n\x08distance\x18\x07\x20\x01\
    (\x02R\x08distance\x12\x16\n\x06weight\x18\x08\x20\x01(\x03R\x06weight\"\
    \xfd\x01\n\x19CMsgClientMMSSetLobbyData\x12\x15\n\x06app_id\x18\x01\x20\
    \x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0cstea\
    mIdLobby\x12&\n\x0fsteam_id_member\x18\x03\x20\x01(\x06R\rsteamIdMember\
    \x12\x1f\n\x0bmax_members\x18\x04\x20\x01(\x05R\nmaxMembers\x12\x1d\n\nl\
    obby_type\x18\x05\x20\x01(\x05R\tlobbyType\x12\x1f\n\x0blobby_flags\x18\
    \x06\x20\x01(\x05R\nlobbyFlags\x12\x1a\n\x08metadata\x18\x07\x20\x01(\
    \x0cR\x08metadata\"}\n!CMsgClientMMSSetLobbyDataResponse\x12\x15\n\x06ap\
    p_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\
    \x01(\x06R\x0csteamIdLobby\x12\x1b\n\x07eresult\x18\x03\x20\x01(\x05:\
    \x012R\x07eresult\"X\n\x19CMsgClientMMSGetLobbyData\x12\x15\n\x06app_id\
    \x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\
    \x06R\x0csteamIdLobby\"\x99\x04\n\x16CMsgClientMMSLobbyData\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\
    \x20\x01(\x06R\x0csteamIdLobby\x12\x1f\n\x0bnum_members\x18\x03\x20\x01(\
    \x05R\nnumMembers\x12\x1f\n\x0bmax_members\x18\x04\x20\x01(\x05R\nmaxMem\
    bers\x12\x1d\n\nlobby_type\x18\x05\x20\x01(\x05R\tlobbyType\x12\x1f\n\
    \x0blobby_flags\x18\x06\x20\x01(\x05R\nlobbyFlags\x12$\n\x0esteam_id_own\
    er\x18\x07\x20\x01(\x06R\x0csteamIdOwner\x12\x1a\n\x08metadata\x18\x08\
    \x20\x01(\x0cR\x08metadata\x128\n\x07members\x18\t\x20\x03(\x0b2\x1e.CMs\
    gClientMMSLobbyData.MemberR\x07members\x12!\n\x0clobby_cellid\x18\n\x20\
    \x01(\rR\x0blobbyCellid\x12=\n\x1bowner_should_accept_changes\x18\x0b\
    \x20\x01(\x08R\x18ownerShouldAcceptChanges\x1ab\n\x06Member\x12\x19\n\
    \x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12!\n\x0cpersona_name\x18\
    \x02\x20\x01(\tR\x0bpersonaName\x12\x1a\n\x08metadata\x18\x03\x20\x01(\
    \x0cR\x08metadata\"\xa9\x01\n\x1dCMsgClientMMSSendLobbyChatMsg\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\
    \x20\x01(\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_target\x18\x03\x20\x01\
    (\x06R\rsteamIdTarget\x12#\n\rlobby_message\x18\x04\x20\x01(\x0cR\x0clob\
    byMessage\"\xa5\x01\n\x19CMsgClientMMSLobbyChatMsg\x12\x15\n\x06app_id\
    \x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\
    \x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_sender\x18\x03\x20\x01(\x06R\rs\
    teamIdSender\x12#\n\rlobby_message\x18\x04\x20\x01(\x0cR\x0clobbyMessage\
    \"\x86\x01\n\x1aCMsgClientMMSSetLobbyOwner\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0c\
    steamIdLobby\x12+\n\x12steam_id_new_owner\x18\x03\x20\x01(\x06R\x0fsteam\
    IdNewOwner\"~\n\"CMsgClientMMSSetLobbyOwnerResponse\x12\x15\n\x06app_id\
    \x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\
    \x06R\x0csteamIdLobby\x12\x1b\n\x07eresult\x18\x03\x20\x01(\x05:\x012R\
    \x07eresult\"\x82\x01\n\x1bCMsgClientMMSSetLobbyLinked\x12\x15\n\x06app_\
    id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01\
    (\x06R\x0csteamIdLobby\x12&\n\x0fsteam_id_lobby2\x18\x03\x20\x01(\x06R\r\
    steamIdLobby2\"\xaa\x02\n\x1fCMsgClientMMSSetLobbyGameServer\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\
    \x20\x01(\x06R\x0csteamIdLobby\x129\n\x19deprecated_game_server_ip\x18\
    \x03\x20\x01(\rR\x16deprecatedGameServerIp\x12(\n\x10game_server_port\
    \x18\x04\x20\x01(\rR\x0egameServerPort\x12/\n\x14game_server_steam_id\
    \x18\x05\x20\x01(\x06R\x11gameServerSteamId\x124\n\x0egame_server_ip\x18\
    \x06\x20\x01(\x0b2\x0e.CMsgIPAddressR\x0cgameServerIp\"\xaa\x02\n\x1fCMs\
    gClientMMSLobbyGameServerSet\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05\
    appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\x12\
    9\n\x19deprecated_game_server_ip\x18\x03\x20\x01(\rR\x16deprecatedGameSe\
    rverIp\x12(\n\x10game_server_port\x18\x04\x20\x01(\rR\x0egameServerPort\
    \x12/\n\x14game_server_steam_id\x18\x05\x20\x01(\x06R\x11gameServerSteam\
    Id\x124\n\x0egame_server_ip\x18\x06\x20\x01(\x0b2\x0e.CMsgIPAddressR\x0c\
    gameServerIp\"\xa2\x01\n\x1cCMsgClientMMSUserJoinedLobby\x12\x15\n\x06ap\
    p_id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\
    \x01(\x06R\x0csteamIdLobby\x12\"\n\rsteam_id_user\x18\x03\x20\x01(\x06R\
    \x0bsteamIdUser\x12!\n\x0cpersona_name\x18\x04\x20\x01(\tR\x0bpersonaNam\
    e\"\xa0\x01\n\x1aCMsgClientMMSUserLeftLobby\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0c\
    steamIdLobby\x12\"\n\rsteam_id_user\x18\x03\x20\x01(\x06R\x0bsteamIdUser\
    \x12!\n\x0cpersona_name\x18\x04\x20\x01(\tR\x0bpersonaName\"\x8c\x01\n\
    \x1aCMsgClientMMSInviteToLobby\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\x0csteamIdLobby\
    \x121\n\x15steam_id_user_invited\x18\x03\x20\x01(\x06R\x12steamIdUserInv\
    ited\"\xae\x01\n\x1bCMsgClientMMSGetLobbyStatus\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01(\x06R\
    \x0csteamIdLobby\x12)\n\x10claim_membership\x18\x03\x20\x01(\x08R\x0fcla\
    imMembership\x12'\n\x0fclaim_ownership\x18\x04\x20\x01(\x08R\x0eclaimOwn\
    ership\"\xb1\x01\n#CMsgClientMMSGetLobbyStatusResponse\x12\x15\n\x06app_\
    id\x18\x01\x20\x01(\rR\x05appId\x12$\n\x0esteam_id_lobby\x18\x02\x20\x01\
    (\x06R\x0csteamIdLobby\x12M\n\x0clobby_status\x18\x03\x20\x01(\x0e2\x10.\
    EMMSLobbyStatus:\x18k_EMMSLobbyStatusInvalidR\x0blobbyStatus\"\xa6\x01\n\
    \x16CMsgClientInviteToGame\x12\"\n\rsteam_id_dest\x18\x01\x20\x01(\x06R\
    \x0bsteamIdDest\x12\x20\n\x0csteam_id_src\x18\x02\x20\x01(\x06R\nsteamId\
    Src\x12%\n\x0econnect_string\x18\x03\x20\x01(\tR\rconnectString\x12\x1f\
    \n\x0bremote_play\x18\x04\x20\x01(\tR\nremotePlay\"\x98\x02\n\x14CMsgCli\
    entChatInvite\x12(\n\x10steam_id_invited\x18\x01\x20\x01(\x06R\x0esteamI\
    dInvited\x12\"\n\rsteam_id_chat\x18\x02\x20\x01(\x06R\x0bsteamIdChat\x12\
    &\n\x0fsteam_id_patron\x18\x03\x20\x01(\x06R\rsteamIdPatron\x12#\n\rchat\
    room_type\x18\x04\x20\x01(\x05R\x0cchatroomType\x12/\n\x14steam_id_frien\
    d_chat\x18\x05\x20\x01(\x06R\x11steamIdFriendChat\x12\x1b\n\tchat_name\
    \x18\x06\x20\x01(\tR\x08chatName\x12\x17\n\x07game_id\x18\x07\x20\x01(\
    \x06R\x06gameId\"\x93\x0c\n\x19CMsgClientConnectionStats\x12G\n\x0bstats\
    _logon\x18\x01\x20\x01(\x0b2&.CMsgClientConnectionStats.Stats_LogonR\nst\
    atsLogon\x12G\n\x0bstats_vconn\x18\x02\x20\x01(\x0b2&.CMsgClientConnecti\
    onStats.Stats_VConnR\nstatsVconn\x1a\xc1\x02\n\x0bStats_Logon\x12)\n\x10\
    connect_attempts\x18\x01\x20\x01(\x05R\x0fconnectAttempts\x12+\n\x11conn\
    ect_successes\x18\x02\x20\x01(\x05R\x10connectSuccesses\x12)\n\x10connec\
    t_failures\x18\x03\x20\x01(\x05R\x0fconnectFailures\x12/\n\x13connection\
    s_dropped\x18\x04\x20\x01(\x05R\x12connectionsDropped\x12'\n\x0fseconds_\
    running\x18\x05\x20\x01(\rR\x0esecondsRunning\x121\n\x14msec_tologonthis\
    time\x18\x06\x20\x01(\rR\x13msecTologonthistime\x12\"\n\rcount_bad_cms\
    \x18\x07\x20\x01(\rR\x0bcountBadCms\x1a\xaa\x01\n\tStats_UDP\x12\x1b\n\t\
    pkts_sent\x18\x01\x20\x01(\x04R\x08pktsSent\x12\x1d\n\nbytes_sent\x18\
    \x02\x20\x01(\x04R\tbytesSent\x12\x1b\n\tpkts_recv\x18\x03\x20\x01(\x04R\
    \x08pktsRecv\x12%\n\x0epkts_processed\x18\x04\x20\x01(\x04R\rpktsProcess\
    ed\x12\x1d\n\nbytes_recv\x18\x05\x20\x01(\x04R\tbytesRecv\x1a\xf2\x06\n\
    \x0bStats_VConn\x12'\n\x0fconnections_udp\x18\x01\x20\x01(\rR\x0econnect\
    ionsUdp\x12'\n\x0fconnections_tcp\x18\x02\x20\x01(\rR\x0econnectionsTcp\
    \x12A\n\tstats_udp\x18\x03\x20\x01(\x0b2$.CMsgClientConnectionStats.Stat\
    s_UDPR\x08statsUdp\x12%\n\x0epkts_abandoned\x18\x04\x20\x01(\x04R\rpktsA\
    bandoned\x12*\n\x11conn_req_received\x18\x05\x20\x01(\x04R\x0fconnReqRec\
    eived\x12\x1f\n\x0bpkts_resent\x18\x06\x20\x01(\x04R\npktsResent\x12\x1b\
    \n\tmsgs_sent\x18\x07\x20\x01(\x04R\x08msgsSent\x12(\n\x10msgs_sent_fail\
    ed\x18\x08\x20\x01(\x04R\x0emsgsSentFailed\x12\x1b\n\tmsgs_recv\x18\t\
    \x20\x01(\x04R\x08msgsRecv\x12%\n\x0edatagrams_sent\x18\n\x20\x01(\x04R\
    \rdatagramsSent\x12%\n\x0edatagrams_recv\x18\x0b\x20\x01(\x04R\rdatagram\
    sRecv\x12\"\n\rbad_pkts_recv\x18\x0c\x20\x01(\x04R\x0bbadPktsRecv\x123\n\
    \x16unknown_conn_pkts_recv\x18\r\x20\x01(\x04R\x13unknownConnPktsRecv\
    \x12(\n\x10missed_pkts_recv\x18\x0e\x20\x01(\x04R\x0emissedPktsRecv\x12\
    \"\n\rdup_pkts_recv\x18\x0f\x20\x01(\x04R\x0bdupPktsRecv\x12:\n\x19faile\
    d_connect_challenges\x18\x10\x20\x01(\x04R\x17failedConnectChallenges\
    \x121\n\x15micro_sec_avg_latency\x18\x11\x20\x01(\rR\x12microSecAvgLaten\
    cy\x121\n\x15micro_sec_min_latency\x18\x12\x20\x01(\rR\x12microSecMinLat\
    ency\x121\n\x15micro_sec_max_latency\x18\x13\x20\x01(\rR\x12microSecMaxL\
    atency\x12,\n\x13mem_pool_msg_in_use\x18\x14\x20\x01(\rR\x0fmemPoolMsgIn\
    Use\"\x94\x02\n\x1aCMsgClientServersAvailable\x12h\n\x16server_types_ava\
    ilable\x18\x01\x20\x03(\x0b22.CMsgClientServersAvailable.Server_Types_Av\
    ailableR\x14serverTypesAvailable\x12@\n\x1dserver_type_for_auth_services\
    \x18\x02\x20\x01(\rR\x19serverTypeForAuthServices\x1aJ\n\x16Server_Types\
    _Available\x12\x16\n\x06server\x18\x01\x20\x01(\rR\x06server\x12\x18\n\
    \x07changed\x18\x02\x20\x01(\x08R\x07changed\"\xab\x01\n\x16CMsgClientGe\
    tUserStats\x12\x17\n\x07game_id\x18\x01\x20\x01(\x06R\x06gameId\x12\x1b\
    \n\tcrc_stats\x18\x02\x20\x01(\rR\x08crcStats\x120\n\x14schema_local_ver\
    sion\x18\x03\x20\x01(\x05R\x12schemaLocalVersion\x12)\n\x11steam_id_for_\
    user\x18\x04\x20\x01(\x06R\x0esteamIdForUser\"\xca\x03\n\x1eCMsgClientGe\
    tUserStatsResponse\x12\x17\n\x07game_id\x18\x01\x20\x01(\x06R\x06gameId\
    \x12\x1b\n\x07eresult\x18\x02\x20\x01(\x05:\x012R\x07eresult\x12\x1b\n\t\
    crc_stats\x18\x03\x20\x01(\rR\x08crcStats\x12\x16\n\x06schema\x18\x04\
    \x20\x01(\x0cR\x06schema\x12;\n\x05stats\x18\x05\x20\x03(\x0b2%.CMsgClie\
    ntGetUserStatsResponse.StatsR\x05stats\x12a\n\x12achievement_blocks\x18\
    \x06\x20\x03(\x0b22.CMsgClientGetUserStatsResponse.Achievement_BlocksR\
    \x11achievementBlocks\x1a?\n\x05Stats\x12\x17\n\x07stat_id\x18\x01\x20\
    \x01(\rR\x06statId\x12\x1d\n\nstat_value\x18\x02\x20\x01(\rR\tstatValue\
    \x1a\\\n\x12Achievement_Blocks\x12%\n\x0eachievement_id\x18\x01\x20\x01(\
    \rR\rachievementId\x12\x1f\n\x0bunlock_time\x18\x02\x20\x03(\x07R\nunloc\
    kTime\"\xf7\x02\n\x20CMsgClientStoreUserStatsResponse\x12\x17\n\x07game_\
    id\x18\x01\x20\x01(\x06R\x06gameId\x12\x1b\n\x07eresult\x18\x02\x20\x01(\
    \x05:\x012R\x07eresult\x12\x1b\n\tcrc_stats\x18\x03\x20\x01(\rR\x08crcSt\
    ats\x12q\n\x17stats_failed_validation\x18\x04\x20\x03(\x0b29.CMsgClientS\
    toreUserStatsResponse.Stats_Failed_ValidationR\x15statsFailedValidation\
    \x12)\n\x11stats_out_of_date\x18\x05\x20\x01(\x08R\x0estatsOutOfDate\x1a\
    b\n\x17Stats_Failed_Validation\x12\x17\n\x07stat_id\x18\x01\x20\x01(\rR\
    \x06statId\x12.\n\x13reverted_stat_value\x18\x02\x20\x01(\rR\x11reverted\
    StatValue\"\xc1\x02\n\x19CMsgClientStoreUserStats2\x12\x17\n\x07game_id\
    \x18\x01\x20\x01(\x06R\x06gameId\x12&\n\x0fsettor_steam_id\x18\x02\x20\
    \x01(\x06R\rsettorSteamId\x12&\n\x0fsettee_steam_id\x18\x03\x20\x01(\x06\
    R\rsetteeSteamId\x12\x1b\n\tcrc_stats\x18\x04\x20\x01(\rR\x08crcStats\
    \x12%\n\x0eexplicit_reset\x18\x05\x20\x01(\x08R\rexplicitReset\x126\n\
    \x05stats\x18\x06\x20\x03(\x0b2\x20.CMsgClientStoreUserStats2.StatsR\x05\
    stats\x1a?\n\x05Stats\x12\x17\n\x07stat_id\x18\x01\x20\x01(\rR\x06statId\
    \x12\x1d\n\nstat_value\x18\x02\x20\x01(\rR\tstatValue\"\xfe\x01\n\x16CMs\
    gClientStatsUpdated\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steam\
    Id\x12\x17\n\x07game_id\x18\x02\x20\x01(\x06R\x06gameId\x12\x1b\n\tcrc_s\
    tats\x18\x03\x20\x01(\rR\x08crcStats\x12J\n\rupdated_stats\x18\x04\x20\
    \x03(\x0b2%.CMsgClientStatsUpdated.Updated_StatsR\x0cupdatedStats\x1aG\n\
    \rUpdated_Stats\x12\x17\n\x07stat_id\x18\x01\x20\x01(\rR\x06statId\x12\
    \x1d\n\nstat_value\x18\x02\x20\x01(\rR\tstatValue\"\xf4\x01\n\x18CMsgCli\
    entStoreUserStats\x12\x17\n\x07game_id\x18\x01\x20\x01(\x06R\x06gameId\
    \x12%\n\x0eexplicit_reset\x18\x02\x20\x01(\x08R\rexplicitReset\x12N\n\
    \x0estats_to_store\x18\x03\x20\x03(\x0b2(.CMsgClientStoreUserStats.Stats\
    _To_StoreR\x0cstatsToStore\x1aH\n\x0eStats_To_Store\x12\x17\n\x07stat_id\
    \x18\x01\x20\x01(\rR\x06statId\x12\x1d\n\nstat_value\x18\x02\x20\x01(\rR\
    \tstatValue\"\x1c\n\x1aCMsgClientGetClientDetails\"O\n$CMsgClientReportO\
    verlayDetourFailure\x12'\n\x0ffailure_strings\x18\x01\x20\x03(\tR\x0efai\
    lureStrings\"\xc6\x03\n\"CMsgClientGetClientDetailsResponse\x12'\n\x0fpa\
    ckage_version\x18\x01\x20\x01(\rR\x0epackageVersion\x12)\n\x10protocol_v\
    ersion\x18\x08\x20\x01(\rR\x0fprotocolVersion\x12\x0e\n\x02os\x18\x02\
    \x20\x01(\tR\x02os\x12!\n\x0cmachine_name\x18\x03\x20\x01(\tR\x0bmachine\
    Name\x12\x1b\n\tip_public\x18\x04\x20\x01(\tR\x08ipPublic\x12\x1d\n\nip_\
    private\x18\x05\x20\x01(\tR\tipPrivate\x12'\n\x0fbytes_available\x18\x07\
    \x20\x01(\x04R\x0ebytesAvailable\x12M\n\rgames_running\x18\x06\x20\x03(\
    \x0b2(.CMsgClientGetClientDetailsResponse.GameR\x0cgamesRunning\x1ae\n\
    \x04Game\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1d\n\nextr\
    a_info\x18\x02\x20\x01(\tR\textraInfo\x12(\n\x10time_running_sec\x18\x03\
    \x20\x01(\rR\x0etimeRunningSec\"\xc2\x01\n\x1aCMsgClientGetClientAppList\
    \x12\x14\n\x05media\x18\x01\x20\x01(\x08R\x05media\x12\x14\n\x05tools\
    \x18\x02\x20\x01(\x08R\x05tools\x12\x14\n\x05games\x18\x03\x20\x01(\x08R\
    \x05games\x12%\n\x0eonly_installed\x18\x04\x20\x01(\x08R\ronlyInstalled\
    \x12#\n\ronly_changing\x18\x05\x20\x01(\x08R\x0conlyChanging\x12\x16\n\
    \x06comics\x18\x06\x20\x01(\x08R\x06comics\"\xf5\x05\n\"CMsgClientGetCli\
    entAppListResponse\x12;\n\x04apps\x18\x01\x20\x03(\x0b2'.CMsgClientGetCl\
    ientAppListResponse.AppR\x04apps\x12'\n\x0fbytes_available\x18\x02\x20\
    \x01(\x04R\x0ebytesAvailable\x1a\xe8\x04\n\x03App\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12\x1a\n\x08category\x18\x02\x20\x01(\tR\x08c\
    ategory\x12\x19\n\x08app_type\x18\n\x20\x01(\tR\x07appType\x12\x1a\n\x08\
    favorite\x18\x03\x20\x01(\x08R\x08favorite\x12\x1c\n\tinstalled\x18\x04\
    \x20\x01(\x08R\tinstalled\x12\x1f\n\x0bauto_update\x18\x05\x20\x01(\x08R\
    \nautoUpdate\x12)\n\x10bytes_downloaded\x18\x06\x20\x01(\x04R\x0fbytesDo\
    wnloaded\x12!\n\x0cbytes_needed\x18\x07\x20\x01(\x04R\x0bbytesNeeded\x12\
    .\n\x13bytes_download_rate\x18\x08\x20\x01(\rR\x11bytesDownloadRate\x12'\
    \n\x0fdownload_paused\x18\x0b\x20\x01(\x08R\x0edownloadPaused\x12'\n\x0f\
    num_downloading\x18\x0c\x20\x01(\rR\x0enumDownloading\x12\x1d\n\nnum_pau\
    sed\x18\r\x20\x01(\rR\tnumPaused\x12\x1a\n\x08changing\x18\x0e\x20\x01(\
    \x08R\x08changing\x122\n\x15available_on_platform\x18\x0f\x20\x01(\x08R\
    \x13availableOnPlatform\x12?\n\x04dlcs\x18\t\x20\x03(\x0b2+.CMsgClientGe\
    tClientAppListResponse.App.DLCR\x04dlcs\x1a9\n\x03DLC\x12\x14\n\x05appid\
    \x18\x01\x20\x01(\rR\x05appid\x12\x1c\n\tinstalled\x18\x02\x20\x01(\x08R\
    \tinstalled\"2\n\x1aCMsgClientInstallClientApp\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\"<\n\"CMsgClientInstallClientAppResponse\x12\
    \x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"4\n\x1cCMsgClientUninsta\
    llClientApp\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\">\n$CMsgCli\
    entUninstallClientAppResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\
    \x06result\"Q\n!CMsgClientSetClientAppUpdateState\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12\x16\n\x06update\x18\x02\x20\x01(\x08R\x06u\
    pdate\"C\n)CMsgClientSetClientAppUpdateStateResponse\x12\x16\n\x06result\
    \x18\x01\x20\x01(\rR\x06result\"\x82\x03\n\x1eCMsgClientUFSUploadFileReq\
    uest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile_si\
    ze\x18\x02\x20\x01(\rR\x08fileSize\x12\"\n\rraw_file_size\x18\x03\x20\
    \x01(\rR\x0brawFileSize\x12\x19\n\x08sha_file\x18\x04\x20\x01(\x0cR\x07s\
    haFile\x12\x1d\n\ntime_stamp\x18\x05\x20\x01(\x04R\ttimeStamp\x12\x1b\n\
    \tfile_name\x18\x06\x20\x01(\tR\x08fileName\x12?\n\x1cplatforms_to_sync_\
    deprecated\x18\x07\x20\x01(\rR\x19platformsToSyncDeprecated\x126\n\x11pl\
    atforms_to_sync\x18\x08\x20\x01(\r:\n4294967295R\x0fplatformsToSync\x12\
    \x17\n\x07cell_id\x18\t\x20\x01(\rR\x06cellId\x12\x1f\n\x0bcan_encrypt\
    \x18\n\x20\x01(\x08R\ncanEncrypt\"\x8b\x02\n\x1fCMsgClientUFSUploadFileR\
    esponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\
    \x19\n\x08sha_file\x18\x02\x20\x01(\x0cR\x07shaFile\x12\x19\n\x08use_htt\
    p\x18\x03\x20\x01(\x08R\x07useHttp\x12\x1b\n\thttp_host\x18\x04\x20\x01(\
    \tR\x08httpHost\x12\x19\n\x08http_url\x18\x05\x20\x01(\tR\x07httpUrl\x12\
    \x1d\n\nkv_headers\x18\x06\x20\x01(\x0cR\tkvHeaders\x12\x1b\n\tuse_https\
    \x18\x07\x20\x01(\x08R\x08useHttps\x12!\n\x0cencrypt_file\x18\x08\x20\
    \x01(\x08R\x0bencryptFile\"\xe2\x01\n\x19CMsgClientUFSUploadCommit\x125\
    \n\x05files\x18\x01\x20\x03(\x0b2\x1f.CMsgClientUFSUploadCommit.FileR\
    \x05files\x1a\x8d\x01\n\x04File\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\
    \x12\x19\n\x08sha_file\x18\x03\x20\x01(\x0cR\x07shaFile\x12\x19\n\x08cub\
    _file\x18\x04\x20\x01(\rR\x07cubFile\x12\x1b\n\tfile_name\x18\x05\x20\
    \x01(\tR\x08fileName\"\xb9\x01\n!CMsgClientUFSUploadCommitResponse\x12=\
    \n\x05files\x18\x01\x20\x03(\x0b2'.CMsgClientUFSUploadCommitResponse.Fil\
    eR\x05files\x1aU\n\x04File\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\
    \x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12\
    \x19\n\x08sha_file\x18\x03\x20\x01(\x0cR\x07shaFile\"f\n\x16CMsgClientUF\
    SFileChunk\x12\x19\n\x08sha_file\x18\x01\x20\x01(\x0cR\x07shaFile\x12\
    \x1d\n\nfile_start\x18\x02\x20\x01(\rR\tfileStart\x12\x12\n\x04data\x18\
    \x03\x20\x01(\x0cR\x04data\"\x20\n\x1eCMsgClientUFSTransferHeartbeat\"Y\
    \n\x1fCMsgClientUFSUploadFileFinished\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12\x19\n\x08sha_file\x18\x02\x20\x01(\x0cR\
    \x07shaFile\"\x82\x01\n\x1eCMsgClientUFSDeleteFileRequest\x12\x15\n\x06a\
    pp_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\
    \tR\x08fileName\x12,\n\x12is_explicit_delete\x18\x03\x20\x01(\x08R\x10is\
    ExplicitDelete\"[\n\x1fCMsgClientUFSDeleteFileResponse\x12\x1b\n\x07eres\
    ult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x1b\n\tfile_name\x18\x02\
    \x20\x01(\tR\x08fileName\"r\n\x1eCMsgClientUFSGetFileListForApp\x12\"\n\
    \rapps_to_query\x18\x01\x20\x03(\rR\x0bappsToQuery\x12,\n\x12send_path_p\
    refixes\x18\x02\x20\x01(\x08R\x10sendPathPrefixes\"\xbc\x03\n&CMsgClient\
    UFSGetFileListForAppResponse\x12B\n\x05files\x18\x01\x20\x03(\x0b2,.CMsg\
    ClientUFSGetFileListForAppResponse.FileR\x05files\x12#\n\rpath_prefixes\
    \x18\x02\x20\x03(\tR\x0cpathPrefixes\x1a\x9e\x02\n\x04File\x12\x15\n\x06\
    app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01\
    (\tR\x08fileName\x12\x19\n\x08sha_file\x18\x03\x20\x01(\x0cR\x07shaFile\
    \x12\x1d\n\ntime_stamp\x18\x04\x20\x01(\x04R\ttimeStamp\x12\"\n\rraw_fil\
    e_size\x18\x05\x20\x01(\rR\x0brawFileSize\x12,\n\x12is_explicit_delete\
    \x18\x06\x20\x01(\x08R\x10isExplicitDelete\x12*\n\x11platforms_to_sync\
    \x18\x07\x20\x01(\rR\x0fplatformsToSync\x12*\n\x11path_prefix_index\x18\
    \x08\x20\x01(\rR\x0fpathPrefixIndex:\x08\x80\xb5\x18\x08\x88\xb5\x18\x10\
    \"z\n\x1cCMsgClientUFSDownloadRequest\x12\x15\n\x06app_id\x18\x01\x20\
    \x01(\rR\x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\
    \x12&\n\x0fcan_handle_http\x18\x03\x20\x01(\x08R\rcanHandleHttp\"\xa9\
    \x03\n\x1dCMsgClientUFSDownloadResponse\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05a\
    ppId\x12\x1b\n\tfile_size\x18\x03\x20\x01(\rR\x08fileSize\x12\"\n\rraw_f\
    ile_size\x18\x04\x20\x01(\rR\x0brawFileSize\x12\x19\n\x08sha_file\x18\
    \x05\x20\x01(\x0cR\x07shaFile\x12\x1d\n\ntime_stamp\x18\x06\x20\x01(\x04\
    R\ttimeStamp\x12,\n\x12is_explicit_delete\x18\x07\x20\x01(\x08R\x10isExp\
    licitDelete\x12\x19\n\x08use_http\x18\x08\x20\x01(\x08R\x07useHttp\x12\
    \x1b\n\thttp_host\x18\t\x20\x01(\tR\x08httpHost\x12\x19\n\x08http_url\
    \x18\n\x20\x01(\tR\x07httpUrl\x12\x1d\n\nkv_headers\x18\x0b\x20\x01(\x0c\
    R\tkvHeaders\x12\x1b\n\tuse_https\x18\x0c\x20\x01(\x08R\x08useHttps\x12\
    \x1c\n\tencrypted\x18\r\x20\x01(\x08R\tencrypted\"\x84\x01\n\x19CMsgClie\
    ntUFSLoginRequest\x12)\n\x10protocol_version\x18\x01\x20\x01(\rR\x0fprot\
    ocolVersion\x12(\n\x10am_session_token\x18\x02\x20\x01(\x04R\x0eamSessio\
    nToken\x12\x12\n\x04apps\x18\x03\x20\x03(\rR\x04apps\"9\n\x1aCMsgClientU\
    FSLoginResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eres\
    ult\"X\n#CMsgClientRequestEncryptedAppTicket\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12\x1a\n\x08userdata\x18\x02\x20\x01(\x0cR\x08use\
    rdata\"\xa8\x01\n+CMsgClientRequestEncryptedAppTicketResponse\x12\x15\n\
    \x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\x07eresult\x18\x02\x20\
    \x01(\x05:\x012R\x07eresult\x12E\n\x14encrypted_app_ticket\x18\x03\x20\
    \x01(\x0b2\x13.EncryptedAppTicketR\x12encryptedAppTicket\"\xf1\x01\n\x1a\
    CMsgClientWalletInfoUpdate\x12\x1d\n\nhas_wallet\x18\x01\x20\x01(\x08R\t\
    hasWallet\x12\x18\n\x07balance\x18\x02\x20\x01(\x05R\x07balance\x12\x1a\
    \n\x08currency\x18\x03\x20\x01(\x05R\x08currency\x12'\n\x0fbalance_delay\
    ed\x18\x04\x20\x01(\x05R\x0ebalanceDelayed\x12\"\n\tbalance64\x18\x05\
    \x20\x01(\x03R\tbalance64B\x04\xa0\xb6\x18\x01\x121\n\x11balance64_delay\
    ed\x18\x06\x20\x01(\x03R\x10balance64DelayedB\x04\xa0\xb6\x18\x01\"o\n\
    \x17CMsgClientAppInfoUpdate\x12+\n\x11last_changenumber\x18\x01\x20\x01(\
    \rR\x10lastChangenumber\x12'\n\x0fsend_changelist\x18\x02\x20\x01(\x08R\
    \x0esendChangelist\"\x92\x01\n\x18CMsgClientAppInfoChanges\x122\n\x15cur\
    rent_change_number\x18\x01\x20\x01(\rR\x13currentChangeNumber\x12*\n\x11\
    force_full_update\x18\x02\x20\x01(\x08R\x0fforceFullUpdate\x12\x16\n\x06\
    appIDs\x18\x03\x20\x03(\rR\x06appIDs\"\xe3\x01\n\x18CMsgClientAppInfoReq\
    uest\x121\n\x04apps\x18\x01\x20\x03(\x0b2\x1d.CMsgClientAppInfoRequest.A\
    ppR\x04apps\x120\n\x10supports_batches\x18\x02\x20\x01(\x08:\x05falseR\
    \x0fsupportsBatches\x1ab\n\x03App\x12\x15\n\x06app_id\x18\x01\x20\x01(\r\
    R\x05appId\x12#\n\rsection_flags\x18\x02\x20\x01(\rR\x0csectionFlags\x12\
    \x1f\n\x0bsection_CRC\x18\x03\x20\x03(\rR\nsectionCRC\"\xf0\x02\n\x19CMs\
    gClientAppInfoResponse\x122\n\x04apps\x18\x01\x20\x03(\x0b2\x1e.CMsgClie\
    ntAppInfoResponse.AppR\x04apps\x12!\n\x0capps_unknown\x18\x02\x20\x03(\r\
    R\x0bappsUnknown\x12!\n\x0capps_pending\x18\x03\x20\x01(\rR\x0bappsPendi\
    ng\x1a\xce\x01\n\x03App\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\
    \x12#\n\rchange_number\x18\x02\x20\x01(\rR\x0cchangeNumber\x12B\n\x08sec\
    tions\x18\x03\x20\x03(\x0b2&.CMsgClientAppInfoResponse.App.SectionR\x08s\
    ections\x1aG\n\x07Section\x12\x1d\n\nsection_id\x18\x01\x20\x01(\rR\tsec\
    tionId\x12\x1d\n\nsection_kv\x18\x02\x20\x01(\x0cR\tsectionKv:\x08\x88\
    \xb5\x18\0\x80\xb5\x18\0\"e\n\x1cCMsgClientPackageInfoRequest\x12\x1f\n\
    \x0bpackage_ids\x18\x01\x20\x03(\rR\npackageIds\x12$\n\x0emeta_data_only\
    \x18\x02\x20\x01(\x08R\x0cmetaDataOnly\"\xb2\x02\n\x1dCMsgClientPackageI\
    nfoResponse\x12B\n\x08packages\x18\x01\x20\x03(\x0b2&.CMsgClientPackageI\
    nfoResponse.PackageR\x08packages\x12)\n\x10packages_unknown\x18\x02\x20\
    \x03(\rR\x0fpackagesUnknown\x12)\n\x10packages_pending\x18\x03\x20\x01(\
    \rR\x0fpackagesPending\x1aw\n\x07Package\x12\x1d\n\npackage_id\x18\x01\
    \x20\x01(\rR\tpackageId\x12#\n\rchange_number\x18\x02\x20\x01(\rR\x0ccha\
    ngeNumber\x12\x10\n\x03sha\x18\x03\x20\x01(\x0cR\x03sha\x12\x16\n\x06buf\
    fer\x18\x04\x20\x01(\x0cR\x06buffer\"\xa7\x02\n!CMsgClientPICSChangesSin\
    ceRequest\x12.\n\x13since_change_number\x18\x01\x20\x01(\rR\x11sinceChan\
    geNumber\x121\n\x15send_app_info_changes\x18\x02\x20\x01(\x08R\x12sendAp\
    pInfoChanges\x129\n\x19send_package_info_changes\x18\x03\x20\x01(\x08R\
    \x16sendPackageInfoChanges\x12-\n\x13num_app_info_cached\x18\x04\x20\x01\
    (\rR\x10numAppInfoCached\x125\n\x17num_package_info_cached\x18\x05\x20\
    \x01(\rR\x14numPackageInfoCached\"\xac\x05\n\"CMsgClientPICSChangesSince\
    Response\x122\n\x15current_change_number\x18\x01\x20\x01(\rR\x13currentC\
    hangeNumber\x12.\n\x13since_change_number\x18\x02\x20\x01(\rR\x11sinceCh\
    angeNumber\x12*\n\x11force_full_update\x18\x03\x20\x01(\x08R\x0fforceFul\
    lUpdate\x12Z\n\x0fpackage_changes\x18\x04\x20\x03(\x0b21.CMsgClientPICSC\
    hangesSinceResponse.PackageChangeR\x0epackageChanges\x12N\n\x0bapp_chang\
    es\x18\x05\x20\x03(\x0b2-.CMsgClientPICSChangesSinceResponse.AppChangeR\
    \nappChanges\x121\n\x15force_full_app_update\x18\x06\x20\x01(\x08R\x12fo\
    rceFullAppUpdate\x129\n\x19force_full_package_update\x18\x07\x20\x01(\
    \x08R\x16forceFullPackageUpdate\x1as\n\rPackageChange\x12\x1c\n\tpackage\
    id\x18\x01\x20\x01(\rR\tpackageid\x12#\n\rchange_number\x18\x02\x20\x01(\
    \rR\x0cchangeNumber\x12\x1f\n\x0bneeds_token\x18\x03\x20\x01(\x08R\nneed\
    sToken\x1ag\n\tAppChange\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \x12#\n\rchange_number\x18\x02\x20\x01(\rR\x0cchangeNumber\x12\x1f\n\x0b\
    needs_token\x18\x03\x20\x01(\x08R\nneedsToken\"\xaf\x03\n\x20CMsgClientP\
    ICSProductInfoRequest\x12I\n\x08packages\x18\x01\x20\x03(\x0b2-.CMsgClie\
    ntPICSProductInfoRequest.PackageInfoR\x08packages\x12=\n\x04apps\x18\x02\
    \x20\x03(\x0b2).CMsgClientPICSProductInfoRequest.AppInfoR\x04apps\x12$\n\
    \x0emeta_data_only\x18\x03\x20\x01(\x08R\x0cmetaDataOnly\x12&\n\x0fnum_p\
    rev_failed\x18\x04\x20\x01(\rR\rnumPrevFailed\x1ac\n\x07AppInfo\x12\x14\
    \n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12!\n\x0caccess_token\x18\x02\
    \x20\x01(\x04R\x0baccessToken\x12\x1f\n\x0bonly_public\x18\x03\x20\x01(\
    \x08R\nonlyPublic\x1aN\n\x0bPackageInfo\x12\x1c\n\tpackageid\x18\x01\x20\
    \x01(\rR\tpackageid\x12!\n\x0caccess_token\x18\x02\x20\x01(\x04R\x0bacce\
    ssToken\"\xa2\x06\n!CMsgClientPICSProductInfoResponse\x12>\n\x04apps\x18\
    \x01\x20\x03(\x0b2*.CMsgClientPICSProductInfoResponse.AppInfoR\x04apps\
    \x12%\n\x0eunknown_appids\x18\x02\x20\x03(\rR\runknownAppids\x12J\n\x08p\
    ackages\x18\x03\x20\x03(\x0b2..CMsgClientPICSProductInfoResponse.Package\
    InfoR\x08packages\x12-\n\x12unknown_packageids\x18\x04\x20\x03(\rR\x11un\
    knownPackageids\x12$\n\x0emeta_data_only\x18\x05\x20\x01(\x08R\x0cmetaDa\
    taOnly\x12)\n\x10response_pending\x18\x06\x20\x01(\x08R\x0fresponsePendi\
    ng\x12\"\n\rhttp_min_size\x18\x07\x20\x01(\rR\x0bhttpMinSize\x12\x1b\n\t\
    http_host\x18\x08\x20\x01(\tR\x08httpHost\x1a\xc8\x01\n\x07AppInfo\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12#\n\rchange_number\x18\
    \x02\x20\x01(\rR\x0cchangeNumber\x12#\n\rmissing_token\x18\x03\x20\x01(\
    \x08R\x0cmissingToken\x12\x10\n\x03sha\x18\x04\x20\x01(\x0cR\x03sha\x12\
    \x16\n\x06buffer\x18\x05\x20\x01(\x0cR\x06buffer\x12\x1f\n\x0bonly_publi\
    c\x18\x06\x20\x01(\x08R\nonlyPublic\x12\x12\n\x04size\x18\x07\x20\x01(\r\
    R\x04size\x1a\xb3\x01\n\x0bPackageInfo\x12\x1c\n\tpackageid\x18\x01\x20\
    \x01(\rR\tpackageid\x12#\n\rchange_number\x18\x02\x20\x01(\rR\x0cchangeN\
    umber\x12#\n\rmissing_token\x18\x03\x20\x01(\x08R\x0cmissingToken\x12\
    \x10\n\x03sha\x18\x04\x20\x01(\x0cR\x03sha\x12\x16\n\x06buffer\x18\x05\
    \x20\x01(\x0cR\x06buffer\x12\x12\n\x04size\x18\x06\x20\x01(\rR\x04size:\
    \x08\x80\xb5\x18\0\x88\xb5\x18\0\"Z\n\x20CMsgClientPICSAccessTokenReques\
    t\x12\x1e\n\npackageids\x18\x01\x20\x03(\rR\npackageids\x12\x16\n\x06app\
    ids\x18\x02\x20\x03(\rR\x06appids\"\xd7\x03\n!CMsgClientPICSAccessTokenR\
    esponse\x12c\n\x15package_access_tokens\x18\x01\x20\x03(\x0b2/.CMsgClien\
    tPICSAccessTokenResponse.PackageTokenR\x13packageAccessTokens\x122\n\x15\
    package_denied_tokens\x18\x02\x20\x03(\rR\x13packageDeniedTokens\x12W\n\
    \x11app_access_tokens\x18\x03\x20\x03(\x0b2+.CMsgClientPICSAccessTokenRe\
    sponse.AppTokenR\x0fappAccessTokens\x12*\n\x11app_denied_tokens\x18\x04\
    \x20\x03(\rR\x0fappDeniedTokens\x1aO\n\x0cPackageToken\x12\x1c\n\tpackag\
    eid\x18\x01\x20\x01(\rR\tpackageid\x12!\n\x0caccess_token\x18\x02\x20\
    \x01(\x04R\x0baccessToken\x1aC\n\x08AppToken\x12\x14\n\x05appid\x18\x01\
    \x20\x01(\rR\x05appid\x12!\n\x0caccess_token\x18\x02\x20\x01(\x04R\x0bac\
    cessToken\"N\n\x1aCMsgClientUFSGetUGCDetails\x120\n\x08hcontent\x18\x01\
    \x20\x01(\x06:\x1418446744073709551615R\x08hcontent\"\xd3\x02\n\"CMsgCli\
    entUFSGetUGCDetailsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\
    \x012R\x07eresult\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x15\n\
    \x06app_id\x18\x03\x20\x01(\rR\x05appId\x12\x1a\n\x08filename\x18\x04\
    \x20\x01(\tR\x08filename\x12'\n\x0fsteamid_creator\x18\x05\x20\x01(\x06R\
    \x0esteamidCreator\x12\x1b\n\tfile_size\x18\x06\x20\x01(\rR\x08fileSize\
    \x120\n\x14compressed_file_size\x18\x07\x20\x01(\rR\x12compressedFileSiz\
    e\x12'\n\x0frangecheck_host\x18\x08\x20\x01(\tR\x0erangecheckHost\x12*\n\
    \x11file_encoded_sha1\x18\t\x20\x01(\tR\x0ffileEncodedSha1\"T\n\x1eCMsgC\
    lientUFSGetSingleFileInfo\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05app\
    Id\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\"\x85\x02\n&CMsg\
    ClientUFSGetSingleFileInfoResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\
    \x12\x1b\n\tfile_name\x18\x03\x20\x01(\tR\x08fileName\x12\x19\n\x08sha_f\
    ile\x18\x04\x20\x01(\x0cR\x07shaFile\x12\x1d\n\ntime_stamp\x18\x05\x20\
    \x01(\x04R\ttimeStamp\x12\"\n\rraw_file_size\x18\x06\x20\x01(\rR\x0brawF\
    ileSize\x12,\n\x12is_explicit_delete\x18\x07\x20\x01(\x08R\x10isExplicit\
    Delete\"L\n\x16CMsgClientUFSShareFile\x12\x15\n\x06app_id\x18\x01\x20\
    \x01(\rR\x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\"\
    o\n\x1eCMsgClientUFSShareFileResponse\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x120\n\x08hcontent\x18\x02\x20\x01(\x06:\x14\
    18446744073709551615R\x08hcontent\"@\n\x1bCMsgClientAMGetClanOfficers\
    \x12!\n\x0csteamid_clan\x18\x01\x20\x01(\x06R\x0bsteamidClan\"\x8a\x01\n\
    #CMsgClientAMGetClanOfficersResponse\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12!\n\x0csteamid_clan\x18\x02\x20\x01(\x06R\
    \x0bsteamidClan\x12#\n\rofficer_count\x18\x03\x20\x01(\x05R\x0cofficerCo\
    unt\"\xa7\x01\n!CMsgClientAMGetPersonaNameHistory\x12\x19\n\x08id_count\
    \x18\x01\x20\x01(\x05R\x07idCount\x12?\n\x03Ids\x18\x02\x20\x03(\x0b2-.C\
    MsgClientAMGetPersonaNameHistory.IdInstanceR\x03Ids\x1a&\n\nIdInstance\
    \x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"\xf8\x02\n)CMsgC\
    lientAMGetPersonaNameHistoryResponse\x12Z\n\tresponses\x18\x02\x20\x03(\
    \x0b2<.CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstanceR\tres\
    ponses\x1a\xee\x01\n\x11NameTableInstance\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\x05:\x012R\x07eresult\x12\x18\n\x07steamid\x18\x02\x20\x01(\
    \x06R\x07steamid\x12_\n\x05names\x18\x03\x20\x03(\x0b2I.CMsgClientAMGetP\
    ersonaNameHistoryResponse.NameTableInstance.NameInstanceR\x05names\x1aA\
    \n\x0cNameInstance\x12\x1d\n\nname_since\x18\x01\x20\x01(\x07R\tnameSinc\
    e\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"Y\n\x1eCMsgClientDeregi\
    sterWithServer\x12\x20\n\x0beservertype\x18\x01\x20\x01(\rR\x0beserverty\
    pe\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\"\x81\x06\n\x13CMsgC\
    lientClanState\x12!\n\x0csteamid_clan\x18\x01\x20\x01(\x06R\x0bsteamidCl\
    an\x12,\n\x12clan_account_flags\x18\x03\x20\x01(\rR\x10clanAccountFlags\
    \x12:\n\tname_info\x18\x04\x20\x01(\x0b2\x1d.CMsgClientClanState.NameInf\
    oR\x08nameInfo\x12@\n\x0buser_counts\x18\x05\x20\x01(\x0b2\x1f.CMsgClien\
    tClanState.UserCountsR\nuserCounts\x122\n\x06events\x18\x06\x20\x03(\x0b\
    2\x1a.CMsgClientClanState.EventR\x06events\x12@\n\rannouncements\x18\x07\
    \x20\x03(\x0b2\x1a.CMsgClientClanState.EventR\rannouncements\x12*\n\x11c\
    hat_room_private\x18\x08\x20\x01(\x08R\x0fchatRoomPrivate\x1aF\n\x08Name\
    Info\x12\x1b\n\tclan_name\x18\x01\x20\x01(\tR\x08clanName\x12\x1d\n\nsha\
    _avatar\x18\x02\x20\x01(\x0cR\tshaAvatar\x1a\x9f\x01\n\nUserCounts\x12\
    \x18\n\x07members\x18\x01\x20\x01(\rR\x07members\x12\x16\n\x06online\x18\
    \x02\x20\x01(\rR\x06online\x12\x1a\n\x08chatting\x18\x03\x20\x01(\rR\x08\
    chatting\x12\x17\n\x07in_game\x18\x04\x20\x01(\rR\x06inGame\x12*\n\x11ch\
    at_room_members\x18\x05\x20\x01(\rR\x0fchatRoomMembers\x1a\x8e\x01\n\x05\
    Event\x12\x10\n\x03gid\x18\x01\x20\x01(\x06R\x03gid\x12\x1d\n\nevent_tim\
    e\x18\x02\x20\x01(\rR\teventTime\x12\x1a\n\x08headline\x18\x03\x20\x01(\
    \tR\x08headline\x12\x17\n\x07game_id\x18\x04\x20\x01(\x06R\x06gameId\x12\
    \x1f\n\x0bjust_posted\x18\x05\x20\x01(\x08R\njustPosted\"\xf8\x01\n\x1fC\
    MsgClientUnsignedInstallScript\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\x12\x1b\n\
    \tfile_size\x18\x03\x20\x01(\rR\x08fileSize\x12)\n\x10signature_broken\
    \x18\x04\x20\x01(\x08R\x0fsignatureBroken\x12\x19\n\x08depot_id\x18\x05\
    \x20\x01(\rR\x07depotId\x12\x1f\n\x0bmanifest_id\x18\x06\x20\x01(\x04R\n\
    manifestId\x12\x1d\n\nfile_flags\x18\x07\x20\x01(\rR\tfileFlags*\x90\x01\
    \n\x0fEMMSLobbyStatus\x12\x1c\n\x18k_EMMSLobbyStatusInvalid\x10\0\x12\
    \x1b\n\x17k_EMMSLobbyStatusExists\x10\x01\x12!\n\x1dk_EMMSLobbyStatusDoe\
    sNotExist\x10\x02\x12\x1f\n\x1bk_EMMSLobbyStatusNotAMember\x10\x03B\x05H\
    \x01\x80\x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
