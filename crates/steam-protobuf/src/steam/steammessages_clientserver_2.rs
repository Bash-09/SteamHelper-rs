// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.10.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//! Generated file from `steammessages_clientserver_2.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMAddScreenshot {
    // message fields
    appid: ::std::option::Option<u32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    thumbname: ::protobuf::SingularField<::std::string::String>,
    vr_filename: ::protobuf::SingularField<::std::string::String>,
    rtime32_created: ::std::option::Option<u32>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    permissions: ::std::option::Option<u32>,
    caption: ::protobuf::SingularField<::std::string::String>,
    shortcut_name: ::protobuf::SingularField<::std::string::String>,
    pub tag: ::protobuf::RepeatedField<cmsg_client_ucmadd_screenshot::Tag>,
    pub tagged_steamid: ::std::vec::Vec<u64>,
    spoiler_tag: ::std::option::Option<bool>,
    pub tagged_publishedfileid: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshot {
    fn default() -> &'a CMsgClientUCMAddScreenshot {
        <CMsgClientUCMAddScreenshot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshot {
    pub fn new() -> CMsgClientUCMAddScreenshot {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string filename = 2;

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string thumbname = 3;

    pub fn get_thumbname(&self) -> &str {
        match self.thumbname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbname(&mut self) {
        self.thumbname.clear();
    }

    pub fn has_thumbname(&self) -> bool {
        self.thumbname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbname(&mut self, v: ::std::string::String) {
        self.thumbname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbname(&mut self) -> &mut ::std::string::String {
        if self.thumbname.is_none() {
            self.thumbname.set_default();
        }
        self.thumbname.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbname(&mut self) -> ::std::string::String {
        self.thumbname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string vr_filename = 14;

    pub fn get_vr_filename(&self) -> &str {
        match self.vr_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vr_filename(&mut self) {
        self.vr_filename.clear();
    }

    pub fn has_vr_filename(&self) -> bool {
        self.vr_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_filename(&mut self, v: ::std::string::String) {
        self.vr_filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_filename(&mut self) -> &mut ::std::string::String {
        if self.vr_filename.is_none() {
            self.vr_filename.set_default();
        }
        self.vr_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_filename(&mut self) -> ::std::string::String {
        self.vr_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 rtime32_created = 4;

    pub fn get_rtime32_created(&self) -> u32 {
        self.rtime32_created.unwrap_or(0)
    }

    pub fn clear_rtime32_created(&mut self) {
        self.rtime32_created = ::std::option::Option::None;
    }

    pub fn has_rtime32_created(&self) -> bool {
        self.rtime32_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_created(&mut self, v: u32) {
        self.rtime32_created = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 5;

    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 6;

    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 permissions = 7;

    pub fn get_permissions(&self) -> u32 {
        self.permissions.unwrap_or(0)
    }

    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u32) {
        self.permissions = ::std::option::Option::Some(v);
    }

    // optional string caption = 8;

    pub fn get_caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption.clear();
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption.set_default();
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shortcut_name = 9;

    pub fn get_shortcut_name(&self) -> &str {
        match self.shortcut_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shortcut_name(&mut self) {
        self.shortcut_name.clear();
    }

    pub fn has_shortcut_name(&self) -> bool {
        self.shortcut_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcut_name(&mut self, v: ::std::string::String) {
        self.shortcut_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortcut_name(&mut self) -> &mut ::std::string::String {
        if self.shortcut_name.is_none() {
            self.shortcut_name.set_default();
        }
        self.shortcut_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_shortcut_name(&mut self) -> ::std::string::String {
        self.shortcut_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool spoiler_tag = 12;

    pub fn get_spoiler_tag(&self) -> bool {
        self.spoiler_tag.unwrap_or(false)
    }

    pub fn clear_spoiler_tag(&mut self) {
        self.spoiler_tag = ::std::option::Option::None;
    }

    pub fn has_spoiler_tag(&self) -> bool {
        self.spoiler_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spoiler_tag(&mut self, v: bool) {
        self.spoiler_tag = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMAddScreenshot {
    fn is_initialized(&self) -> bool {
        for v in &self.tag {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbname)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vr_filename)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rtime32_created = ::std::option::Option::Some(is.read_fixed32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.permissions = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caption)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shortcut_name)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.tag)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.tagged_steamid)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.spoiler_tag = ::std::option::Option::Some(is.read_bool()?);
                },
                13 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.tagged_publishedfileid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.thumbname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.vr_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.rtime32_created {
            my_size += 5;
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permissions {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.shortcut_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.tag {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 9 * self.tagged_steamid.len() as u32;
        if let Some(v) = self.spoiler_tag {
            my_size += 2;
        }
        for value in &self.tagged_publishedfileid {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.thumbname.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.vr_filename.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.rtime32_created {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.permissions {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.shortcut_name.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.tag {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.tagged_steamid {
            os.write_fixed64(11, *v)?;
        };
        if let Some(v) = self.spoiler_tag {
            os.write_bool(12, v)?;
        }
        for v in &self.tagged_publishedfileid {
            os.write_uint64(13, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMAddScreenshot {
        CMsgClientUCMAddScreenshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CMsgClientUCMAddScreenshot| { &m.appid },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.appid },
                CMsgClientUCMAddScreenshot::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename",
                |m: &CMsgClientUCMAddScreenshot| { &m.filename },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.filename },
                CMsgClientUCMAddScreenshot::get_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "thumbname",
                |m: &CMsgClientUCMAddScreenshot| { &m.thumbname },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.thumbname },
                CMsgClientUCMAddScreenshot::get_thumbname,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "vr_filename",
                |m: &CMsgClientUCMAddScreenshot| { &m.vr_filename },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.vr_filename },
                CMsgClientUCMAddScreenshot::get_vr_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "rtime32_created",
                |m: &CMsgClientUCMAddScreenshot| { &m.rtime32_created },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.rtime32_created },
                CMsgClientUCMAddScreenshot::get_rtime32_created,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "width",
                |m: &CMsgClientUCMAddScreenshot| { &m.width },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.width },
                CMsgClientUCMAddScreenshot::get_width,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "height",
                |m: &CMsgClientUCMAddScreenshot| { &m.height },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.height },
                CMsgClientUCMAddScreenshot::get_height,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "permissions",
                |m: &CMsgClientUCMAddScreenshot| { &m.permissions },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.permissions },
                CMsgClientUCMAddScreenshot::get_permissions,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "caption",
                |m: &CMsgClientUCMAddScreenshot| { &m.caption },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.caption },
                CMsgClientUCMAddScreenshot::get_caption,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "shortcut_name",
                |m: &CMsgClientUCMAddScreenshot| { &m.shortcut_name },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.shortcut_name },
                CMsgClientUCMAddScreenshot::get_shortcut_name,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ucmadd_screenshot::Tag>>(
                "tag",
                |m: &CMsgClientUCMAddScreenshot| { &m.tag },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "tagged_steamid",
                |m: &CMsgClientUCMAddScreenshot| { &m.tagged_steamid },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tagged_steamid },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "spoiler_tag",
                |m: &CMsgClientUCMAddScreenshot| { &m.spoiler_tag },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.spoiler_tag },
                CMsgClientUCMAddScreenshot::get_spoiler_tag,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64>(
                "tagged_publishedfileid",
                |m: &CMsgClientUCMAddScreenshot| { &m.tagged_publishedfileid },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tagged_publishedfileid },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMAddScreenshot>(
                "CMsgClientUCMAddScreenshot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshot {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMAddScreenshot> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMAddScreenshot::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMAddScreenshot {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.filename.clear();
        self.thumbname.clear();
        self.vr_filename.clear();
        self.rtime32_created = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.permissions = ::std::option::Option::None;
        self.caption.clear();
        self.shortcut_name.clear();
        self.tag.clear();
        self.tagged_steamid.clear();
        self.spoiler_tag = ::std::option::Option::None;
        self.tagged_publishedfileid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMAddScreenshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMAddScreenshot {
}

/// Nested message and enums of message `CMsgClientUCMAddScreenshot`
pub mod cmsg_client_ucmadd_screenshot {
    #[derive(PartialEq,Clone,Default)]
    pub struct Tag {
        // message fields
        tag_name: ::protobuf::SingularField<::std::string::String>,
        tag_value: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional string tag_name = 1;

        pub fn get_tag_name(&self) -> &str {
            match self.tag_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tag_name(&mut self) {
            self.tag_name.clear();
        }

        pub fn has_tag_name(&self) -> bool {
            self.tag_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag_name(&mut self, v: ::std::string::String) {
            self.tag_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tag_name(&mut self) -> &mut ::std::string::String {
            if self.tag_name.is_none() {
                self.tag_name.set_default();
            }
            self.tag_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_tag_name(&mut self) -> ::std::string::String {
            self.tag_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string tag_value = 2;

        pub fn get_tag_value(&self) -> &str {
            match self.tag_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tag_value(&mut self) {
            self.tag_value.clear();
        }

        pub fn has_tag_value(&self) -> bool {
            self.tag_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag_value(&mut self, v: ::std::string::String) {
            self.tag_value = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tag_value(&mut self) -> &mut ::std::string::String {
            if self.tag_value.is_none() {
                self.tag_value.set_default();
            }
            self.tag_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_tag_value(&mut self) -> ::std::string::String {
            self.tag_value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Tag {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag_name)?;
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag_value)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.tag_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.tag_value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.tag_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.tag_value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "tag_name",
                    |m: &Tag| { &m.tag_name },
                    |m: &mut Tag| { &mut m.tag_name },
                    Tag::get_tag_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "tag_value",
                    |m: &Tag| { &m.tag_value },
                    |m: &mut Tag| { &mut m.tag_value },
                    Tag::get_tag_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Tag>(
                    "CMsgClientUCMAddScreenshot.Tag",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Tag {
            static instance: ::protobuf::rt::Lazy<Tag> = ::protobuf::rt::Lazy::INIT;
            instance.get(Tag::new)
        }
    }

    impl ::protobuf::Clear for Tag {
        fn clear(&mut self) {
            self.tag_name.clear();
            self.tag_value.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Tag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Tag {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMAddScreenshotResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    screenshotid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshotResponse {
    fn default() -> &'a CMsgClientUCMAddScreenshotResponse {
        <CMsgClientUCMAddScreenshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshotResponse {
    pub fn new() -> CMsgClientUCMAddScreenshotResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 screenshotid = 2;

    pub fn get_screenshotid(&self) -> u64 {
        self.screenshotid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_screenshotid(&mut self) {
        self.screenshotid = ::std::option::Option::None;
    }

    pub fn has_screenshotid(&self) -> bool {
        self.screenshotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshotid(&mut self, v: u64) {
        self.screenshotid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMAddScreenshotResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.screenshotid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenshotid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.screenshotid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMAddScreenshotResponse {
        CMsgClientUCMAddScreenshotResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMAddScreenshotResponse| { &m.eresult },
                |m: &mut CMsgClientUCMAddScreenshotResponse| { &mut m.eresult },
                CMsgClientUCMAddScreenshotResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "screenshotid",
                |m: &CMsgClientUCMAddScreenshotResponse| { &m.screenshotid },
                |m: &mut CMsgClientUCMAddScreenshotResponse| { &mut m.screenshotid },
                CMsgClientUCMAddScreenshotResponse::get_screenshotid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMAddScreenshotResponse>(
                "CMsgClientUCMAddScreenshotResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshotResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMAddScreenshotResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMAddScreenshotResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMAddScreenshotResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.screenshotid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMAddScreenshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMAddScreenshotResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMDeleteScreenshot {
    // message fields
    screenshotid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeleteScreenshot {
    fn default() -> &'a CMsgClientUCMDeleteScreenshot {
        <CMsgClientUCMDeleteScreenshot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeleteScreenshot {
    pub fn new() -> CMsgClientUCMDeleteScreenshot {
        ::std::default::Default::default()
    }

    // optional fixed64 screenshotid = 1;

    pub fn get_screenshotid(&self) -> u64 {
        self.screenshotid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_screenshotid(&mut self) {
        self.screenshotid = ::std::option::Option::None;
    }

    pub fn has_screenshotid(&self) -> bool {
        self.screenshotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshotid(&mut self, v: u64) {
        self.screenshotid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeleteScreenshot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.screenshotid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.screenshotid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.screenshotid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMDeleteScreenshot {
        CMsgClientUCMDeleteScreenshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "screenshotid",
                |m: &CMsgClientUCMDeleteScreenshot| { &m.screenshotid },
                |m: &mut CMsgClientUCMDeleteScreenshot| { &mut m.screenshotid },
                CMsgClientUCMDeleteScreenshot::get_screenshotid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMDeleteScreenshot>(
                "CMsgClientUCMDeleteScreenshot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMDeleteScreenshot {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMDeleteScreenshot> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMDeleteScreenshot::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMDeleteScreenshot {
    fn clear(&mut self) {
        self.screenshotid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMDeleteScreenshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeleteScreenshot {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMDeleteScreenshotResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeleteScreenshotResponse {
    fn default() -> &'a CMsgClientUCMDeleteScreenshotResponse {
        <CMsgClientUCMDeleteScreenshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeleteScreenshotResponse {
    pub fn new() -> CMsgClientUCMDeleteScreenshotResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeleteScreenshotResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMDeleteScreenshotResponse {
        CMsgClientUCMDeleteScreenshotResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMDeleteScreenshotResponse| { &m.eresult },
                |m: &mut CMsgClientUCMDeleteScreenshotResponse| { &mut m.eresult },
                CMsgClientUCMDeleteScreenshotResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMDeleteScreenshotResponse>(
                "CMsgClientUCMDeleteScreenshotResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMDeleteScreenshotResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMDeleteScreenshotResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMDeleteScreenshotResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMDeleteScreenshotResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMDeleteScreenshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeleteScreenshotResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMPublishFile {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    preview_file_name: ::protobuf::SingularField<::std::string::String>,
    consumer_app_id: ::std::option::Option<u32>,
    title: ::protobuf::SingularField<::std::string::String>,
    description: ::protobuf::SingularField<::std::string::String>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    workshop_file: ::std::option::Option<bool>,
    visibility: ::std::option::Option<i32>,
    file_type: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    video_provider: ::std::option::Option<u32>,
    video_account_name: ::protobuf::SingularField<::std::string::String>,
    video_identifier: ::protobuf::SingularField<::std::string::String>,
    in_progress: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishFile {
    fn default() -> &'a CMsgClientUCMPublishFile {
        <CMsgClientUCMPublishFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishFile {
    pub fn new() -> CMsgClientUCMPublishFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_file_name = 3;

    pub fn get_preview_file_name(&self) -> &str {
        match self.preview_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_file_name(&mut self) {
        self.preview_file_name.clear();
    }

    pub fn has_preview_file_name(&self) -> bool {
        self.preview_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_name(&mut self, v: ::std::string::String) {
        self.preview_file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_file_name(&mut self) -> &mut ::std::string::String {
        if self.preview_file_name.is_none() {
            self.preview_file_name.set_default();
        }
        self.preview_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_file_name(&mut self) -> ::std::string::String {
        self.preview_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 consumer_app_id = 4;

    pub fn get_consumer_app_id(&self) -> u32 {
        self.consumer_app_id.unwrap_or(0)
    }

    pub fn clear_consumer_app_id(&mut self) {
        self.consumer_app_id = ::std::option::Option::None;
    }

    pub fn has_consumer_app_id(&self) -> bool {
        self.consumer_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_app_id(&mut self, v: u32) {
        self.consumer_app_id = ::std::option::Option::Some(v);
    }

    // optional string title = 5;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 6;

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool workshop_file = 9;

    pub fn get_workshop_file(&self) -> bool {
        self.workshop_file.unwrap_or(false)
    }

    pub fn clear_workshop_file(&mut self) {
        self.workshop_file = ::std::option::Option::None;
    }

    pub fn has_workshop_file(&self) -> bool {
        self.workshop_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshop_file(&mut self, v: bool) {
        self.workshop_file = ::std::option::Option::Some(v);
    }

    // optional int32 visibility = 10;

    pub fn get_visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional uint32 file_type = 11;

    pub fn get_file_type(&self) -> u32 {
        self.file_type.unwrap_or(0)
    }

    pub fn clear_file_type(&mut self) {
        self.file_type = ::std::option::Option::None;
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: u32) {
        self.file_type = ::std::option::Option::Some(v);
    }

    // optional string url = 12;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 video_provider = 13;

    pub fn get_video_provider(&self) -> u32 {
        self.video_provider.unwrap_or(0)
    }

    pub fn clear_video_provider(&mut self) {
        self.video_provider = ::std::option::Option::None;
    }

    pub fn has_video_provider(&self) -> bool {
        self.video_provider.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_provider(&mut self, v: u32) {
        self.video_provider = ::std::option::Option::Some(v);
    }

    // optional string video_account_name = 14;

    pub fn get_video_account_name(&self) -> &str {
        match self.video_account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_account_name(&mut self) {
        self.video_account_name.clear();
    }

    pub fn has_video_account_name(&self) -> bool {
        self.video_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_account_name(&mut self, v: ::std::string::String) {
        self.video_account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_account_name(&mut self) -> &mut ::std::string::String {
        if self.video_account_name.is_none() {
            self.video_account_name.set_default();
        }
        self.video_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_account_name(&mut self) -> ::std::string::String {
        self.video_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string video_identifier = 15;

    pub fn get_video_identifier(&self) -> &str {
        match self.video_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_identifier(&mut self) {
        self.video_identifier.clear();
    }

    pub fn has_video_identifier(&self) -> bool {
        self.video_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_identifier(&mut self, v: ::std::string::String) {
        self.video_identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_identifier(&mut self) -> &mut ::std::string::String {
        if self.video_identifier.is_none() {
            self.video_identifier.set_default();
        }
        self.video_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_identifier(&mut self) -> ::std::string::String {
        self.video_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool in_progress = 16;

    pub fn get_in_progress(&self) -> bool {
        self.in_progress.unwrap_or(false)
    }

    pub fn clear_in_progress(&mut self) {
        self.in_progress = ::std::option::Option::None;
    }

    pub fn has_in_progress(&self) -> bool {
        self.in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_progress(&mut self, v: bool) {
        self.in_progress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preview_file_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consumer_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.workshop_file = ::std::option::Option::Some(is.read_bool()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.visibility = ::std::option::Option::Some(is.read_int32()?);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.video_provider = ::std::option::Option::Some(is.read_uint32()?);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.video_account_name)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.video_identifier)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.in_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.consumer_app_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.workshop_file {
            my_size += 2;
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_type {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.video_provider {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.video_account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.video_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.in_progress {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.consumer_app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.tags {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.workshop_file {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.file_type {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.video_provider {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.video_account_name.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.video_identifier.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.in_progress {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMPublishFile {
        CMsgClientUCMPublishFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMPublishFile| { &m.app_id },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.app_id },
                CMsgClientUCMPublishFile::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_name",
                |m: &CMsgClientUCMPublishFile| { &m.file_name },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.file_name },
                CMsgClientUCMPublishFile::get_file_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "preview_file_name",
                |m: &CMsgClientUCMPublishFile| { &m.preview_file_name },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.preview_file_name },
                CMsgClientUCMPublishFile::get_preview_file_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "consumer_app_id",
                |m: &CMsgClientUCMPublishFile| { &m.consumer_app_id },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.consumer_app_id },
                CMsgClientUCMPublishFile::get_consumer_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "title",
                |m: &CMsgClientUCMPublishFile| { &m.title },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.title },
                CMsgClientUCMPublishFile::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "description",
                |m: &CMsgClientUCMPublishFile| { &m.description },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.description },
                CMsgClientUCMPublishFile::get_description,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "tags",
                |m: &CMsgClientUCMPublishFile| { &m.tags },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "workshop_file",
                |m: &CMsgClientUCMPublishFile| { &m.workshop_file },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.workshop_file },
                CMsgClientUCMPublishFile::get_workshop_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "visibility",
                |m: &CMsgClientUCMPublishFile| { &m.visibility },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.visibility },
                CMsgClientUCMPublishFile::get_visibility,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "file_type",
                |m: &CMsgClientUCMPublishFile| { &m.file_type },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.file_type },
                CMsgClientUCMPublishFile::get_file_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "url",
                |m: &CMsgClientUCMPublishFile| { &m.url },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.url },
                CMsgClientUCMPublishFile::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "video_provider",
                |m: &CMsgClientUCMPublishFile| { &m.video_provider },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.video_provider },
                CMsgClientUCMPublishFile::get_video_provider,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "video_account_name",
                |m: &CMsgClientUCMPublishFile| { &m.video_account_name },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.video_account_name },
                CMsgClientUCMPublishFile::get_video_account_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "video_identifier",
                |m: &CMsgClientUCMPublishFile| { &m.video_identifier },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.video_identifier },
                CMsgClientUCMPublishFile::get_video_identifier,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "in_progress",
                |m: &CMsgClientUCMPublishFile| { &m.in_progress },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.in_progress },
                CMsgClientUCMPublishFile::get_in_progress,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMPublishFile>(
                "CMsgClientUCMPublishFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMPublishFile {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMPublishFile> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMPublishFile::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMPublishFile {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.preview_file_name.clear();
        self.consumer_app_id = ::std::option::Option::None;
        self.title.clear();
        self.description.clear();
        self.tags.clear();
        self.workshop_file = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.file_type = ::std::option::Option::None;
        self.url.clear();
        self.video_provider = ::std::option::Option::None;
        self.video_account_name.clear();
        self.video_identifier.clear();
        self.in_progress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMPublishFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMPublishFile {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMPublishFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    published_file_id: ::std::option::Option<u64>,
    needs_workshop_legal_agreement_acceptance: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishFileResponse {
    fn default() -> &'a CMsgClientUCMPublishFileResponse {
        <CMsgClientUCMPublishFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishFileResponse {
    pub fn new() -> CMsgClientUCMPublishFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 published_file_id = 2;

    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional bool needs_workshop_legal_agreement_acceptance = 3;

    pub fn get_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.unwrap_or(false)
    }

    pub fn clear_needs_workshop_legal_agreement_acceptance(&mut self) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
    }

    pub fn has_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_workshop_legal_agreement_acceptance(&mut self, v: bool) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMPublishFileResponse {
        CMsgClientUCMPublishFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMPublishFileResponse| { &m.eresult },
                |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.eresult },
                CMsgClientUCMPublishFileResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "published_file_id",
                |m: &CMsgClientUCMPublishFileResponse| { &m.published_file_id },
                |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.published_file_id },
                CMsgClientUCMPublishFileResponse::get_published_file_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "needs_workshop_legal_agreement_acceptance",
                |m: &CMsgClientUCMPublishFileResponse| { &m.needs_workshop_legal_agreement_acceptance },
                |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.needs_workshop_legal_agreement_acceptance },
                CMsgClientUCMPublishFileResponse::get_needs_workshop_legal_agreement_acceptance,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMPublishFileResponse>(
                "CMsgClientUCMPublishFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMPublishFileResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMPublishFileResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMPublishFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMPublishFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMPublishFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMPublishFileResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMUpdatePublishedFile {
    // message fields
    app_id: ::std::option::Option<u32>,
    published_file_id: ::std::option::Option<u64>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    preview_file_name: ::protobuf::SingularField<::std::string::String>,
    title: ::protobuf::SingularField<::std::string::String>,
    description: ::protobuf::SingularField<::std::string::String>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    visibility: ::std::option::Option<i32>,
    update_file: ::std::option::Option<bool>,
    update_preview_file: ::std::option::Option<bool>,
    update_title: ::std::option::Option<bool>,
    update_description: ::std::option::Option<bool>,
    update_tags: ::std::option::Option<bool>,
    update_visibility: ::std::option::Option<bool>,
    change_description: ::protobuf::SingularField<::std::string::String>,
    update_url: ::std::option::Option<bool>,
    url: ::protobuf::SingularField<::std::string::String>,
    update_content_manifest: ::std::option::Option<bool>,
    content_manifest: ::std::option::Option<u64>,
    metadata: ::protobuf::SingularField<::std::string::String>,
    update_metadata: ::std::option::Option<bool>,
    language: ::std::option::Option<i32>,
    pub removed_kvtags: ::protobuf::RepeatedField<::std::string::String>,
    pub kvtags: ::protobuf::RepeatedField<cmsg_client_ucmupdate_published_file::KeyValueTag>,
    pub previews: ::protobuf::RepeatedField<cmsg_client_ucmupdate_published_file::AdditionalPreview>,
    pub previews_to_remove: ::std::vec::Vec<i32>,
    clear_in_progress: ::std::option::Option<bool>,
    remove_all_kvtags: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFile {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFile {
        <CMsgClientUCMUpdatePublishedFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFile {
    pub fn new() -> CMsgClientUCMUpdatePublishedFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 published_file_id = 2;

    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 3;

    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_file_name = 4;

    pub fn get_preview_file_name(&self) -> &str {
        match self.preview_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_file_name(&mut self) {
        self.preview_file_name.clear();
    }

    pub fn has_preview_file_name(&self) -> bool {
        self.preview_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_name(&mut self, v: ::std::string::String) {
        self.preview_file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_file_name(&mut self) -> &mut ::std::string::String {
        if self.preview_file_name.is_none() {
            self.preview_file_name.set_default();
        }
        self.preview_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_file_name(&mut self) -> ::std::string::String {
        self.preview_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 5;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 6;

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 visibility = 8;

    pub fn get_visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional bool update_file = 9;

    pub fn get_update_file(&self) -> bool {
        self.update_file.unwrap_or(false)
    }

    pub fn clear_update_file(&mut self) {
        self.update_file = ::std::option::Option::None;
    }

    pub fn has_update_file(&self) -> bool {
        self.update_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_file(&mut self, v: bool) {
        self.update_file = ::std::option::Option::Some(v);
    }

    // optional bool update_preview_file = 10;

    pub fn get_update_preview_file(&self) -> bool {
        self.update_preview_file.unwrap_or(false)
    }

    pub fn clear_update_preview_file(&mut self) {
        self.update_preview_file = ::std::option::Option::None;
    }

    pub fn has_update_preview_file(&self) -> bool {
        self.update_preview_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_preview_file(&mut self, v: bool) {
        self.update_preview_file = ::std::option::Option::Some(v);
    }

    // optional bool update_title = 11;

    pub fn get_update_title(&self) -> bool {
        self.update_title.unwrap_or(false)
    }

    pub fn clear_update_title(&mut self) {
        self.update_title = ::std::option::Option::None;
    }

    pub fn has_update_title(&self) -> bool {
        self.update_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_title(&mut self, v: bool) {
        self.update_title = ::std::option::Option::Some(v);
    }

    // optional bool update_description = 12;

    pub fn get_update_description(&self) -> bool {
        self.update_description.unwrap_or(false)
    }

    pub fn clear_update_description(&mut self) {
        self.update_description = ::std::option::Option::None;
    }

    pub fn has_update_description(&self) -> bool {
        self.update_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_description(&mut self, v: bool) {
        self.update_description = ::std::option::Option::Some(v);
    }

    // optional bool update_tags = 13;

    pub fn get_update_tags(&self) -> bool {
        self.update_tags.unwrap_or(false)
    }

    pub fn clear_update_tags(&mut self) {
        self.update_tags = ::std::option::Option::None;
    }

    pub fn has_update_tags(&self) -> bool {
        self.update_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_tags(&mut self, v: bool) {
        self.update_tags = ::std::option::Option::Some(v);
    }

    // optional bool update_visibility = 14;

    pub fn get_update_visibility(&self) -> bool {
        self.update_visibility.unwrap_or(false)
    }

    pub fn clear_update_visibility(&mut self) {
        self.update_visibility = ::std::option::Option::None;
    }

    pub fn has_update_visibility(&self) -> bool {
        self.update_visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_visibility(&mut self, v: bool) {
        self.update_visibility = ::std::option::Option::Some(v);
    }

    // optional string change_description = 15;

    pub fn get_change_description(&self) -> &str {
        match self.change_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_change_description(&mut self) {
        self.change_description.clear();
    }

    pub fn has_change_description(&self) -> bool {
        self.change_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_description(&mut self, v: ::std::string::String) {
        self.change_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_description(&mut self) -> &mut ::std::string::String {
        if self.change_description.is_none() {
            self.change_description.set_default();
        }
        self.change_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_description(&mut self) -> ::std::string::String {
        self.change_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_url = 16;

    pub fn get_update_url(&self) -> bool {
        self.update_url.unwrap_or(false)
    }

    pub fn clear_update_url(&mut self) {
        self.update_url = ::std::option::Option::None;
    }

    pub fn has_update_url(&self) -> bool {
        self.update_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_url(&mut self, v: bool) {
        self.update_url = ::std::option::Option::Some(v);
    }

    // optional string url = 17;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_content_manifest = 18;

    pub fn get_update_content_manifest(&self) -> bool {
        self.update_content_manifest.unwrap_or(false)
    }

    pub fn clear_update_content_manifest(&mut self) {
        self.update_content_manifest = ::std::option::Option::None;
    }

    pub fn has_update_content_manifest(&self) -> bool {
        self.update_content_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_content_manifest(&mut self, v: bool) {
        self.update_content_manifest = ::std::option::Option::Some(v);
    }

    // optional fixed64 content_manifest = 19;

    pub fn get_content_manifest(&self) -> u64 {
        self.content_manifest.unwrap_or(0)
    }

    pub fn clear_content_manifest(&mut self) {
        self.content_manifest = ::std::option::Option::None;
    }

    pub fn has_content_manifest(&self) -> bool {
        self.content_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_manifest(&mut self, v: u64) {
        self.content_manifest = ::std::option::Option::Some(v);
    }

    // optional string metadata = 20;

    pub fn get_metadata(&self) -> &str {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        self.metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_metadata = 21;

    pub fn get_update_metadata(&self) -> bool {
        self.update_metadata.unwrap_or(false)
    }

    pub fn clear_update_metadata(&mut self) {
        self.update_metadata = ::std::option::Option::None;
    }

    pub fn has_update_metadata(&self) -> bool {
        self.update_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_metadata(&mut self, v: bool) {
        self.update_metadata = ::std::option::Option::Some(v);
    }

    // optional int32 language = 22;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool clear_in_progress = 27;

    pub fn get_clear_in_progress(&self) -> bool {
        self.clear_in_progress.unwrap_or(false)
    }

    pub fn clear_clear_in_progress(&mut self) {
        self.clear_in_progress = ::std::option::Option::None;
    }

    pub fn has_clear_in_progress(&self) -> bool {
        self.clear_in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear_in_progress(&mut self, v: bool) {
        self.clear_in_progress = ::std::option::Option::Some(v);
    }

    // optional bool remove_all_kvtags = 28;

    pub fn get_remove_all_kvtags(&self) -> bool {
        self.remove_all_kvtags.unwrap_or(false)
    }

    pub fn clear_remove_all_kvtags(&mut self) {
        self.remove_all_kvtags = ::std::option::Option::None;
    }

    pub fn has_remove_all_kvtags(&self) -> bool {
        self.remove_all_kvtags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_all_kvtags(&mut self, v: bool) {
        self.remove_all_kvtags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMUpdatePublishedFile {
    fn is_initialized(&self) -> bool {
        for v in &self.kvtags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.previews {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preview_file_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.visibility = ::std::option::Option::Some(is.read_int32()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_file = ::std::option::Option::Some(is.read_bool()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_preview_file = ::std::option::Option::Some(is.read_bool()?);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_title = ::std::option::Option::Some(is.read_bool()?);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_description = ::std::option::Option::Some(is.read_bool()?);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_visibility = ::std::option::Option::Some(is.read_bool()?);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.change_description)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_url = ::std::option::Option::Some(is.read_bool()?);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_content_manifest = ::std::option::Option::Some(is.read_bool()?);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content_manifest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.metadata)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_metadata = ::std::option::Option::Some(is.read_bool()?);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                23 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.removed_kvtags)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.kvtags)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.previews)?;
                },
                26 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.previews_to_remove)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.clear_in_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.remove_all_kvtags = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update_file {
            my_size += 2;
        }
        if let Some(v) = self.update_preview_file {
            my_size += 2;
        }
        if let Some(v) = self.update_title {
            my_size += 2;
        }
        if let Some(v) = self.update_description {
            my_size += 2;
        }
        if let Some(v) = self.update_tags {
            my_size += 2;
        }
        if let Some(v) = self.update_visibility {
            my_size += 2;
        }
        if let Some(v) = self.change_description.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.update_url {
            my_size += 3;
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.update_content_manifest {
            my_size += 3;
        }
        if let Some(v) = self.content_manifest {
            my_size += 10;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.update_metadata {
            my_size += 3;
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.removed_kvtags {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        for value in &self.kvtags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.previews {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.previews_to_remove {
            my_size += ::protobuf::rt::value_size(26, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.clear_in_progress {
            my_size += 3;
        }
        if let Some(v) = self.remove_all_kvtags {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.preview_file_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.tags {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.visibility {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.update_file {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.update_preview_file {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.update_title {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.update_description {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.update_tags {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.update_visibility {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.change_description.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.update_url {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.update_content_manifest {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.content_manifest {
            os.write_fixed64(19, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.update_metadata {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(22, v)?;
        }
        for v in &self.removed_kvtags {
            os.write_string(23, &v)?;
        };
        for v in &self.kvtags {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        for v in &self.previews {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        for v in &self.previews_to_remove {
            os.write_int32(26, *v)?;
        };
        if let Some(v) = self.clear_in_progress {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.remove_all_kvtags {
            os.write_bool(28, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMUpdatePublishedFile {
        CMsgClientUCMUpdatePublishedFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.app_id },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.app_id },
                CMsgClientUCMUpdatePublishedFile::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "published_file_id",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.published_file_id },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.published_file_id },
                CMsgClientUCMUpdatePublishedFile::get_published_file_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_name",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.file_name },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.file_name },
                CMsgClientUCMUpdatePublishedFile::get_file_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "preview_file_name",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.preview_file_name },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.preview_file_name },
                CMsgClientUCMUpdatePublishedFile::get_preview_file_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "title",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.title },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.title },
                CMsgClientUCMUpdatePublishedFile::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "description",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.description },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.description },
                CMsgClientUCMUpdatePublishedFile::get_description,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "tags",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.tags },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "visibility",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.visibility },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.visibility },
                CMsgClientUCMUpdatePublishedFile::get_visibility,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "update_file",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_file },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_file },
                CMsgClientUCMUpdatePublishedFile::get_update_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "update_preview_file",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_preview_file },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_preview_file },
                CMsgClientUCMUpdatePublishedFile::get_update_preview_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "update_title",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_title },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_title },
                CMsgClientUCMUpdatePublishedFile::get_update_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "update_description",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_description },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_description },
                CMsgClientUCMUpdatePublishedFile::get_update_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "update_tags",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_tags },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_tags },
                CMsgClientUCMUpdatePublishedFile::get_update_tags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "update_visibility",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_visibility },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_visibility },
                CMsgClientUCMUpdatePublishedFile::get_update_visibility,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "change_description",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.change_description },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.change_description },
                CMsgClientUCMUpdatePublishedFile::get_change_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "update_url",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_url },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_url },
                CMsgClientUCMUpdatePublishedFile::get_update_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "url",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.url },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.url },
                CMsgClientUCMUpdatePublishedFile::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "update_content_manifest",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_content_manifest },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_content_manifest },
                CMsgClientUCMUpdatePublishedFile::get_update_content_manifest,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "content_manifest",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.content_manifest },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.content_manifest },
                CMsgClientUCMUpdatePublishedFile::get_content_manifest,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "metadata",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.metadata },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.metadata },
                CMsgClientUCMUpdatePublishedFile::get_metadata,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "update_metadata",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_metadata },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_metadata },
                CMsgClientUCMUpdatePublishedFile::get_update_metadata,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "language",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.language },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.language },
                CMsgClientUCMUpdatePublishedFile::get_language,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "removed_kvtags",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.removed_kvtags },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.removed_kvtags },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ucmupdate_published_file::KeyValueTag>>(
                "kvtags",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.kvtags },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.kvtags },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ucmupdate_published_file::AdditionalPreview>>(
                "previews",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.previews },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.previews },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32>(
                "previews_to_remove",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.previews_to_remove },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.previews_to_remove },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "clear_in_progress",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.clear_in_progress },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.clear_in_progress },
                CMsgClientUCMUpdatePublishedFile::get_clear_in_progress,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "remove_all_kvtags",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.remove_all_kvtags },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.remove_all_kvtags },
                CMsgClientUCMUpdatePublishedFile::get_remove_all_kvtags,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMUpdatePublishedFile>(
                "CMsgClientUCMUpdatePublishedFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFile {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMUpdatePublishedFile> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMUpdatePublishedFile::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMUpdatePublishedFile {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.file_name.clear();
        self.preview_file_name.clear();
        self.title.clear();
        self.description.clear();
        self.tags.clear();
        self.visibility = ::std::option::Option::None;
        self.update_file = ::std::option::Option::None;
        self.update_preview_file = ::std::option::Option::None;
        self.update_title = ::std::option::Option::None;
        self.update_description = ::std::option::Option::None;
        self.update_tags = ::std::option::Option::None;
        self.update_visibility = ::std::option::Option::None;
        self.change_description.clear();
        self.update_url = ::std::option::Option::None;
        self.url.clear();
        self.update_content_manifest = ::std::option::Option::None;
        self.content_manifest = ::std::option::Option::None;
        self.metadata.clear();
        self.update_metadata = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.removed_kvtags.clear();
        self.kvtags.clear();
        self.previews.clear();
        self.previews_to_remove.clear();
        self.clear_in_progress = ::std::option::Option::None;
        self.remove_all_kvtags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMUpdatePublishedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMUpdatePublishedFile {
}

/// Nested message and enums of message `CMsgClientUCMUpdatePublishedFile`
pub mod cmsg_client_ucmupdate_published_file {
    #[derive(PartialEq,Clone,Default)]
    pub struct KeyValueTag {
        // message fields
        key: ::protobuf::SingularField<::std::string::String>,
        value: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a KeyValueTag {
        fn default() -> &'a KeyValueTag {
            <KeyValueTag as ::protobuf::Message>::default_instance()
        }
    }

    impl KeyValueTag {
        pub fn new() -> KeyValueTag {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn get_key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key.clear();
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key.set_default();
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn get_value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value.clear();
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value.set_default();
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for KeyValueTag {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> KeyValueTag {
            KeyValueTag::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "key",
                    |m: &KeyValueTag| { &m.key },
                    |m: &mut KeyValueTag| { &mut m.key },
                    KeyValueTag::get_key,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "value",
                    |m: &KeyValueTag| { &m.value },
                    |m: &mut KeyValueTag| { &mut m.value },
                    KeyValueTag::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyValueTag>(
                    "CMsgClientUCMUpdatePublishedFile.KeyValueTag",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static KeyValueTag {
            static instance: ::protobuf::rt::Lazy<KeyValueTag> = ::protobuf::rt::Lazy::INIT;
            instance.get(KeyValueTag::new)
        }
    }

    impl ::protobuf::Clear for KeyValueTag {
        fn clear(&mut self) {
            self.key.clear();
            self.value.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for KeyValueTag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KeyValueTag {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct AdditionalPreview {
        // message fields
        original_file_name: ::protobuf::SingularField<::std::string::String>,
        internal_file_name: ::protobuf::SingularField<::std::string::String>,
        videoid: ::protobuf::SingularField<::std::string::String>,
        preview_type: ::std::option::Option<u32>,
        update_index: ::std::option::Option<i32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a AdditionalPreview {
        fn default() -> &'a AdditionalPreview {
            <AdditionalPreview as ::protobuf::Message>::default_instance()
        }
    }

    impl AdditionalPreview {
        pub fn new() -> AdditionalPreview {
            ::std::default::Default::default()
        }

        // optional string original_file_name = 1;

        pub fn get_original_file_name(&self) -> &str {
            match self.original_file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_original_file_name(&mut self) {
            self.original_file_name.clear();
        }

        pub fn has_original_file_name(&self) -> bool {
            self.original_file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_file_name(&mut self, v: ::std::string::String) {
            self.original_file_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_original_file_name(&mut self) -> &mut ::std::string::String {
            if self.original_file_name.is_none() {
                self.original_file_name.set_default();
            }
            self.original_file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_original_file_name(&mut self) -> ::std::string::String {
            self.original_file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string internal_file_name = 2;

        pub fn get_internal_file_name(&self) -> &str {
            match self.internal_file_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_internal_file_name(&mut self) {
            self.internal_file_name.clear();
        }

        pub fn has_internal_file_name(&self) -> bool {
            self.internal_file_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_internal_file_name(&mut self, v: ::std::string::String) {
            self.internal_file_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_internal_file_name(&mut self) -> &mut ::std::string::String {
            if self.internal_file_name.is_none() {
                self.internal_file_name.set_default();
            }
            self.internal_file_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_internal_file_name(&mut self) -> ::std::string::String {
            self.internal_file_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string videoid = 3;

        pub fn get_videoid(&self) -> &str {
            match self.videoid.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_videoid(&mut self) {
            self.videoid.clear();
        }

        pub fn has_videoid(&self) -> bool {
            self.videoid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_videoid(&mut self, v: ::std::string::String) {
            self.videoid = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_videoid(&mut self) -> &mut ::std::string::String {
            if self.videoid.is_none() {
                self.videoid.set_default();
            }
            self.videoid.as_mut().unwrap()
        }

        // Take field
        pub fn take_videoid(&mut self) -> ::std::string::String {
            self.videoid.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 preview_type = 4;

        pub fn get_preview_type(&self) -> u32 {
            self.preview_type.unwrap_or(0)
        }

        pub fn clear_preview_type(&mut self) {
            self.preview_type = ::std::option::Option::None;
        }

        pub fn has_preview_type(&self) -> bool {
            self.preview_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_preview_type(&mut self, v: u32) {
            self.preview_type = ::std::option::Option::Some(v);
        }

        // optional int32 update_index = 5;

        pub fn get_update_index(&self) -> i32 {
            self.update_index.unwrap_or(-1i32)
        }

        pub fn clear_update_index(&mut self) {
            self.update_index = ::std::option::Option::None;
        }

        pub fn has_update_index(&self) -> bool {
            self.update_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_update_index(&mut self, v: i32) {
            self.update_index = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AdditionalPreview {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_file_name)?;
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.internal_file_name)?;
                    },
                    3 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.videoid)?;
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.preview_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.update_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.original_file_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.internal_file_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.videoid.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.preview_type {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.update_index {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.original_file_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.internal_file_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.videoid.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.preview_type {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.update_index {
                os.write_int32(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> AdditionalPreview {
            AdditionalPreview::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "original_file_name",
                    |m: &AdditionalPreview| { &m.original_file_name },
                    |m: &mut AdditionalPreview| { &mut m.original_file_name },
                    AdditionalPreview::get_original_file_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "internal_file_name",
                    |m: &AdditionalPreview| { &m.internal_file_name },
                    |m: &mut AdditionalPreview| { &mut m.internal_file_name },
                    AdditionalPreview::get_internal_file_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "videoid",
                    |m: &AdditionalPreview| { &m.videoid },
                    |m: &mut AdditionalPreview| { &mut m.videoid },
                    AdditionalPreview::get_videoid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "preview_type",
                    |m: &AdditionalPreview| { &m.preview_type },
                    |m: &mut AdditionalPreview| { &mut m.preview_type },
                    AdditionalPreview::get_preview_type,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "update_index",
                    |m: &AdditionalPreview| { &m.update_index },
                    |m: &mut AdditionalPreview| { &mut m.update_index },
                    AdditionalPreview::get_update_index,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdditionalPreview>(
                    "CMsgClientUCMUpdatePublishedFile.AdditionalPreview",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static AdditionalPreview {
            static instance: ::protobuf::rt::Lazy<AdditionalPreview> = ::protobuf::rt::Lazy::INIT;
            instance.get(AdditionalPreview::new)
        }
    }

    impl ::protobuf::Clear for AdditionalPreview {
        fn clear(&mut self) {
            self.original_file_name.clear();
            self.internal_file_name.clear();
            self.videoid.clear();
            self.preview_type = ::std::option::Option::None;
            self.update_index = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for AdditionalPreview {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AdditionalPreview {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMUpdatePublishedFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    needs_workshop_legal_agreement_acceptance: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFileResponse {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFileResponse {
        <CMsgClientUCMUpdatePublishedFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFileResponse {
    pub fn new() -> CMsgClientUCMUpdatePublishedFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool needs_workshop_legal_agreement_acceptance = 2;

    pub fn get_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.unwrap_or(false)
    }

    pub fn clear_needs_workshop_legal_agreement_acceptance(&mut self) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
    }

    pub fn has_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_workshop_legal_agreement_acceptance(&mut self, v: bool) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMUpdatePublishedFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMUpdatePublishedFileResponse {
        CMsgClientUCMUpdatePublishedFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMUpdatePublishedFileResponse| { &m.eresult },
                |m: &mut CMsgClientUCMUpdatePublishedFileResponse| { &mut m.eresult },
                CMsgClientUCMUpdatePublishedFileResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "needs_workshop_legal_agreement_acceptance",
                |m: &CMsgClientUCMUpdatePublishedFileResponse| { &m.needs_workshop_legal_agreement_acceptance },
                |m: &mut CMsgClientUCMUpdatePublishedFileResponse| { &mut m.needs_workshop_legal_agreement_acceptance },
                CMsgClientUCMUpdatePublishedFileResponse::get_needs_workshop_legal_agreement_acceptance,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMUpdatePublishedFileResponse>(
                "CMsgClientUCMUpdatePublishedFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFileResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMUpdatePublishedFileResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMUpdatePublishedFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMUpdatePublishedFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMUpdatePublishedFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMUpdatePublishedFileResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMDeletePublishedFile {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeletePublishedFile {
    fn default() -> &'a CMsgClientUCMDeletePublishedFile {
        <CMsgClientUCMDeletePublishedFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeletePublishedFile {
    pub fn new() -> CMsgClientUCMDeletePublishedFile {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeletePublishedFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMDeletePublishedFile {
        CMsgClientUCMDeletePublishedFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "published_file_id",
                |m: &CMsgClientUCMDeletePublishedFile| { &m.published_file_id },
                |m: &mut CMsgClientUCMDeletePublishedFile| { &mut m.published_file_id },
                CMsgClientUCMDeletePublishedFile::get_published_file_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMDeletePublishedFile| { &m.app_id },
                |m: &mut CMsgClientUCMDeletePublishedFile| { &mut m.app_id },
                CMsgClientUCMDeletePublishedFile::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMDeletePublishedFile>(
                "CMsgClientUCMDeletePublishedFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMDeletePublishedFile {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMDeletePublishedFile> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMDeletePublishedFile::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMDeletePublishedFile {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMDeletePublishedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeletePublishedFile {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMDeletePublishedFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeletePublishedFileResponse {
    fn default() -> &'a CMsgClientUCMDeletePublishedFileResponse {
        <CMsgClientUCMDeletePublishedFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeletePublishedFileResponse {
    pub fn new() -> CMsgClientUCMDeletePublishedFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeletePublishedFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMDeletePublishedFileResponse {
        CMsgClientUCMDeletePublishedFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMDeletePublishedFileResponse| { &m.eresult },
                |m: &mut CMsgClientUCMDeletePublishedFileResponse| { &mut m.eresult },
                CMsgClientUCMDeletePublishedFileResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMDeletePublishedFileResponse>(
                "CMsgClientUCMDeletePublishedFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMDeletePublishedFileResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMDeletePublishedFileResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMDeletePublishedFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMDeletePublishedFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMDeletePublishedFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeletePublishedFileResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserPublishedFiles {
    // message fields
    app_id: ::std::option::Option<u32>,
    start_index: ::std::option::Option<u32>,
    sort_order: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserPublishedFiles {
    fn default() -> &'a CMsgClientUCMEnumerateUserPublishedFiles {
        <CMsgClientUCMEnumerateUserPublishedFiles as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserPublishedFiles {
    pub fn new() -> CMsgClientUCMEnumerateUserPublishedFiles {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_order = 3;

    pub fn get_sort_order(&self) -> u32 {
        self.sort_order.unwrap_or(0)
    }

    pub fn clear_sort_order(&mut self) {
        self.sort_order = ::std::option::Option::None;
    }

    pub fn has_sort_order(&self) -> bool {
        self.sort_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: u32) {
        self.sort_order = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserPublishedFiles {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sort_order = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sort_order {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.sort_order {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserPublishedFiles {
        CMsgClientUCMEnumerateUserPublishedFiles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMEnumerateUserPublishedFiles| { &m.app_id },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFiles| { &mut m.app_id },
                CMsgClientUCMEnumerateUserPublishedFiles::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "start_index",
                |m: &CMsgClientUCMEnumerateUserPublishedFiles| { &m.start_index },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFiles| { &mut m.start_index },
                CMsgClientUCMEnumerateUserPublishedFiles::get_start_index,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "sort_order",
                |m: &CMsgClientUCMEnumerateUserPublishedFiles| { &m.sort_order },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFiles| { &mut m.sort_order },
                CMsgClientUCMEnumerateUserPublishedFiles::get_sort_order,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMEnumerateUserPublishedFiles>(
                "CMsgClientUCMEnumerateUserPublishedFiles",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserPublishedFiles {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMEnumerateUserPublishedFiles> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMEnumerateUserPublishedFiles::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserPublishedFiles {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.sort_order = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserPublishedFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserPublishedFiles {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserPublishedFilesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub published_files: ::protobuf::RepeatedField<cmsg_client_ucmenumerate_user_published_files_response::PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserPublishedFilesResponse {
        <CMsgClientUCMEnumerateUserPublishedFilesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserPublishedFilesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserPublishedFilesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.published_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.published_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserPublishedFilesResponse {
        CMsgClientUCMEnumerateUserPublishedFilesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMEnumerateUserPublishedFilesResponse| { &m.eresult },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFilesResponse| { &mut m.eresult },
                CMsgClientUCMEnumerateUserPublishedFilesResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ucmenumerate_user_published_files_response::PublishedFileId>>(
                "published_files",
                |m: &CMsgClientUCMEnumerateUserPublishedFilesResponse| { &m.published_files },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFilesResponse| { &mut m.published_files },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "total_results",
                |m: &CMsgClientUCMEnumerateUserPublishedFilesResponse| { &m.total_results },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFilesResponse| { &mut m.total_results },
                CMsgClientUCMEnumerateUserPublishedFilesResponse::get_total_results,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMEnumerateUserPublishedFilesResponse>(
                "CMsgClientUCMEnumerateUserPublishedFilesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserPublishedFilesResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMEnumerateUserPublishedFilesResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMEnumerateUserPublishedFilesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserPublishedFilesResponse {
}

/// Nested message and enums of message `CMsgClientUCMEnumerateUserPublishedFilesResponse`
pub mod cmsg_client_ucmenumerate_user_published_files_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct PublishedFileId {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &PublishedFileId| { &m.published_file_id },
                    |m: &mut PublishedFileId| { &mut m.published_file_id },
                    PublishedFileId::get_published_file_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileId>(
                    "CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: ::protobuf::rt::Lazy<PublishedFileId> = ::protobuf::rt::Lazy::INIT;
            instance.get(PublishedFileId::new)
        }
    }

    impl ::protobuf::Clear for PublishedFileId {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserSubscribedFiles {
    // message fields
    app_id: ::std::option::Option<u32>,
    start_index: ::std::option::Option<u32>,
    list_type: ::std::option::Option<u32>,
    matching_file_type: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFiles {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFiles {
        <CMsgClientUCMEnumerateUserSubscribedFiles as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFiles {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFiles {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 list_type = 3;

    pub fn get_list_type(&self) -> u32 {
        self.list_type.unwrap_or(1u32)
    }

    pub fn clear_list_type(&mut self) {
        self.list_type = ::std::option::Option::None;
    }

    pub fn has_list_type(&self) -> bool {
        self.list_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_type(&mut self, v: u32) {
        self.list_type = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_file_type = 4;

    pub fn get_matching_file_type(&self) -> u32 {
        self.matching_file_type.unwrap_or(0u32)
    }

    pub fn clear_matching_file_type(&mut self) {
        self.matching_file_type = ::std::option::Option::None;
    }

    pub fn has_matching_file_type(&self) -> bool {
        self.matching_file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_file_type(&mut self, v: u32) {
        self.matching_file_type = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 5;

    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(50u32)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFiles {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.list_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.matching_file_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.list_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matching_file_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.list_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.matching_file_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFiles {
        CMsgClientUCMEnumerateUserSubscribedFiles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.app_id },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.app_id },
                CMsgClientUCMEnumerateUserSubscribedFiles::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "start_index",
                |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.start_index },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.start_index },
                CMsgClientUCMEnumerateUserSubscribedFiles::get_start_index,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "list_type",
                |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.list_type },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.list_type },
                CMsgClientUCMEnumerateUserSubscribedFiles::get_list_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "matching_file_type",
                |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.matching_file_type },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.matching_file_type },
                CMsgClientUCMEnumerateUserSubscribedFiles::get_matching_file_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "count",
                |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.count },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.count },
                CMsgClientUCMEnumerateUserSubscribedFiles::get_count,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMEnumerateUserSubscribedFiles>(
                "CMsgClientUCMEnumerateUserSubscribedFiles",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFiles {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMEnumerateUserSubscribedFiles> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMEnumerateUserSubscribedFiles::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserSubscribedFiles {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.list_type = ::std::option::Option::None;
        self.matching_file_type = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserSubscribedFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFiles {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub subscribed_files: ::protobuf::RepeatedField<cmsg_client_ucmenumerate_user_subscribed_files_response::PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        <CMsgClientUCMEnumerateUserSubscribedFilesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.subscribed_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.subscribed_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.subscribed_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.subscribed_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        CMsgClientUCMEnumerateUserSubscribedFilesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &m.eresult },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &mut m.eresult },
                CMsgClientUCMEnumerateUserSubscribedFilesResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ucmenumerate_user_subscribed_files_response::PublishedFileId>>(
                "subscribed_files",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &m.subscribed_files },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &mut m.subscribed_files },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "total_results",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &m.total_results },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &mut m.total_results },
                CMsgClientUCMEnumerateUserSubscribedFilesResponse::get_total_results,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMEnumerateUserSubscribedFilesResponse>(
                "CMsgClientUCMEnumerateUserSubscribedFilesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMEnumerateUserSubscribedFilesResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMEnumerateUserSubscribedFilesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.subscribed_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
}

/// Nested message and enums of message `CMsgClientUCMEnumerateUserSubscribedFilesResponse`
pub mod cmsg_client_ucmenumerate_user_subscribed_files_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct PublishedFileId {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        rtime32_subscribed: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_subscribed = 2;

        pub fn get_rtime32_subscribed(&self) -> u32 {
            self.rtime32_subscribed.unwrap_or(0u32)
        }

        pub fn clear_rtime32_subscribed(&mut self) {
            self.rtime32_subscribed = ::std::option::Option::None;
        }

        pub fn has_rtime32_subscribed(&self) -> bool {
            self.rtime32_subscribed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_subscribed(&mut self, v: u32) {
            self.rtime32_subscribed = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.rtime32_subscribed = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.rtime32_subscribed {
                my_size += 5;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rtime32_subscribed {
                os.write_fixed32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &PublishedFileId| { &m.published_file_id },
                    |m: &mut PublishedFileId| { &mut m.published_file_id },
                    PublishedFileId::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                    "rtime32_subscribed",
                    |m: &PublishedFileId| { &m.rtime32_subscribed },
                    |m: &mut PublishedFileId| { &mut m.rtime32_subscribed },
                    PublishedFileId::get_rtime32_subscribed,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileId>(
                    "CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: ::protobuf::rt::Lazy<PublishedFileId> = ::protobuf::rt::Lazy::INIT;
            instance.get(PublishedFileId::new)
        }
    }

    impl ::protobuf::Clear for PublishedFileId {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.rtime32_subscribed = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    // message fields
    app_id: ::std::option::Option<u32>,
    start_index: ::std::option::Option<u32>,
    start_time: ::std::option::Option<u32>,
    desired_revision: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional fixed32 start_time = 3;

    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 desired_revision = 4;

    pub fn get_desired_revision(&self) -> u32 {
        self.desired_revision.unwrap_or(0u32)
    }

    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: u32) {
        self.desired_revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.desired_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += 5;
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.app_id },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.app_id },
                CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "start_index",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.start_index },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.start_index },
                CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::get_start_index,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "start_time",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.start_time },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.start_time },
                CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::get_start_time,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "desired_revision",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.desired_revision },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.desired_revision },
                CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::get_desired_revision,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates>(
                "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub subscribed_files: ::protobuf::RepeatedField<cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.subscribed_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.subscribed_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.subscribed_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.subscribed_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.eresult },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.eresult },
                CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response::PublishedFileId>>(
                "subscribed_files",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.subscribed_files },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.subscribed_files },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "total_results",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.total_results },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.total_results },
                CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::get_total_results,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse>(
                "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.subscribed_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
}

/// Nested message and enums of message `CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse`
pub mod cmsg_client_ucmenumerate_user_subscribed_files_with_updates_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct PublishedFileId {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        rtime32_subscribed: ::std::option::Option<u32>,
        appid: ::std::option::Option<u32>,
        file_hcontent: ::std::option::Option<u64>,
        file_size: ::std::option::Option<u32>,
        rtime32_last_updated: ::std::option::Option<u32>,
        is_depot_content: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_subscribed = 2;

        pub fn get_rtime32_subscribed(&self) -> u32 {
            self.rtime32_subscribed.unwrap_or(0u32)
        }

        pub fn clear_rtime32_subscribed(&mut self) {
            self.rtime32_subscribed = ::std::option::Option::None;
        }

        pub fn has_rtime32_subscribed(&self) -> bool {
            self.rtime32_subscribed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_subscribed(&mut self, v: u32) {
            self.rtime32_subscribed = ::std::option::Option::Some(v);
        }

        // optional uint32 appid = 3;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional fixed64 file_hcontent = 4;

        pub fn get_file_hcontent(&self) -> u64 {
            self.file_hcontent.unwrap_or(0)
        }

        pub fn clear_file_hcontent(&mut self) {
            self.file_hcontent = ::std::option::Option::None;
        }

        pub fn has_file_hcontent(&self) -> bool {
            self.file_hcontent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_hcontent(&mut self, v: u64) {
            self.file_hcontent = ::std::option::Option::Some(v);
        }

        // optional uint32 file_size = 5;

        pub fn get_file_size(&self) -> u32 {
            self.file_size.unwrap_or(0)
        }

        pub fn clear_file_size(&mut self) {
            self.file_size = ::std::option::Option::None;
        }

        pub fn has_file_size(&self) -> bool {
            self.file_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_size(&mut self, v: u32) {
            self.file_size = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_last_updated = 6;

        pub fn get_rtime32_last_updated(&self) -> u32 {
            self.rtime32_last_updated.unwrap_or(0)
        }

        pub fn clear_rtime32_last_updated(&mut self) {
            self.rtime32_last_updated = ::std::option::Option::None;
        }

        pub fn has_rtime32_last_updated(&self) -> bool {
            self.rtime32_last_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_last_updated(&mut self, v: u32) {
            self.rtime32_last_updated = ::std::option::Option::Some(v);
        }

        // optional bool is_depot_content = 7;

        pub fn get_is_depot_content(&self) -> bool {
            self.is_depot_content.unwrap_or(false)
        }

        pub fn clear_is_depot_content(&mut self) {
            self.is_depot_content = ::std::option::Option::None;
        }

        pub fn has_is_depot_content(&self) -> bool {
            self.is_depot_content.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_depot_content(&mut self, v: bool) {
            self.is_depot_content = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.rtime32_subscribed = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.file_hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.rtime32_last_updated = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.is_depot_content = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.rtime32_subscribed {
                my_size += 5;
            }
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.file_hcontent {
                my_size += 9;
            }
            if let Some(v) = self.file_size {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.rtime32_last_updated {
                my_size += 5;
            }
            if let Some(v) = self.is_depot_content {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rtime32_subscribed {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.appid {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.file_hcontent {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.file_size {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.rtime32_last_updated {
                os.write_fixed32(6, v)?;
            }
            if let Some(v) = self.is_depot_content {
                os.write_bool(7, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &PublishedFileId| { &m.published_file_id },
                    |m: &mut PublishedFileId| { &mut m.published_file_id },
                    PublishedFileId::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                    "rtime32_subscribed",
                    |m: &PublishedFileId| { &m.rtime32_subscribed },
                    |m: &mut PublishedFileId| { &mut m.rtime32_subscribed },
                    PublishedFileId::get_rtime32_subscribed,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &PublishedFileId| { &m.appid },
                    |m: &mut PublishedFileId| { &mut m.appid },
                    PublishedFileId::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "file_hcontent",
                    |m: &PublishedFileId| { &m.file_hcontent },
                    |m: &mut PublishedFileId| { &mut m.file_hcontent },
                    PublishedFileId::get_file_hcontent,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "file_size",
                    |m: &PublishedFileId| { &m.file_size },
                    |m: &mut PublishedFileId| { &mut m.file_size },
                    PublishedFileId::get_file_size,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                    "rtime32_last_updated",
                    |m: &PublishedFileId| { &m.rtime32_last_updated },
                    |m: &mut PublishedFileId| { &mut m.rtime32_last_updated },
                    PublishedFileId::get_rtime32_last_updated,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "is_depot_content",
                    |m: &PublishedFileId| { &m.is_depot_content },
                    |m: &mut PublishedFileId| { &mut m.is_depot_content },
                    PublishedFileId::get_is_depot_content,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileId>(
                    "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: ::protobuf::rt::Lazy<PublishedFileId> = ::protobuf::rt::Lazy::INIT;
            instance.get(PublishedFileId::new)
        }
    }

    impl ::protobuf::Clear for PublishedFileId {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.rtime32_subscribed = ::std::option::Option::None;
            self.appid = ::std::option::Option::None;
            self.file_hcontent = ::std::option::Option::None;
            self.file_size = ::std::option::Option::None;
            self.rtime32_last_updated = ::std::option::Option::None;
            self.is_depot_content = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMPublishedFileDeleted {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishedFileDeleted {
    fn default() -> &'a CMsgClientUCMPublishedFileDeleted {
        <CMsgClientUCMPublishedFileDeleted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishedFileDeleted {
    pub fn new() -> CMsgClientUCMPublishedFileDeleted {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishedFileDeleted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMPublishedFileDeleted {
        CMsgClientUCMPublishedFileDeleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "published_file_id",
                |m: &CMsgClientUCMPublishedFileDeleted| { &m.published_file_id },
                |m: &mut CMsgClientUCMPublishedFileDeleted| { &mut m.published_file_id },
                CMsgClientUCMPublishedFileDeleted::get_published_file_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMPublishedFileDeleted| { &m.app_id },
                |m: &mut CMsgClientUCMPublishedFileDeleted| { &mut m.app_id },
                CMsgClientUCMPublishedFileDeleted::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMPublishedFileDeleted>(
                "CMsgClientUCMPublishedFileDeleted",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMPublishedFileDeleted {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMPublishedFileDeleted> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMPublishedFileDeleted::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMPublishedFileDeleted {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMPublishedFileDeleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMPublishedFileDeleted {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMPublishedFileUpdated {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    time_updated: ::std::option::Option<u32>,
    hcontent: ::std::option::Option<u64>,
    file_size: ::std::option::Option<u32>,
    is_depot_content: ::std::option::Option<bool>,
    revision: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishedFileUpdated {
    fn default() -> &'a CMsgClientUCMPublishedFileUpdated {
        <CMsgClientUCMPublishedFileUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishedFileUpdated {
    pub fn new() -> CMsgClientUCMPublishedFileUpdated {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 3;

    pub fn get_time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }

    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional fixed64 hcontent = 4;

    pub fn get_hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(0)
    }

    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }

    // optional fixed32 file_size = 5;

    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional bool is_depot_content = 6;

    pub fn get_is_depot_content(&self) -> bool {
        self.is_depot_content.unwrap_or(false)
    }

    pub fn clear_is_depot_content(&mut self) {
        self.is_depot_content = ::std::option::Option::None;
    }

    pub fn has_is_depot_content(&self) -> bool {
        self.is_depot_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_depot_content(&mut self, v: bool) {
        self.is_depot_content = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 7;

    pub fn get_revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishedFileUpdated {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_size = ::std::option::Option::Some(is.read_fixed32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_depot_content = ::std::option::Option::Some(is.read_bool()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hcontent {
            my_size += 9;
        }
        if let Some(v) = self.file_size {
            my_size += 5;
        }
        if let Some(v) = self.is_depot_content {
            my_size += 2;
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hcontent {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.is_depot_content {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMPublishedFileUpdated {
        CMsgClientUCMPublishedFileUpdated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "published_file_id",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.published_file_id },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.published_file_id },
                CMsgClientUCMPublishedFileUpdated::get_published_file_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.app_id },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.app_id },
                CMsgClientUCMPublishedFileUpdated::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "time_updated",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.time_updated },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.time_updated },
                CMsgClientUCMPublishedFileUpdated::get_time_updated,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "hcontent",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.hcontent },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.hcontent },
                CMsgClientUCMPublishedFileUpdated::get_hcontent,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "file_size",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.file_size },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.file_size },
                CMsgClientUCMPublishedFileUpdated::get_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_depot_content",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.is_depot_content },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.is_depot_content },
                CMsgClientUCMPublishedFileUpdated::get_is_depot_content,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "revision",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.revision },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.revision },
                CMsgClientUCMPublishedFileUpdated::get_revision,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMPublishedFileUpdated>(
                "CMsgClientUCMPublishedFileUpdated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMPublishedFileUpdated {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMPublishedFileUpdated> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMPublishedFileUpdated::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMPublishedFileUpdated {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.hcontent = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.is_depot_content = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMPublishedFileUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMPublishedFileUpdated {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemChangesRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    last_time_updated: ::std::option::Option<u32>,
    num_items_needed: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesRequest {
    fn default() -> &'a CMsgClientWorkshopItemChangesRequest {
        <CMsgClientWorkshopItemChangesRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesRequest {
    pub fn new() -> CMsgClientWorkshopItemChangesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_updated = 2;

    pub fn get_last_time_updated(&self) -> u32 {
        self.last_time_updated.unwrap_or(0)
    }

    pub fn clear_last_time_updated(&mut self) {
        self.last_time_updated = ::std::option::Option::None;
    }

    pub fn has_last_time_updated(&self) -> bool {
        self.last_time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_updated(&mut self, v: u32) {
        self.last_time_updated = ::std::option::Option::Some(v);
    }

    // optional uint32 num_items_needed = 3;

    pub fn get_num_items_needed(&self) -> u32 {
        self.num_items_needed.unwrap_or(0)
    }

    pub fn clear_num_items_needed(&mut self) {
        self.num_items_needed = ::std::option::Option::None;
    }

    pub fn has_num_items_needed(&self) -> bool {
        self.num_items_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_items_needed(&mut self, v: u32) {
        self.num_items_needed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemChangesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_items_needed = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_items_needed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_time_updated {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_items_needed {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemChangesRequest {
        CMsgClientWorkshopItemChangesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientWorkshopItemChangesRequest| { &m.app_id },
                |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.app_id },
                CMsgClientWorkshopItemChangesRequest::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_time_updated",
                |m: &CMsgClientWorkshopItemChangesRequest| { &m.last_time_updated },
                |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.last_time_updated },
                CMsgClientWorkshopItemChangesRequest::get_last_time_updated,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "num_items_needed",
                |m: &CMsgClientWorkshopItemChangesRequest| { &m.num_items_needed },
                |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.num_items_needed },
                CMsgClientWorkshopItemChangesRequest::get_num_items_needed,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientWorkshopItemChangesRequest>(
                "CMsgClientWorkshopItemChangesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientWorkshopItemChangesRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientWorkshopItemChangesRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemChangesRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.last_time_updated = ::std::option::Option::None;
        self.num_items_needed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemChangesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemChangesRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemChangesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    update_time: ::std::option::Option<u32>,
    pub workshop_items: ::protobuf::RepeatedField<cmsg_client_workshop_item_changes_response::WorkshopItemInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesResponse {
    fn default() -> &'a CMsgClientWorkshopItemChangesResponse {
        <CMsgClientWorkshopItemChangesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesResponse {
    pub fn new() -> CMsgClientWorkshopItemChangesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 update_time = 2;

    pub fn get_update_time(&self) -> u32 {
        self.update_time.unwrap_or(0)
    }

    pub fn clear_update_time(&mut self) {
        self.update_time = ::std::option::Option::None;
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: u32) {
        self.update_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemChangesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.workshop_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.workshop_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.update_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemChangesResponse {
        CMsgClientWorkshopItemChangesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientWorkshopItemChangesResponse| { &m.eresult },
                |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.eresult },
                CMsgClientWorkshopItemChangesResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "update_time",
                |m: &CMsgClientWorkshopItemChangesResponse| { &m.update_time },
                |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.update_time },
                CMsgClientWorkshopItemChangesResponse::get_update_time,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_workshop_item_changes_response::WorkshopItemInfo>>(
                "workshop_items",
                |m: &CMsgClientWorkshopItemChangesResponse| { &m.workshop_items },
                |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.workshop_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientWorkshopItemChangesResponse>(
                "CMsgClientWorkshopItemChangesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientWorkshopItemChangesResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientWorkshopItemChangesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemChangesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.update_time = ::std::option::Option::None;
        self.workshop_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemChangesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemChangesResponse {
}

/// Nested message and enums of message `CMsgClientWorkshopItemChangesResponse`
pub mod cmsg_client_workshop_item_changes_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct WorkshopItemInfo {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        time_updated: ::std::option::Option<u32>,
        manifest_id: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemInfo {
        fn default() -> &'a WorkshopItemInfo {
            <WorkshopItemInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemInfo {
        pub fn new() -> WorkshopItemInfo {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_updated = 2;

        pub fn get_time_updated(&self) -> u32 {
            self.time_updated.unwrap_or(0)
        }

        pub fn clear_time_updated(&mut self) {
            self.time_updated = ::std::option::Option::None;
        }

        pub fn has_time_updated(&self) -> bool {
            self.time_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_updated(&mut self, v: u32) {
            self.time_updated = ::std::option::Option::Some(v);
        }

        // optional fixed64 manifest_id = 3;

        pub fn get_manifest_id(&self) -> u64 {
            self.manifest_id.unwrap_or(0)
        }

        pub fn clear_manifest_id(&mut self) {
            self.manifest_id = ::std::option::Option::None;
        }

        pub fn has_manifest_id(&self) -> bool {
            self.manifest_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manifest_id(&mut self, v: u64) {
            self.manifest_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for WorkshopItemInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.manifest_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.time_updated {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.manifest_id {
                my_size += 9;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.time_updated {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.manifest_id {
                os.write_fixed64(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> WorkshopItemInfo {
            WorkshopItemInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &WorkshopItemInfo| { &m.published_file_id },
                    |m: &mut WorkshopItemInfo| { &mut m.published_file_id },
                    WorkshopItemInfo::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_updated",
                    |m: &WorkshopItemInfo| { &m.time_updated },
                    |m: &mut WorkshopItemInfo| { &mut m.time_updated },
                    WorkshopItemInfo::get_time_updated,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "manifest_id",
                    |m: &WorkshopItemInfo| { &m.manifest_id },
                    |m: &mut WorkshopItemInfo| { &mut m.manifest_id },
                    WorkshopItemInfo::get_manifest_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkshopItemInfo>(
                    "CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static WorkshopItemInfo {
            static instance: ::protobuf::rt::Lazy<WorkshopItemInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(WorkshopItemInfo::new)
        }
    }

    impl ::protobuf::Clear for WorkshopItemInfo {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.time_updated = ::std::option::Option::None;
            self.manifest_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for WorkshopItemInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItemInfo {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemInfoRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    last_time_updated: ::std::option::Option<u32>,
    pub workshop_items: ::protobuf::RepeatedField<cmsg_client_workshop_item_info_request::WorkshopItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemInfoRequest {
    fn default() -> &'a CMsgClientWorkshopItemInfoRequest {
        <CMsgClientWorkshopItemInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemInfoRequest {
    pub fn new() -> CMsgClientWorkshopItemInfoRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_updated = 2;

    pub fn get_last_time_updated(&self) -> u32 {
        self.last_time_updated.unwrap_or(0)
    }

    pub fn clear_last_time_updated(&mut self) {
        self.last_time_updated = ::std::option::Option::None;
    }

    pub fn has_last_time_updated(&self) -> bool {
        self.last_time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_updated(&mut self, v: u32) {
        self.last_time_updated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemInfoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.workshop_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.workshop_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_time_updated {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemInfoRequest {
        CMsgClientWorkshopItemInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientWorkshopItemInfoRequest| { &m.app_id },
                |m: &mut CMsgClientWorkshopItemInfoRequest| { &mut m.app_id },
                CMsgClientWorkshopItemInfoRequest::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_time_updated",
                |m: &CMsgClientWorkshopItemInfoRequest| { &m.last_time_updated },
                |m: &mut CMsgClientWorkshopItemInfoRequest| { &mut m.last_time_updated },
                CMsgClientWorkshopItemInfoRequest::get_last_time_updated,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_workshop_item_info_request::WorkshopItem>>(
                "workshop_items",
                |m: &CMsgClientWorkshopItemInfoRequest| { &m.workshop_items },
                |m: &mut CMsgClientWorkshopItemInfoRequest| { &mut m.workshop_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientWorkshopItemInfoRequest>(
                "CMsgClientWorkshopItemInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemInfoRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientWorkshopItemInfoRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientWorkshopItemInfoRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemInfoRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.last_time_updated = ::std::option::Option::None;
        self.workshop_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemInfoRequest {
}

/// Nested message and enums of message `CMsgClientWorkshopItemInfoRequest`
pub mod cmsg_client_workshop_item_info_request {
    #[derive(PartialEq,Clone,Default)]
    pub struct WorkshopItem {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        time_updated: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItem {
        fn default() -> &'a WorkshopItem {
            <WorkshopItem as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItem {
        pub fn new() -> WorkshopItem {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_updated = 2;

        pub fn get_time_updated(&self) -> u32 {
            self.time_updated.unwrap_or(0)
        }

        pub fn clear_time_updated(&mut self) {
            self.time_updated = ::std::option::Option::None;
        }

        pub fn has_time_updated(&self) -> bool {
            self.time_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_updated(&mut self, v: u32) {
            self.time_updated = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for WorkshopItem {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.time_updated {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.time_updated {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> WorkshopItem {
            WorkshopItem::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &WorkshopItem| { &m.published_file_id },
                    |m: &mut WorkshopItem| { &mut m.published_file_id },
                    WorkshopItem::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_updated",
                    |m: &WorkshopItem| { &m.time_updated },
                    |m: &mut WorkshopItem| { &mut m.time_updated },
                    WorkshopItem::get_time_updated,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkshopItem>(
                    "CMsgClientWorkshopItemInfoRequest.WorkshopItem",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static WorkshopItem {
            static instance: ::protobuf::rt::Lazy<WorkshopItem> = ::protobuf::rt::Lazy::INIT;
            instance.get(WorkshopItem::new)
        }
    }

    impl ::protobuf::Clear for WorkshopItem {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.time_updated = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for WorkshopItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItem {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemInfoResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    update_time: ::std::option::Option<u32>,
    pub workshop_items: ::protobuf::RepeatedField<cmsg_client_workshop_item_info_response::WorkshopItemInfo>,
    pub private_items: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemInfoResponse {
    fn default() -> &'a CMsgClientWorkshopItemInfoResponse {
        <CMsgClientWorkshopItemInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemInfoResponse {
    pub fn new() -> CMsgClientWorkshopItemInfoResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 update_time = 2;

    pub fn get_update_time(&self) -> u32 {
        self.update_time.unwrap_or(0)
    }

    pub fn clear_update_time(&mut self) {
        self.update_time = ::std::option::Option::None;
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: u32) {
        self.update_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.workshop_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.workshop_items)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.private_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 9 * self.private_items.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.update_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.private_items {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemInfoResponse {
        CMsgClientWorkshopItemInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientWorkshopItemInfoResponse| { &m.eresult },
                |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.eresult },
                CMsgClientWorkshopItemInfoResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "update_time",
                |m: &CMsgClientWorkshopItemInfoResponse| { &m.update_time },
                |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.update_time },
                CMsgClientWorkshopItemInfoResponse::get_update_time,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_workshop_item_info_response::WorkshopItemInfo>>(
                "workshop_items",
                |m: &CMsgClientWorkshopItemInfoResponse| { &m.workshop_items },
                |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.workshop_items },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "private_items",
                |m: &CMsgClientWorkshopItemInfoResponse| { &m.private_items },
                |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.private_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientWorkshopItemInfoResponse>(
                "CMsgClientWorkshopItemInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemInfoResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientWorkshopItemInfoResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientWorkshopItemInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemInfoResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.update_time = ::std::option::Option::None;
        self.workshop_items.clear();
        self.private_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemInfoResponse {
}

/// Nested message and enums of message `CMsgClientWorkshopItemInfoResponse`
pub mod cmsg_client_workshop_item_info_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct WorkshopItemInfo {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        time_updated: ::std::option::Option<u32>,
        manifest_id: ::std::option::Option<u64>,
        is_legacy: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemInfo {
        fn default() -> &'a WorkshopItemInfo {
            <WorkshopItemInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemInfo {
        pub fn new() -> WorkshopItemInfo {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_updated = 2;

        pub fn get_time_updated(&self) -> u32 {
            self.time_updated.unwrap_or(0)
        }

        pub fn clear_time_updated(&mut self) {
            self.time_updated = ::std::option::Option::None;
        }

        pub fn has_time_updated(&self) -> bool {
            self.time_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_updated(&mut self, v: u32) {
            self.time_updated = ::std::option::Option::Some(v);
        }

        // optional fixed64 manifest_id = 3;

        pub fn get_manifest_id(&self) -> u64 {
            self.manifest_id.unwrap_or(0)
        }

        pub fn clear_manifest_id(&mut self) {
            self.manifest_id = ::std::option::Option::None;
        }

        pub fn has_manifest_id(&self) -> bool {
            self.manifest_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manifest_id(&mut self, v: u64) {
            self.manifest_id = ::std::option::Option::Some(v);
        }

        // optional bool is_legacy = 4;

        pub fn get_is_legacy(&self) -> bool {
            self.is_legacy.unwrap_or(false)
        }

        pub fn clear_is_legacy(&mut self) {
            self.is_legacy = ::std::option::Option::None;
        }

        pub fn has_is_legacy(&self) -> bool {
            self.is_legacy.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_legacy(&mut self, v: bool) {
            self.is_legacy = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for WorkshopItemInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.manifest_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.is_legacy = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.time_updated {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.manifest_id {
                my_size += 9;
            }
            if let Some(v) = self.is_legacy {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.time_updated {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.manifest_id {
                os.write_fixed64(3, v)?;
            }
            if let Some(v) = self.is_legacy {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> WorkshopItemInfo {
            WorkshopItemInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &WorkshopItemInfo| { &m.published_file_id },
                    |m: &mut WorkshopItemInfo| { &mut m.published_file_id },
                    WorkshopItemInfo::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_updated",
                    |m: &WorkshopItemInfo| { &m.time_updated },
                    |m: &mut WorkshopItemInfo| { &mut m.time_updated },
                    WorkshopItemInfo::get_time_updated,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "manifest_id",
                    |m: &WorkshopItemInfo| { &m.manifest_id },
                    |m: &mut WorkshopItemInfo| { &mut m.manifest_id },
                    WorkshopItemInfo::get_manifest_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "is_legacy",
                    |m: &WorkshopItemInfo| { &m.is_legacy },
                    |m: &mut WorkshopItemInfo| { &mut m.is_legacy },
                    WorkshopItemInfo::get_is_legacy,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkshopItemInfo>(
                    "CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static WorkshopItemInfo {
            static instance: ::protobuf::rt::Lazy<WorkshopItemInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(WorkshopItemInfo::new)
        }
    }

    impl ::protobuf::Clear for WorkshopItemInfo {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.time_updated = ::std::option::Option::None;
            self.manifest_id = ::std::option::Option::None;
            self.is_legacy = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for WorkshopItemInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItemInfo {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMGetPublishedFilesForUser {
    // message fields
    app_id: ::std::option::Option<u32>,
    creator_steam_id: ::std::option::Option<u64>,
    pub required_tags: ::protobuf::RepeatedField<::std::string::String>,
    pub excluded_tags: ::protobuf::RepeatedField<::std::string::String>,
    start_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMGetPublishedFilesForUser {
    fn default() -> &'a CMsgClientUCMGetPublishedFilesForUser {
        <CMsgClientUCMGetPublishedFilesForUser as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMGetPublishedFilesForUser {
    pub fn new() -> CMsgClientUCMGetPublishedFilesForUser {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator_steam_id = 2;

    pub fn get_creator_steam_id(&self) -> u64 {
        self.creator_steam_id.unwrap_or(0)
    }

    pub fn clear_creator_steam_id(&mut self) {
        self.creator_steam_id = ::std::option::Option::None;
    }

    pub fn has_creator_steam_id(&self) -> bool {
        self.creator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_steam_id(&mut self, v: u64) {
        self.creator_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 5;

    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMGetPublishedFilesForUser {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.creator_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.required_tags)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excluded_tags)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creator_steam_id {
            my_size += 9;
        }
        for value in &self.required_tags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.excluded_tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.creator_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.required_tags {
            os.write_string(3, &v)?;
        };
        for v in &self.excluded_tags {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.start_index {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMGetPublishedFilesForUser {
        CMsgClientUCMGetPublishedFilesForUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.app_id },
                |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.app_id },
                CMsgClientUCMGetPublishedFilesForUser::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "creator_steam_id",
                |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.creator_steam_id },
                |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.creator_steam_id },
                CMsgClientUCMGetPublishedFilesForUser::get_creator_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "required_tags",
                |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.required_tags },
                |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.required_tags },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "excluded_tags",
                |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.excluded_tags },
                |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.excluded_tags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "start_index",
                |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.start_index },
                |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.start_index },
                CMsgClientUCMGetPublishedFilesForUser::get_start_index,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMGetPublishedFilesForUser>(
                "CMsgClientUCMGetPublishedFilesForUser",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMGetPublishedFilesForUser {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMGetPublishedFilesForUser> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMGetPublishedFilesForUser::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMGetPublishedFilesForUser {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.creator_steam_id = ::std::option::Option::None;
        self.required_tags.clear();
        self.excluded_tags.clear();
        self.start_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMGetPublishedFilesForUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMGetPublishedFilesForUser {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMGetPublishedFilesForUserResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub published_files: ::protobuf::RepeatedField<cmsg_client_ucmget_published_files_for_user_response::PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMGetPublishedFilesForUserResponse {
    fn default() -> &'a CMsgClientUCMGetPublishedFilesForUserResponse {
        <CMsgClientUCMGetPublishedFilesForUserResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMGetPublishedFilesForUserResponse {
    pub fn new() -> CMsgClientUCMGetPublishedFilesForUserResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMGetPublishedFilesForUserResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.published_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.published_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMGetPublishedFilesForUserResponse {
        CMsgClientUCMGetPublishedFilesForUserResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMGetPublishedFilesForUserResponse| { &m.eresult },
                |m: &mut CMsgClientUCMGetPublishedFilesForUserResponse| { &mut m.eresult },
                CMsgClientUCMGetPublishedFilesForUserResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ucmget_published_files_for_user_response::PublishedFileId>>(
                "published_files",
                |m: &CMsgClientUCMGetPublishedFilesForUserResponse| { &m.published_files },
                |m: &mut CMsgClientUCMGetPublishedFilesForUserResponse| { &mut m.published_files },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "total_results",
                |m: &CMsgClientUCMGetPublishedFilesForUserResponse| { &m.total_results },
                |m: &mut CMsgClientUCMGetPublishedFilesForUserResponse| { &mut m.total_results },
                CMsgClientUCMGetPublishedFilesForUserResponse::get_total_results,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMGetPublishedFilesForUserResponse>(
                "CMsgClientUCMGetPublishedFilesForUserResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMGetPublishedFilesForUserResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMGetPublishedFilesForUserResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMGetPublishedFilesForUserResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMGetPublishedFilesForUserResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMGetPublishedFilesForUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMGetPublishedFilesForUserResponse {
}

/// Nested message and enums of message `CMsgClientUCMGetPublishedFilesForUserResponse`
pub mod cmsg_client_ucmget_published_files_for_user_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct PublishedFileId {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &PublishedFileId| { &m.published_file_id },
                    |m: &mut PublishedFileId| { &mut m.published_file_id },
                    PublishedFileId::get_published_file_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileId>(
                    "CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: ::protobuf::rt::Lazy<PublishedFileId> = ::protobuf::rt::Lazy::INIT;
            instance.get(PublishedFileId::new)
        }
    }

    impl ::protobuf::Clear for PublishedFileId {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMSetUserPublishedFileAction {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    action: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMSetUserPublishedFileAction {
    fn default() -> &'a CMsgClientUCMSetUserPublishedFileAction {
        <CMsgClientUCMSetUserPublishedFileAction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMSetUserPublishedFileAction {
    pub fn new() -> CMsgClientUCMSetUserPublishedFileAction {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 action = 3;

    pub fn get_action(&self) -> i32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: i32) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMSetUserPublishedFileAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMSetUserPublishedFileAction {
        CMsgClientUCMSetUserPublishedFileAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "published_file_id",
                |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.published_file_id },
                |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.published_file_id },
                CMsgClientUCMSetUserPublishedFileAction::get_published_file_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.app_id },
                |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.app_id },
                CMsgClientUCMSetUserPublishedFileAction::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "action",
                |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.action },
                |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.action },
                CMsgClientUCMSetUserPublishedFileAction::get_action,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMSetUserPublishedFileAction>(
                "CMsgClientUCMSetUserPublishedFileAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMSetUserPublishedFileAction {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMSetUserPublishedFileAction> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMSetUserPublishedFileAction::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMSetUserPublishedFileAction {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMSetUserPublishedFileAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMSetUserPublishedFileAction {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMSetUserPublishedFileActionResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMSetUserPublishedFileActionResponse {
    fn default() -> &'a CMsgClientUCMSetUserPublishedFileActionResponse {
        <CMsgClientUCMSetUserPublishedFileActionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMSetUserPublishedFileActionResponse {
    pub fn new() -> CMsgClientUCMSetUserPublishedFileActionResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMSetUserPublishedFileActionResponse {
        CMsgClientUCMSetUserPublishedFileActionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMSetUserPublishedFileActionResponse| { &m.eresult },
                |m: &mut CMsgClientUCMSetUserPublishedFileActionResponse| { &mut m.eresult },
                CMsgClientUCMSetUserPublishedFileActionResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMSetUserPublishedFileActionResponse>(
                "CMsgClientUCMSetUserPublishedFileActionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMSetUserPublishedFileActionResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMSetUserPublishedFileActionResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMSetUserPublishedFileActionResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMSetUserPublishedFileActionResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserAction {
    // message fields
    app_id: ::std::option::Option<u32>,
    start_index: ::std::option::Option<u32>,
    action: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserAction {
        <CMsgClientUCMEnumeratePublishedFilesByUserAction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserAction {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserAction {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;

    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional int32 action = 3;

    pub fn get_action(&self) -> i32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: i32) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserAction {
        CMsgClientUCMEnumeratePublishedFilesByUserAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.app_id },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.app_id },
                CMsgClientUCMEnumeratePublishedFilesByUserAction::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "start_index",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.start_index },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.start_index },
                CMsgClientUCMEnumeratePublishedFilesByUserAction::get_start_index,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "action",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.action },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.action },
                CMsgClientUCMEnumeratePublishedFilesByUserAction::get_action,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMEnumeratePublishedFilesByUserAction>(
                "CMsgClientUCMEnumeratePublishedFilesByUserAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserAction {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMEnumeratePublishedFilesByUserAction> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMEnumeratePublishedFilesByUserAction::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumeratePublishedFilesByUserAction {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub published_files: ::protobuf::RepeatedField<cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        <CMsgClientUCMEnumeratePublishedFilesByUserActionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.published_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.published_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.eresult },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.eresult },
                CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ucmenumerate_published_files_by_user_action_response::PublishedFileId>>(
                "published_files",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.published_files },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.published_files },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "total_results",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.total_results },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.total_results },
                CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::get_total_results,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse>(
                "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
}

/// Nested message and enums of message `CMsgClientUCMEnumeratePublishedFilesByUserActionResponse`
pub mod cmsg_client_ucmenumerate_published_files_by_user_action_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct PublishedFileId {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        rtime_time_stamp: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime_time_stamp = 2;

        pub fn get_rtime_time_stamp(&self) -> u32 {
            self.rtime_time_stamp.unwrap_or(0u32)
        }

        pub fn clear_rtime_time_stamp(&mut self) {
            self.rtime_time_stamp = ::std::option::Option::None;
        }

        pub fn has_rtime_time_stamp(&self) -> bool {
            self.rtime_time_stamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime_time_stamp(&mut self, v: u32) {
            self.rtime_time_stamp = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.rtime_time_stamp = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.rtime_time_stamp {
                my_size += 5;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rtime_time_stamp {
                os.write_fixed32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &PublishedFileId| { &m.published_file_id },
                    |m: &mut PublishedFileId| { &mut m.published_file_id },
                    PublishedFileId::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                    "rtime_time_stamp",
                    |m: &PublishedFileId| { &m.rtime_time_stamp },
                    |m: &mut PublishedFileId| { &mut m.rtime_time_stamp },
                    PublishedFileId::get_rtime_time_stamp,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileId>(
                    "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: ::protobuf::rt::Lazy<PublishedFileId> = ::protobuf::rt::Lazy::INIT;
            instance.get(PublishedFileId::new)
        }
    }

    impl ::protobuf::Clear for PublishedFileId {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.rtime_time_stamp = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientScreenshotsChanged {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientScreenshotsChanged {
    fn default() -> &'a CMsgClientScreenshotsChanged {
        <CMsgClientScreenshotsChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientScreenshotsChanged {
    pub fn new() -> CMsgClientScreenshotsChanged {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientScreenshotsChanged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientScreenshotsChanged {
        CMsgClientScreenshotsChanged::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientScreenshotsChanged>(
                "CMsgClientScreenshotsChanged",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientScreenshotsChanged {
        static instance: ::protobuf::rt::Lazy<CMsgClientScreenshotsChanged> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientScreenshotsChanged::new)
    }
}

impl ::protobuf::Clear for CMsgClientScreenshotsChanged {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientScreenshotsChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientScreenshotsChanged {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUpdateUserGameInfo {
    // message fields
    steamid_idgs: ::std::option::Option<u64>,
    gameid: ::std::option::Option<u64>,
    game_ip: ::std::option::Option<u32>,
    game_port: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateUserGameInfo {
    fn default() -> &'a CMsgClientUpdateUserGameInfo {
        <CMsgClientUpdateUserGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateUserGameInfo {
    pub fn new() -> CMsgClientUpdateUserGameInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_idgs = 1;

    pub fn get_steamid_idgs(&self) -> u64 {
        self.steamid_idgs.unwrap_or(0)
    }

    pub fn clear_steamid_idgs(&mut self) {
        self.steamid_idgs = ::std::option::Option::None;
    }

    pub fn has_steamid_idgs(&self) -> bool {
        self.steamid_idgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_idgs(&mut self, v: u64) {
        self.steamid_idgs = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameid = 2;

    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 game_ip = 3;

    pub fn get_game_ip(&self) -> u32 {
        self.game_ip.unwrap_or(0)
    }

    pub fn clear_game_ip(&mut self) {
        self.game_ip = ::std::option::Option::None;
    }

    pub fn has_game_ip(&self) -> bool {
        self.game_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_ip(&mut self, v: u32) {
        self.game_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn get_game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional bytes token = 5;

    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientUpdateUserGameInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid_idgs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_idgs {
            my_size += 9;
        }
        if let Some(v) = self.gameid {
            my_size += 9;
        }
        if let Some(v) = self.game_ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_idgs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.game_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUpdateUserGameInfo {
        CMsgClientUpdateUserGameInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid_idgs",
                |m: &CMsgClientUpdateUserGameInfo| { &m.steamid_idgs },
                |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.steamid_idgs },
                CMsgClientUpdateUserGameInfo::get_steamid_idgs,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "gameid",
                |m: &CMsgClientUpdateUserGameInfo| { &m.gameid },
                |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.gameid },
                CMsgClientUpdateUserGameInfo::get_gameid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "game_ip",
                |m: &CMsgClientUpdateUserGameInfo| { &m.game_ip },
                |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.game_ip },
                CMsgClientUpdateUserGameInfo::get_game_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "game_port",
                |m: &CMsgClientUpdateUserGameInfo| { &m.game_port },
                |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.game_port },
                CMsgClientUpdateUserGameInfo::get_game_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "token",
                |m: &CMsgClientUpdateUserGameInfo| { &m.token },
                |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.token },
                CMsgClientUpdateUserGameInfo::get_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUpdateUserGameInfo>(
                "CMsgClientUpdateUserGameInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUpdateUserGameInfo {
        static instance: ::protobuf::rt::Lazy<CMsgClientUpdateUserGameInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUpdateUserGameInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientUpdateUserGameInfo {
    fn clear(&mut self) {
        self.steamid_idgs = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.game_ip = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUpdateUserGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateUserGameInfo {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRichPresenceUpload {
    // message fields
    rich_presence_kv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub steamid_broadcast: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceUpload {
    fn default() -> &'a CMsgClientRichPresenceUpload {
        <CMsgClientRichPresenceUpload as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceUpload {
    pub fn new() -> CMsgClientRichPresenceUpload {
        ::std::default::Default::default()
    }

    // optional bytes rich_presence_kv = 1;

    pub fn get_rich_presence_kv(&self) -> &[u8] {
        match self.rich_presence_kv.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rich_presence_kv(&mut self) {
        self.rich_presence_kv.clear();
    }

    pub fn has_rich_presence_kv(&self) -> bool {
        self.rich_presence_kv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rich_presence_kv(&mut self, v: ::std::vec::Vec<u8>) {
        self.rich_presence_kv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rich_presence_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rich_presence_kv.is_none() {
            self.rich_presence_kv.set_default();
        }
        self.rich_presence_kv.as_mut().unwrap()
    }

    // Take field
    pub fn take_rich_presence_kv(&mut self) -> ::std::vec::Vec<u8> {
        self.rich_presence_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceUpload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rich_presence_kv)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_broadcast)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.rich_presence_kv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += 9 * self.steamid_broadcast.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rich_presence_kv.as_ref() {
            os.write_bytes(1, v)?;
        }
        for v in &self.steamid_broadcast {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRichPresenceUpload {
        CMsgClientRichPresenceUpload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "rich_presence_kv",
                |m: &CMsgClientRichPresenceUpload| { &m.rich_presence_kv },
                |m: &mut CMsgClientRichPresenceUpload| { &mut m.rich_presence_kv },
                CMsgClientRichPresenceUpload::get_rich_presence_kv,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "steamid_broadcast",
                |m: &CMsgClientRichPresenceUpload| { &m.steamid_broadcast },
                |m: &mut CMsgClientRichPresenceUpload| { &mut m.steamid_broadcast },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRichPresenceUpload>(
                "CMsgClientRichPresenceUpload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRichPresenceUpload {
        static instance: ::protobuf::rt::Lazy<CMsgClientRichPresenceUpload> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRichPresenceUpload::new)
    }
}

impl ::protobuf::Clear for CMsgClientRichPresenceUpload {
    fn clear(&mut self) {
        self.rich_presence_kv.clear();
        self.steamid_broadcast.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRichPresenceUpload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRichPresenceUpload {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRichPresenceRequest {
    // message fields
    pub steamid_request: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceRequest {
    fn default() -> &'a CMsgClientRichPresenceRequest {
        <CMsgClientRichPresenceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceRequest {
    pub fn new() -> CMsgClientRichPresenceRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_request)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.steamid_request.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.steamid_request {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRichPresenceRequest {
        CMsgClientRichPresenceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "steamid_request",
                |m: &CMsgClientRichPresenceRequest| { &m.steamid_request },
                |m: &mut CMsgClientRichPresenceRequest| { &mut m.steamid_request },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRichPresenceRequest>(
                "CMsgClientRichPresenceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRichPresenceRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientRichPresenceRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRichPresenceRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientRichPresenceRequest {
    fn clear(&mut self) {
        self.steamid_request.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRichPresenceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRichPresenceRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRichPresenceInfo {
    // message fields
    pub rich_presence: ::protobuf::RepeatedField<cmsg_client_rich_presence_info::RichPresence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceInfo {
    fn default() -> &'a CMsgClientRichPresenceInfo {
        <CMsgClientRichPresenceInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceInfo {
    pub fn new() -> CMsgClientRichPresenceInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.rich_presence {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.rich_presence)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rich_presence {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rich_presence {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRichPresenceInfo {
        CMsgClientRichPresenceInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_rich_presence_info::RichPresence>>(
                "rich_presence",
                |m: &CMsgClientRichPresenceInfo| { &m.rich_presence },
                |m: &mut CMsgClientRichPresenceInfo| { &mut m.rich_presence },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRichPresenceInfo>(
                "CMsgClientRichPresenceInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRichPresenceInfo {
        static instance: ::protobuf::rt::Lazy<CMsgClientRichPresenceInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRichPresenceInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientRichPresenceInfo {
    fn clear(&mut self) {
        self.rich_presence.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRichPresenceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRichPresenceInfo {
}

/// Nested message and enums of message `CMsgClientRichPresenceInfo`
pub mod cmsg_client_rich_presence_info {
    #[derive(PartialEq,Clone,Default)]
    pub struct RichPresence {
        // message fields
        steamid_user: ::std::option::Option<u64>,
        rich_presence_kv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a RichPresence {
        fn default() -> &'a RichPresence {
            <RichPresence as ::protobuf::Message>::default_instance()
        }
    }

    impl RichPresence {
        pub fn new() -> RichPresence {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid_user = 1;

        pub fn get_steamid_user(&self) -> u64 {
            self.steamid_user.unwrap_or(0)
        }

        pub fn clear_steamid_user(&mut self) {
            self.steamid_user = ::std::option::Option::None;
        }

        pub fn has_steamid_user(&self) -> bool {
            self.steamid_user.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid_user(&mut self, v: u64) {
            self.steamid_user = ::std::option::Option::Some(v);
        }

        // optional bytes rich_presence_kv = 2;

        pub fn get_rich_presence_kv(&self) -> &[u8] {
            match self.rich_presence_kv.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_rich_presence_kv(&mut self) {
            self.rich_presence_kv.clear();
        }

        pub fn has_rich_presence_kv(&self) -> bool {
            self.rich_presence_kv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rich_presence_kv(&mut self, v: ::std::vec::Vec<u8>) {
            self.rich_presence_kv = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rich_presence_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.rich_presence_kv.is_none() {
                self.rich_presence_kv.set_default();
            }
            self.rich_presence_kv.as_mut().unwrap()
        }

        // Take field
        pub fn take_rich_presence_kv(&mut self) -> ::std::vec::Vec<u8> {
            self.rich_presence_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for RichPresence {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steamid_user = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rich_presence_kv)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steamid_user {
                my_size += 9;
            }
            if let Some(v) = self.rich_presence_kv.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steamid_user {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.rich_presence_kv.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> RichPresence {
            RichPresence::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steamid_user",
                    |m: &RichPresence| { &m.steamid_user },
                    |m: &mut RichPresence| { &mut m.steamid_user },
                    RichPresence::get_steamid_user,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "rich_presence_kv",
                    |m: &RichPresence| { &m.rich_presence_kv },
                    |m: &mut RichPresence| { &mut m.rich_presence_kv },
                    RichPresence::get_rich_presence_kv,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RichPresence>(
                    "CMsgClientRichPresenceInfo.RichPresence",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static RichPresence {
            static instance: ::protobuf::rt::Lazy<RichPresence> = ::protobuf::rt::Lazy::INIT;
            instance.get(RichPresence::new)
        }
    }

    impl ::protobuf::Clear for RichPresence {
        fn clear(&mut self) {
            self.steamid_user = ::std::option::Option::None;
            self.rich_presence_kv.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for RichPresence {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RichPresence {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCheckFileSignature {
    // message fields
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckFileSignature {
    fn default() -> &'a CMsgClientCheckFileSignature {
        <CMsgClientCheckFileSignature as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckFileSignature {
    pub fn new() -> CMsgClientCheckFileSignature {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCheckFileSignature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCheckFileSignature {
        CMsgClientCheckFileSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientCheckFileSignature| { &m.app_id },
                |m: &mut CMsgClientCheckFileSignature| { &mut m.app_id },
                CMsgClientCheckFileSignature::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientCheckFileSignature>(
                "CMsgClientCheckFileSignature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCheckFileSignature {
        static instance: ::protobuf::rt::Lazy<CMsgClientCheckFileSignature> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientCheckFileSignature::new)
    }
}

impl ::protobuf::Clear for CMsgClientCheckFileSignature {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCheckFileSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckFileSignature {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCheckFileSignatureResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    pid: ::std::option::Option<u32>,
    eresult: ::std::option::Option<u32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    esignatureresult: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signatureheader: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    filesize: ::std::option::Option<u32>,
    getlasterror: ::std::option::Option<u32>,
    evalvesignaturecheckdetail: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckFileSignatureResponse {
    fn default() -> &'a CMsgClientCheckFileSignatureResponse {
        <CMsgClientCheckFileSignatureResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckFileSignatureResponse {
    pub fn new() -> CMsgClientCheckFileSignatureResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 pid = 2;

    pub fn get_pid(&self) -> u32 {
        self.pid.unwrap_or(0)
    }

    pub fn clear_pid(&mut self) {
        self.pid = ::std::option::Option::None;
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 3;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 esignatureresult = 5;

    pub fn get_esignatureresult(&self) -> u32 {
        self.esignatureresult.unwrap_or(0)
    }

    pub fn clear_esignatureresult(&mut self) {
        self.esignatureresult = ::std::option::Option::None;
    }

    pub fn has_esignatureresult(&self) -> bool {
        self.esignatureresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_esignatureresult(&mut self, v: u32) {
        self.esignatureresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 6;

    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signatureheader = 7;

    pub fn get_signatureheader(&self) -> &[u8] {
        match self.signatureheader.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signatureheader(&mut self) {
        self.signatureheader.clear();
    }

    pub fn has_signatureheader(&self) -> bool {
        self.signatureheader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signatureheader(&mut self, v: ::std::vec::Vec<u8>) {
        self.signatureheader = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signatureheader(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signatureheader.is_none() {
            self.signatureheader.set_default();
        }
        self.signatureheader.as_mut().unwrap()
    }

    // Take field
    pub fn take_signatureheader(&mut self) -> ::std::vec::Vec<u8> {
        self.signatureheader.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 filesize = 8;

    pub fn get_filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional uint32 getlasterror = 9;

    pub fn get_getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 evalvesignaturecheckdetail = 10;

    pub fn get_evalvesignaturecheckdetail(&self) -> u32 {
        self.evalvesignaturecheckdetail.unwrap_or(0)
    }

    pub fn clear_evalvesignaturecheckdetail(&mut self) {
        self.evalvesignaturecheckdetail = ::std::option::Option::None;
    }

    pub fn has_evalvesignaturecheckdetail(&self) -> bool {
        self.evalvesignaturecheckdetail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evalvesignaturecheckdetail(&mut self, v: u32) {
        self.evalvesignaturecheckdetail = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCheckFileSignatureResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pid = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.esignatureresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signatureheader)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.evalvesignaturecheckdetail = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.esignatureresult {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.signatureheader.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.evalvesignaturecheckdetail {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.pid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.esignatureresult {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.signatureheader.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.evalvesignaturecheckdetail {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCheckFileSignatureResponse {
        CMsgClientCheckFileSignatureResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.app_id },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.app_id },
                CMsgClientCheckFileSignatureResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "pid",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.pid },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.pid },
                CMsgClientCheckFileSignatureResponse::get_pid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.eresult },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.eresult },
                CMsgClientCheckFileSignatureResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.filename },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.filename },
                CMsgClientCheckFileSignatureResponse::get_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "esignatureresult",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.esignatureresult },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.esignatureresult },
                CMsgClientCheckFileSignatureResponse::get_esignatureresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sha_file",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.sha_file },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.sha_file },
                CMsgClientCheckFileSignatureResponse::get_sha_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "signatureheader",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.signatureheader },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.signatureheader },
                CMsgClientCheckFileSignatureResponse::get_signatureheader,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "filesize",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.filesize },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.filesize },
                CMsgClientCheckFileSignatureResponse::get_filesize,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "getlasterror",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.getlasterror },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.getlasterror },
                CMsgClientCheckFileSignatureResponse::get_getlasterror,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "evalvesignaturecheckdetail",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.evalvesignaturecheckdetail },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.evalvesignaturecheckdetail },
                CMsgClientCheckFileSignatureResponse::get_evalvesignaturecheckdetail,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientCheckFileSignatureResponse>(
                "CMsgClientCheckFileSignatureResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCheckFileSignatureResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientCheckFileSignatureResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientCheckFileSignatureResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientCheckFileSignatureResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.pid = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filename.clear();
        self.esignatureresult = ::std::option::Option::None;
        self.sha_file.clear();
        self.signatureheader.clear();
        self.filesize = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.evalvesignaturecheckdetail = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCheckFileSignatureResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckFileSignatureResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientReadMachineAuth {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<u32>,
    cubtoread: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientReadMachineAuth {
    fn default() -> &'a CMsgClientReadMachineAuth {
        <CMsgClientReadMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReadMachineAuth {
    pub fn new() -> CMsgClientReadMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 offset = 2;

    pub fn get_offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubtoread = 3;

    pub fn get_cubtoread(&self) -> u32 {
        self.cubtoread.unwrap_or(0)
    }

    pub fn clear_cubtoread(&mut self) {
        self.cubtoread = ::std::option::Option::None;
    }

    pub fn has_cubtoread(&self) -> bool {
        self.cubtoread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubtoread(&mut self, v: u32) {
        self.cubtoread = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientReadMachineAuth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cubtoread = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cubtoread {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubtoread {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientReadMachineAuth {
        CMsgClientReadMachineAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename",
                |m: &CMsgClientReadMachineAuth| { &m.filename },
                |m: &mut CMsgClientReadMachineAuth| { &mut m.filename },
                CMsgClientReadMachineAuth::get_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "offset",
                |m: &CMsgClientReadMachineAuth| { &m.offset },
                |m: &mut CMsgClientReadMachineAuth| { &mut m.offset },
                CMsgClientReadMachineAuth::get_offset,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cubtoread",
                |m: &CMsgClientReadMachineAuth| { &m.cubtoread },
                |m: &mut CMsgClientReadMachineAuth| { &mut m.cubtoread },
                CMsgClientReadMachineAuth::get_cubtoread,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientReadMachineAuth>(
                "CMsgClientReadMachineAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientReadMachineAuth {
        static instance: ::protobuf::rt::Lazy<CMsgClientReadMachineAuth> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientReadMachineAuth::new)
    }
}

impl ::protobuf::Clear for CMsgClientReadMachineAuth {
    fn clear(&mut self) {
        self.filename.clear();
        self.offset = ::std::option::Option::None;
        self.cubtoread = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientReadMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientReadMachineAuth {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientReadMachineAuthResponse {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    eresult: ::std::option::Option<u32>,
    filesize: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    getlasterror: ::std::option::Option<u32>,
    offset: ::std::option::Option<u32>,
    cubread: ::std::option::Option<u32>,
    bytes_read: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    filename_sentry: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientReadMachineAuthResponse {
    fn default() -> &'a CMsgClientReadMachineAuthResponse {
        <CMsgClientReadMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReadMachineAuthResponse {
    pub fn new() -> CMsgClientReadMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult = 2;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn get_filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;

    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 getlasterror = 5;

    pub fn get_getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 6;

    pub fn get_offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubread = 7;

    pub fn get_cubread(&self) -> u32 {
        self.cubread.unwrap_or(0)
    }

    pub fn clear_cubread(&mut self) {
        self.cubread = ::std::option::Option::None;
    }

    pub fn has_cubread(&self) -> bool {
        self.cubread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubread(&mut self, v: u32) {
        self.cubread = ::std::option::Option::Some(v);
    }

    // optional bytes bytes_read = 8;

    pub fn get_bytes_read(&self) -> &[u8] {
        match self.bytes_read.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes_read(&mut self) {
        self.bytes_read.clear();
    }

    pub fn has_bytes_read(&self) -> bool {
        self.bytes_read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_read(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_read = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_read(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes_read.is_none() {
            self.bytes_read.set_default();
        }
        self.bytes_read.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_read(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes_read.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string filename_sentry = 9;

    pub fn get_filename_sentry(&self) -> &str {
        match self.filename_sentry.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename_sentry(&mut self) {
        self.filename_sentry.clear();
    }

    pub fn has_filename_sentry(&self) -> bool {
        self.filename_sentry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename_sentry(&mut self, v: ::std::string::String) {
        self.filename_sentry = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename_sentry(&mut self) -> &mut ::std::string::String {
        if self.filename_sentry.is_none() {
            self.filename_sentry.set_default();
        }
        self.filename_sentry.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename_sentry(&mut self) -> ::std::string::String {
        self.filename_sentry.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientReadMachineAuthResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cubread = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.bytes_read)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename_sentry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cubread {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_read.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.filename_sentry.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cubread {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bytes_read.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.filename_sentry.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientReadMachineAuthResponse {
        CMsgClientReadMachineAuthResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename",
                |m: &CMsgClientReadMachineAuthResponse| { &m.filename },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filename },
                CMsgClientReadMachineAuthResponse::get_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientReadMachineAuthResponse| { &m.eresult },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.eresult },
                CMsgClientReadMachineAuthResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "filesize",
                |m: &CMsgClientReadMachineAuthResponse| { &m.filesize },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filesize },
                CMsgClientReadMachineAuthResponse::get_filesize,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sha_file",
                |m: &CMsgClientReadMachineAuthResponse| { &m.sha_file },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.sha_file },
                CMsgClientReadMachineAuthResponse::get_sha_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "getlasterror",
                |m: &CMsgClientReadMachineAuthResponse| { &m.getlasterror },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.getlasterror },
                CMsgClientReadMachineAuthResponse::get_getlasterror,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "offset",
                |m: &CMsgClientReadMachineAuthResponse| { &m.offset },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.offset },
                CMsgClientReadMachineAuthResponse::get_offset,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cubread",
                |m: &CMsgClientReadMachineAuthResponse| { &m.cubread },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.cubread },
                CMsgClientReadMachineAuthResponse::get_cubread,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "bytes_read",
                |m: &CMsgClientReadMachineAuthResponse| { &m.bytes_read },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.bytes_read },
                CMsgClientReadMachineAuthResponse::get_bytes_read,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename_sentry",
                |m: &CMsgClientReadMachineAuthResponse| { &m.filename_sentry },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filename_sentry },
                CMsgClientReadMachineAuthResponse::get_filename_sentry,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientReadMachineAuthResponse>(
                "CMsgClientReadMachineAuthResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientReadMachineAuthResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientReadMachineAuthResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientReadMachineAuthResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientReadMachineAuthResponse {
    fn clear(&mut self) {
        self.filename.clear();
        self.eresult = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_file.clear();
        self.getlasterror = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubread = ::std::option::Option::None;
        self.bytes_read.clear();
        self.filename_sentry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientReadMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientReadMachineAuthResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUpdateMachineAuth {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<u32>,
    cubtowrite: ::std::option::Option<u32>,
    bytes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    otp_type: ::std::option::Option<u32>,
    otp_identifier: ::protobuf::SingularField<::std::string::String>,
    otp_sharedsecret: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    otp_timedrift: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateMachineAuth {
    fn default() -> &'a CMsgClientUpdateMachineAuth {
        <CMsgClientUpdateMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateMachineAuth {
    pub fn new() -> CMsgClientUpdateMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 offset = 2;

    pub fn get_offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubtowrite = 3;

    pub fn get_cubtowrite(&self) -> u32 {
        self.cubtowrite.unwrap_or(0)
    }

    pub fn clear_cubtowrite(&mut self) {
        self.cubtowrite = ::std::option::Option::None;
    }

    pub fn has_cubtowrite(&self) -> bool {
        self.cubtowrite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubtowrite(&mut self, v: u32) {
        self.cubtowrite = ::std::option::Option::Some(v);
    }

    // optional bytes bytes = 4;

    pub fn get_bytes(&self) -> &[u8] {
        match self.bytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes(&mut self) {
        self.bytes.clear();
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes.is_none() {
            self.bytes.set_default();
        }
        self.bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_type = 5;

    pub fn get_otp_type(&self) -> u32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: u32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 6;

    pub fn get_otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier.clear();
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier.set_default();
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes otp_sharedsecret = 7;

    pub fn get_otp_sharedsecret(&self) -> &[u8] {
        match self.otp_sharedsecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_otp_sharedsecret(&mut self) {
        self.otp_sharedsecret.clear();
    }

    pub fn has_otp_sharedsecret(&self) -> bool {
        self.otp_sharedsecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_sharedsecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.otp_sharedsecret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_sharedsecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otp_sharedsecret.is_none() {
            self.otp_sharedsecret.set_default();
        }
        self.otp_sharedsecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_sharedsecret(&mut self) -> ::std::vec::Vec<u8> {
        self.otp_sharedsecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_timedrift = 8;

    pub fn get_otp_timedrift(&self) -> u32 {
        self.otp_timedrift.unwrap_or(0)
    }

    pub fn clear_otp_timedrift(&mut self) {
        self.otp_timedrift = ::std::option::Option::None;
    }

    pub fn has_otp_timedrift(&self) -> bool {
        self.otp_timedrift.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_timedrift(&mut self, v: u32) {
        self.otp_timedrift = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUpdateMachineAuth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cubtowrite = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.bytes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.otp_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.otp_identifier)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.otp_sharedsecret)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.otp_timedrift = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cubtowrite {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.otp_timedrift {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubtowrite {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.bytes.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.otp_timedrift {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUpdateMachineAuth {
        CMsgClientUpdateMachineAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename",
                |m: &CMsgClientUpdateMachineAuth| { &m.filename },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.filename },
                CMsgClientUpdateMachineAuth::get_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "offset",
                |m: &CMsgClientUpdateMachineAuth| { &m.offset },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.offset },
                CMsgClientUpdateMachineAuth::get_offset,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cubtowrite",
                |m: &CMsgClientUpdateMachineAuth| { &m.cubtowrite },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.cubtowrite },
                CMsgClientUpdateMachineAuth::get_cubtowrite,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "bytes",
                |m: &CMsgClientUpdateMachineAuth| { &m.bytes },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.bytes },
                CMsgClientUpdateMachineAuth::get_bytes,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "otp_type",
                |m: &CMsgClientUpdateMachineAuth| { &m.otp_type },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_type },
                CMsgClientUpdateMachineAuth::get_otp_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "otp_identifier",
                |m: &CMsgClientUpdateMachineAuth| { &m.otp_identifier },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_identifier },
                CMsgClientUpdateMachineAuth::get_otp_identifier,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "otp_sharedsecret",
                |m: &CMsgClientUpdateMachineAuth| { &m.otp_sharedsecret },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_sharedsecret },
                CMsgClientUpdateMachineAuth::get_otp_sharedsecret,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "otp_timedrift",
                |m: &CMsgClientUpdateMachineAuth| { &m.otp_timedrift },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_timedrift },
                CMsgClientUpdateMachineAuth::get_otp_timedrift,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUpdateMachineAuth>(
                "CMsgClientUpdateMachineAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUpdateMachineAuth {
        static instance: ::protobuf::rt::Lazy<CMsgClientUpdateMachineAuth> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUpdateMachineAuth::new)
    }
}

impl ::protobuf::Clear for CMsgClientUpdateMachineAuth {
    fn clear(&mut self) {
        self.filename.clear();
        self.offset = ::std::option::Option::None;
        self.cubtowrite = ::std::option::Option::None;
        self.bytes.clear();
        self.otp_type = ::std::option::Option::None;
        self.otp_identifier.clear();
        self.otp_sharedsecret.clear();
        self.otp_timedrift = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUpdateMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateMachineAuth {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUpdateMachineAuthResponse {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    eresult: ::std::option::Option<u32>,
    filesize: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    getlasterror: ::std::option::Option<u32>,
    offset: ::std::option::Option<u32>,
    cubwrote: ::std::option::Option<u32>,
    otp_type: ::std::option::Option<i32>,
    otp_value: ::std::option::Option<u32>,
    otp_identifier: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateMachineAuthResponse {
    fn default() -> &'a CMsgClientUpdateMachineAuthResponse {
        <CMsgClientUpdateMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateMachineAuthResponse {
    pub fn new() -> CMsgClientUpdateMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult = 2;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn get_filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;

    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 getlasterror = 5;

    pub fn get_getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }

    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 6;

    pub fn get_offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubwrote = 7;

    pub fn get_cubwrote(&self) -> u32 {
        self.cubwrote.unwrap_or(0)
    }

    pub fn clear_cubwrote(&mut self) {
        self.cubwrote = ::std::option::Option::None;
    }

    pub fn has_cubwrote(&self) -> bool {
        self.cubwrote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubwrote(&mut self, v: u32) {
        self.cubwrote = ::std::option::Option::Some(v);
    }

    // optional int32 otp_type = 8;

    pub fn get_otp_type(&self) -> i32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: i32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional uint32 otp_value = 9;

    pub fn get_otp_value(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }

    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 10;

    pub fn get_otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier.clear();
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier.set_default();
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUpdateMachineAuthResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.getlasterror = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cubwrote = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.otp_type = ::std::option::Option::Some(is.read_int32()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.otp_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.otp_identifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cubwrote {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.otp_value {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_file.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cubwrote {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.otp_value {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUpdateMachineAuthResponse {
        CMsgClientUpdateMachineAuthResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.filename },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.filename },
                CMsgClientUpdateMachineAuthResponse::get_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.eresult },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.eresult },
                CMsgClientUpdateMachineAuthResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "filesize",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.filesize },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.filesize },
                CMsgClientUpdateMachineAuthResponse::get_filesize,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sha_file",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.sha_file },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.sha_file },
                CMsgClientUpdateMachineAuthResponse::get_sha_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "getlasterror",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.getlasterror },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.getlasterror },
                CMsgClientUpdateMachineAuthResponse::get_getlasterror,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "offset",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.offset },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.offset },
                CMsgClientUpdateMachineAuthResponse::get_offset,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cubwrote",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.cubwrote },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.cubwrote },
                CMsgClientUpdateMachineAuthResponse::get_cubwrote,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "otp_type",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_type },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_type },
                CMsgClientUpdateMachineAuthResponse::get_otp_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "otp_value",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_value },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_value },
                CMsgClientUpdateMachineAuthResponse::get_otp_value,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "otp_identifier",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_identifier },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_identifier },
                CMsgClientUpdateMachineAuthResponse::get_otp_identifier,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUpdateMachineAuthResponse>(
                "CMsgClientUpdateMachineAuthResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUpdateMachineAuthResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUpdateMachineAuthResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUpdateMachineAuthResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUpdateMachineAuthResponse {
    fn clear(&mut self) {
        self.filename.clear();
        self.eresult = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_file.clear();
        self.getlasterror = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubwrote = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_value = ::std::option::Option::None;
        self.otp_identifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUpdateMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateMachineAuthResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestMachineAuth {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    eresult_sentryfile: ::std::option::Option<u32>,
    filesize: ::std::option::Option<u32>,
    sha_sentryfile: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    lock_account_action: ::std::option::Option<i32>,
    otp_type: ::std::option::Option<u32>,
    otp_identifier: ::protobuf::SingularField<::std::string::String>,
    otp_sharedsecret: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    otp_value: ::std::option::Option<u32>,
    machine_name: ::protobuf::SingularField<::std::string::String>,
    machine_name_userchosen: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestMachineAuth {
    fn default() -> &'a CMsgClientRequestMachineAuth {
        <CMsgClientRequestMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestMachineAuth {
    pub fn new() -> CMsgClientRequestMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult_sentryfile = 2;

    pub fn get_eresult_sentryfile(&self) -> u32 {
        self.eresult_sentryfile.unwrap_or(0)
    }

    pub fn clear_eresult_sentryfile(&mut self) {
        self.eresult_sentryfile = ::std::option::Option::None;
    }

    pub fn has_eresult_sentryfile(&self) -> bool {
        self.eresult_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult_sentryfile(&mut self, v: u32) {
        self.eresult_sentryfile = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;

    pub fn get_filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_sentryfile = 4;

    pub fn get_sha_sentryfile(&self) -> &[u8] {
        match self.sha_sentryfile.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_sentryfile(&mut self) {
        self.sha_sentryfile.clear();
    }

    pub fn has_sha_sentryfile(&self) -> bool {
        self.sha_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_sentryfile(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_sentryfile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_sentryfile(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_sentryfile.is_none() {
            self.sha_sentryfile.set_default();
        }
        self.sha_sentryfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_sentryfile(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_sentryfile.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 lock_account_action = 6;

    pub fn get_lock_account_action(&self) -> i32 {
        self.lock_account_action.unwrap_or(0)
    }

    pub fn clear_lock_account_action(&mut self) {
        self.lock_account_action = ::std::option::Option::None;
    }

    pub fn has_lock_account_action(&self) -> bool {
        self.lock_account_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_account_action(&mut self, v: i32) {
        self.lock_account_action = ::std::option::Option::Some(v);
    }

    // optional uint32 otp_type = 7;

    pub fn get_otp_type(&self) -> u32 {
        self.otp_type.unwrap_or(0)
    }

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: u32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 8;

    pub fn get_otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier.clear();
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier.set_default();
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes otp_sharedsecret = 9;

    pub fn get_otp_sharedsecret(&self) -> &[u8] {
        match self.otp_sharedsecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_otp_sharedsecret(&mut self) {
        self.otp_sharedsecret.clear();
    }

    pub fn has_otp_sharedsecret(&self) -> bool {
        self.otp_sharedsecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_sharedsecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.otp_sharedsecret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_sharedsecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otp_sharedsecret.is_none() {
            self.otp_sharedsecret.set_default();
        }
        self.otp_sharedsecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_sharedsecret(&mut self) -> ::std::vec::Vec<u8> {
        self.otp_sharedsecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_value = 10;

    pub fn get_otp_value(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }

    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    // optional string machine_name = 11;

    pub fn get_machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name(&mut self) {
        self.machine_name.clear();
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name.set_default();
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_name_userchosen = 12;

    pub fn get_machine_name_userchosen(&self) -> &str {
        match self.machine_name_userchosen.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_name_userchosen(&mut self) {
        self.machine_name_userchosen.clear();
    }

    pub fn has_machine_name_userchosen(&self) -> bool {
        self.machine_name_userchosen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name_userchosen(&mut self, v: ::std::string::String) {
        self.machine_name_userchosen = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name_userchosen(&mut self) -> &mut ::std::string::String {
        if self.machine_name_userchosen.is_none() {
            self.machine_name_userchosen.set_default();
        }
        self.machine_name_userchosen.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name_userchosen(&mut self) -> ::std::string::String {
        self.machine_name_userchosen.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestMachineAuth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult_sentryfile = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filesize = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_sentryfile)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lock_account_action = ::std::option::Option::Some(is.read_int32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.otp_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.otp_identifier)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.otp_sharedsecret)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.otp_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name_userchosen)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult_sentryfile {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sha_sentryfile.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.lock_account_action {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.otp_value {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.machine_name_userchosen.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eresult_sentryfile {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.sha_sentryfile.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.lock_account_action {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.otp_identifier.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.otp_sharedsecret.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.otp_value {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.machine_name.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.machine_name_userchosen.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestMachineAuth {
        CMsgClientRequestMachineAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename",
                |m: &CMsgClientRequestMachineAuth| { &m.filename },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.filename },
                CMsgClientRequestMachineAuth::get_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult_sentryfile",
                |m: &CMsgClientRequestMachineAuth| { &m.eresult_sentryfile },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.eresult_sentryfile },
                CMsgClientRequestMachineAuth::get_eresult_sentryfile,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "filesize",
                |m: &CMsgClientRequestMachineAuth| { &m.filesize },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.filesize },
                CMsgClientRequestMachineAuth::get_filesize,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sha_sentryfile",
                |m: &CMsgClientRequestMachineAuth| { &m.sha_sentryfile },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.sha_sentryfile },
                CMsgClientRequestMachineAuth::get_sha_sentryfile,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "lock_account_action",
                |m: &CMsgClientRequestMachineAuth| { &m.lock_account_action },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.lock_account_action },
                CMsgClientRequestMachineAuth::get_lock_account_action,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "otp_type",
                |m: &CMsgClientRequestMachineAuth| { &m.otp_type },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_type },
                CMsgClientRequestMachineAuth::get_otp_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "otp_identifier",
                |m: &CMsgClientRequestMachineAuth| { &m.otp_identifier },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_identifier },
                CMsgClientRequestMachineAuth::get_otp_identifier,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "otp_sharedsecret",
                |m: &CMsgClientRequestMachineAuth| { &m.otp_sharedsecret },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_sharedsecret },
                CMsgClientRequestMachineAuth::get_otp_sharedsecret,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "otp_value",
                |m: &CMsgClientRequestMachineAuth| { &m.otp_value },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_value },
                CMsgClientRequestMachineAuth::get_otp_value,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "machine_name",
                |m: &CMsgClientRequestMachineAuth| { &m.machine_name },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.machine_name },
                CMsgClientRequestMachineAuth::get_machine_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "machine_name_userchosen",
                |m: &CMsgClientRequestMachineAuth| { &m.machine_name_userchosen },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.machine_name_userchosen },
                CMsgClientRequestMachineAuth::get_machine_name_userchosen,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestMachineAuth>(
                "CMsgClientRequestMachineAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestMachineAuth {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestMachineAuth> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestMachineAuth::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestMachineAuth {
    fn clear(&mut self) {
        self.filename.clear();
        self.eresult_sentryfile = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_sentryfile.clear();
        self.lock_account_action = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_identifier.clear();
        self.otp_sharedsecret.clear();
        self.otp_value = ::std::option::Option::None;
        self.machine_name.clear();
        self.machine_name_userchosen.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestMachineAuth {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestMachineAuthResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestMachineAuthResponse {
    fn default() -> &'a CMsgClientRequestMachineAuthResponse {
        <CMsgClientRequestMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestMachineAuthResponse {
    pub fn new() -> CMsgClientRequestMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestMachineAuthResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestMachineAuthResponse {
        CMsgClientRequestMachineAuthResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientRequestMachineAuthResponse| { &m.eresult },
                |m: &mut CMsgClientRequestMachineAuthResponse| { &mut m.eresult },
                CMsgClientRequestMachineAuthResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestMachineAuthResponse>(
                "CMsgClientRequestMachineAuthResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestMachineAuthResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestMachineAuthResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestMachineAuthResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestMachineAuthResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestMachineAuthResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRegisterKey {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterKey {
    fn default() -> &'a CMsgClientRegisterKey {
        <CMsgClientRegisterKey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterKey {
    pub fn new() -> CMsgClientRegisterKey {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRegisterKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRegisterKey {
        CMsgClientRegisterKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "key",
                |m: &CMsgClientRegisterKey| { &m.key },
                |m: &mut CMsgClientRegisterKey| { &mut m.key },
                CMsgClientRegisterKey::get_key,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRegisterKey>(
                "CMsgClientRegisterKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRegisterKey {
        static instance: ::protobuf::rt::Lazy<CMsgClientRegisterKey> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRegisterKey::new)
    }
}

impl ::protobuf::Clear for CMsgClientRegisterKey {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRegisterKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterKey {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPurchaseResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    purchase_result_details: ::std::option::Option<i32>,
    purchase_receipt_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPurchaseResponse {
    fn default() -> &'a CMsgClientPurchaseResponse {
        <CMsgClientPurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPurchaseResponse {
    pub fn new() -> CMsgClientPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 purchase_result_details = 2;

    pub fn get_purchase_result_details(&self) -> i32 {
        self.purchase_result_details.unwrap_or(0)
    }

    pub fn clear_purchase_result_details(&mut self) {
        self.purchase_result_details = ::std::option::Option::None;
    }

    pub fn has_purchase_result_details(&self) -> bool {
        self.purchase_result_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_result_details(&mut self, v: i32) {
        self.purchase_result_details = ::std::option::Option::Some(v);
    }

    // optional bytes purchase_receipt_info = 3;

    pub fn get_purchase_receipt_info(&self) -> &[u8] {
        match self.purchase_receipt_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_purchase_receipt_info(&mut self) {
        self.purchase_receipt_info.clear();
    }

    pub fn has_purchase_receipt_info(&self) -> bool {
        self.purchase_receipt_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_receipt_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.purchase_receipt_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_purchase_receipt_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.purchase_receipt_info.is_none() {
            self.purchase_receipt_info.set_default();
        }
        self.purchase_receipt_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_purchase_receipt_info(&mut self) -> ::std::vec::Vec<u8> {
        self.purchase_receipt_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientPurchaseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.purchase_result_details = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.purchase_receipt_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchase_result_details {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchase_result_details {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.purchase_receipt_info.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPurchaseResponse {
        CMsgClientPurchaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientPurchaseResponse| { &m.eresult },
                |m: &mut CMsgClientPurchaseResponse| { &mut m.eresult },
                CMsgClientPurchaseResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "purchase_result_details",
                |m: &CMsgClientPurchaseResponse| { &m.purchase_result_details },
                |m: &mut CMsgClientPurchaseResponse| { &mut m.purchase_result_details },
                CMsgClientPurchaseResponse::get_purchase_result_details,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "purchase_receipt_info",
                |m: &CMsgClientPurchaseResponse| { &m.purchase_receipt_info },
                |m: &mut CMsgClientPurchaseResponse| { &mut m.purchase_receipt_info },
                CMsgClientPurchaseResponse::get_purchase_receipt_info,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPurchaseResponse>(
                "CMsgClientPurchaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPurchaseResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientPurchaseResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPurchaseResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientPurchaseResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.purchase_result_details = ::std::option::Option::None;
        self.purchase_receipt_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPurchaseResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientActivateOEMLicense {
    // message fields
    bios_manufacturer: ::protobuf::SingularField<::std::string::String>,
    bios_serialnumber: ::protobuf::SingularField<::std::string::String>,
    license_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mainboard_manufacturer: ::protobuf::SingularField<::std::string::String>,
    mainboard_product: ::protobuf::SingularField<::std::string::String>,
    mainboard_serialnumber: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientActivateOEMLicense {
    fn default() -> &'a CMsgClientActivateOEMLicense {
        <CMsgClientActivateOEMLicense as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientActivateOEMLicense {
    pub fn new() -> CMsgClientActivateOEMLicense {
        ::std::default::Default::default()
    }

    // optional string bios_manufacturer = 1;

    pub fn get_bios_manufacturer(&self) -> &str {
        match self.bios_manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bios_manufacturer(&mut self) {
        self.bios_manufacturer.clear();
    }

    pub fn has_bios_manufacturer(&self) -> bool {
        self.bios_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bios_manufacturer(&mut self, v: ::std::string::String) {
        self.bios_manufacturer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bios_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.bios_manufacturer.is_none() {
            self.bios_manufacturer.set_default();
        }
        self.bios_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_bios_manufacturer(&mut self) -> ::std::string::String {
        self.bios_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bios_serialnumber = 2;

    pub fn get_bios_serialnumber(&self) -> &str {
        match self.bios_serialnumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bios_serialnumber(&mut self) {
        self.bios_serialnumber.clear();
    }

    pub fn has_bios_serialnumber(&self) -> bool {
        self.bios_serialnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bios_serialnumber(&mut self, v: ::std::string::String) {
        self.bios_serialnumber = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bios_serialnumber(&mut self) -> &mut ::std::string::String {
        if self.bios_serialnumber.is_none() {
            self.bios_serialnumber.set_default();
        }
        self.bios_serialnumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_bios_serialnumber(&mut self) -> ::std::string::String {
        self.bios_serialnumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes license_file = 3;

    pub fn get_license_file(&self) -> &[u8] {
        match self.license_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_license_file(&mut self) {
        self.license_file.clear();
    }

    pub fn has_license_file(&self) -> bool {
        self.license_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_license_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.license_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.license_file.is_none() {
            self.license_file.set_default();
        }
        self.license_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_license_file(&mut self) -> ::std::vec::Vec<u8> {
        self.license_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string mainboard_manufacturer = 4;

    pub fn get_mainboard_manufacturer(&self) -> &str {
        match self.mainboard_manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_manufacturer(&mut self) {
        self.mainboard_manufacturer.clear();
    }

    pub fn has_mainboard_manufacturer(&self) -> bool {
        self.mainboard_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_manufacturer(&mut self, v: ::std::string::String) {
        self.mainboard_manufacturer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.mainboard_manufacturer.is_none() {
            self.mainboard_manufacturer.set_default();
        }
        self.mainboard_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_manufacturer(&mut self) -> ::std::string::String {
        self.mainboard_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mainboard_product = 5;

    pub fn get_mainboard_product(&self) -> &str {
        match self.mainboard_product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_product(&mut self) {
        self.mainboard_product.clear();
    }

    pub fn has_mainboard_product(&self) -> bool {
        self.mainboard_product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_product(&mut self, v: ::std::string::String) {
        self.mainboard_product = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_product(&mut self) -> &mut ::std::string::String {
        if self.mainboard_product.is_none() {
            self.mainboard_product.set_default();
        }
        self.mainboard_product.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_product(&mut self) -> ::std::string::String {
        self.mainboard_product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mainboard_serialnumber = 6;

    pub fn get_mainboard_serialnumber(&self) -> &str {
        match self.mainboard_serialnumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mainboard_serialnumber(&mut self) {
        self.mainboard_serialnumber.clear();
    }

    pub fn has_mainboard_serialnumber(&self) -> bool {
        self.mainboard_serialnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_serialnumber(&mut self, v: ::std::string::String) {
        self.mainboard_serialnumber = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_serialnumber(&mut self) -> &mut ::std::string::String {
        if self.mainboard_serialnumber.is_none() {
            self.mainboard_serialnumber.set_default();
        }
        self.mainboard_serialnumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_serialnumber(&mut self) -> ::std::string::String {
        self.mainboard_serialnumber.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientActivateOEMLicense {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bios_manufacturer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bios_serialnumber)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.license_file)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mainboard_manufacturer)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mainboard_product)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mainboard_serialnumber)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bios_manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.bios_serialnumber.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.license_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.mainboard_manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.mainboard_product.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.mainboard_serialnumber.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bios_manufacturer.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.bios_serialnumber.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.license_file.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.mainboard_manufacturer.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.mainboard_product.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.mainboard_serialnumber.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientActivateOEMLicense {
        CMsgClientActivateOEMLicense::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "bios_manufacturer",
                |m: &CMsgClientActivateOEMLicense| { &m.bios_manufacturer },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.bios_manufacturer },
                CMsgClientActivateOEMLicense::get_bios_manufacturer,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "bios_serialnumber",
                |m: &CMsgClientActivateOEMLicense| { &m.bios_serialnumber },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.bios_serialnumber },
                CMsgClientActivateOEMLicense::get_bios_serialnumber,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "license_file",
                |m: &CMsgClientActivateOEMLicense| { &m.license_file },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.license_file },
                CMsgClientActivateOEMLicense::get_license_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "mainboard_manufacturer",
                |m: &CMsgClientActivateOEMLicense| { &m.mainboard_manufacturer },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_manufacturer },
                CMsgClientActivateOEMLicense::get_mainboard_manufacturer,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "mainboard_product",
                |m: &CMsgClientActivateOEMLicense| { &m.mainboard_product },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_product },
                CMsgClientActivateOEMLicense::get_mainboard_product,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "mainboard_serialnumber",
                |m: &CMsgClientActivateOEMLicense| { &m.mainboard_serialnumber },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_serialnumber },
                CMsgClientActivateOEMLicense::get_mainboard_serialnumber,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientActivateOEMLicense>(
                "CMsgClientActivateOEMLicense",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientActivateOEMLicense {
        static instance: ::protobuf::rt::Lazy<CMsgClientActivateOEMLicense> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientActivateOEMLicense::new)
    }
}

impl ::protobuf::Clear for CMsgClientActivateOEMLicense {
    fn clear(&mut self) {
        self.bios_manufacturer.clear();
        self.bios_serialnumber.clear();
        self.license_file.clear();
        self.mainboard_manufacturer.clear();
        self.mainboard_product.clear();
        self.mainboard_serialnumber.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientActivateOEMLicense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientActivateOEMLicense {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRegisterOEMMachine {
    // message fields
    oem_register_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterOEMMachine {
    fn default() -> &'a CMsgClientRegisterOEMMachine {
        <CMsgClientRegisterOEMMachine as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterOEMMachine {
    pub fn new() -> CMsgClientRegisterOEMMachine {
        ::std::default::Default::default()
    }

    // optional bytes oem_register_file = 1;

    pub fn get_oem_register_file(&self) -> &[u8] {
        match self.oem_register_file.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_oem_register_file(&mut self) {
        self.oem_register_file.clear();
    }

    pub fn has_oem_register_file(&self) -> bool {
        self.oem_register_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oem_register_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.oem_register_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oem_register_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.oem_register_file.is_none() {
            self.oem_register_file.set_default();
        }
        self.oem_register_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_oem_register_file(&mut self) -> ::std::vec::Vec<u8> {
        self.oem_register_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRegisterOEMMachine {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.oem_register_file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.oem_register_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.oem_register_file.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRegisterOEMMachine {
        CMsgClientRegisterOEMMachine::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "oem_register_file",
                |m: &CMsgClientRegisterOEMMachine| { &m.oem_register_file },
                |m: &mut CMsgClientRegisterOEMMachine| { &mut m.oem_register_file },
                CMsgClientRegisterOEMMachine::get_oem_register_file,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRegisterOEMMachine>(
                "CMsgClientRegisterOEMMachine",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRegisterOEMMachine {
        static instance: ::protobuf::rt::Lazy<CMsgClientRegisterOEMMachine> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRegisterOEMMachine::new)
    }
}

impl ::protobuf::Clear for CMsgClientRegisterOEMMachine {
    fn clear(&mut self) {
        self.oem_register_file.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRegisterOEMMachine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterOEMMachine {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRegisterOEMMachineResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterOEMMachineResponse {
    fn default() -> &'a CMsgClientRegisterOEMMachineResponse {
        <CMsgClientRegisterOEMMachineResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterOEMMachineResponse {
    pub fn new() -> CMsgClientRegisterOEMMachineResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRegisterOEMMachineResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRegisterOEMMachineResponse {
        CMsgClientRegisterOEMMachineResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientRegisterOEMMachineResponse| { &m.eresult },
                |m: &mut CMsgClientRegisterOEMMachineResponse| { &mut m.eresult },
                CMsgClientRegisterOEMMachineResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRegisterOEMMachineResponse>(
                "CMsgClientRegisterOEMMachineResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRegisterOEMMachineResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientRegisterOEMMachineResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRegisterOEMMachineResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRegisterOEMMachineResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRegisterOEMMachineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterOEMMachineResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPurchaseWithMachineID {
    // message fields
    package_id: ::std::option::Option<u32>,
    machine_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPurchaseWithMachineID {
    fn default() -> &'a CMsgClientPurchaseWithMachineID {
        <CMsgClientPurchaseWithMachineID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPurchaseWithMachineID {
    pub fn new() -> CMsgClientPurchaseWithMachineID {
        ::std::default::Default::default()
    }

    // optional uint32 package_id = 1;

    pub fn get_package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }

    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional bytes machine_info = 2;

    pub fn get_machine_info(&self) -> &[u8] {
        match self.machine_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_machine_info(&mut self) {
        self.machine_info.clear();
    }

    pub fn has_machine_info(&self) -> bool {
        self.machine_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.machine_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.machine_info.is_none() {
            self.machine_info.set_default();
        }
        self.machine_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_info(&mut self) -> ::std::vec::Vec<u8> {
        self.machine_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientPurchaseWithMachineID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.machine_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.package_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.machine_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.package_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.machine_info.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPurchaseWithMachineID {
        CMsgClientPurchaseWithMachineID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "package_id",
                |m: &CMsgClientPurchaseWithMachineID| { &m.package_id },
                |m: &mut CMsgClientPurchaseWithMachineID| { &mut m.package_id },
                CMsgClientPurchaseWithMachineID::get_package_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "machine_info",
                |m: &CMsgClientPurchaseWithMachineID| { &m.machine_info },
                |m: &mut CMsgClientPurchaseWithMachineID| { &mut m.machine_info },
                CMsgClientPurchaseWithMachineID::get_machine_info,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPurchaseWithMachineID>(
                "CMsgClientPurchaseWithMachineID",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPurchaseWithMachineID {
        static instance: ::protobuf::rt::Lazy<CMsgClientPurchaseWithMachineID> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPurchaseWithMachineID::new)
    }
}

impl ::protobuf::Clear for CMsgClientPurchaseWithMachineID {
    fn clear(&mut self) {
        self.package_id = ::std::option::Option::None;
        self.machine_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPurchaseWithMachineID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPurchaseWithMachineID {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTrading_InitiateTradeRequest {
    // message fields
    trade_request_id: ::std::option::Option<u32>,
    other_steamid: ::std::option::Option<u64>,
    other_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_InitiateTradeRequest {
    fn default() -> &'a CMsgTrading_InitiateTradeRequest {
        <CMsgTrading_InitiateTradeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_InitiateTradeRequest {
    pub fn new() -> CMsgTrading_InitiateTradeRequest {
        ::std::default::Default::default()
    }

    // optional uint32 trade_request_id = 1;

    pub fn get_trade_request_id(&self) -> u32 {
        self.trade_request_id.unwrap_or(0)
    }

    pub fn clear_trade_request_id(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
    }

    pub fn has_trade_request_id(&self) -> bool {
        self.trade_request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_request_id(&mut self, v: u32) {
        self.trade_request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 other_steamid = 2;

    pub fn get_other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    // optional string other_name = 3;

    pub fn get_other_name(&self) -> &str {
        match self.other_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_other_name(&mut self) {
        self.other_name.clear();
    }

    pub fn has_other_name(&self) -> bool {
        self.other_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_name(&mut self, v: ::std::string::String) {
        self.other_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_name(&mut self) -> &mut ::std::string::String {
        if self.other_name.is_none() {
            self.other_name.set_default();
        }
        self.other_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_name(&mut self) -> ::std::string::String {
        self.other_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgTrading_InitiateTradeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.trade_request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.other_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.trade_request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.other_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.trade_request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.other_steamid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.other_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTrading_InitiateTradeRequest {
        CMsgTrading_InitiateTradeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "trade_request_id",
                |m: &CMsgTrading_InitiateTradeRequest| { &m.trade_request_id },
                |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.trade_request_id },
                CMsgTrading_InitiateTradeRequest::get_trade_request_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "other_steamid",
                |m: &CMsgTrading_InitiateTradeRequest| { &m.other_steamid },
                |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.other_steamid },
                CMsgTrading_InitiateTradeRequest::get_other_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "other_name",
                |m: &CMsgTrading_InitiateTradeRequest| { &m.other_name },
                |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.other_name },
                CMsgTrading_InitiateTradeRequest::get_other_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgTrading_InitiateTradeRequest>(
                "CMsgTrading_InitiateTradeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTrading_InitiateTradeRequest {
        static instance: ::protobuf::rt::Lazy<CMsgTrading_InitiateTradeRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgTrading_InitiateTradeRequest::new)
    }
}

impl ::protobuf::Clear for CMsgTrading_InitiateTradeRequest {
    fn clear(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
        self.other_steamid = ::std::option::Option::None;
        self.other_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTrading_InitiateTradeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_InitiateTradeRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTrading_InitiateTradeResponse {
    // message fields
    response: ::std::option::Option<u32>,
    trade_request_id: ::std::option::Option<u32>,
    other_steamid: ::std::option::Option<u64>,
    steamguard_required_days: ::std::option::Option<u32>,
    new_device_cooldown_days: ::std::option::Option<u32>,
    default_password_reset_probation_days: ::std::option::Option<u32>,
    password_reset_probation_days: ::std::option::Option<u32>,
    default_email_change_probation_days: ::std::option::Option<u32>,
    email_change_probation_days: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_InitiateTradeResponse {
    fn default() -> &'a CMsgTrading_InitiateTradeResponse {
        <CMsgTrading_InitiateTradeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_InitiateTradeResponse {
    pub fn new() -> CMsgTrading_InitiateTradeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn get_response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional uint32 trade_request_id = 2;

    pub fn get_trade_request_id(&self) -> u32 {
        self.trade_request_id.unwrap_or(0)
    }

    pub fn clear_trade_request_id(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
    }

    pub fn has_trade_request_id(&self) -> bool {
        self.trade_request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_request_id(&mut self, v: u32) {
        self.trade_request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 other_steamid = 3;

    pub fn get_other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 steamguard_required_days = 4;

    pub fn get_steamguard_required_days(&self) -> u32 {
        self.steamguard_required_days.unwrap_or(0)
    }

    pub fn clear_steamguard_required_days(&mut self) {
        self.steamguard_required_days = ::std::option::Option::None;
    }

    pub fn has_steamguard_required_days(&self) -> bool {
        self.steamguard_required_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamguard_required_days(&mut self, v: u32) {
        self.steamguard_required_days = ::std::option::Option::Some(v);
    }

    // optional uint32 new_device_cooldown_days = 5;

    pub fn get_new_device_cooldown_days(&self) -> u32 {
        self.new_device_cooldown_days.unwrap_or(0)
    }

    pub fn clear_new_device_cooldown_days(&mut self) {
        self.new_device_cooldown_days = ::std::option::Option::None;
    }

    pub fn has_new_device_cooldown_days(&self) -> bool {
        self.new_device_cooldown_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_device_cooldown_days(&mut self, v: u32) {
        self.new_device_cooldown_days = ::std::option::Option::Some(v);
    }

    // optional uint32 default_password_reset_probation_days = 6;

    pub fn get_default_password_reset_probation_days(&self) -> u32 {
        self.default_password_reset_probation_days.unwrap_or(0)
    }

    pub fn clear_default_password_reset_probation_days(&mut self) {
        self.default_password_reset_probation_days = ::std::option::Option::None;
    }

    pub fn has_default_password_reset_probation_days(&self) -> bool {
        self.default_password_reset_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_password_reset_probation_days(&mut self, v: u32) {
        self.default_password_reset_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 password_reset_probation_days = 7;

    pub fn get_password_reset_probation_days(&self) -> u32 {
        self.password_reset_probation_days.unwrap_or(0)
    }

    pub fn clear_password_reset_probation_days(&mut self) {
        self.password_reset_probation_days = ::std::option::Option::None;
    }

    pub fn has_password_reset_probation_days(&self) -> bool {
        self.password_reset_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_reset_probation_days(&mut self, v: u32) {
        self.password_reset_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 default_email_change_probation_days = 8;

    pub fn get_default_email_change_probation_days(&self) -> u32 {
        self.default_email_change_probation_days.unwrap_or(0)
    }

    pub fn clear_default_email_change_probation_days(&mut self) {
        self.default_email_change_probation_days = ::std::option::Option::None;
    }

    pub fn has_default_email_change_probation_days(&self) -> bool {
        self.default_email_change_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_email_change_probation_days(&mut self, v: u32) {
        self.default_email_change_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 email_change_probation_days = 9;

    pub fn get_email_change_probation_days(&self) -> u32 {
        self.email_change_probation_days.unwrap_or(0)
    }

    pub fn clear_email_change_probation_days(&mut self) {
        self.email_change_probation_days = ::std::option::Option::None;
    }

    pub fn has_email_change_probation_days(&self) -> bool {
        self.email_change_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_change_probation_days(&mut self, v: u32) {
        self.email_change_probation_days = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTrading_InitiateTradeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.trade_request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamguard_required_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.new_device_cooldown_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.default_password_reset_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.password_reset_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.default_email_change_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.email_change_probation_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trade_request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamguard_required_days {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_device_cooldown_days {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_password_reset_probation_days {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.password_reset_probation_days {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_email_change_probation_days {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.email_change_probation_days {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trade_request_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.other_steamid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamguard_required_days {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.new_device_cooldown_days {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.default_password_reset_probation_days {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.password_reset_probation_days {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.default_email_change_probation_days {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.email_change_probation_days {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTrading_InitiateTradeResponse {
        CMsgTrading_InitiateTradeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "response",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.response },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.response },
                CMsgTrading_InitiateTradeResponse::get_response,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "trade_request_id",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.trade_request_id },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.trade_request_id },
                CMsgTrading_InitiateTradeResponse::get_trade_request_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "other_steamid",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.other_steamid },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.other_steamid },
                CMsgTrading_InitiateTradeResponse::get_other_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "steamguard_required_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.steamguard_required_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.steamguard_required_days },
                CMsgTrading_InitiateTradeResponse::get_steamguard_required_days,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "new_device_cooldown_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.new_device_cooldown_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.new_device_cooldown_days },
                CMsgTrading_InitiateTradeResponse::get_new_device_cooldown_days,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "default_password_reset_probation_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.default_password_reset_probation_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.default_password_reset_probation_days },
                CMsgTrading_InitiateTradeResponse::get_default_password_reset_probation_days,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "password_reset_probation_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.password_reset_probation_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.password_reset_probation_days },
                CMsgTrading_InitiateTradeResponse::get_password_reset_probation_days,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "default_email_change_probation_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.default_email_change_probation_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.default_email_change_probation_days },
                CMsgTrading_InitiateTradeResponse::get_default_email_change_probation_days,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "email_change_probation_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.email_change_probation_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.email_change_probation_days },
                CMsgTrading_InitiateTradeResponse::get_email_change_probation_days,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgTrading_InitiateTradeResponse>(
                "CMsgTrading_InitiateTradeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTrading_InitiateTradeResponse {
        static instance: ::protobuf::rt::Lazy<CMsgTrading_InitiateTradeResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgTrading_InitiateTradeResponse::new)
    }
}

impl ::protobuf::Clear for CMsgTrading_InitiateTradeResponse {
    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.trade_request_id = ::std::option::Option::None;
        self.other_steamid = ::std::option::Option::None;
        self.steamguard_required_days = ::std::option::Option::None;
        self.new_device_cooldown_days = ::std::option::Option::None;
        self.default_password_reset_probation_days = ::std::option::Option::None;
        self.password_reset_probation_days = ::std::option::Option::None;
        self.default_email_change_probation_days = ::std::option::Option::None;
        self.email_change_probation_days = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTrading_InitiateTradeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_InitiateTradeResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTrading_CancelTradeRequest {
    // message fields
    other_steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_CancelTradeRequest {
    fn default() -> &'a CMsgTrading_CancelTradeRequest {
        <CMsgTrading_CancelTradeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_CancelTradeRequest {
    pub fn new() -> CMsgTrading_CancelTradeRequest {
        ::std::default::Default::default()
    }

    // optional uint64 other_steamid = 1;

    pub fn get_other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTrading_CancelTradeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.other_steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTrading_CancelTradeRequest {
        CMsgTrading_CancelTradeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "other_steamid",
                |m: &CMsgTrading_CancelTradeRequest| { &m.other_steamid },
                |m: &mut CMsgTrading_CancelTradeRequest| { &mut m.other_steamid },
                CMsgTrading_CancelTradeRequest::get_other_steamid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgTrading_CancelTradeRequest>(
                "CMsgTrading_CancelTradeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTrading_CancelTradeRequest {
        static instance: ::protobuf::rt::Lazy<CMsgTrading_CancelTradeRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgTrading_CancelTradeRequest::new)
    }
}

impl ::protobuf::Clear for CMsgTrading_CancelTradeRequest {
    fn clear(&mut self) {
        self.other_steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTrading_CancelTradeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_CancelTradeRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTrading_StartSession {
    // message fields
    other_steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_StartSession {
    fn default() -> &'a CMsgTrading_StartSession {
        <CMsgTrading_StartSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_StartSession {
    pub fn new() -> CMsgTrading_StartSession {
        ::std::default::Default::default()
    }

    // optional uint64 other_steamid = 1;

    pub fn get_other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }

    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTrading_StartSession {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.other_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.other_steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTrading_StartSession {
        CMsgTrading_StartSession::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "other_steamid",
                |m: &CMsgTrading_StartSession| { &m.other_steamid },
                |m: &mut CMsgTrading_StartSession| { &mut m.other_steamid },
                CMsgTrading_StartSession::get_other_steamid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgTrading_StartSession>(
                "CMsgTrading_StartSession",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTrading_StartSession {
        static instance: ::protobuf::rt::Lazy<CMsgTrading_StartSession> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgTrading_StartSession::new)
    }
}

impl ::protobuf::Clear for CMsgTrading_StartSession {
    fn clear(&mut self) {
        self.other_steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTrading_StartSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_StartSession {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetCDNAuthToken {
    // message fields
    depot_id: ::std::option::Option<u32>,
    host_name: ::protobuf::SingularField<::std::string::String>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetCDNAuthToken {
    fn default() -> &'a CMsgClientGetCDNAuthToken {
        <CMsgClientGetCDNAuthToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetCDNAuthToken {
    pub fn new() -> CMsgClientGetCDNAuthToken {
        ::std::default::Default::default()
    }

    // optional uint32 depot_id = 1;

    pub fn get_depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional string host_name = 2;

    pub fn get_host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host_name(&mut self) {
        self.host_name.clear();
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if self.host_name.is_none() {
            self.host_name.set_default();
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 3;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetCDNAuthToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.host_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.depot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.host_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetCDNAuthToken {
        CMsgClientGetCDNAuthToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "depot_id",
                |m: &CMsgClientGetCDNAuthToken| { &m.depot_id },
                |m: &mut CMsgClientGetCDNAuthToken| { &mut m.depot_id },
                CMsgClientGetCDNAuthToken::get_depot_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "host_name",
                |m: &CMsgClientGetCDNAuthToken| { &m.host_name },
                |m: &mut CMsgClientGetCDNAuthToken| { &mut m.host_name },
                CMsgClientGetCDNAuthToken::get_host_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientGetCDNAuthToken| { &m.app_id },
                |m: &mut CMsgClientGetCDNAuthToken| { &mut m.app_id },
                CMsgClientGetCDNAuthToken::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetCDNAuthToken>(
                "CMsgClientGetCDNAuthToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetCDNAuthToken {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetCDNAuthToken> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetCDNAuthToken::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetCDNAuthToken {
    fn clear(&mut self) {
        self.depot_id = ::std::option::Option::None;
        self.host_name.clear();
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetCDNAuthToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetCDNAuthToken {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetDepotDecryptionKey {
    // message fields
    depot_id: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetDepotDecryptionKey {
    fn default() -> &'a CMsgClientGetDepotDecryptionKey {
        <CMsgClientGetDepotDecryptionKey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetDepotDecryptionKey {
    pub fn new() -> CMsgClientGetDepotDecryptionKey {
        ::std::default::Default::default()
    }

    // optional uint32 depot_id = 1;

    pub fn get_depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetDepotDecryptionKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.depot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetDepotDecryptionKey {
        CMsgClientGetDepotDecryptionKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "depot_id",
                |m: &CMsgClientGetDepotDecryptionKey| { &m.depot_id },
                |m: &mut CMsgClientGetDepotDecryptionKey| { &mut m.depot_id },
                CMsgClientGetDepotDecryptionKey::get_depot_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientGetDepotDecryptionKey| { &m.app_id },
                |m: &mut CMsgClientGetDepotDecryptionKey| { &mut m.app_id },
                CMsgClientGetDepotDecryptionKey::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetDepotDecryptionKey>(
                "CMsgClientGetDepotDecryptionKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetDepotDecryptionKey {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetDepotDecryptionKey> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetDepotDecryptionKey::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetDepotDecryptionKey {
    fn clear(&mut self) {
        self.depot_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetDepotDecryptionKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetDepotDecryptionKey {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetDepotDecryptionKeyResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    depot_id: ::std::option::Option<u32>,
    depot_encryption_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetDepotDecryptionKeyResponse {
    fn default() -> &'a CMsgClientGetDepotDecryptionKeyResponse {
        <CMsgClientGetDepotDecryptionKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetDepotDecryptionKeyResponse {
    pub fn new() -> CMsgClientGetDepotDecryptionKeyResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 depot_id = 2;

    pub fn get_depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional bytes depot_encryption_key = 3;

    pub fn get_depot_encryption_key(&self) -> &[u8] {
        match self.depot_encryption_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_depot_encryption_key(&mut self) {
        self.depot_encryption_key.clear();
    }

    pub fn has_depot_encryption_key(&self) -> bool {
        self.depot_encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_encryption_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.depot_encryption_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_depot_encryption_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.depot_encryption_key.is_none() {
            self.depot_encryption_key.set_default();
        }
        self.depot_encryption_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_depot_encryption_key(&mut self) -> ::std::vec::Vec<u8> {
        self.depot_encryption_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientGetDepotDecryptionKeyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.depot_encryption_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.depot_encryption_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.depot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.depot_encryption_key.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetDepotDecryptionKeyResponse {
        CMsgClientGetDepotDecryptionKeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.eresult },
                |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.eresult },
                CMsgClientGetDepotDecryptionKeyResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "depot_id",
                |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.depot_id },
                |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.depot_id },
                CMsgClientGetDepotDecryptionKeyResponse::get_depot_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "depot_encryption_key",
                |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.depot_encryption_key },
                |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.depot_encryption_key },
                CMsgClientGetDepotDecryptionKeyResponse::get_depot_encryption_key,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetDepotDecryptionKeyResponse>(
                "CMsgClientGetDepotDecryptionKeyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetDepotDecryptionKeyResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetDepotDecryptionKeyResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetDepotDecryptionKeyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetDepotDecryptionKeyResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.depot_id = ::std::option::Option::None;
        self.depot_encryption_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetDepotDecryptionKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetDepotDecryptionKeyResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCheckAppBetaPassword {
    // message fields
    app_id: ::std::option::Option<u32>,
    betapassword: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPassword {
    fn default() -> &'a CMsgClientCheckAppBetaPassword {
        <CMsgClientCheckAppBetaPassword as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPassword {
    pub fn new() -> CMsgClientCheckAppBetaPassword {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string betapassword = 2;

    pub fn get_betapassword(&self) -> &str {
        match self.betapassword.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_betapassword(&mut self) {
        self.betapassword.clear();
    }

    pub fn has_betapassword(&self) -> bool {
        self.betapassword.is_some()
    }

    // Param is passed by value, moved
    pub fn set_betapassword(&mut self, v: ::std::string::String) {
        self.betapassword = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_betapassword(&mut self) -> &mut ::std::string::String {
        if self.betapassword.is_none() {
            self.betapassword.set_default();
        }
        self.betapassword.as_mut().unwrap()
    }

    // Take field
    pub fn take_betapassword(&mut self) -> ::std::string::String {
        self.betapassword.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientCheckAppBetaPassword {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.betapassword)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.betapassword.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.betapassword.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCheckAppBetaPassword {
        CMsgClientCheckAppBetaPassword::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientCheckAppBetaPassword| { &m.app_id },
                |m: &mut CMsgClientCheckAppBetaPassword| { &mut m.app_id },
                CMsgClientCheckAppBetaPassword::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "betapassword",
                |m: &CMsgClientCheckAppBetaPassword| { &m.betapassword },
                |m: &mut CMsgClientCheckAppBetaPassword| { &mut m.betapassword },
                CMsgClientCheckAppBetaPassword::get_betapassword,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientCheckAppBetaPassword>(
                "CMsgClientCheckAppBetaPassword",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPassword {
        static instance: ::protobuf::rt::Lazy<CMsgClientCheckAppBetaPassword> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientCheckAppBetaPassword::new)
    }
}

impl ::protobuf::Clear for CMsgClientCheckAppBetaPassword {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.betapassword.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCheckAppBetaPassword {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckAppBetaPassword {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCheckAppBetaPasswordResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub betapasswords: ::protobuf::RepeatedField<cmsg_client_check_app_beta_password_response::BetaPassword>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPasswordResponse {
    fn default() -> &'a CMsgClientCheckAppBetaPasswordResponse {
        <CMsgClientCheckAppBetaPasswordResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPasswordResponse {
    pub fn new() -> CMsgClientCheckAppBetaPasswordResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCheckAppBetaPasswordResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.betapasswords {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.betapasswords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.betapasswords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.betapasswords {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCheckAppBetaPasswordResponse {
        CMsgClientCheckAppBetaPasswordResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientCheckAppBetaPasswordResponse| { &m.eresult },
                |m: &mut CMsgClientCheckAppBetaPasswordResponse| { &mut m.eresult },
                CMsgClientCheckAppBetaPasswordResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_check_app_beta_password_response::BetaPassword>>(
                "betapasswords",
                |m: &CMsgClientCheckAppBetaPasswordResponse| { &m.betapasswords },
                |m: &mut CMsgClientCheckAppBetaPasswordResponse| { &mut m.betapasswords },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientCheckAppBetaPasswordResponse>(
                "CMsgClientCheckAppBetaPasswordResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPasswordResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientCheckAppBetaPasswordResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientCheckAppBetaPasswordResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientCheckAppBetaPasswordResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.betapasswords.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCheckAppBetaPasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckAppBetaPasswordResponse {
}

/// Nested message and enums of message `CMsgClientCheckAppBetaPasswordResponse`
pub mod cmsg_client_check_app_beta_password_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct BetaPassword {
        // message fields
        betaname: ::protobuf::SingularField<::std::string::String>,
        betapassword: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a BetaPassword {
        fn default() -> &'a BetaPassword {
            <BetaPassword as ::protobuf::Message>::default_instance()
        }
    }

    impl BetaPassword {
        pub fn new() -> BetaPassword {
            ::std::default::Default::default()
        }

        // optional string betaname = 1;

        pub fn get_betaname(&self) -> &str {
            match self.betaname.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betaname(&mut self) {
            self.betaname.clear();
        }

        pub fn has_betaname(&self) -> bool {
            self.betaname.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betaname(&mut self, v: ::std::string::String) {
            self.betaname = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betaname(&mut self) -> &mut ::std::string::String {
            if self.betaname.is_none() {
                self.betaname.set_default();
            }
            self.betaname.as_mut().unwrap()
        }

        // Take field
        pub fn take_betaname(&mut self) -> ::std::string::String {
            self.betaname.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string betapassword = 2;

        pub fn get_betapassword(&self) -> &str {
            match self.betapassword.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_betapassword(&mut self) {
            self.betapassword.clear();
        }

        pub fn has_betapassword(&self) -> bool {
            self.betapassword.is_some()
        }

        // Param is passed by value, moved
        pub fn set_betapassword(&mut self, v: ::std::string::String) {
            self.betapassword = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_betapassword(&mut self) -> &mut ::std::string::String {
            if self.betapassword.is_none() {
                self.betapassword.set_default();
            }
            self.betapassword.as_mut().unwrap()
        }

        // Take field
        pub fn take_betapassword(&mut self) -> ::std::string::String {
            self.betapassword.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for BetaPassword {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.betaname)?;
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.betapassword)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.betaname.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.betapassword.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.betaname.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.betapassword.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> BetaPassword {
            BetaPassword::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "betaname",
                    |m: &BetaPassword| { &m.betaname },
                    |m: &mut BetaPassword| { &mut m.betaname },
                    BetaPassword::get_betaname,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "betapassword",
                    |m: &BetaPassword| { &m.betapassword },
                    |m: &mut BetaPassword| { &mut m.betapassword },
                    BetaPassword::get_betapassword,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BetaPassword>(
                    "CMsgClientCheckAppBetaPasswordResponse.BetaPassword",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static BetaPassword {
            static instance: ::protobuf::rt::Lazy<BetaPassword> = ::protobuf::rt::Lazy::INIT;
            instance.get(BetaPassword::new)
        }
    }

    impl ::protobuf::Clear for BetaPassword {
        fn clear(&mut self) {
            self.betaname.clear();
            self.betapassword.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for BetaPassword {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BetaPassword {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUpdateAppJobReport {
    // message fields
    app_id: ::std::option::Option<u32>,
    pub depot_ids: ::std::vec::Vec<u32>,
    app_state: ::std::option::Option<u32>,
    job_app_error: ::std::option::Option<u32>,
    error_details: ::protobuf::SingularField<::std::string::String>,
    job_duration: ::std::option::Option<u32>,
    files_validation_failed: ::std::option::Option<u32>,
    job_bytes_downloaded: ::std::option::Option<u64>,
    job_bytes_staged: ::std::option::Option<u64>,
    bytes_comitted: ::std::option::Option<u64>,
    start_app_state: ::std::option::Option<u32>,
    stats_machine_id: ::std::option::Option<u64>,
    branch_name: ::protobuf::SingularField<::std::string::String>,
    total_bytes_downloaded: ::std::option::Option<u64>,
    total_bytes_staged: ::std::option::Option<u64>,
    total_bytes_restored: ::std::option::Option<u64>,
    is_borrowed: ::std::option::Option<bool>,
    is_free_weekend: ::std::option::Option<bool>,
    total_bytes_legacy: ::std::option::Option<u64>,
    total_bytes_patched: ::std::option::Option<u64>,
    total_bytes_saved: ::std::option::Option<u64>,
    cell_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateAppJobReport {
    fn default() -> &'a CMsgClientUpdateAppJobReport {
        <CMsgClientUpdateAppJobReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateAppJobReport {
    pub fn new() -> CMsgClientUpdateAppJobReport {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_state = 3;

    pub fn get_app_state(&self) -> u32 {
        self.app_state.unwrap_or(0)
    }

    pub fn clear_app_state(&mut self) {
        self.app_state = ::std::option::Option::None;
    }

    pub fn has_app_state(&self) -> bool {
        self.app_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_state(&mut self, v: u32) {
        self.app_state = ::std::option::Option::Some(v);
    }

    // optional uint32 job_app_error = 4;

    pub fn get_job_app_error(&self) -> u32 {
        self.job_app_error.unwrap_or(0)
    }

    pub fn clear_job_app_error(&mut self) {
        self.job_app_error = ::std::option::Option::None;
    }

    pub fn has_job_app_error(&self) -> bool {
        self.job_app_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_app_error(&mut self, v: u32) {
        self.job_app_error = ::std::option::Option::Some(v);
    }

    // optional string error_details = 5;

    pub fn get_error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_details(&mut self) {
        self.error_details.clear();
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details.set_default();
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 job_duration = 6;

    pub fn get_job_duration(&self) -> u32 {
        self.job_duration.unwrap_or(0)
    }

    pub fn clear_job_duration(&mut self) {
        self.job_duration = ::std::option::Option::None;
    }

    pub fn has_job_duration(&self) -> bool {
        self.job_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_duration(&mut self, v: u32) {
        self.job_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 files_validation_failed = 7;

    pub fn get_files_validation_failed(&self) -> u32 {
        self.files_validation_failed.unwrap_or(0)
    }

    pub fn clear_files_validation_failed(&mut self) {
        self.files_validation_failed = ::std::option::Option::None;
    }

    pub fn has_files_validation_failed(&self) -> bool {
        self.files_validation_failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_validation_failed(&mut self, v: u32) {
        self.files_validation_failed = ::std::option::Option::Some(v);
    }

    // optional uint64 job_bytes_downloaded = 8;

    pub fn get_job_bytes_downloaded(&self) -> u64 {
        self.job_bytes_downloaded.unwrap_or(0)
    }

    pub fn clear_job_bytes_downloaded(&mut self) {
        self.job_bytes_downloaded = ::std::option::Option::None;
    }

    pub fn has_job_bytes_downloaded(&self) -> bool {
        self.job_bytes_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_bytes_downloaded(&mut self, v: u64) {
        self.job_bytes_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint64 job_bytes_staged = 9;

    pub fn get_job_bytes_staged(&self) -> u64 {
        self.job_bytes_staged.unwrap_or(0)
    }

    pub fn clear_job_bytes_staged(&mut self) {
        self.job_bytes_staged = ::std::option::Option::None;
    }

    pub fn has_job_bytes_staged(&self) -> bool {
        self.job_bytes_staged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_bytes_staged(&mut self, v: u64) {
        self.job_bytes_staged = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_comitted = 10;

    pub fn get_bytes_comitted(&self) -> u64 {
        self.bytes_comitted.unwrap_or(0)
    }

    pub fn clear_bytes_comitted(&mut self) {
        self.bytes_comitted = ::std::option::Option::None;
    }

    pub fn has_bytes_comitted(&self) -> bool {
        self.bytes_comitted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_comitted(&mut self, v: u64) {
        self.bytes_comitted = ::std::option::Option::Some(v);
    }

    // optional uint32 start_app_state = 11;

    pub fn get_start_app_state(&self) -> u32 {
        self.start_app_state.unwrap_or(0)
    }

    pub fn clear_start_app_state(&mut self) {
        self.start_app_state = ::std::option::Option::None;
    }

    pub fn has_start_app_state(&self) -> bool {
        self.start_app_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_app_state(&mut self, v: u32) {
        self.start_app_state = ::std::option::Option::Some(v);
    }

    // optional fixed64 stats_machine_id = 12;

    pub fn get_stats_machine_id(&self) -> u64 {
        self.stats_machine_id.unwrap_or(0)
    }

    pub fn clear_stats_machine_id(&mut self) {
        self.stats_machine_id = ::std::option::Option::None;
    }

    pub fn has_stats_machine_id(&self) -> bool {
        self.stats_machine_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_machine_id(&mut self, v: u64) {
        self.stats_machine_id = ::std::option::Option::Some(v);
    }

    // optional string branch_name = 13;

    pub fn get_branch_name(&self) -> &str {
        match self.branch_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_branch_name(&mut self) {
        self.branch_name.clear();
    }

    pub fn has_branch_name(&self) -> bool {
        self.branch_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_name(&mut self, v: ::std::string::String) {
        self.branch_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_branch_name(&mut self) -> &mut ::std::string::String {
        if self.branch_name.is_none() {
            self.branch_name.set_default();
        }
        self.branch_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_branch_name(&mut self) -> ::std::string::String {
        self.branch_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 total_bytes_downloaded = 14;

    pub fn get_total_bytes_downloaded(&self) -> u64 {
        self.total_bytes_downloaded.unwrap_or(0)
    }

    pub fn clear_total_bytes_downloaded(&mut self) {
        self.total_bytes_downloaded = ::std::option::Option::None;
    }

    pub fn has_total_bytes_downloaded(&self) -> bool {
        self.total_bytes_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_downloaded(&mut self, v: u64) {
        self.total_bytes_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_staged = 15;

    pub fn get_total_bytes_staged(&self) -> u64 {
        self.total_bytes_staged.unwrap_or(0)
    }

    pub fn clear_total_bytes_staged(&mut self) {
        self.total_bytes_staged = ::std::option::Option::None;
    }

    pub fn has_total_bytes_staged(&self) -> bool {
        self.total_bytes_staged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_staged(&mut self, v: u64) {
        self.total_bytes_staged = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_restored = 16;

    pub fn get_total_bytes_restored(&self) -> u64 {
        self.total_bytes_restored.unwrap_or(0)
    }

    pub fn clear_total_bytes_restored(&mut self) {
        self.total_bytes_restored = ::std::option::Option::None;
    }

    pub fn has_total_bytes_restored(&self) -> bool {
        self.total_bytes_restored.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_restored(&mut self, v: u64) {
        self.total_bytes_restored = ::std::option::Option::Some(v);
    }

    // optional bool is_borrowed = 17;

    pub fn get_is_borrowed(&self) -> bool {
        self.is_borrowed.unwrap_or(false)
    }

    pub fn clear_is_borrowed(&mut self) {
        self.is_borrowed = ::std::option::Option::None;
    }

    pub fn has_is_borrowed(&self) -> bool {
        self.is_borrowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_borrowed(&mut self, v: bool) {
        self.is_borrowed = ::std::option::Option::Some(v);
    }

    // optional bool is_free_weekend = 18;

    pub fn get_is_free_weekend(&self) -> bool {
        self.is_free_weekend.unwrap_or(false)
    }

    pub fn clear_is_free_weekend(&mut self) {
        self.is_free_weekend = ::std::option::Option::None;
    }

    pub fn has_is_free_weekend(&self) -> bool {
        self.is_free_weekend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_free_weekend(&mut self, v: bool) {
        self.is_free_weekend = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_legacy = 19;

    pub fn get_total_bytes_legacy(&self) -> u64 {
        self.total_bytes_legacy.unwrap_or(0)
    }

    pub fn clear_total_bytes_legacy(&mut self) {
        self.total_bytes_legacy = ::std::option::Option::None;
    }

    pub fn has_total_bytes_legacy(&self) -> bool {
        self.total_bytes_legacy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_legacy(&mut self, v: u64) {
        self.total_bytes_legacy = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_patched = 20;

    pub fn get_total_bytes_patched(&self) -> u64 {
        self.total_bytes_patched.unwrap_or(0)
    }

    pub fn clear_total_bytes_patched(&mut self) {
        self.total_bytes_patched = ::std::option::Option::None;
    }

    pub fn has_total_bytes_patched(&self) -> bool {
        self.total_bytes_patched.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_patched(&mut self, v: u64) {
        self.total_bytes_patched = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_saved = 21;

    pub fn get_total_bytes_saved(&self) -> u64 {
        self.total_bytes_saved.unwrap_or(0)
    }

    pub fn clear_total_bytes_saved(&mut self) {
        self.total_bytes_saved = ::std::option::Option::None;
    }

    pub fn has_total_bytes_saved(&self) -> bool {
        self.total_bytes_saved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_saved(&mut self, v: u64) {
        self.total_bytes_saved = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 22;

    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUpdateAppJobReport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.depot_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.job_app_error = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_details)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.job_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.files_validation_failed = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.job_bytes_downloaded = ::std::option::Option::Some(is.read_uint64()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.job_bytes_staged = ::std::option::Option::Some(is.read_uint64()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bytes_comitted = ::std::option::Option::Some(is.read_uint64()?);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_app_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stats_machine_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.branch_name)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_bytes_downloaded = ::std::option::Option::Some(is.read_uint64()?);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_bytes_staged = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_bytes_restored = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_borrowed = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_free_weekend = ::std::option::Option::Some(is.read_bool()?);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_bytes_legacy = ::std::option::Option::Some(is.read_uint64()?);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_bytes_patched = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_bytes_saved = ::std::option::Option::Some(is.read_uint64()?);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.depot_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.app_state {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.job_app_error {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.job_duration {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.files_validation_failed {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.job_bytes_downloaded {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.job_bytes_staged {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_comitted {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_app_state {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stats_machine_id {
            my_size += 9;
        }
        if let Some(v) = self.branch_name.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.total_bytes_downloaded {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_bytes_staged {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_bytes_restored {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_borrowed {
            my_size += 3;
        }
        if let Some(v) = self.is_free_weekend {
            my_size += 3;
        }
        if let Some(v) = self.total_bytes_legacy {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_bytes_patched {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_bytes_saved {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.depot_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.app_state {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.job_app_error {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.error_details.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.job_duration {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.files_validation_failed {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.job_bytes_downloaded {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.job_bytes_staged {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.bytes_comitted {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.start_app_state {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.stats_machine_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.branch_name.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.total_bytes_downloaded {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.total_bytes_staged {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.total_bytes_restored {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.is_borrowed {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.is_free_weekend {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.total_bytes_legacy {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.total_bytes_patched {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.total_bytes_saved {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(22, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUpdateAppJobReport {
        CMsgClientUpdateAppJobReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientUpdateAppJobReport| { &m.app_id },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.app_id },
                CMsgClientUpdateAppJobReport::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "depot_ids",
                |m: &CMsgClientUpdateAppJobReport| { &m.depot_ids },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.depot_ids },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_state",
                |m: &CMsgClientUpdateAppJobReport| { &m.app_state },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.app_state },
                CMsgClientUpdateAppJobReport::get_app_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "job_app_error",
                |m: &CMsgClientUpdateAppJobReport| { &m.job_app_error },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_app_error },
                CMsgClientUpdateAppJobReport::get_job_app_error,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "error_details",
                |m: &CMsgClientUpdateAppJobReport| { &m.error_details },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.error_details },
                CMsgClientUpdateAppJobReport::get_error_details,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "job_duration",
                |m: &CMsgClientUpdateAppJobReport| { &m.job_duration },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_duration },
                CMsgClientUpdateAppJobReport::get_job_duration,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "files_validation_failed",
                |m: &CMsgClientUpdateAppJobReport| { &m.files_validation_failed },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.files_validation_failed },
                CMsgClientUpdateAppJobReport::get_files_validation_failed,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "job_bytes_downloaded",
                |m: &CMsgClientUpdateAppJobReport| { &m.job_bytes_downloaded },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_bytes_downloaded },
                CMsgClientUpdateAppJobReport::get_job_bytes_downloaded,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "job_bytes_staged",
                |m: &CMsgClientUpdateAppJobReport| { &m.job_bytes_staged },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_bytes_staged },
                CMsgClientUpdateAppJobReport::get_job_bytes_staged,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "bytes_comitted",
                |m: &CMsgClientUpdateAppJobReport| { &m.bytes_comitted },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.bytes_comitted },
                CMsgClientUpdateAppJobReport::get_bytes_comitted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "start_app_state",
                |m: &CMsgClientUpdateAppJobReport| { &m.start_app_state },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.start_app_state },
                CMsgClientUpdateAppJobReport::get_start_app_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "stats_machine_id",
                |m: &CMsgClientUpdateAppJobReport| { &m.stats_machine_id },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.stats_machine_id },
                CMsgClientUpdateAppJobReport::get_stats_machine_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "branch_name",
                |m: &CMsgClientUpdateAppJobReport| { &m.branch_name },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.branch_name },
                CMsgClientUpdateAppJobReport::get_branch_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "total_bytes_downloaded",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_downloaded },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_downloaded },
                CMsgClientUpdateAppJobReport::get_total_bytes_downloaded,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "total_bytes_staged",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_staged },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_staged },
                CMsgClientUpdateAppJobReport::get_total_bytes_staged,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "total_bytes_restored",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_restored },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_restored },
                CMsgClientUpdateAppJobReport::get_total_bytes_restored,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_borrowed",
                |m: &CMsgClientUpdateAppJobReport| { &m.is_borrowed },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.is_borrowed },
                CMsgClientUpdateAppJobReport::get_is_borrowed,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_free_weekend",
                |m: &CMsgClientUpdateAppJobReport| { &m.is_free_weekend },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.is_free_weekend },
                CMsgClientUpdateAppJobReport::get_is_free_weekend,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "total_bytes_legacy",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_legacy },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_legacy },
                CMsgClientUpdateAppJobReport::get_total_bytes_legacy,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "total_bytes_patched",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_patched },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_patched },
                CMsgClientUpdateAppJobReport::get_total_bytes_patched,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "total_bytes_saved",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_saved },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_saved },
                CMsgClientUpdateAppJobReport::get_total_bytes_saved,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cell_id",
                |m: &CMsgClientUpdateAppJobReport| { &m.cell_id },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.cell_id },
                CMsgClientUpdateAppJobReport::get_cell_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUpdateAppJobReport>(
                "CMsgClientUpdateAppJobReport",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUpdateAppJobReport {
        static instance: ::protobuf::rt::Lazy<CMsgClientUpdateAppJobReport> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUpdateAppJobReport::new)
    }
}

impl ::protobuf::Clear for CMsgClientUpdateAppJobReport {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.depot_ids.clear();
        self.app_state = ::std::option::Option::None;
        self.job_app_error = ::std::option::Option::None;
        self.error_details.clear();
        self.job_duration = ::std::option::Option::None;
        self.files_validation_failed = ::std::option::Option::None;
        self.job_bytes_downloaded = ::std::option::Option::None;
        self.job_bytes_staged = ::std::option::Option::None;
        self.bytes_comitted = ::std::option::Option::None;
        self.start_app_state = ::std::option::Option::None;
        self.stats_machine_id = ::std::option::Option::None;
        self.branch_name.clear();
        self.total_bytes_downloaded = ::std::option::Option::None;
        self.total_bytes_staged = ::std::option::Option::None;
        self.total_bytes_restored = ::std::option::Option::None;
        self.is_borrowed = ::std::option::Option::None;
        self.is_free_weekend = ::std::option::Option::None;
        self.total_bytes_legacy = ::std::option::Option::None;
        self.total_bytes_patched = ::std::option::Option::None;
        self.total_bytes_saved = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUpdateAppJobReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateAppJobReport {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDPContentStatsReport {
    // message fields
    stats_machine_id: ::std::option::Option<u64>,
    country_code: ::protobuf::SingularField<::std::string::String>,
    os_type: ::std::option::Option<i32>,
    language: ::std::option::Option<i32>,
    num_install_folders: ::std::option::Option<u32>,
    num_installed_games: ::std::option::Option<u32>,
    size_installed_games: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPContentStatsReport {
    fn default() -> &'a CMsgClientDPContentStatsReport {
        <CMsgClientDPContentStatsReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPContentStatsReport {
    pub fn new() -> CMsgClientDPContentStatsReport {
        ::std::default::Default::default()
    }

    // optional fixed64 stats_machine_id = 1;

    pub fn get_stats_machine_id(&self) -> u64 {
        self.stats_machine_id.unwrap_or(0)
    }

    pub fn clear_stats_machine_id(&mut self) {
        self.stats_machine_id = ::std::option::Option::None;
    }

    pub fn has_stats_machine_id(&self) -> bool {
        self.stats_machine_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_machine_id(&mut self, v: u64) {
        self.stats_machine_id = ::std::option::Option::Some(v);
    }

    // optional string country_code = 2;

    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 os_type = 3;

    pub fn get_os_type(&self) -> i32 {
        self.os_type.unwrap_or(0)
    }

    pub fn clear_os_type(&mut self) {
        self.os_type = ::std::option::Option::None;
    }

    pub fn has_os_type(&self) -> bool {
        self.os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_type(&mut self, v: i32) {
        self.os_type = ::std::option::Option::Some(v);
    }

    // optional int32 language = 4;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional uint32 num_install_folders = 5;

    pub fn get_num_install_folders(&self) -> u32 {
        self.num_install_folders.unwrap_or(0)
    }

    pub fn clear_num_install_folders(&mut self) {
        self.num_install_folders = ::std::option::Option::None;
    }

    pub fn has_num_install_folders(&self) -> bool {
        self.num_install_folders.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_install_folders(&mut self, v: u32) {
        self.num_install_folders = ::std::option::Option::Some(v);
    }

    // optional uint32 num_installed_games = 6;

    pub fn get_num_installed_games(&self) -> u32 {
        self.num_installed_games.unwrap_or(0)
    }

    pub fn clear_num_installed_games(&mut self) {
        self.num_installed_games = ::std::option::Option::None;
    }

    pub fn has_num_installed_games(&self) -> bool {
        self.num_installed_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_installed_games(&mut self, v: u32) {
        self.num_installed_games = ::std::option::Option::Some(v);
    }

    // optional uint64 size_installed_games = 7;

    pub fn get_size_installed_games(&self) -> u64 {
        self.size_installed_games.unwrap_or(0)
    }

    pub fn clear_size_installed_games(&mut self) {
        self.size_installed_games = ::std::option::Option::None;
    }

    pub fn has_size_installed_games(&self) -> bool {
        self.size_installed_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_installed_games(&mut self, v: u64) {
        self.size_installed_games = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDPContentStatsReport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stats_machine_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.os_type = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_install_folders = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_installed_games = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.size_installed_games = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stats_machine_id {
            my_size += 9;
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.os_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_install_folders {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_installed_games {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size_installed_games {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stats_machine_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.os_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.num_install_folders {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.num_installed_games {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.size_installed_games {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDPContentStatsReport {
        CMsgClientDPContentStatsReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "stats_machine_id",
                |m: &CMsgClientDPContentStatsReport| { &m.stats_machine_id },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.stats_machine_id },
                CMsgClientDPContentStatsReport::get_stats_machine_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "country_code",
                |m: &CMsgClientDPContentStatsReport| { &m.country_code },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.country_code },
                CMsgClientDPContentStatsReport::get_country_code,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "os_type",
                |m: &CMsgClientDPContentStatsReport| { &m.os_type },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.os_type },
                CMsgClientDPContentStatsReport::get_os_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "language",
                |m: &CMsgClientDPContentStatsReport| { &m.language },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.language },
                CMsgClientDPContentStatsReport::get_language,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "num_install_folders",
                |m: &CMsgClientDPContentStatsReport| { &m.num_install_folders },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.num_install_folders },
                CMsgClientDPContentStatsReport::get_num_install_folders,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "num_installed_games",
                |m: &CMsgClientDPContentStatsReport| { &m.num_installed_games },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.num_installed_games },
                CMsgClientDPContentStatsReport::get_num_installed_games,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "size_installed_games",
                |m: &CMsgClientDPContentStatsReport| { &m.size_installed_games },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.size_installed_games },
                CMsgClientDPContentStatsReport::get_size_installed_games,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDPContentStatsReport>(
                "CMsgClientDPContentStatsReport",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDPContentStatsReport {
        static instance: ::protobuf::rt::Lazy<CMsgClientDPContentStatsReport> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientDPContentStatsReport::new)
    }
}

impl ::protobuf::Clear for CMsgClientDPContentStatsReport {
    fn clear(&mut self) {
        self.stats_machine_id = ::std::option::Option::None;
        self.country_code.clear();
        self.os_type = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.num_install_folders = ::std::option::Option::None;
        self.num_installed_games = ::std::option::Option::None;
        self.size_installed_games = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDPContentStatsReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPContentStatsReport {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetCDNAuthTokenResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::string::String>,
    expiration_time: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetCDNAuthTokenResponse {
    fn default() -> &'a CMsgClientGetCDNAuthTokenResponse {
        <CMsgClientGetCDNAuthTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetCDNAuthTokenResponse {
    pub fn new() -> CMsgClientGetCDNAuthTokenResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string token = 2;

    pub fn get_token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 expiration_time = 3;

    pub fn get_expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetCDNAuthTokenResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetCDNAuthTokenResponse {
        CMsgClientGetCDNAuthTokenResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientGetCDNAuthTokenResponse| { &m.eresult },
                |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.eresult },
                CMsgClientGetCDNAuthTokenResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "token",
                |m: &CMsgClientGetCDNAuthTokenResponse| { &m.token },
                |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.token },
                CMsgClientGetCDNAuthTokenResponse::get_token,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "expiration_time",
                |m: &CMsgClientGetCDNAuthTokenResponse| { &m.expiration_time },
                |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.expiration_time },
                CMsgClientGetCDNAuthTokenResponse::get_expiration_time,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetCDNAuthTokenResponse>(
                "CMsgClientGetCDNAuthTokenResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetCDNAuthTokenResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetCDNAuthTokenResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetCDNAuthTokenResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetCDNAuthTokenResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.token.clear();
        self.expiration_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetCDNAuthTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetCDNAuthTokenResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDownloadRateStatistics {
    // message fields
    cell_id: ::std::option::Option<u32>,
    pub stats: ::protobuf::RepeatedField<cmsg_download_rate_statistics::StatsInfo>,
    throttling_kbps: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDownloadRateStatistics {
    fn default() -> &'a CMsgDownloadRateStatistics {
        <CMsgDownloadRateStatistics as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDownloadRateStatistics {
    pub fn new() -> CMsgDownloadRateStatistics {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 throttling_kbps = 3;

    pub fn get_throttling_kbps(&self) -> u32 {
        self.throttling_kbps.unwrap_or(0)
    }

    pub fn clear_throttling_kbps(&mut self) {
        self.throttling_kbps = ::std::option::Option::None;
    }

    pub fn has_throttling_kbps(&self) -> bool {
        self.throttling_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling_kbps(&mut self, v: u32) {
        self.throttling_kbps = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDownloadRateStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.stats)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.throttling_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.throttling_kbps {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.throttling_kbps {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDownloadRateStatistics {
        CMsgDownloadRateStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cell_id",
                |m: &CMsgDownloadRateStatistics| { &m.cell_id },
                |m: &mut CMsgDownloadRateStatistics| { &mut m.cell_id },
                CMsgDownloadRateStatistics::get_cell_id,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_download_rate_statistics::StatsInfo>>(
                "stats",
                |m: &CMsgDownloadRateStatistics| { &m.stats },
                |m: &mut CMsgDownloadRateStatistics| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "throttling_kbps",
                |m: &CMsgDownloadRateStatistics| { &m.throttling_kbps },
                |m: &mut CMsgDownloadRateStatistics| { &mut m.throttling_kbps },
                CMsgDownloadRateStatistics::get_throttling_kbps,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgDownloadRateStatistics>(
                "CMsgDownloadRateStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDownloadRateStatistics {
        static instance: ::protobuf::rt::Lazy<CMsgDownloadRateStatistics> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgDownloadRateStatistics::new)
    }
}

impl ::protobuf::Clear for CMsgDownloadRateStatistics {
    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.stats.clear();
        self.throttling_kbps = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDownloadRateStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDownloadRateStatistics {
}

/// Nested message and enums of message `CMsgDownloadRateStatistics`
pub mod cmsg_download_rate_statistics {
    #[derive(PartialEq,Clone,Default)]
    pub struct StatsInfo {
        // message fields
        source_type: ::std::option::Option<u32>,
        source_id: ::std::option::Option<u32>,
        seconds: ::std::option::Option<u32>,
        bytes: ::std::option::Option<u64>,
        host_name: ::protobuf::SingularField<::std::string::String>,
        microseconds: ::std::option::Option<u64>,
        used_ipv6: ::std::option::Option<bool>,
        proxied: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a StatsInfo {
        fn default() -> &'a StatsInfo {
            <StatsInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl StatsInfo {
        pub fn new() -> StatsInfo {
            ::std::default::Default::default()
        }

        // optional uint32 source_type = 1;

        pub fn get_source_type(&self) -> u32 {
            self.source_type.unwrap_or(0)
        }

        pub fn clear_source_type(&mut self) {
            self.source_type = ::std::option::Option::None;
        }

        pub fn has_source_type(&self) -> bool {
            self.source_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_type(&mut self, v: u32) {
            self.source_type = ::std::option::Option::Some(v);
        }

        // optional uint32 source_id = 2;

        pub fn get_source_id(&self) -> u32 {
            self.source_id.unwrap_or(0)
        }

        pub fn clear_source_id(&mut self) {
            self.source_id = ::std::option::Option::None;
        }

        pub fn has_source_id(&self) -> bool {
            self.source_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_id(&mut self, v: u32) {
            self.source_id = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds = 3;

        pub fn get_seconds(&self) -> u32 {
            self.seconds.unwrap_or(0)
        }

        pub fn clear_seconds(&mut self) {
            self.seconds = ::std::option::Option::None;
        }

        pub fn has_seconds(&self) -> bool {
            self.seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds(&mut self, v: u32) {
            self.seconds = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes = 4;

        pub fn get_bytes(&self) -> u64 {
            self.bytes.unwrap_or(0)
        }

        pub fn clear_bytes(&mut self) {
            self.bytes = ::std::option::Option::None;
        }

        pub fn has_bytes(&self) -> bool {
            self.bytes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes(&mut self, v: u64) {
            self.bytes = ::std::option::Option::Some(v);
        }

        // optional string host_name = 5;

        pub fn get_host_name(&self) -> &str {
            match self.host_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_host_name(&mut self) {
            self.host_name.clear();
        }

        pub fn has_host_name(&self) -> bool {
            self.host_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_host_name(&mut self, v: ::std::string::String) {
            self.host_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
            if self.host_name.is_none() {
                self.host_name.set_default();
            }
            self.host_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_host_name(&mut self) -> ::std::string::String {
            self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 microseconds = 6;

        pub fn get_microseconds(&self) -> u64 {
            self.microseconds.unwrap_or(0)
        }

        pub fn clear_microseconds(&mut self) {
            self.microseconds = ::std::option::Option::None;
        }

        pub fn has_microseconds(&self) -> bool {
            self.microseconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_microseconds(&mut self, v: u64) {
            self.microseconds = ::std::option::Option::Some(v);
        }

        // optional bool used_ipv6 = 7;

        pub fn get_used_ipv6(&self) -> bool {
            self.used_ipv6.unwrap_or(false)
        }

        pub fn clear_used_ipv6(&mut self) {
            self.used_ipv6 = ::std::option::Option::None;
        }

        pub fn has_used_ipv6(&self) -> bool {
            self.used_ipv6.is_some()
        }

        // Param is passed by value, moved
        pub fn set_used_ipv6(&mut self, v: bool) {
            self.used_ipv6 = ::std::option::Option::Some(v);
        }

        // optional bool proxied = 8;

        pub fn get_proxied(&self) -> bool {
            self.proxied.unwrap_or(false)
        }

        pub fn clear_proxied(&mut self) {
            self.proxied = ::std::option::Option::None;
        }

        pub fn has_proxied(&self) -> bool {
            self.proxied.is_some()
        }

        // Param is passed by value, moved
        pub fn set_proxied(&mut self, v: bool) {
            self.proxied = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for StatsInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.source_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.source_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.seconds = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.bytes = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    5 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host_name)?;
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.microseconds = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.used_ipv6 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    8 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.proxied = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.source_type {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.source_id {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.seconds {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.bytes {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.host_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.microseconds {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.used_ipv6 {
                my_size += 2;
            }
            if let Some(v) = self.proxied {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.source_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.source_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.seconds {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.bytes {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.host_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.microseconds {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.used_ipv6 {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.proxied {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> StatsInfo {
            StatsInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "source_type",
                    |m: &StatsInfo| { &m.source_type },
                    |m: &mut StatsInfo| { &mut m.source_type },
                    StatsInfo::get_source_type,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "source_id",
                    |m: &StatsInfo| { &m.source_id },
                    |m: &mut StatsInfo| { &mut m.source_id },
                    StatsInfo::get_source_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "seconds",
                    |m: &StatsInfo| { &m.seconds },
                    |m: &mut StatsInfo| { &mut m.seconds },
                    StatsInfo::get_seconds,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "bytes",
                    |m: &StatsInfo| { &m.bytes },
                    |m: &mut StatsInfo| { &mut m.bytes },
                    StatsInfo::get_bytes,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "host_name",
                    |m: &StatsInfo| { &m.host_name },
                    |m: &mut StatsInfo| { &mut m.host_name },
                    StatsInfo::get_host_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "microseconds",
                    |m: &StatsInfo| { &m.microseconds },
                    |m: &mut StatsInfo| { &mut m.microseconds },
                    StatsInfo::get_microseconds,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "used_ipv6",
                    |m: &StatsInfo| { &m.used_ipv6 },
                    |m: &mut StatsInfo| { &mut m.used_ipv6 },
                    StatsInfo::get_used_ipv6,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "proxied",
                    |m: &StatsInfo| { &m.proxied },
                    |m: &mut StatsInfo| { &mut m.proxied },
                    StatsInfo::get_proxied,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatsInfo>(
                    "CMsgDownloadRateStatistics.StatsInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static StatsInfo {
            static instance: ::protobuf::rt::Lazy<StatsInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(StatsInfo::new)
        }
    }

    impl ::protobuf::Clear for StatsInfo {
        fn clear(&mut self) {
            self.source_type = ::std::option::Option::None;
            self.source_id = ::std::option::Option::None;
            self.seconds = ::std::option::Option::None;
            self.bytes = ::std::option::Option::None;
            self.host_name.clear();
            self.microseconds = ::std::option::Option::None;
            self.used_ipv6 = ::std::option::Option::None;
            self.proxied = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for StatsInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StatsInfo {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestAccountData {
    // message fields
    account_or_email: ::protobuf::SingularField<::std::string::String>,
    action: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestAccountData {
    fn default() -> &'a CMsgClientRequestAccountData {
        <CMsgClientRequestAccountData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestAccountData {
    pub fn new() -> CMsgClientRequestAccountData {
        ::std::default::Default::default()
    }

    // optional string account_or_email = 1;

    pub fn get_account_or_email(&self) -> &str {
        match self.account_or_email.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_or_email(&mut self) {
        self.account_or_email.clear();
    }

    pub fn has_account_or_email(&self) -> bool {
        self.account_or_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_or_email(&mut self, v: ::std::string::String) {
        self.account_or_email = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_or_email(&mut self) -> &mut ::std::string::String {
        if self.account_or_email.is_none() {
            self.account_or_email.set_default();
        }
        self.account_or_email.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_or_email(&mut self) -> ::std::string::String {
        self.account_or_email.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 action = 2;

    pub fn get_action(&self) -> u32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestAccountData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_or_email)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_or_email.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_or_email.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.action {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestAccountData {
        CMsgClientRequestAccountData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "account_or_email",
                |m: &CMsgClientRequestAccountData| { &m.account_or_email },
                |m: &mut CMsgClientRequestAccountData| { &mut m.account_or_email },
                CMsgClientRequestAccountData::get_account_or_email,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "action",
                |m: &CMsgClientRequestAccountData| { &m.action },
                |m: &mut CMsgClientRequestAccountData| { &mut m.action },
                CMsgClientRequestAccountData::get_action,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestAccountData>(
                "CMsgClientRequestAccountData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestAccountData {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestAccountData> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestAccountData::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestAccountData {
    fn clear(&mut self) {
        self.account_or_email.clear();
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestAccountData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestAccountData {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestAccountDataResponse {
    // message fields
    action: ::std::option::Option<u32>,
    eresult: ::std::option::Option<u32>,
    account_name: ::protobuf::SingularField<::std::string::String>,
    ct_matches: ::std::option::Option<u32>,
    account_name_suggestion1: ::protobuf::SingularField<::std::string::String>,
    account_name_suggestion2: ::protobuf::SingularField<::std::string::String>,
    account_name_suggestion3: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestAccountDataResponse {
    fn default() -> &'a CMsgClientRequestAccountDataResponse {
        <CMsgClientRequestAccountDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestAccountDataResponse {
    pub fn new() -> CMsgClientRequestAccountDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 action = 1;

    pub fn get_action(&self) -> u32 {
        self.action.unwrap_or(0)
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string account_name = 3;

    pub fn get_account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name.set_default();
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ct_matches = 4;

    pub fn get_ct_matches(&self) -> u32 {
        self.ct_matches.unwrap_or(0)
    }

    pub fn clear_ct_matches(&mut self) {
        self.ct_matches = ::std::option::Option::None;
    }

    pub fn has_ct_matches(&self) -> bool {
        self.ct_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_matches(&mut self, v: u32) {
        self.ct_matches = ::std::option::Option::Some(v);
    }

    // optional string account_name_suggestion1 = 5;

    pub fn get_account_name_suggestion1(&self) -> &str {
        match self.account_name_suggestion1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion1(&mut self) {
        self.account_name_suggestion1.clear();
    }

    pub fn has_account_name_suggestion1(&self) -> bool {
        self.account_name_suggestion1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion1(&mut self, v: ::std::string::String) {
        self.account_name_suggestion1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion1(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion1.is_none() {
            self.account_name_suggestion1.set_default();
        }
        self.account_name_suggestion1.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion1(&mut self) -> ::std::string::String {
        self.account_name_suggestion1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string account_name_suggestion2 = 6;

    pub fn get_account_name_suggestion2(&self) -> &str {
        match self.account_name_suggestion2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion2(&mut self) {
        self.account_name_suggestion2.clear();
    }

    pub fn has_account_name_suggestion2(&self) -> bool {
        self.account_name_suggestion2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion2(&mut self, v: ::std::string::String) {
        self.account_name_suggestion2 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion2(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion2.is_none() {
            self.account_name_suggestion2.set_default();
        }
        self.account_name_suggestion2.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion2(&mut self) -> ::std::string::String {
        self.account_name_suggestion2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string account_name_suggestion3 = 7;

    pub fn get_account_name_suggestion3(&self) -> &str {
        match self.account_name_suggestion3.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name_suggestion3(&mut self) {
        self.account_name_suggestion3.clear();
    }

    pub fn has_account_name_suggestion3(&self) -> bool {
        self.account_name_suggestion3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion3(&mut self, v: ::std::string::String) {
        self.account_name_suggestion3 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion3(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion3.is_none() {
            self.account_name_suggestion3.set_default();
        }
        self.account_name_suggestion3.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion3(&mut self) -> ::std::string::String {
        self.account_name_suggestion3.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestAccountDataResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ct_matches = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name_suggestion1)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name_suggestion2)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name_suggestion3)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ct_matches {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_name_suggestion1.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.account_name_suggestion2.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.account_name_suggestion3.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ct_matches {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.account_name_suggestion1.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.account_name_suggestion2.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.account_name_suggestion3.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestAccountDataResponse {
        CMsgClientRequestAccountDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "action",
                |m: &CMsgClientRequestAccountDataResponse| { &m.action },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.action },
                CMsgClientRequestAccountDataResponse::get_action,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientRequestAccountDataResponse| { &m.eresult },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.eresult },
                CMsgClientRequestAccountDataResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "account_name",
                |m: &CMsgClientRequestAccountDataResponse| { &m.account_name },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name },
                CMsgClientRequestAccountDataResponse::get_account_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "ct_matches",
                |m: &CMsgClientRequestAccountDataResponse| { &m.ct_matches },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.ct_matches },
                CMsgClientRequestAccountDataResponse::get_ct_matches,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "account_name_suggestion1",
                |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion1 },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion1 },
                CMsgClientRequestAccountDataResponse::get_account_name_suggestion1,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "account_name_suggestion2",
                |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion2 },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion2 },
                CMsgClientRequestAccountDataResponse::get_account_name_suggestion2,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "account_name_suggestion3",
                |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion3 },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion3 },
                CMsgClientRequestAccountDataResponse::get_account_name_suggestion3,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestAccountDataResponse>(
                "CMsgClientRequestAccountDataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestAccountDataResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestAccountDataResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestAccountDataResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestAccountDataResponse {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.account_name.clear();
        self.ct_matches = ::std::option::Option::None;
        self.account_name_suggestion1.clear();
        self.account_name_suggestion2.clear();
        self.account_name_suggestion3.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestAccountDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestAccountDataResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUGSGetGlobalStats {
    // message fields
    gameid: ::std::option::Option<u64>,
    history_days_requested: ::std::option::Option<u32>,
    time_last_requested: ::std::option::Option<u32>,
    first_day_cached: ::std::option::Option<u32>,
    days_cached: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStats {
    fn default() -> &'a CMsgClientUGSGetGlobalStats {
        <CMsgClientUGSGetGlobalStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStats {
    pub fn new() -> CMsgClientUGSGetGlobalStats {
        ::std::default::Default::default()
    }

    // optional uint64 gameid = 1;

    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 history_days_requested = 2;

    pub fn get_history_days_requested(&self) -> u32 {
        self.history_days_requested.unwrap_or(0)
    }

    pub fn clear_history_days_requested(&mut self) {
        self.history_days_requested = ::std::option::Option::None;
    }

    pub fn has_history_days_requested(&self) -> bool {
        self.history_days_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history_days_requested(&mut self, v: u32) {
        self.history_days_requested = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_last_requested = 3;

    pub fn get_time_last_requested(&self) -> u32 {
        self.time_last_requested.unwrap_or(0)
    }

    pub fn clear_time_last_requested(&mut self) {
        self.time_last_requested = ::std::option::Option::None;
    }

    pub fn has_time_last_requested(&self) -> bool {
        self.time_last_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_requested(&mut self, v: u32) {
        self.time_last_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 first_day_cached = 4;

    pub fn get_first_day_cached(&self) -> u32 {
        self.first_day_cached.unwrap_or(0)
    }

    pub fn clear_first_day_cached(&mut self) {
        self.first_day_cached = ::std::option::Option::None;
    }

    pub fn has_first_day_cached(&self) -> bool {
        self.first_day_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_day_cached(&mut self, v: u32) {
        self.first_day_cached = ::std::option::Option::Some(v);
    }

    // optional uint32 days_cached = 5;

    pub fn get_days_cached(&self) -> u32 {
        self.days_cached.unwrap_or(0)
    }

    pub fn clear_days_cached(&mut self) {
        self.days_cached = ::std::option::Option::None;
    }

    pub fn has_days_cached(&self) -> bool {
        self.days_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_days_cached(&mut self, v: u32) {
        self.days_cached = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUGSGetGlobalStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.history_days_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_last_requested = ::std::option::Option::Some(is.read_fixed32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.first_day_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.days_cached = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.history_days_requested {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_requested {
            my_size += 5;
        }
        if let Some(v) = self.first_day_cached {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.days_cached {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gameid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.history_days_requested {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_last_requested {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.first_day_cached {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.days_cached {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUGSGetGlobalStats {
        CMsgClientUGSGetGlobalStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "gameid",
                |m: &CMsgClientUGSGetGlobalStats| { &m.gameid },
                |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.gameid },
                CMsgClientUGSGetGlobalStats::get_gameid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "history_days_requested",
                |m: &CMsgClientUGSGetGlobalStats| { &m.history_days_requested },
                |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.history_days_requested },
                CMsgClientUGSGetGlobalStats::get_history_days_requested,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "time_last_requested",
                |m: &CMsgClientUGSGetGlobalStats| { &m.time_last_requested },
                |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.time_last_requested },
                CMsgClientUGSGetGlobalStats::get_time_last_requested,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "first_day_cached",
                |m: &CMsgClientUGSGetGlobalStats| { &m.first_day_cached },
                |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.first_day_cached },
                CMsgClientUGSGetGlobalStats::get_first_day_cached,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "days_cached",
                |m: &CMsgClientUGSGetGlobalStats| { &m.days_cached },
                |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.days_cached },
                CMsgClientUGSGetGlobalStats::get_days_cached,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUGSGetGlobalStats>(
                "CMsgClientUGSGetGlobalStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStats {
        static instance: ::protobuf::rt::Lazy<CMsgClientUGSGetGlobalStats> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUGSGetGlobalStats::new)
    }
}

impl ::protobuf::Clear for CMsgClientUGSGetGlobalStats {
    fn clear(&mut self) {
        self.gameid = ::std::option::Option::None;
        self.history_days_requested = ::std::option::Option::None;
        self.time_last_requested = ::std::option::Option::None;
        self.first_day_cached = ::std::option::Option::None;
        self.days_cached = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUGSGetGlobalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUGSGetGlobalStats {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUGSGetGlobalStatsResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    timestamp: ::std::option::Option<u32>,
    day_current: ::std::option::Option<i32>,
    pub days: ::protobuf::RepeatedField<cmsg_client_ugsget_global_stats_response::Day>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStatsResponse {
    fn default() -> &'a CMsgClientUGSGetGlobalStatsResponse {
        <CMsgClientUGSGetGlobalStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStatsResponse {
    pub fn new() -> CMsgClientUGSGetGlobalStatsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed32 timestamp = 2;

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 day_current = 3;

    pub fn get_day_current(&self) -> i32 {
        self.day_current.unwrap_or(0)
    }

    pub fn clear_day_current(&mut self) {
        self.day_current = ::std::option::Option::None;
    }

    pub fn has_day_current(&self) -> bool {
        self.day_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_day_current(&mut self, v: i32) {
        self.day_current = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUGSGetGlobalStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.days {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.day_current = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.days)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += 5;
        }
        if let Some(v) = self.day_current {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.days {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.day_current {
            os.write_int32(3, v)?;
        }
        for v in &self.days {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUGSGetGlobalStatsResponse {
        CMsgClientUGSGetGlobalStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.eresult },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.eresult },
                CMsgClientUGSGetGlobalStatsResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "timestamp",
                |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.timestamp },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.timestamp },
                CMsgClientUGSGetGlobalStatsResponse::get_timestamp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "day_current",
                |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.day_current },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.day_current },
                CMsgClientUGSGetGlobalStatsResponse::get_day_current,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_ugsget_global_stats_response::Day>>(
                "days",
                |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.days },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.days },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUGSGetGlobalStatsResponse>(
                "CMsgClientUGSGetGlobalStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStatsResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientUGSGetGlobalStatsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUGSGetGlobalStatsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUGSGetGlobalStatsResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.day_current = ::std::option::Option::None;
        self.days.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUGSGetGlobalStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUGSGetGlobalStatsResponse {
}

/// Nested message and enums of message `CMsgClientUGSGetGlobalStatsResponse`
pub mod cmsg_client_ugsget_global_stats_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Day {
        // message fields
        day_id: ::std::option::Option<u32>,
        pub stats: ::protobuf::RepeatedField<day::Stat>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Day {
        fn default() -> &'a Day {
            <Day as ::protobuf::Message>::default_instance()
        }
    }

    impl Day {
        pub fn new() -> Day {
            ::std::default::Default::default()
        }

        // optional uint32 day_id = 1;

        pub fn get_day_id(&self) -> u32 {
            self.day_id.unwrap_or(0)
        }

        pub fn clear_day_id(&mut self) {
            self.day_id = ::std::option::Option::None;
        }

        pub fn has_day_id(&self) -> bool {
            self.day_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_day_id(&mut self, v: u32) {
            self.day_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Day {
        fn is_initialized(&self) -> bool {
            for v in &self.stats {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.day_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.stats)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.day_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            for value in &self.stats {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.day_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.stats {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Day {
            Day::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "day_id",
                    |m: &Day| { &m.day_id },
                    |m: &mut Day| { &mut m.day_id },
                    Day::get_day_id,
                ));
                fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<day::Stat>>(
                    "stats",
                    |m: &Day| { &m.stats },
                    |m: &mut Day| { &mut m.stats },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Day>(
                    "CMsgClientUGSGetGlobalStatsResponse.Day",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Day {
            static instance: ::protobuf::rt::Lazy<Day> = ::protobuf::rt::Lazy::INIT;
            instance.get(Day::new)
        }
    }

    impl ::protobuf::Clear for Day {
        fn clear(&mut self) {
            self.day_id = ::std::option::Option::None;
            self.stats.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Day {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Day {
    }

    /// Nested message and enums of message `Day`
    pub mod day {
        #[derive(PartialEq,Clone,Default)]
        pub struct Stat {
            // message fields
            stat_id: ::std::option::Option<i32>,
            data: ::std::option::Option<i64>,
            // special fields
            pub unknown_fields: ::protobuf::UnknownFields,
            pub cached_size: ::protobuf::rt::CachedSize,
        }

        impl<'a> ::std::default::Default for &'a Stat {
            fn default() -> &'a Stat {
                <Stat as ::protobuf::Message>::default_instance()
            }
        }

        impl Stat {
            pub fn new() -> Stat {
                ::std::default::Default::default()
            }

            // optional int32 stat_id = 1;

            pub fn get_stat_id(&self) -> i32 {
                self.stat_id.unwrap_or(0)
            }

            pub fn clear_stat_id(&mut self) {
                self.stat_id = ::std::option::Option::None;
            }

            pub fn has_stat_id(&self) -> bool {
                self.stat_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stat_id(&mut self, v: i32) {
                self.stat_id = ::std::option::Option::Some(v);
            }

            // optional int64 data = 2;

            pub fn get_data(&self) -> i64 {
                self.data.unwrap_or(0)
            }

            pub fn clear_data(&mut self) {
                self.data = ::std::option::Option::None;
            }

            pub fn has_data(&self) -> bool {
                self.data.is_some()
            }

            // Param is passed by value, moved
            pub fn set_data(&mut self, v: i64) {
                self.data = ::std::option::Option::Some(v);
            }
        }

        impl ::protobuf::Message for Stat {
            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                while !is.eof()? {
                    let (field_number, wire_type) = is.read_tag_unpack()?;
                    match field_number {
                        1 => {
                            if wire_type != ::protobuf::wire_format::WireTypeVarint {
                                return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                            }
                            self.stat_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        2 => {
                            if wire_type != ::protobuf::wire_format::WireTypeVarint {
                                return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                            }
                            self.data = ::std::option::Option::Some(is.read_int64()?);
                        },
                        _ => {
                            ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u32 {
                let mut my_size = 0;
                if let Some(v) = self.stat_id {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                }
                if let Some(v) = self.data {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
                self.cached_size.set(my_size);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                if let Some(v) = self.stat_id {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.data {
                    os.write_int64(2, v)?;
                }
                os.write_unknown_fields(self.get_unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn get_cached_size(&self) -> u32 {
                self.cached_size.get()
            }

            fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
                &self.unknown_fields
            }

            fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
                &mut self.unknown_fields
            }

            fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
                Self::descriptor_static()
            }

            fn new() -> Stat {
                Stat::new()
            }

            fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
                descriptor.get(|| {
                    let mut fields = ::std::vec::Vec::new();
                    fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                        "stat_id",
                        |m: &Stat| { &m.stat_id },
                        |m: &mut Stat| { &mut m.stat_id },
                        Stat::get_stat_id,
                    ));
                    fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt64, _>(
                        "data",
                        |m: &Stat| { &m.data },
                        |m: &mut Stat| { &mut m.data },
                        Stat::get_data,
                    ));
                    ::protobuf::reflect::MessageDescriptor::new::<Stat>(
                        "CMsgClientUGSGetGlobalStatsResponse.Day.Stat",
                        fields,
                        super::super::file_descriptor_proto()
                    )
                })
            }

            fn default_instance() -> &'static Stat {
                static instance: ::protobuf::rt::Lazy<Stat> = ::protobuf::rt::Lazy::INIT;
                instance.get(Stat::new)
            }
        }

        impl ::protobuf::Clear for Stat {
            fn clear(&mut self) {
                self.stat_id = ::std::option::Option::None;
                self.data = ::std::option::Option::None;
                self.unknown_fields.clear();
            }
        }

        impl ::std::fmt::Debug for Stat {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Stat {
        }
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerData {
    // message fields
    steam_id_gs: ::std::option::Option<u64>,
    deprecated_ip: ::std::option::Option<u32>,
    query_port: ::std::option::Option<u32>,
    game_port: ::std::option::Option<u32>,
    sourcetv_port: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub game_ip_address: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    app_id: ::std::option::Option<u32>,
    gamedir: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    product: ::protobuf::SingularField<::std::string::String>,
    region: ::protobuf::SingularField<::std::string::String>,
    pub players: ::protobuf::RepeatedField<cmsg_game_server_data::Player>,
    max_players: ::std::option::Option<u32>,
    bot_count: ::std::option::Option<u32>,
    password: ::std::option::Option<bool>,
    secure: ::std::option::Option<bool>,
    dedicated: ::std::option::Option<bool>,
    os: ::protobuf::SingularField<::std::string::String>,
    game_data: ::protobuf::SingularField<::std::string::String>,
    game_data_version: ::std::option::Option<u32>,
    game_type: ::protobuf::SingularField<::std::string::String>,
    map: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerData {
    fn default() -> &'a CMsgGameServerData {
        <CMsgGameServerData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerData {
    pub fn new() -> CMsgGameServerData {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_gs = 1;

    pub fn get_steam_id_gs(&self) -> u64 {
        self.steam_id_gs.unwrap_or(0)
    }

    pub fn clear_steam_id_gs(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_steam_id_gs(&self) -> bool {
        self.steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_gs(&mut self, v: u64) {
        self.steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_ip = 2;

    pub fn get_deprecated_ip(&self) -> u32 {
        self.deprecated_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_ip(&mut self) {
        self.deprecated_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_ip(&self) -> bool {
        self.deprecated_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_ip(&mut self, v: u32) {
        self.deprecated_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 query_port = 3;

    pub fn get_query_port(&self) -> u32 {
        self.query_port.unwrap_or(0)
    }

    pub fn clear_query_port(&mut self) {
        self.query_port = ::std::option::Option::None;
    }

    pub fn has_query_port(&self) -> bool {
        self.query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_port(&mut self, v: u32) {
        self.query_port = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;

    pub fn get_game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional uint32 sourcetv_port = 5;

    pub fn get_sourcetv_port(&self) -> u32 {
        self.sourcetv_port.unwrap_or(0)
    }

    pub fn clear_sourcetv_port(&mut self) {
        self.sourcetv_port = ::std::option::Option::None;
    }

    pub fn has_sourcetv_port(&self) -> bool {
        self.sourcetv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourcetv_port(&mut self, v: u32) {
        self.sourcetv_port = ::std::option::Option::Some(v);
    }

    // optional string name = 22;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 6;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string gamedir = 7;

    pub fn get_gamedir(&self) -> &str {
        match self.gamedir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gamedir(&mut self) {
        self.gamedir.clear();
    }

    pub fn has_gamedir(&self) -> bool {
        self.gamedir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamedir(&mut self, v: ::std::string::String) {
        self.gamedir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamedir(&mut self) -> &mut ::std::string::String {
        if self.gamedir.is_none() {
            self.gamedir.set_default();
        }
        self.gamedir.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamedir(&mut self) -> ::std::string::String {
        self.gamedir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 8;

    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string product = 9;

    pub fn get_product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product.set_default();
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string region = 10;

    pub fn get_region(&self) -> &str {
        match self.region.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_region(&mut self) {
        self.region.clear();
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: ::std::string::String) {
        self.region = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region(&mut self) -> &mut ::std::string::String {
        if self.region.is_none() {
            self.region.set_default();
        }
        self.region.as_mut().unwrap()
    }

    // Take field
    pub fn take_region(&mut self) -> ::std::string::String {
        self.region.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_players = 12;

    pub fn get_max_players(&self) -> u32 {
        self.max_players.unwrap_or(0)
    }

    pub fn clear_max_players(&mut self) {
        self.max_players = ::std::option::Option::None;
    }

    pub fn has_max_players(&self) -> bool {
        self.max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_players(&mut self, v: u32) {
        self.max_players = ::std::option::Option::Some(v);
    }

    // optional uint32 bot_count = 13;

    pub fn get_bot_count(&self) -> u32 {
        self.bot_count.unwrap_or(0)
    }

    pub fn clear_bot_count(&mut self) {
        self.bot_count = ::std::option::Option::None;
    }

    pub fn has_bot_count(&self) -> bool {
        self.bot_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_count(&mut self, v: u32) {
        self.bot_count = ::std::option::Option::Some(v);
    }

    // optional bool password = 14;

    pub fn get_password(&self) -> bool {
        self.password.unwrap_or(false)
    }

    pub fn clear_password(&mut self) {
        self.password = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: bool) {
        self.password = ::std::option::Option::Some(v);
    }

    // optional bool secure = 15;

    pub fn get_secure(&self) -> bool {
        self.secure.unwrap_or(false)
    }

    pub fn clear_secure(&mut self) {
        self.secure = ::std::option::Option::None;
    }

    pub fn has_secure(&self) -> bool {
        self.secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure(&mut self, v: bool) {
        self.secure = ::std::option::Option::Some(v);
    }

    // optional bool dedicated = 16;

    pub fn get_dedicated(&self) -> bool {
        self.dedicated.unwrap_or(false)
    }

    pub fn clear_dedicated(&mut self) {
        self.dedicated = ::std::option::Option::None;
    }

    pub fn has_dedicated(&self) -> bool {
        self.dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dedicated(&mut self, v: bool) {
        self.dedicated = ::std::option::Option::Some(v);
    }

    // optional string os = 17;

    pub fn get_os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os.set_default();
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_data = 18;

    pub fn get_game_data(&self) -> &str {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data.clear();
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::string::String) {
        self.game_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::string::String {
        if self.game_data.is_none() {
            self.game_data.set_default();
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::string::String {
        self.game_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 game_data_version = 19;

    pub fn get_game_data_version(&self) -> u32 {
        self.game_data_version.unwrap_or(0)
    }

    pub fn clear_game_data_version(&mut self) {
        self.game_data_version = ::std::option::Option::None;
    }

    pub fn has_game_data_version(&self) -> bool {
        self.game_data_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data_version(&mut self, v: u32) {
        self.game_data_version = ::std::option::Option::Some(v);
    }

    // optional string game_type = 20;

    pub fn get_game_type(&self) -> &str {
        match self.game_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_type(&mut self) {
        self.game_type.clear();
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: ::std::string::String) {
        self.game_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_type(&mut self) -> &mut ::std::string::String {
        if self.game_type.is_none() {
            self.game_type.set_default();
        }
        self.game_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_type(&mut self) -> ::std::string::String {
        self.game_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map = 21;

    pub fn get_map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGameServerData {
    fn is_initialized(&self) -> bool {
        for v in &self.game_ip_address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_gs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deprecated_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sourcetv_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into::<super::steammessages_base::CMsgIPAddress, _>(wire_type, is, &mut self.game_ip_address)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gamedir)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.product)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.region)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.players)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.max_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bot_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.password = ::std::option::Option::Some(is.read_bool()?);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.secure = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_data)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_data_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_type)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_gs {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.query_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sourcetv_port {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.game_ip_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gamedir.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.region.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.max_players {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bot_count {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.password {
            my_size += 2;
        }
        if let Some(v) = self.secure {
            my_size += 2;
        }
        if let Some(v) = self.dedicated {
            my_size += 3;
        }
        if let Some(v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.game_data_version {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.deprecated_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.query_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sourcetv_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.game_ip_address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.gamedir.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.product.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.region.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.max_players {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.bot_count {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.password {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.secure {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.dedicated {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.os.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.game_data_version {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.game_type.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(21, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerData {
        CMsgGameServerData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_gs",
                |m: &CMsgGameServerData| { &m.steam_id_gs },
                |m: &mut CMsgGameServerData| { &mut m.steam_id_gs },
                CMsgGameServerData::get_steam_id_gs,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "deprecated_ip",
                |m: &CMsgGameServerData| { &m.deprecated_ip },
                |m: &mut CMsgGameServerData| { &mut m.deprecated_ip },
                CMsgGameServerData::get_deprecated_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "query_port",
                |m: &CMsgGameServerData| { &m.query_port },
                |m: &mut CMsgGameServerData| { &mut m.query_port },
                CMsgGameServerData::get_query_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "game_port",
                |m: &CMsgGameServerData| { &m.game_port },
                |m: &mut CMsgGameServerData| { &mut m.game_port },
                CMsgGameServerData::get_game_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "sourcetv_port",
                |m: &CMsgGameServerData| { &m.sourcetv_port },
                |m: &mut CMsgGameServerData| { &mut m.sourcetv_port },
                CMsgGameServerData::get_sourcetv_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "name",
                |m: &CMsgGameServerData| { &m.name },
                |m: &mut CMsgGameServerData| { &mut m.name },
                CMsgGameServerData::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>, _>(
                "game_ip_address",
                |m: &CMsgGameServerData| { &m.game_ip_address },
                |m: &mut CMsgGameServerData| { &mut m.game_ip_address },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgGameServerData| { &m.app_id },
                |m: &mut CMsgGameServerData| { &mut m.app_id },
                CMsgGameServerData::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "gamedir",
                |m: &CMsgGameServerData| { &m.gamedir },
                |m: &mut CMsgGameServerData| { &mut m.gamedir },
                CMsgGameServerData::get_gamedir,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "version",
                |m: &CMsgGameServerData| { &m.version },
                |m: &mut CMsgGameServerData| { &mut m.version },
                CMsgGameServerData::get_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "product",
                |m: &CMsgGameServerData| { &m.product },
                |m: &mut CMsgGameServerData| { &mut m.product },
                CMsgGameServerData::get_product,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "region",
                |m: &CMsgGameServerData| { &m.region },
                |m: &mut CMsgGameServerData| { &mut m.region },
                CMsgGameServerData::get_region,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_game_server_data::Player>>(
                "players",
                |m: &CMsgGameServerData| { &m.players },
                |m: &mut CMsgGameServerData| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "max_players",
                |m: &CMsgGameServerData| { &m.max_players },
                |m: &mut CMsgGameServerData| { &mut m.max_players },
                CMsgGameServerData::get_max_players,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "bot_count",
                |m: &CMsgGameServerData| { &m.bot_count },
                |m: &mut CMsgGameServerData| { &mut m.bot_count },
                CMsgGameServerData::get_bot_count,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "password",
                |m: &CMsgGameServerData| { &m.password },
                |m: &mut CMsgGameServerData| { &mut m.password },
                CMsgGameServerData::get_password,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "secure",
                |m: &CMsgGameServerData| { &m.secure },
                |m: &mut CMsgGameServerData| { &mut m.secure },
                CMsgGameServerData::get_secure,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "dedicated",
                |m: &CMsgGameServerData| { &m.dedicated },
                |m: &mut CMsgGameServerData| { &mut m.dedicated },
                CMsgGameServerData::get_dedicated,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "os",
                |m: &CMsgGameServerData| { &m.os },
                |m: &mut CMsgGameServerData| { &mut m.os },
                CMsgGameServerData::get_os,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "game_data",
                |m: &CMsgGameServerData| { &m.game_data },
                |m: &mut CMsgGameServerData| { &mut m.game_data },
                CMsgGameServerData::get_game_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "game_data_version",
                |m: &CMsgGameServerData| { &m.game_data_version },
                |m: &mut CMsgGameServerData| { &mut m.game_data_version },
                CMsgGameServerData::get_game_data_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "game_type",
                |m: &CMsgGameServerData| { &m.game_type },
                |m: &mut CMsgGameServerData| { &mut m.game_type },
                CMsgGameServerData::get_game_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "map",
                |m: &CMsgGameServerData| { &m.map },
                |m: &mut CMsgGameServerData| { &mut m.map },
                CMsgGameServerData::get_map,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGameServerData>(
                "CMsgGameServerData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerData {
        static instance: ::protobuf::rt::Lazy<CMsgGameServerData> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGameServerData::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerData {
    fn clear(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
        self.deprecated_ip = ::std::option::Option::None;
        self.query_port = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.sourcetv_port = ::std::option::Option::None;
        self.name.clear();
        self.game_ip_address.clear();
        self.app_id = ::std::option::Option::None;
        self.gamedir.clear();
        self.version.clear();
        self.product.clear();
        self.region.clear();
        self.players.clear();
        self.max_players = ::std::option::Option::None;
        self.bot_count = ::std::option::Option::None;
        self.password = ::std::option::Option::None;
        self.secure = ::std::option::Option::None;
        self.dedicated = ::std::option::Option::None;
        self.os.clear();
        self.game_data.clear();
        self.game_data_version = ::std::option::Option::None;
        self.game_type.clear();
        self.map.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerData {
}

/// Nested message and enums of message `CMsgGameServerData`
pub mod cmsg_game_server_data {
    #[derive(PartialEq,Clone,Default)]
    pub struct Player {
        // message fields
        steam_id: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn get_steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Player {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 9;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Player {
            Player::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steam_id",
                    |m: &Player| { &m.steam_id },
                    |m: &mut Player| { &mut m.steam_id },
                    Player::get_steam_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Player>(
                    "CMsgGameServerData.Player",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Player {
            static instance: ::protobuf::rt::Lazy<Player> = ::protobuf::rt::Lazy::INIT;
            instance.get(Player::new)
        }
    }

    impl ::protobuf::Clear for Player {
        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerRemove {
    // message fields
    steam_id: ::std::option::Option<u64>,
    deprecated_ip: ::std::option::Option<u32>,
    query_port: ::std::option::Option<u32>,
    pub ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerRemove {
    fn default() -> &'a CMsgGameServerRemove {
        <CMsgGameServerRemove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerRemove {
    pub fn new() -> CMsgGameServerRemove {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_ip = 2;

    pub fn get_deprecated_ip(&self) -> u32 {
        self.deprecated_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_ip(&mut self) {
        self.deprecated_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_ip(&self) -> bool {
        self.deprecated_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_ip(&mut self, v: u32) {
        self.deprecated_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 query_port = 3;

    pub fn get_query_port(&self) -> u32 {
        self.query_port.unwrap_or(0)
    }

    pub fn clear_query_port(&mut self) {
        self.query_port = ::std::option::Option::None;
    }

    pub fn has_query_port(&self) -> bool {
        self.query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_port(&mut self, v: u32) {
        self.query_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameServerRemove {
    fn is_initialized(&self) -> bool {
        for v in &self.ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deprecated_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into::<super::steammessages_base::CMsgIPAddress, _>(wire_type, is, &mut self.ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.query_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.deprecated_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.query_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerRemove {
        CMsgGameServerRemove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id",
                |m: &CMsgGameServerRemove| { &m.steam_id },
                |m: &mut CMsgGameServerRemove| { &mut m.steam_id },
                CMsgGameServerRemove::get_steam_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "deprecated_ip",
                |m: &CMsgGameServerRemove| { &m.deprecated_ip },
                |m: &mut CMsgGameServerRemove| { &mut m.deprecated_ip },
                CMsgGameServerRemove::get_deprecated_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "query_port",
                |m: &CMsgGameServerRemove| { &m.query_port },
                |m: &mut CMsgGameServerRemove| { &mut m.query_port },
                CMsgGameServerRemove::get_query_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>, _>(
                "ip",
                |m: &CMsgGameServerRemove| { &m.ip },
                |m: &mut CMsgGameServerRemove| { &mut m.ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGameServerRemove>(
                "CMsgGameServerRemove",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerRemove {
        static instance: ::protobuf::rt::Lazy<CMsgGameServerRemove> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGameServerRemove::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerRemove {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.deprecated_ip = ::std::option::Option::None;
        self.query_port = ::std::option::Option::None;
        self.ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerRemove {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGMSServerQuery {
    // message fields
    app_id: ::std::option::Option<u32>,
    geo_location_ip: ::std::option::Option<u32>,
    region_code: ::std::option::Option<u32>,
    filter_text: ::protobuf::SingularField<::std::string::String>,
    max_servers: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGMSServerQuery {
    fn default() -> &'a CMsgClientGMSServerQuery {
        <CMsgClientGMSServerQuery as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGMSServerQuery {
    pub fn new() -> CMsgClientGMSServerQuery {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 geo_location_ip = 2;

    pub fn get_geo_location_ip(&self) -> u32 {
        self.geo_location_ip.unwrap_or(0)
    }

    pub fn clear_geo_location_ip(&mut self) {
        self.geo_location_ip = ::std::option::Option::None;
    }

    pub fn has_geo_location_ip(&self) -> bool {
        self.geo_location_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geo_location_ip(&mut self, v: u32) {
        self.geo_location_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 region_code = 3;

    pub fn get_region_code(&self) -> u32 {
        self.region_code.unwrap_or(0)
    }

    pub fn clear_region_code(&mut self) {
        self.region_code = ::std::option::Option::None;
    }

    pub fn has_region_code(&self) -> bool {
        self.region_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_code(&mut self, v: u32) {
        self.region_code = ::std::option::Option::Some(v);
    }

    // optional string filter_text = 4;

    pub fn get_filter_text(&self) -> &str {
        match self.filter_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filter_text(&mut self) {
        self.filter_text.clear();
    }

    pub fn has_filter_text(&self) -> bool {
        self.filter_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_text(&mut self, v: ::std::string::String) {
        self.filter_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter_text(&mut self) -> &mut ::std::string::String {
        if self.filter_text.is_none() {
            self.filter_text.set_default();
        }
        self.filter_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter_text(&mut self) -> ::std::string::String {
        self.filter_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_servers = 5;

    pub fn get_max_servers(&self) -> u32 {
        self.max_servers.unwrap_or(0)
    }

    pub fn clear_max_servers(&mut self) {
        self.max_servers = ::std::option::Option::None;
    }

    pub fn has_max_servers(&self) -> bool {
        self.max_servers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_servers(&mut self, v: u32) {
        self.max_servers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGMSServerQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.geo_location_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.region_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filter_text)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.max_servers = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.geo_location_ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.region_code {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_text.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.max_servers {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.geo_location_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.region_code {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filter_text.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.max_servers {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGMSServerQuery {
        CMsgClientGMSServerQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgClientGMSServerQuery| { &m.app_id },
                |m: &mut CMsgClientGMSServerQuery| { &mut m.app_id },
                CMsgClientGMSServerQuery::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "geo_location_ip",
                |m: &CMsgClientGMSServerQuery| { &m.geo_location_ip },
                |m: &mut CMsgClientGMSServerQuery| { &mut m.geo_location_ip },
                CMsgClientGMSServerQuery::get_geo_location_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "region_code",
                |m: &CMsgClientGMSServerQuery| { &m.region_code },
                |m: &mut CMsgClientGMSServerQuery| { &mut m.region_code },
                CMsgClientGMSServerQuery::get_region_code,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filter_text",
                |m: &CMsgClientGMSServerQuery| { &m.filter_text },
                |m: &mut CMsgClientGMSServerQuery| { &mut m.filter_text },
                CMsgClientGMSServerQuery::get_filter_text,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "max_servers",
                |m: &CMsgClientGMSServerQuery| { &m.max_servers },
                |m: &mut CMsgClientGMSServerQuery| { &mut m.max_servers },
                CMsgClientGMSServerQuery::get_max_servers,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGMSServerQuery>(
                "CMsgClientGMSServerQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGMSServerQuery {
        static instance: ::protobuf::rt::Lazy<CMsgClientGMSServerQuery> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGMSServerQuery::new)
    }
}

impl ::protobuf::Clear for CMsgClientGMSServerQuery {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.geo_location_ip = ::std::option::Option::None;
        self.region_code = ::std::option::Option::None;
        self.filter_text.clear();
        self.max_servers = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGMSServerQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGMSServerQuery {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGMSClientServerQueryResponse {
    // message fields
    pub servers: ::protobuf::RepeatedField<cmsg_gmsclient_server_query_response::Server>,
    error: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGMSClientServerQueryResponse {
    fn default() -> &'a CMsgGMSClientServerQueryResponse {
        <CMsgGMSClientServerQueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGMSClientServerQueryResponse {
    pub fn new() -> CMsgGMSClientServerQueryResponse {
        ::std::default::Default::default()
    }

    // optional string error = 2;

    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGMSClientServerQueryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.servers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.error.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGMSClientServerQueryResponse {
        CMsgGMSClientServerQueryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_gmsclient_server_query_response::Server>>(
                "servers",
                |m: &CMsgGMSClientServerQueryResponse| { &m.servers },
                |m: &mut CMsgGMSClientServerQueryResponse| { &mut m.servers },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "error",
                |m: &CMsgGMSClientServerQueryResponse| { &m.error },
                |m: &mut CMsgGMSClientServerQueryResponse| { &mut m.error },
                CMsgGMSClientServerQueryResponse::get_error,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGMSClientServerQueryResponse>(
                "CMsgGMSClientServerQueryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGMSClientServerQueryResponse {
        static instance: ::protobuf::rt::Lazy<CMsgGMSClientServerQueryResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGMSClientServerQueryResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGMSClientServerQueryResponse {
    fn clear(&mut self) {
        self.servers.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGMSClientServerQueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGMSClientServerQueryResponse {
}

/// Nested message and enums of message `CMsgGMSClientServerQueryResponse`
pub mod cmsg_gmsclient_server_query_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Server {
        // message fields
        deprecated_server_ip: ::std::option::Option<u32>,
        server_port: ::std::option::Option<u32>,
        auth_players: ::std::option::Option<u32>,
        pub server_ip: ::protobuf::SingularPtrField<super::super::steammessages_base::CMsgIPAddress>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Server {
        fn default() -> &'a Server {
            <Server as ::protobuf::Message>::default_instance()
        }
    }

    impl Server {
        pub fn new() -> Server {
            ::std::default::Default::default()
        }

        // optional uint32 deprecated_server_ip = 1;

        pub fn get_deprecated_server_ip(&self) -> u32 {
            self.deprecated_server_ip.unwrap_or(0)
        }

        pub fn clear_deprecated_server_ip(&mut self) {
            self.deprecated_server_ip = ::std::option::Option::None;
        }

        pub fn has_deprecated_server_ip(&self) -> bool {
            self.deprecated_server_ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_server_ip(&mut self, v: u32) {
            self.deprecated_server_ip = ::std::option::Option::Some(v);
        }

        // optional uint32 server_port = 2;

        pub fn get_server_port(&self) -> u32 {
            self.server_port.unwrap_or(0)
        }

        pub fn clear_server_port(&mut self) {
            self.server_port = ::std::option::Option::None;
        }

        pub fn has_server_port(&self) -> bool {
            self.server_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_port(&mut self, v: u32) {
            self.server_port = ::std::option::Option::Some(v);
        }

        // optional uint32 auth_players = 3;

        pub fn get_auth_players(&self) -> u32 {
            self.auth_players.unwrap_or(0)
        }

        pub fn clear_auth_players(&mut self) {
            self.auth_players = ::std::option::Option::None;
        }

        pub fn has_auth_players(&self) -> bool {
            self.auth_players.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_players(&mut self, v: u32) {
            self.auth_players = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Server {
        fn is_initialized(&self) -> bool {
            for v in &self.server_ip {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.deprecated_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.auth_players = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        ::protobuf::rt::read_singular_message_into::<super::super::steammessages_base::CMsgIPAddress, _>(wire_type, is, &mut self.server_ip)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.deprecated_server_ip {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.server_port {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.auth_players {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.server_ip.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.deprecated_server_ip {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.server_port {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.auth_players {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.server_ip.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Server {
            Server::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "deprecated_server_ip",
                    |m: &Server| { &m.deprecated_server_ip },
                    |m: &mut Server| { &mut m.deprecated_server_ip },
                    Server::get_deprecated_server_ip,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "server_port",
                    |m: &Server| { &m.server_port },
                    |m: &mut Server| { &mut m.server_port },
                    Server::get_server_port,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "auth_players",
                    |m: &Server| { &m.auth_players },
                    |m: &mut Server| { &mut m.auth_players },
                    Server::get_auth_players,
                ));
                fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<super::super::steammessages_base::CMsgIPAddress>, _>(
                    "server_ip",
                    |m: &Server| { &m.server_ip },
                    |m: &mut Server| { &mut m.server_ip },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Server>(
                    "CMsgGMSClientServerQueryResponse.Server",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Server {
            static instance: ::protobuf::rt::Lazy<Server> = ::protobuf::rt::Lazy::INIT;
            instance.get(Server::new)
        }
    }

    impl ::protobuf::Clear for Server {
        fn clear(&mut self) {
            self.deprecated_server_ip = ::std::option::Option::None;
            self.server_port = ::std::option::Option::None;
            self.auth_players = ::std::option::Option::None;
            self.server_ip.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Server {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Server {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerOutOfDate {
    // message fields
    steam_id_gs: ::std::option::Option<u64>,
    reject: ::std::option::Option<bool>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerOutOfDate {
    fn default() -> &'a CMsgGameServerOutOfDate {
        <CMsgGameServerOutOfDate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerOutOfDate {
    pub fn new() -> CMsgGameServerOutOfDate {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_gs = 1;

    pub fn get_steam_id_gs(&self) -> u64 {
        self.steam_id_gs.unwrap_or(0)
    }

    pub fn clear_steam_id_gs(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_steam_id_gs(&self) -> bool {
        self.steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_gs(&mut self, v: u64) {
        self.steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional bool reject = 2;

    pub fn get_reject(&self) -> bool {
        self.reject.unwrap_or(false)
    }

    pub fn clear_reject(&mut self) {
        self.reject = ::std::option::Option::None;
    }

    pub fn has_reject(&self) -> bool {
        self.reject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reject(&mut self, v: bool) {
        self.reject = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGameServerOutOfDate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_gs = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reject = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_gs {
            my_size += 9;
        }
        if let Some(v) = self.reject {
            my_size += 2;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.reject {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerOutOfDate {
        CMsgGameServerOutOfDate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_gs",
                |m: &CMsgGameServerOutOfDate| { &m.steam_id_gs },
                |m: &mut CMsgGameServerOutOfDate| { &mut m.steam_id_gs },
                CMsgGameServerOutOfDate::get_steam_id_gs,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "reject",
                |m: &CMsgGameServerOutOfDate| { &m.reject },
                |m: &mut CMsgGameServerOutOfDate| { &mut m.reject },
                CMsgGameServerOutOfDate::get_reject,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "message",
                |m: &CMsgGameServerOutOfDate| { &m.message },
                |m: &mut CMsgGameServerOutOfDate| { &mut m.message },
                CMsgGameServerOutOfDate::get_message,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGameServerOutOfDate>(
                "CMsgGameServerOutOfDate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerOutOfDate {
        static instance: ::protobuf::rt::Lazy<CMsgGameServerOutOfDate> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGameServerOutOfDate::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerOutOfDate {
    fn clear(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
        self.reject = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerOutOfDate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerOutOfDate {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRedeemGuestPass {
    // message fields
    guest_pass_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRedeemGuestPass {
    fn default() -> &'a CMsgClientRedeemGuestPass {
        <CMsgClientRedeemGuestPass as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRedeemGuestPass {
    pub fn new() -> CMsgClientRedeemGuestPass {
        ::std::default::Default::default()
    }

    // optional fixed64 guest_pass_id = 1;

    pub fn get_guest_pass_id(&self) -> u64 {
        self.guest_pass_id.unwrap_or(0)
    }

    pub fn clear_guest_pass_id(&mut self) {
        self.guest_pass_id = ::std::option::Option::None;
    }

    pub fn has_guest_pass_id(&self) -> bool {
        self.guest_pass_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guest_pass_id(&mut self, v: u64) {
        self.guest_pass_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRedeemGuestPass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.guest_pass_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.guest_pass_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.guest_pass_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRedeemGuestPass {
        CMsgClientRedeemGuestPass::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "guest_pass_id",
                |m: &CMsgClientRedeemGuestPass| { &m.guest_pass_id },
                |m: &mut CMsgClientRedeemGuestPass| { &mut m.guest_pass_id },
                CMsgClientRedeemGuestPass::get_guest_pass_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRedeemGuestPass>(
                "CMsgClientRedeemGuestPass",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRedeemGuestPass {
        static instance: ::protobuf::rt::Lazy<CMsgClientRedeemGuestPass> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRedeemGuestPass::new)
    }
}

impl ::protobuf::Clear for CMsgClientRedeemGuestPass {
    fn clear(&mut self) {
        self.guest_pass_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRedeemGuestPass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRedeemGuestPass {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRedeemGuestPassResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    package_id: ::std::option::Option<u32>,
    must_own_appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRedeemGuestPassResponse {
    fn default() -> &'a CMsgClientRedeemGuestPassResponse {
        <CMsgClientRedeemGuestPassResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRedeemGuestPassResponse {
    pub fn new() -> CMsgClientRedeemGuestPassResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 package_id = 2;

    pub fn get_package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }

    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional uint32 must_own_appid = 3;

    pub fn get_must_own_appid(&self) -> u32 {
        self.must_own_appid.unwrap_or(0)
    }

    pub fn clear_must_own_appid(&mut self) {
        self.must_own_appid = ::std::option::Option::None;
    }

    pub fn has_must_own_appid(&self) -> bool {
        self.must_own_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_own_appid(&mut self, v: u32) {
        self.must_own_appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRedeemGuestPassResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.must_own_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.package_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.must_own_appid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.package_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.must_own_appid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRedeemGuestPassResponse {
        CMsgClientRedeemGuestPassResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientRedeemGuestPassResponse| { &m.eresult },
                |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.eresult },
                CMsgClientRedeemGuestPassResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "package_id",
                |m: &CMsgClientRedeemGuestPassResponse| { &m.package_id },
                |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.package_id },
                CMsgClientRedeemGuestPassResponse::get_package_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "must_own_appid",
                |m: &CMsgClientRedeemGuestPassResponse| { &m.must_own_appid },
                |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.must_own_appid },
                CMsgClientRedeemGuestPassResponse::get_must_own_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRedeemGuestPassResponse>(
                "CMsgClientRedeemGuestPassResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRedeemGuestPassResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientRedeemGuestPassResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRedeemGuestPassResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRedeemGuestPassResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.package_id = ::std::option::Option::None;
        self.must_own_appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRedeemGuestPassResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRedeemGuestPassResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClanActivityCounts {
    // message fields
    pub steamid_clans: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClanActivityCounts {
    fn default() -> &'a CMsgClientGetClanActivityCounts {
        <CMsgClientGetClanActivityCounts as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClanActivityCounts {
    pub fn new() -> CMsgClientGetClanActivityCounts {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetClanActivityCounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.steamid_clans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.steamid_clans {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.steamid_clans {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClanActivityCounts {
        CMsgClientGetClanActivityCounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64>(
                "steamid_clans",
                |m: &CMsgClientGetClanActivityCounts| { &m.steamid_clans },
                |m: &mut CMsgClientGetClanActivityCounts| { &mut m.steamid_clans },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClanActivityCounts>(
                "CMsgClientGetClanActivityCounts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClanActivityCounts {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetClanActivityCounts> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetClanActivityCounts::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClanActivityCounts {
    fn clear(&mut self) {
        self.steamid_clans.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClanActivityCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClanActivityCounts {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClanActivityCountsResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClanActivityCountsResponse {
    fn default() -> &'a CMsgClientGetClanActivityCountsResponse {
        <CMsgClientGetClanActivityCountsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClanActivityCountsResponse {
    pub fn new() -> CMsgClientGetClanActivityCountsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClanActivityCountsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClanActivityCountsResponse {
        CMsgClientGetClanActivityCountsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientGetClanActivityCountsResponse| { &m.eresult },
                |m: &mut CMsgClientGetClanActivityCountsResponse| { &mut m.eresult },
                CMsgClientGetClanActivityCountsResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClanActivityCountsResponse>(
                "CMsgClientGetClanActivityCountsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClanActivityCountsResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetClanActivityCountsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetClanActivityCountsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClanActivityCountsResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClanActivityCountsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClanActivityCountsResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientOGSReportString {
    // message fields
    accumulated: ::std::option::Option<bool>,
    sessionid: ::std::option::Option<u64>,
    severity: ::std::option::Option<i32>,
    formatter: ::protobuf::SingularField<::std::string::String>,
    varargs: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientOGSReportString {
    fn default() -> &'a CMsgClientOGSReportString {
        <CMsgClientOGSReportString as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOGSReportString {
    pub fn new() -> CMsgClientOGSReportString {
        ::std::default::Default::default()
    }

    // optional bool accumulated = 1;

    pub fn get_accumulated(&self) -> bool {
        self.accumulated.unwrap_or(false)
    }

    pub fn clear_accumulated(&mut self) {
        self.accumulated = ::std::option::Option::None;
    }

    pub fn has_accumulated(&self) -> bool {
        self.accumulated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accumulated(&mut self, v: bool) {
        self.accumulated = ::std::option::Option::Some(v);
    }

    // optional uint64 sessionid = 2;

    pub fn get_sessionid(&self) -> u64 {
        self.sessionid.unwrap_or(0)
    }

    pub fn clear_sessionid(&mut self) {
        self.sessionid = ::std::option::Option::None;
    }

    pub fn has_sessionid(&self) -> bool {
        self.sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionid(&mut self, v: u64) {
        self.sessionid = ::std::option::Option::Some(v);
    }

    // optional int32 severity = 3;

    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0)
    }

    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional string formatter = 4;

    pub fn get_formatter(&self) -> &str {
        match self.formatter.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_formatter(&mut self) {
        self.formatter.clear();
    }

    pub fn has_formatter(&self) -> bool {
        self.formatter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_formatter(&mut self, v: ::std::string::String) {
        self.formatter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_formatter(&mut self) -> &mut ::std::string::String {
        if self.formatter.is_none() {
            self.formatter.set_default();
        }
        self.formatter.as_mut().unwrap()
    }

    // Take field
    pub fn take_formatter(&mut self) -> ::std::string::String {
        self.formatter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes varargs = 5;

    pub fn get_varargs(&self) -> &[u8] {
        match self.varargs.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_varargs(&mut self) {
        self.varargs.clear();
    }

    pub fn has_varargs(&self) -> bool {
        self.varargs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_varargs(&mut self, v: ::std::vec::Vec<u8>) {
        self.varargs = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_varargs(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.varargs.is_none() {
            self.varargs.set_default();
        }
        self.varargs.as_mut().unwrap()
    }

    // Take field
    pub fn take_varargs(&mut self) -> ::std::vec::Vec<u8> {
        self.varargs.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientOGSReportString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.accumulated = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sessionid = ::std::option::Option::Some(is.read_uint64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.severity = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formatter)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.varargs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accumulated {
            my_size += 2;
        }
        if let Some(v) = self.sessionid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.formatter.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.varargs.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accumulated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.sessionid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.formatter.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.varargs.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientOGSReportString {
        CMsgClientOGSReportString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "accumulated",
                |m: &CMsgClientOGSReportString| { &m.accumulated },
                |m: &mut CMsgClientOGSReportString| { &mut m.accumulated },
                CMsgClientOGSReportString::get_accumulated,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "sessionid",
                |m: &CMsgClientOGSReportString| { &m.sessionid },
                |m: &mut CMsgClientOGSReportString| { &mut m.sessionid },
                CMsgClientOGSReportString::get_sessionid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "severity",
                |m: &CMsgClientOGSReportString| { &m.severity },
                |m: &mut CMsgClientOGSReportString| { &mut m.severity },
                CMsgClientOGSReportString::get_severity,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "formatter",
                |m: &CMsgClientOGSReportString| { &m.formatter },
                |m: &mut CMsgClientOGSReportString| { &mut m.formatter },
                CMsgClientOGSReportString::get_formatter,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "varargs",
                |m: &CMsgClientOGSReportString| { &m.varargs },
                |m: &mut CMsgClientOGSReportString| { &mut m.varargs },
                CMsgClientOGSReportString::get_varargs,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientOGSReportString>(
                "CMsgClientOGSReportString",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientOGSReportString {
        static instance: ::protobuf::rt::Lazy<CMsgClientOGSReportString> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientOGSReportString::new)
    }
}

impl ::protobuf::Clear for CMsgClientOGSReportString {
    fn clear(&mut self) {
        self.accumulated = ::std::option::Option::None;
        self.sessionid = ::std::option::Option::None;
        self.severity = ::std::option::Option::None;
        self.formatter.clear();
        self.varargs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientOGSReportString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientOGSReportString {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientOGSReportBug {
    // message fields
    sessionid: ::std::option::Option<u64>,
    bugtext: ::protobuf::SingularField<::std::string::String>,
    screenshot: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientOGSReportBug {
    fn default() -> &'a CMsgClientOGSReportBug {
        <CMsgClientOGSReportBug as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOGSReportBug {
    pub fn new() -> CMsgClientOGSReportBug {
        ::std::default::Default::default()
    }

    // optional uint64 sessionid = 1;

    pub fn get_sessionid(&self) -> u64 {
        self.sessionid.unwrap_or(0)
    }

    pub fn clear_sessionid(&mut self) {
        self.sessionid = ::std::option::Option::None;
    }

    pub fn has_sessionid(&self) -> bool {
        self.sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionid(&mut self, v: u64) {
        self.sessionid = ::std::option::Option::Some(v);
    }

    // optional string bugtext = 2;

    pub fn get_bugtext(&self) -> &str {
        match self.bugtext.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bugtext(&mut self) {
        self.bugtext.clear();
    }

    pub fn has_bugtext(&self) -> bool {
        self.bugtext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bugtext(&mut self, v: ::std::string::String) {
        self.bugtext = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bugtext(&mut self) -> &mut ::std::string::String {
        if self.bugtext.is_none() {
            self.bugtext.set_default();
        }
        self.bugtext.as_mut().unwrap()
    }

    // Take field
    pub fn take_bugtext(&mut self) -> ::std::string::String {
        self.bugtext.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes screenshot = 3;

    pub fn get_screenshot(&self) -> &[u8] {
        match self.screenshot.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_screenshot(&mut self) {
        self.screenshot.clear();
    }

    pub fn has_screenshot(&self) -> bool {
        self.screenshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screenshot.is_none() {
            self.screenshot.set_default();
        }
        self.screenshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenshot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientOGSReportBug {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sessionid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bugtext)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.screenshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sessionid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bugtext.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.screenshot.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sessionid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.bugtext.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.screenshot.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientOGSReportBug {
        CMsgClientOGSReportBug::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "sessionid",
                |m: &CMsgClientOGSReportBug| { &m.sessionid },
                |m: &mut CMsgClientOGSReportBug| { &mut m.sessionid },
                CMsgClientOGSReportBug::get_sessionid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "bugtext",
                |m: &CMsgClientOGSReportBug| { &m.bugtext },
                |m: &mut CMsgClientOGSReportBug| { &mut m.bugtext },
                CMsgClientOGSReportBug::get_bugtext,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "screenshot",
                |m: &CMsgClientOGSReportBug| { &m.screenshot },
                |m: &mut CMsgClientOGSReportBug| { &mut m.screenshot },
                CMsgClientOGSReportBug::get_screenshot,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientOGSReportBug>(
                "CMsgClientOGSReportBug",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientOGSReportBug {
        static instance: ::protobuf::rt::Lazy<CMsgClientOGSReportBug> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientOGSReportBug::new)
    }
}

impl ::protobuf::Clear for CMsgClientOGSReportBug {
    fn clear(&mut self) {
        self.sessionid = ::std::option::Option::None;
        self.bugtext.clear();
        self.screenshot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientOGSReportBug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientOGSReportBug {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSAssociateWithClan {
    // message fields
    steam_id_clan: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSAssociateWithClan {
    fn default() -> &'a CMsgGSAssociateWithClan {
        <CMsgGSAssociateWithClan as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSAssociateWithClan {
    pub fn new() -> CMsgGSAssociateWithClan {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_clan = 1;

    pub fn get_steam_id_clan(&self) -> u64 {
        self.steam_id_clan.unwrap_or(0)
    }

    pub fn clear_steam_id_clan(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
    }

    pub fn has_steam_id_clan(&self) -> bool {
        self.steam_id_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_clan(&mut self, v: u64) {
        self.steam_id_clan = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSAssociateWithClan {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_clan {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_clan {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSAssociateWithClan {
        CMsgGSAssociateWithClan::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_clan",
                |m: &CMsgGSAssociateWithClan| { &m.steam_id_clan },
                |m: &mut CMsgGSAssociateWithClan| { &mut m.steam_id_clan },
                CMsgGSAssociateWithClan::get_steam_id_clan,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSAssociateWithClan>(
                "CMsgGSAssociateWithClan",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSAssociateWithClan {
        static instance: ::protobuf::rt::Lazy<CMsgGSAssociateWithClan> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSAssociateWithClan::new)
    }
}

impl ::protobuf::Clear for CMsgGSAssociateWithClan {
    fn clear(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSAssociateWithClan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSAssociateWithClan {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSAssociateWithClanResponse {
    // message fields
    steam_id_clan: ::std::option::Option<u64>,
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSAssociateWithClanResponse {
    fn default() -> &'a CMsgGSAssociateWithClanResponse {
        <CMsgGSAssociateWithClanResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSAssociateWithClanResponse {
    pub fn new() -> CMsgGSAssociateWithClanResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_clan = 1;

    pub fn get_steam_id_clan(&self) -> u64 {
        self.steam_id_clan.unwrap_or(0)
    }

    pub fn clear_steam_id_clan(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
    }

    pub fn has_steam_id_clan(&self) -> bool {
        self.steam_id_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_clan(&mut self, v: u64) {
        self.steam_id_clan = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSAssociateWithClanResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_clan {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_clan {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSAssociateWithClanResponse {
        CMsgGSAssociateWithClanResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_clan",
                |m: &CMsgGSAssociateWithClanResponse| { &m.steam_id_clan },
                |m: &mut CMsgGSAssociateWithClanResponse| { &mut m.steam_id_clan },
                CMsgGSAssociateWithClanResponse::get_steam_id_clan,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgGSAssociateWithClanResponse| { &m.eresult },
                |m: &mut CMsgGSAssociateWithClanResponse| { &mut m.eresult },
                CMsgGSAssociateWithClanResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSAssociateWithClanResponse>(
                "CMsgGSAssociateWithClanResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSAssociateWithClanResponse {
        static instance: ::protobuf::rt::Lazy<CMsgGSAssociateWithClanResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSAssociateWithClanResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGSAssociateWithClanResponse {
    fn clear(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSAssociateWithClanResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSAssociateWithClanResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSComputeNewPlayerCompatibility {
    // message fields
    steam_id_candidate: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSComputeNewPlayerCompatibility {
    fn default() -> &'a CMsgGSComputeNewPlayerCompatibility {
        <CMsgGSComputeNewPlayerCompatibility as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSComputeNewPlayerCompatibility {
    pub fn new() -> CMsgGSComputeNewPlayerCompatibility {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_candidate = 1;

    pub fn get_steam_id_candidate(&self) -> u64 {
        self.steam_id_candidate.unwrap_or(0)
    }

    pub fn clear_steam_id_candidate(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
    }

    pub fn has_steam_id_candidate(&self) -> bool {
        self.steam_id_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_candidate(&mut self, v: u64) {
        self.steam_id_candidate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSComputeNewPlayerCompatibility {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_candidate = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_candidate {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_candidate {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSComputeNewPlayerCompatibility {
        CMsgGSComputeNewPlayerCompatibility::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_candidate",
                |m: &CMsgGSComputeNewPlayerCompatibility| { &m.steam_id_candidate },
                |m: &mut CMsgGSComputeNewPlayerCompatibility| { &mut m.steam_id_candidate },
                CMsgGSComputeNewPlayerCompatibility::get_steam_id_candidate,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSComputeNewPlayerCompatibility>(
                "CMsgGSComputeNewPlayerCompatibility",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSComputeNewPlayerCompatibility {
        static instance: ::protobuf::rt::Lazy<CMsgGSComputeNewPlayerCompatibility> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSComputeNewPlayerCompatibility::new)
    }
}

impl ::protobuf::Clear for CMsgGSComputeNewPlayerCompatibility {
    fn clear(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSComputeNewPlayerCompatibility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSComputeNewPlayerCompatibility {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSComputeNewPlayerCompatibilityResponse {
    // message fields
    steam_id_candidate: ::std::option::Option<u64>,
    eresult: ::std::option::Option<u32>,
    is_clan_member: ::std::option::Option<bool>,
    ct_dont_like_you: ::std::option::Option<i32>,
    ct_you_dont_like: ::std::option::Option<i32>,
    ct_clanmembers_dont_like_you: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSComputeNewPlayerCompatibilityResponse {
    fn default() -> &'a CMsgGSComputeNewPlayerCompatibilityResponse {
        <CMsgGSComputeNewPlayerCompatibilityResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSComputeNewPlayerCompatibilityResponse {
    pub fn new() -> CMsgGSComputeNewPlayerCompatibilityResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_candidate = 1;

    pub fn get_steam_id_candidate(&self) -> u64 {
        self.steam_id_candidate.unwrap_or(0)
    }

    pub fn clear_steam_id_candidate(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
    }

    pub fn has_steam_id_candidate(&self) -> bool {
        self.steam_id_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_candidate(&mut self, v: u64) {
        self.steam_id_candidate = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool is_clan_member = 3;

    pub fn get_is_clan_member(&self) -> bool {
        self.is_clan_member.unwrap_or(false)
    }

    pub fn clear_is_clan_member(&mut self) {
        self.is_clan_member = ::std::option::Option::None;
    }

    pub fn has_is_clan_member(&self) -> bool {
        self.is_clan_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_clan_member(&mut self, v: bool) {
        self.is_clan_member = ::std::option::Option::Some(v);
    }

    // optional int32 ct_dont_like_you = 4;

    pub fn get_ct_dont_like_you(&self) -> i32 {
        self.ct_dont_like_you.unwrap_or(0)
    }

    pub fn clear_ct_dont_like_you(&mut self) {
        self.ct_dont_like_you = ::std::option::Option::None;
    }

    pub fn has_ct_dont_like_you(&self) -> bool {
        self.ct_dont_like_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_dont_like_you(&mut self, v: i32) {
        self.ct_dont_like_you = ::std::option::Option::Some(v);
    }

    // optional int32 ct_you_dont_like = 5;

    pub fn get_ct_you_dont_like(&self) -> i32 {
        self.ct_you_dont_like.unwrap_or(0)
    }

    pub fn clear_ct_you_dont_like(&mut self) {
        self.ct_you_dont_like = ::std::option::Option::None;
    }

    pub fn has_ct_you_dont_like(&self) -> bool {
        self.ct_you_dont_like.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_you_dont_like(&mut self, v: i32) {
        self.ct_you_dont_like = ::std::option::Option::Some(v);
    }

    // optional int32 ct_clanmembers_dont_like_you = 6;

    pub fn get_ct_clanmembers_dont_like_you(&self) -> i32 {
        self.ct_clanmembers_dont_like_you.unwrap_or(0)
    }

    pub fn clear_ct_clanmembers_dont_like_you(&mut self) {
        self.ct_clanmembers_dont_like_you = ::std::option::Option::None;
    }

    pub fn has_ct_clanmembers_dont_like_you(&self) -> bool {
        self.ct_clanmembers_dont_like_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_clanmembers_dont_like_you(&mut self, v: i32) {
        self.ct_clanmembers_dont_like_you = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id_candidate = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_clan_member = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ct_dont_like_you = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ct_you_dont_like = ::std::option::Option::Some(is.read_int32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ct_clanmembers_dont_like_you = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_candidate {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_clan_member {
            my_size += 2;
        }
        if let Some(v) = self.ct_dont_like_you {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ct_you_dont_like {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ct_clanmembers_dont_like_you {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_candidate {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_clan_member {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ct_dont_like_you {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.ct_you_dont_like {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.ct_clanmembers_dont_like_you {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSComputeNewPlayerCompatibilityResponse {
        CMsgGSComputeNewPlayerCompatibilityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id_candidate",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.steam_id_candidate },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.steam_id_candidate },
                CMsgGSComputeNewPlayerCompatibilityResponse::get_steam_id_candidate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.eresult },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.eresult },
                CMsgGSComputeNewPlayerCompatibilityResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_clan_member",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.is_clan_member },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.is_clan_member },
                CMsgGSComputeNewPlayerCompatibilityResponse::get_is_clan_member,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "ct_dont_like_you",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_dont_like_you },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_dont_like_you },
                CMsgGSComputeNewPlayerCompatibilityResponse::get_ct_dont_like_you,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "ct_you_dont_like",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_you_dont_like },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_you_dont_like },
                CMsgGSComputeNewPlayerCompatibilityResponse::get_ct_you_dont_like,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "ct_clanmembers_dont_like_you",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_clanmembers_dont_like_you },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_clanmembers_dont_like_you },
                CMsgGSComputeNewPlayerCompatibilityResponse::get_ct_clanmembers_dont_like_you,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGSComputeNewPlayerCompatibilityResponse>(
                "CMsgGSComputeNewPlayerCompatibilityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSComputeNewPlayerCompatibilityResponse {
        static instance: ::protobuf::rt::Lazy<CMsgGSComputeNewPlayerCompatibilityResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGSComputeNewPlayerCompatibilityResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn clear(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.is_clan_member = ::std::option::Option::None;
        self.ct_dont_like_you = ::std::option::Option::None;
        self.ct_you_dont_like = ::std::option::Option::None;
        self.ct_clanmembers_dont_like_you = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSComputeNewPlayerCompatibilityResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSentLogs {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSentLogs {
    fn default() -> &'a CMsgClientSentLogs {
        <CMsgClientSentLogs as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSentLogs {
    pub fn new() -> CMsgClientSentLogs {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientSentLogs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSentLogs {
        CMsgClientSentLogs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSentLogs>(
                "CMsgClientSentLogs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSentLogs {
        static instance: ::protobuf::rt::Lazy<CMsgClientSentLogs> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientSentLogs::new)
    }
}

impl ::protobuf::Clear for CMsgClientSentLogs {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSentLogs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSentLogs {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCClient {
    // message fields
    appid: ::std::option::Option<u32>,
    msgtype: ::std::option::Option<u32>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    steamid: ::std::option::Option<u64>,
    gcname: ::protobuf::SingularField<::std::string::String>,
    ip: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCClient {
    fn default() -> &'a CMsgGCClient {
        <CMsgGCClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClient {
    pub fn new() -> CMsgGCClient {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 msgtype = 2;

    pub fn get_msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 3;

    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 steamid = 4;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string gcname = 5;

    pub fn get_gcname(&self) -> &str {
        match self.gcname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gcname(&mut self) {
        self.gcname.clear();
    }

    pub fn has_gcname(&self) -> bool {
        self.gcname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcname(&mut self, v: ::std::string::String) {
        self.gcname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcname(&mut self) -> &mut ::std::string::String {
        if self.gcname.is_none() {
            self.gcname.set_default();
        }
        self.gcname.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcname(&mut self) -> ::std::string::String {
        self.gcname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ip = 6;

    pub fn get_ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gcname)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msgtype {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.gcname.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.msgtype {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.gcname.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCClient {
        CMsgGCClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CMsgGCClient| { &m.appid },
                |m: &mut CMsgGCClient| { &mut m.appid },
                CMsgGCClient::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "msgtype",
                |m: &CMsgGCClient| { &m.msgtype },
                |m: &mut CMsgGCClient| { &mut m.msgtype },
                CMsgGCClient::get_msgtype,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "payload",
                |m: &CMsgGCClient| { &m.payload },
                |m: &mut CMsgGCClient| { &mut m.payload },
                CMsgGCClient::get_payload,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CMsgGCClient| { &m.steamid },
                |m: &mut CMsgGCClient| { &mut m.steamid },
                CMsgGCClient::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "gcname",
                |m: &CMsgGCClient| { &m.gcname },
                |m: &mut CMsgGCClient| { &mut m.gcname },
                CMsgGCClient::get_gcname,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "ip",
                |m: &CMsgGCClient| { &m.ip },
                |m: &mut CMsgGCClient| { &mut m.ip },
                CMsgGCClient::get_ip,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGCClient>(
                "CMsgGCClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCClient {
        static instance: ::protobuf::rt::Lazy<CMsgGCClient> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGCClient::new)
    }
}

impl ::protobuf::Clear for CMsgGCClient {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.msgtype = ::std::option::Option::None;
        self.payload.clear();
        self.steamid = ::std::option::Option::None;
        self.gcname.clear();
        self.ip = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClient {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestFreeLicense {
    // message fields
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFreeLicense {
    fn default() -> &'a CMsgClientRequestFreeLicense {
        <CMsgClientRequestFreeLicense as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFreeLicense {
    pub fn new() -> CMsgClientRequestFreeLicense {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestFreeLicense {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestFreeLicense {
        CMsgClientRequestFreeLicense::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "appids",
                |m: &CMsgClientRequestFreeLicense| { &m.appids },
                |m: &mut CMsgClientRequestFreeLicense| { &mut m.appids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestFreeLicense>(
                "CMsgClientRequestFreeLicense",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestFreeLicense {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestFreeLicense> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestFreeLicense::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestFreeLicense {
    fn clear(&mut self) {
        self.appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestFreeLicense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestFreeLicense {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestFreeLicenseResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    pub granted_packageids: ::std::vec::Vec<u32>,
    pub granted_appids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFreeLicenseResponse {
    fn default() -> &'a CMsgClientRequestFreeLicenseResponse {
        <CMsgClientRequestFreeLicenseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFreeLicenseResponse {
    pub fn new() -> CMsgClientRequestFreeLicenseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestFreeLicenseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.granted_packageids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.granted_appids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.granted_packageids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.granted_appids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        for v in &self.granted_packageids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.granted_appids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestFreeLicenseResponse {
        CMsgClientRequestFreeLicenseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgClientRequestFreeLicenseResponse| { &m.eresult },
                |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.eresult },
                CMsgClientRequestFreeLicenseResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "granted_packageids",
                |m: &CMsgClientRequestFreeLicenseResponse| { &m.granted_packageids },
                |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.granted_packageids },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "granted_appids",
                |m: &CMsgClientRequestFreeLicenseResponse| { &m.granted_appids },
                |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.granted_appids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestFreeLicenseResponse>(
                "CMsgClientRequestFreeLicenseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestFreeLicenseResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestFreeLicenseResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestFreeLicenseResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestFreeLicenseResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.granted_packageids.clear();
        self.granted_appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestFreeLicenseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestFreeLicenseResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDRMDownloadRequestWithCrashData {
    // message fields
    download_flags: ::std::option::Option<u32>,
    download_types_known: ::std::option::Option<u32>,
    guid_drm: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    guid_split: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    guid_merge: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    module_name: ::protobuf::SingularField<::std::string::String>,
    module_path: ::protobuf::SingularField<::std::string::String>,
    crash_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDRMDownloadRequestWithCrashData {
    fn default() -> &'a CMsgDRMDownloadRequestWithCrashData {
        <CMsgDRMDownloadRequestWithCrashData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMDownloadRequestWithCrashData {
    pub fn new() -> CMsgDRMDownloadRequestWithCrashData {
        ::std::default::Default::default()
    }

    // optional uint32 download_flags = 1;

    pub fn get_download_flags(&self) -> u32 {
        self.download_flags.unwrap_or(0)
    }

    pub fn clear_download_flags(&mut self) {
        self.download_flags = ::std::option::Option::None;
    }

    pub fn has_download_flags(&self) -> bool {
        self.download_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_flags(&mut self, v: u32) {
        self.download_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 download_types_known = 2;

    pub fn get_download_types_known(&self) -> u32 {
        self.download_types_known.unwrap_or(0)
    }

    pub fn clear_download_types_known(&mut self) {
        self.download_types_known = ::std::option::Option::None;
    }

    pub fn has_download_types_known(&self) -> bool {
        self.download_types_known.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_types_known(&mut self, v: u32) {
        self.download_types_known = ::std::option::Option::Some(v);
    }

    // optional bytes guid_drm = 3;

    pub fn get_guid_drm(&self) -> &[u8] {
        match self.guid_drm.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_drm(&mut self) {
        self.guid_drm.clear();
    }

    pub fn has_guid_drm(&self) -> bool {
        self.guid_drm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_drm(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_drm = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_drm(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_drm.is_none() {
            self.guid_drm.set_default();
        }
        self.guid_drm.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_drm(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_drm.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes guid_split = 4;

    pub fn get_guid_split(&self) -> &[u8] {
        match self.guid_split.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_split(&mut self) {
        self.guid_split.clear();
    }

    pub fn has_guid_split(&self) -> bool {
        self.guid_split.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_split(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_split = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_split(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_split.is_none() {
            self.guid_split.set_default();
        }
        self.guid_split.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_split(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_split.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes guid_merge = 5;

    pub fn get_guid_merge(&self) -> &[u8] {
        match self.guid_merge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_guid_merge(&mut self) {
        self.guid_merge.clear();
    }

    pub fn has_guid_merge(&self) -> bool {
        self.guid_merge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_merge(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_merge = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_merge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_merge.is_none() {
            self.guid_merge.set_default();
        }
        self.guid_merge.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_merge(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_merge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string module_name = 6;

    pub fn get_module_name(&self) -> &str {
        match self.module_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_name(&mut self) {
        self.module_name.clear();
    }

    pub fn has_module_name(&self) -> bool {
        self.module_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_name(&mut self, v: ::std::string::String) {
        self.module_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_name(&mut self) -> &mut ::std::string::String {
        if self.module_name.is_none() {
            self.module_name.set_default();
        }
        self.module_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_name(&mut self) -> ::std::string::String {
        self.module_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module_path = 7;

    pub fn get_module_path(&self) -> &str {
        match self.module_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_path(&mut self) {
        self.module_path.clear();
    }

    pub fn has_module_path(&self) -> bool {
        self.module_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_path(&mut self, v: ::std::string::String) {
        self.module_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_path(&mut self) -> &mut ::std::string::String {
        if self.module_path.is_none() {
            self.module_path.set_default();
        }
        self.module_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_path(&mut self) -> ::std::string::String {
        self.module_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes crash_data = 8;

    pub fn get_crash_data(&self) -> &[u8] {
        match self.crash_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_crash_data(&mut self) {
        self.crash_data.clear();
    }

    pub fn has_crash_data(&self) -> bool {
        self.crash_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crash_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.crash_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crash_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.crash_data.is_none() {
            self.crash_data.set_default();
        }
        self.crash_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_crash_data(&mut self) -> ::std::vec::Vec<u8> {
        self.crash_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgDRMDownloadRequestWithCrashData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.download_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.download_types_known = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.guid_drm)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.guid_split)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.guid_merge)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.module_name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.module_path)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.crash_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.download_flags {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.download_types_known {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.guid_drm.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.guid_split.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.guid_merge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.module_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.module_path.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.crash_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.download_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.download_types_known {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.guid_drm.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.guid_split.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.guid_merge.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.module_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.module_path.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.crash_data.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDRMDownloadRequestWithCrashData {
        CMsgDRMDownloadRequestWithCrashData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "download_flags",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.download_flags },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.download_flags },
                CMsgDRMDownloadRequestWithCrashData::get_download_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "download_types_known",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.download_types_known },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.download_types_known },
                CMsgDRMDownloadRequestWithCrashData::get_download_types_known,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "guid_drm",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_drm },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_drm },
                CMsgDRMDownloadRequestWithCrashData::get_guid_drm,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "guid_split",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_split },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_split },
                CMsgDRMDownloadRequestWithCrashData::get_guid_split,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "guid_merge",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_merge },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_merge },
                CMsgDRMDownloadRequestWithCrashData::get_guid_merge,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "module_name",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.module_name },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.module_name },
                CMsgDRMDownloadRequestWithCrashData::get_module_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "module_path",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.module_path },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.module_path },
                CMsgDRMDownloadRequestWithCrashData::get_module_path,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "crash_data",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.crash_data },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.crash_data },
                CMsgDRMDownloadRequestWithCrashData::get_crash_data,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgDRMDownloadRequestWithCrashData>(
                "CMsgDRMDownloadRequestWithCrashData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDRMDownloadRequestWithCrashData {
        static instance: ::protobuf::rt::Lazy<CMsgDRMDownloadRequestWithCrashData> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgDRMDownloadRequestWithCrashData::new)
    }
}

impl ::protobuf::Clear for CMsgDRMDownloadRequestWithCrashData {
    fn clear(&mut self) {
        self.download_flags = ::std::option::Option::None;
        self.download_types_known = ::std::option::Option::None;
        self.guid_drm.clear();
        self.guid_split.clear();
        self.guid_merge.clear();
        self.module_name.clear();
        self.module_path.clear();
        self.crash_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDRMDownloadRequestWithCrashData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDRMDownloadRequestWithCrashData {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDRMDownloadResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    blob_download_type: ::std::option::Option<u32>,
    merge_guid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    download_file_dfs_ip: ::std::option::Option<u32>,
    download_file_dfs_port: ::std::option::Option<u32>,
    download_file_url: ::protobuf::SingularField<::std::string::String>,
    module_path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDRMDownloadResponse {
    fn default() -> &'a CMsgDRMDownloadResponse {
        <CMsgDRMDownloadResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMDownloadResponse {
    pub fn new() -> CMsgDRMDownloadResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 blob_download_type = 3;

    pub fn get_blob_download_type(&self) -> u32 {
        self.blob_download_type.unwrap_or(0)
    }

    pub fn clear_blob_download_type(&mut self) {
        self.blob_download_type = ::std::option::Option::None;
    }

    pub fn has_blob_download_type(&self) -> bool {
        self.blob_download_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_download_type(&mut self, v: u32) {
        self.blob_download_type = ::std::option::Option::Some(v);
    }

    // optional bytes merge_guid = 4;

    pub fn get_merge_guid(&self) -> &[u8] {
        match self.merge_guid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_merge_guid(&mut self) {
        self.merge_guid.clear();
    }

    pub fn has_merge_guid(&self) -> bool {
        self.merge_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_guid(&mut self, v: ::std::vec::Vec<u8>) {
        self.merge_guid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_guid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.merge_guid.is_none() {
            self.merge_guid.set_default();
        }
        self.merge_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_guid(&mut self) -> ::std::vec::Vec<u8> {
        self.merge_guid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 download_file_dfs_ip = 5;

    pub fn get_download_file_dfs_ip(&self) -> u32 {
        self.download_file_dfs_ip.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_ip(&mut self) {
        self.download_file_dfs_ip = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_ip(&self) -> bool {
        self.download_file_dfs_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_ip(&mut self, v: u32) {
        self.download_file_dfs_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 download_file_dfs_port = 6;

    pub fn get_download_file_dfs_port(&self) -> u32 {
        self.download_file_dfs_port.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_port(&mut self) {
        self.download_file_dfs_port = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_port(&self) -> bool {
        self.download_file_dfs_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_port(&mut self, v: u32) {
        self.download_file_dfs_port = ::std::option::Option::Some(v);
    }

    // optional string download_file_url = 7;

    pub fn get_download_file_url(&self) -> &str {
        match self.download_file_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_download_file_url(&mut self) {
        self.download_file_url.clear();
    }

    pub fn has_download_file_url(&self) -> bool {
        self.download_file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_url(&mut self, v: ::std::string::String) {
        self.download_file_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_download_file_url(&mut self) -> &mut ::std::string::String {
        if self.download_file_url.is_none() {
            self.download_file_url.set_default();
        }
        self.download_file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_download_file_url(&mut self) -> ::std::string::String {
        self.download_file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module_path = 8;

    pub fn get_module_path(&self) -> &str {
        match self.module_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module_path(&mut self) {
        self.module_path.clear();
    }

    pub fn has_module_path(&self) -> bool {
        self.module_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_path(&mut self, v: ::std::string::String) {
        self.module_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_path(&mut self) -> &mut ::std::string::String {
        if self.module_path.is_none() {
            self.module_path.set_default();
        }
        self.module_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_path(&mut self) -> ::std::string::String {
        self.module_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgDRMDownloadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.blob_download_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.merge_guid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.download_file_dfs_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.download_file_dfs_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.download_file_url)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.module_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blob_download_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.merge_guid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.download_file_dfs_ip {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.download_file_dfs_port {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.download_file_url.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.module_path.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blob_download_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.merge_guid.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.download_file_dfs_ip {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.download_file_dfs_port {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.download_file_url.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.module_path.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDRMDownloadResponse {
        CMsgDRMDownloadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eresult",
                |m: &CMsgDRMDownloadResponse| { &m.eresult },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.eresult },
                CMsgDRMDownloadResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgDRMDownloadResponse| { &m.app_id },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.app_id },
                CMsgDRMDownloadResponse::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "blob_download_type",
                |m: &CMsgDRMDownloadResponse| { &m.blob_download_type },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.blob_download_type },
                CMsgDRMDownloadResponse::get_blob_download_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "merge_guid",
                |m: &CMsgDRMDownloadResponse| { &m.merge_guid },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.merge_guid },
                CMsgDRMDownloadResponse::get_merge_guid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "download_file_dfs_ip",
                |m: &CMsgDRMDownloadResponse| { &m.download_file_dfs_ip },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_dfs_ip },
                CMsgDRMDownloadResponse::get_download_file_dfs_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "download_file_dfs_port",
                |m: &CMsgDRMDownloadResponse| { &m.download_file_dfs_port },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_dfs_port },
                CMsgDRMDownloadResponse::get_download_file_dfs_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "download_file_url",
                |m: &CMsgDRMDownloadResponse| { &m.download_file_url },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_url },
                CMsgDRMDownloadResponse::get_download_file_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "module_path",
                |m: &CMsgDRMDownloadResponse| { &m.module_path },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.module_path },
                CMsgDRMDownloadResponse::get_module_path,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgDRMDownloadResponse>(
                "CMsgDRMDownloadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDRMDownloadResponse {
        static instance: ::protobuf::rt::Lazy<CMsgDRMDownloadResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgDRMDownloadResponse::new)
    }
}

impl ::protobuf::Clear for CMsgDRMDownloadResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.blob_download_type = ::std::option::Option::None;
        self.merge_guid.clear();
        self.download_file_dfs_ip = ::std::option::Option::None;
        self.download_file_dfs_port = ::std::option::Option::None;
        self.download_file_url.clear();
        self.module_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDRMDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDRMDownloadResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDRMFinalResult {
    // message fields
    eResult: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    blob_download_type: ::std::option::Option<u32>,
    error_detail: ::std::option::Option<u32>,
    merge_guid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    download_file_dfs_ip: ::std::option::Option<u32>,
    download_file_dfs_port: ::std::option::Option<u32>,
    download_file_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDRMFinalResult {
    fn default() -> &'a CMsgDRMFinalResult {
        <CMsgDRMFinalResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMFinalResult {
    pub fn new() -> CMsgDRMFinalResult {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn get_eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 blob_download_type = 3;

    pub fn get_blob_download_type(&self) -> u32 {
        self.blob_download_type.unwrap_or(0)
    }

    pub fn clear_blob_download_type(&mut self) {
        self.blob_download_type = ::std::option::Option::None;
    }

    pub fn has_blob_download_type(&self) -> bool {
        self.blob_download_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_download_type(&mut self, v: u32) {
        self.blob_download_type = ::std::option::Option::Some(v);
    }

    // optional uint32 error_detail = 4;

    pub fn get_error_detail(&self) -> u32 {
        self.error_detail.unwrap_or(0)
    }

    pub fn clear_error_detail(&mut self) {
        self.error_detail = ::std::option::Option::None;
    }

    pub fn has_error_detail(&self) -> bool {
        self.error_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_detail(&mut self, v: u32) {
        self.error_detail = ::std::option::Option::Some(v);
    }

    // optional bytes merge_guid = 5;

    pub fn get_merge_guid(&self) -> &[u8] {
        match self.merge_guid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_merge_guid(&mut self) {
        self.merge_guid.clear();
    }

    pub fn has_merge_guid(&self) -> bool {
        self.merge_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_guid(&mut self, v: ::std::vec::Vec<u8>) {
        self.merge_guid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_guid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.merge_guid.is_none() {
            self.merge_guid.set_default();
        }
        self.merge_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_guid(&mut self) -> ::std::vec::Vec<u8> {
        self.merge_guid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 download_file_dfs_ip = 6;

    pub fn get_download_file_dfs_ip(&self) -> u32 {
        self.download_file_dfs_ip.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_ip(&mut self) {
        self.download_file_dfs_ip = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_ip(&self) -> bool {
        self.download_file_dfs_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_ip(&mut self, v: u32) {
        self.download_file_dfs_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 download_file_dfs_port = 7;

    pub fn get_download_file_dfs_port(&self) -> u32 {
        self.download_file_dfs_port.unwrap_or(0)
    }

    pub fn clear_download_file_dfs_port(&mut self) {
        self.download_file_dfs_port = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_port(&self) -> bool {
        self.download_file_dfs_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_port(&mut self, v: u32) {
        self.download_file_dfs_port = ::std::option::Option::Some(v);
    }

    // optional string download_file_url = 8;

    pub fn get_download_file_url(&self) -> &str {
        match self.download_file_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_download_file_url(&mut self) {
        self.download_file_url.clear();
    }

    pub fn has_download_file_url(&self) -> bool {
        self.download_file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_url(&mut self, v: ::std::string::String) {
        self.download_file_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_download_file_url(&mut self) -> &mut ::std::string::String {
        if self.download_file_url.is_none() {
            self.download_file_url.set_default();
        }
        self.download_file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_download_file_url(&mut self) -> ::std::string::String {
        self.download_file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgDRMFinalResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.blob_download_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error_detail = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.merge_guid)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.download_file_dfs_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.download_file_dfs_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.download_file_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blob_download_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error_detail {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.merge_guid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.download_file_dfs_ip {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.download_file_dfs_port {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.download_file_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blob_download_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.error_detail {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.merge_guid.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.download_file_dfs_ip {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.download_file_dfs_port {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.download_file_url.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDRMFinalResult {
        CMsgDRMFinalResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eResult",
                |m: &CMsgDRMFinalResult| { &m.eResult },
                |m: &mut CMsgDRMFinalResult| { &mut m.eResult },
                CMsgDRMFinalResult::get_eResult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgDRMFinalResult| { &m.app_id },
                |m: &mut CMsgDRMFinalResult| { &mut m.app_id },
                CMsgDRMFinalResult::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "blob_download_type",
                |m: &CMsgDRMFinalResult| { &m.blob_download_type },
                |m: &mut CMsgDRMFinalResult| { &mut m.blob_download_type },
                CMsgDRMFinalResult::get_blob_download_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "error_detail",
                |m: &CMsgDRMFinalResult| { &m.error_detail },
                |m: &mut CMsgDRMFinalResult| { &mut m.error_detail },
                CMsgDRMFinalResult::get_error_detail,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "merge_guid",
                |m: &CMsgDRMFinalResult| { &m.merge_guid },
                |m: &mut CMsgDRMFinalResult| { &mut m.merge_guid },
                CMsgDRMFinalResult::get_merge_guid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "download_file_dfs_ip",
                |m: &CMsgDRMFinalResult| { &m.download_file_dfs_ip },
                |m: &mut CMsgDRMFinalResult| { &mut m.download_file_dfs_ip },
                CMsgDRMFinalResult::get_download_file_dfs_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "download_file_dfs_port",
                |m: &CMsgDRMFinalResult| { &m.download_file_dfs_port },
                |m: &mut CMsgDRMFinalResult| { &mut m.download_file_dfs_port },
                CMsgDRMFinalResult::get_download_file_dfs_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "download_file_url",
                |m: &CMsgDRMFinalResult| { &m.download_file_url },
                |m: &mut CMsgDRMFinalResult| { &mut m.download_file_url },
                CMsgDRMFinalResult::get_download_file_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgDRMFinalResult>(
                "CMsgDRMFinalResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDRMFinalResult {
        static instance: ::protobuf::rt::Lazy<CMsgDRMFinalResult> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgDRMFinalResult::new)
    }
}

impl ::protobuf::Clear for CMsgDRMFinalResult {
    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.blob_download_type = ::std::option::Option::None;
        self.error_detail = ::std::option::Option::None;
        self.merge_guid.clear();
        self.download_file_dfs_ip = ::std::option::Option::None;
        self.download_file_dfs_port = ::std::option::Option::None;
        self.download_file_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDRMFinalResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDRMFinalResult {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDPCheckSpecialSurvey {
    // message fields
    survey_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPCheckSpecialSurvey {
    fn default() -> &'a CMsgClientDPCheckSpecialSurvey {
        <CMsgClientDPCheckSpecialSurvey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPCheckSpecialSurvey {
    pub fn new() -> CMsgClientDPCheckSpecialSurvey {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;

    pub fn get_survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDPCheckSpecialSurvey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDPCheckSpecialSurvey {
        CMsgClientDPCheckSpecialSurvey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "survey_id",
                |m: &CMsgClientDPCheckSpecialSurvey| { &m.survey_id },
                |m: &mut CMsgClientDPCheckSpecialSurvey| { &mut m.survey_id },
                CMsgClientDPCheckSpecialSurvey::get_survey_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDPCheckSpecialSurvey>(
                "CMsgClientDPCheckSpecialSurvey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDPCheckSpecialSurvey {
        static instance: ::protobuf::rt::Lazy<CMsgClientDPCheckSpecialSurvey> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientDPCheckSpecialSurvey::new)
    }
}

impl ::protobuf::Clear for CMsgClientDPCheckSpecialSurvey {
    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDPCheckSpecialSurvey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPCheckSpecialSurvey {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDPCheckSpecialSurveyResponse {
    // message fields
    eResult: ::std::option::Option<u32>,
    state: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    custom_url: ::protobuf::SingularField<::std::string::String>,
    include_software: ::std::option::Option<bool>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPCheckSpecialSurveyResponse {
    fn default() -> &'a CMsgClientDPCheckSpecialSurveyResponse {
        <CMsgClientDPCheckSpecialSurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPCheckSpecialSurveyResponse {
    pub fn new() -> CMsgClientDPCheckSpecialSurveyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn get_eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional uint32 state = 2;

    pub fn get_state(&self) -> u32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_url = 4;

    pub fn get_custom_url(&self) -> &str {
        match self.custom_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_url(&mut self) {
        self.custom_url.clear();
    }

    pub fn has_custom_url(&self) -> bool {
        self.custom_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_url(&mut self, v: ::std::string::String) {
        self.custom_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_url(&mut self) -> &mut ::std::string::String {
        if self.custom_url.is_none() {
            self.custom_url.set_default();
        }
        self.custom_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_url(&mut self) -> ::std::string::String {
        self.custom_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool include_software = 5;

    pub fn get_include_software(&self) -> bool {
        self.include_software.unwrap_or(false)
    }

    pub fn clear_include_software(&mut self) {
        self.include_software = ::std::option::Option::None;
    }

    pub fn has_include_software(&self) -> bool {
        self.include_software.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_software(&mut self, v: bool) {
        self.include_software = ::std::option::Option::Some(v);
    }

    // optional bytes token = 6;

    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientDPCheckSpecialSurveyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.state = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.custom_url)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.include_software = ::std::option::Option::Some(is.read_bool()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.custom_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.include_software {
            my_size += 2;
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.custom_url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.include_software {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDPCheckSpecialSurveyResponse {
        CMsgClientDPCheckSpecialSurveyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eResult",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.eResult },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.eResult },
                CMsgClientDPCheckSpecialSurveyResponse::get_eResult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "state",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.state },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.state },
                CMsgClientDPCheckSpecialSurveyResponse::get_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "name",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.name },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.name },
                CMsgClientDPCheckSpecialSurveyResponse::get_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "custom_url",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.custom_url },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.custom_url },
                CMsgClientDPCheckSpecialSurveyResponse::get_custom_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "include_software",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.include_software },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.include_software },
                CMsgClientDPCheckSpecialSurveyResponse::get_include_software,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "token",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.token },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.token },
                CMsgClientDPCheckSpecialSurveyResponse::get_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDPCheckSpecialSurveyResponse>(
                "CMsgClientDPCheckSpecialSurveyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDPCheckSpecialSurveyResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientDPCheckSpecialSurveyResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientDPCheckSpecialSurveyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientDPCheckSpecialSurveyResponse {
    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.name.clear();
        self.custom_url.clear();
        self.include_software = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDPCheckSpecialSurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPCheckSpecialSurveyResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDPSendSpecialSurveyResponse {
    // message fields
    survey_id: ::std::option::Option<u32>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPSendSpecialSurveyResponse {
    fn default() -> &'a CMsgClientDPSendSpecialSurveyResponse {
        <CMsgClientDPSendSpecialSurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPSendSpecialSurveyResponse {
    pub fn new() -> CMsgClientDPSendSpecialSurveyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;

    pub fn get_survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientDPSendSpecialSurveyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDPSendSpecialSurveyResponse {
        CMsgClientDPSendSpecialSurveyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "survey_id",
                |m: &CMsgClientDPSendSpecialSurveyResponse| { &m.survey_id },
                |m: &mut CMsgClientDPSendSpecialSurveyResponse| { &mut m.survey_id },
                CMsgClientDPSendSpecialSurveyResponse::get_survey_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "data",
                |m: &CMsgClientDPSendSpecialSurveyResponse| { &m.data },
                |m: &mut CMsgClientDPSendSpecialSurveyResponse| { &mut m.data },
                CMsgClientDPSendSpecialSurveyResponse::get_data,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDPSendSpecialSurveyResponse>(
                "CMsgClientDPSendSpecialSurveyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDPSendSpecialSurveyResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientDPSendSpecialSurveyResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientDPSendSpecialSurveyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientDPSendSpecialSurveyResponse {
    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDPSendSpecialSurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPSendSpecialSurveyResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDPSendSpecialSurveyResponseReply {
    // message fields
    eResult: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPSendSpecialSurveyResponseReply {
    fn default() -> &'a CMsgClientDPSendSpecialSurveyResponseReply {
        <CMsgClientDPSendSpecialSurveyResponseReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPSendSpecialSurveyResponseReply {
    pub fn new() -> CMsgClientDPSendSpecialSurveyResponseReply {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn get_eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional bytes token = 2;

    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientDPSendSpecialSurveyResponseReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDPSendSpecialSurveyResponseReply {
        CMsgClientDPSendSpecialSurveyResponseReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eResult",
                |m: &CMsgClientDPSendSpecialSurveyResponseReply| { &m.eResult },
                |m: &mut CMsgClientDPSendSpecialSurveyResponseReply| { &mut m.eResult },
                CMsgClientDPSendSpecialSurveyResponseReply::get_eResult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "token",
                |m: &CMsgClientDPSendSpecialSurveyResponseReply| { &m.token },
                |m: &mut CMsgClientDPSendSpecialSurveyResponseReply| { &mut m.token },
                CMsgClientDPSendSpecialSurveyResponseReply::get_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDPSendSpecialSurveyResponseReply>(
                "CMsgClientDPSendSpecialSurveyResponseReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDPSendSpecialSurveyResponseReply {
        static instance: ::protobuf::rt::Lazy<CMsgClientDPSendSpecialSurveyResponseReply> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientDPSendSpecialSurveyResponseReply::new)
    }
}

impl ::protobuf::Clear for CMsgClientDPSendSpecialSurveyResponseReply {
    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDPSendSpecialSurveyResponseReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPSendSpecialSurveyResponseReply {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestForgottenPasswordEmail {
    // message fields
    account_name: ::protobuf::SingularField<::std::string::String>,
    password_tried: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestForgottenPasswordEmail {
    fn default() -> &'a CMsgClientRequestForgottenPasswordEmail {
        <CMsgClientRequestForgottenPasswordEmail as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestForgottenPasswordEmail {
    pub fn new() -> CMsgClientRequestForgottenPasswordEmail {
        ::std::default::Default::default()
    }

    // optional string account_name = 1;

    pub fn get_account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name.set_default();
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password_tried = 2;

    pub fn get_password_tried(&self) -> &str {
        match self.password_tried.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_password_tried(&mut self) {
        self.password_tried.clear();
    }

    pub fn has_password_tried(&self) -> bool {
        self.password_tried.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_tried(&mut self, v: ::std::string::String) {
        self.password_tried = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password_tried(&mut self) -> &mut ::std::string::String {
        if self.password_tried.is_none() {
            self.password_tried.set_default();
        }
        self.password_tried.as_mut().unwrap()
    }

    // Take field
    pub fn take_password_tried(&mut self) -> ::std::string::String {
        self.password_tried.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestForgottenPasswordEmail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password_tried)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.password_tried.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.password_tried.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestForgottenPasswordEmail {
        CMsgClientRequestForgottenPasswordEmail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "account_name",
                |m: &CMsgClientRequestForgottenPasswordEmail| { &m.account_name },
                |m: &mut CMsgClientRequestForgottenPasswordEmail| { &mut m.account_name },
                CMsgClientRequestForgottenPasswordEmail::get_account_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "password_tried",
                |m: &CMsgClientRequestForgottenPasswordEmail| { &m.password_tried },
                |m: &mut CMsgClientRequestForgottenPasswordEmail| { &mut m.password_tried },
                CMsgClientRequestForgottenPasswordEmail::get_password_tried,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestForgottenPasswordEmail>(
                "CMsgClientRequestForgottenPasswordEmail",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestForgottenPasswordEmail {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestForgottenPasswordEmail> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestForgottenPasswordEmail::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestForgottenPasswordEmail {
    fn clear(&mut self) {
        self.account_name.clear();
        self.password_tried.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestForgottenPasswordEmail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestForgottenPasswordEmail {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestForgottenPasswordEmailResponse {
    // message fields
    eResult: ::std::option::Option<u32>,
    use_secret_question: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestForgottenPasswordEmailResponse {
    fn default() -> &'a CMsgClientRequestForgottenPasswordEmailResponse {
        <CMsgClientRequestForgottenPasswordEmailResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestForgottenPasswordEmailResponse {
    pub fn new() -> CMsgClientRequestForgottenPasswordEmailResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;

    pub fn get_eResult(&self) -> u32 {
        self.eResult.unwrap_or(0)
    }

    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional bool use_secret_question = 2;

    pub fn get_use_secret_question(&self) -> bool {
        self.use_secret_question.unwrap_or(false)
    }

    pub fn clear_use_secret_question(&mut self) {
        self.use_secret_question = ::std::option::Option::None;
    }

    pub fn has_use_secret_question(&self) -> bool {
        self.use_secret_question.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_secret_question(&mut self, v: bool) {
        self.use_secret_question = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestForgottenPasswordEmailResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eResult = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.use_secret_question = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.use_secret_question {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.use_secret_question {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestForgottenPasswordEmailResponse {
        CMsgClientRequestForgottenPasswordEmailResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "eResult",
                |m: &CMsgClientRequestForgottenPasswordEmailResponse| { &m.eResult },
                |m: &mut CMsgClientRequestForgottenPasswordEmailResponse| { &mut m.eResult },
                CMsgClientRequestForgottenPasswordEmailResponse::get_eResult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "use_secret_question",
                |m: &CMsgClientRequestForgottenPasswordEmailResponse| { &m.use_secret_question },
                |m: &mut CMsgClientRequestForgottenPasswordEmailResponse| { &mut m.use_secret_question },
                CMsgClientRequestForgottenPasswordEmailResponse::get_use_secret_question,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestForgottenPasswordEmailResponse>(
                "CMsgClientRequestForgottenPasswordEmailResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestForgottenPasswordEmailResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestForgottenPasswordEmailResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestForgottenPasswordEmailResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestForgottenPasswordEmailResponse {
    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.use_secret_question = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestForgottenPasswordEmailResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestForgottenPasswordEmailResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientItemAnnouncements {
    // message fields
    count_new_items: ::std::option::Option<u32>,
    pub unseen_items: ::protobuf::RepeatedField<cmsg_client_item_announcements::UnseenItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientItemAnnouncements {
    fn default() -> &'a CMsgClientItemAnnouncements {
        <CMsgClientItemAnnouncements as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientItemAnnouncements {
    pub fn new() -> CMsgClientItemAnnouncements {
        ::std::default::Default::default()
    }

    // optional uint32 count_new_items = 1;

    pub fn get_count_new_items(&self) -> u32 {
        self.count_new_items.unwrap_or(0)
    }

    pub fn clear_count_new_items(&mut self) {
        self.count_new_items = ::std::option::Option::None;
    }

    pub fn has_count_new_items(&self) -> bool {
        self.count_new_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_items(&mut self, v: u32) {
        self.count_new_items = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientItemAnnouncements {
    fn is_initialized(&self) -> bool {
        for v in &self.unseen_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.count_new_items = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.unseen_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.count_new_items {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.unseen_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.count_new_items {
            os.write_uint32(1, v)?;
        }
        for v in &self.unseen_items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientItemAnnouncements {
        CMsgClientItemAnnouncements::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "count_new_items",
                |m: &CMsgClientItemAnnouncements| { &m.count_new_items },
                |m: &mut CMsgClientItemAnnouncements| { &mut m.count_new_items },
                CMsgClientItemAnnouncements::get_count_new_items,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_item_announcements::UnseenItem>>(
                "unseen_items",
                |m: &CMsgClientItemAnnouncements| { &m.unseen_items },
                |m: &mut CMsgClientItemAnnouncements| { &mut m.unseen_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientItemAnnouncements>(
                "CMsgClientItemAnnouncements",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientItemAnnouncements {
        static instance: ::protobuf::rt::Lazy<CMsgClientItemAnnouncements> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientItemAnnouncements::new)
    }
}

impl ::protobuf::Clear for CMsgClientItemAnnouncements {
    fn clear(&mut self) {
        self.count_new_items = ::std::option::Option::None;
        self.unseen_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientItemAnnouncements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientItemAnnouncements {
}

/// Nested message and enums of message `CMsgClientItemAnnouncements`
pub mod cmsg_client_item_announcements {
    #[derive(PartialEq,Clone,Default)]
    pub struct UnseenItem {
        // message fields
        appid: ::std::option::Option<u32>,
        context_id: ::std::option::Option<u64>,
        asset_id: ::std::option::Option<u64>,
        amount: ::std::option::Option<u64>,
        rtime32_gained: ::std::option::Option<u32>,
        source_appid: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a UnseenItem {
        fn default() -> &'a UnseenItem {
            <UnseenItem as ::protobuf::Message>::default_instance()
        }
    }

    impl UnseenItem {
        pub fn new() -> UnseenItem {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint64 context_id = 2;

        pub fn get_context_id(&self) -> u64 {
            self.context_id.unwrap_or(0)
        }

        pub fn clear_context_id(&mut self) {
            self.context_id = ::std::option::Option::None;
        }

        pub fn has_context_id(&self) -> bool {
            self.context_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_context_id(&mut self, v: u64) {
            self.context_id = ::std::option::Option::Some(v);
        }

        // optional uint64 asset_id = 3;

        pub fn get_asset_id(&self) -> u64 {
            self.asset_id.unwrap_or(0)
        }

        pub fn clear_asset_id(&mut self) {
            self.asset_id = ::std::option::Option::None;
        }

        pub fn has_asset_id(&self) -> bool {
            self.asset_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_asset_id(&mut self, v: u64) {
            self.asset_id = ::std::option::Option::Some(v);
        }

        // optional uint64 amount = 4;

        pub fn get_amount(&self) -> u64 {
            self.amount.unwrap_or(0)
        }

        pub fn clear_amount(&mut self) {
            self.amount = ::std::option::Option::None;
        }

        pub fn has_amount(&self) -> bool {
            self.amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_amount(&mut self, v: u64) {
            self.amount = ::std::option::Option::Some(v);
        }

        // optional fixed32 rtime32_gained = 5;

        pub fn get_rtime32_gained(&self) -> u32 {
            self.rtime32_gained.unwrap_or(0)
        }

        pub fn clear_rtime32_gained(&mut self) {
            self.rtime32_gained = ::std::option::Option::None;
        }

        pub fn has_rtime32_gained(&self) -> bool {
            self.rtime32_gained.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime32_gained(&mut self, v: u32) {
            self.rtime32_gained = ::std::option::Option::Some(v);
        }

        // optional uint32 source_appid = 6;

        pub fn get_source_appid(&self) -> u32 {
            self.source_appid.unwrap_or(0)
        }

        pub fn clear_source_appid(&mut self) {
            self.source_appid = ::std::option::Option::None;
        }

        pub fn has_source_appid(&self) -> bool {
            self.source_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_appid(&mut self, v: u32) {
            self.source_appid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for UnseenItem {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.context_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.asset_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.amount = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.rtime32_gained = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.source_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.context_id {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.asset_id {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.amount {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.rtime32_gained {
                my_size += 5;
            }
            if let Some(v) = self.source_appid {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.context_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.asset_id {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.amount {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.rtime32_gained {
                os.write_fixed32(5, v)?;
            }
            if let Some(v) = self.source_appid {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> UnseenItem {
            UnseenItem::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &UnseenItem| { &m.appid },
                    |m: &mut UnseenItem| { &mut m.appid },
                    UnseenItem::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "context_id",
                    |m: &UnseenItem| { &m.context_id },
                    |m: &mut UnseenItem| { &mut m.context_id },
                    UnseenItem::get_context_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "asset_id",
                    |m: &UnseenItem| { &m.asset_id },
                    |m: &mut UnseenItem| { &mut m.asset_id },
                    UnseenItem::get_asset_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "amount",
                    |m: &UnseenItem| { &m.amount },
                    |m: &mut UnseenItem| { &mut m.amount },
                    UnseenItem::get_amount,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                    "rtime32_gained",
                    |m: &UnseenItem| { &m.rtime32_gained },
                    |m: &mut UnseenItem| { &mut m.rtime32_gained },
                    UnseenItem::get_rtime32_gained,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "source_appid",
                    |m: &UnseenItem| { &m.source_appid },
                    |m: &mut UnseenItem| { &mut m.source_appid },
                    UnseenItem::get_source_appid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnseenItem>(
                    "CMsgClientItemAnnouncements.UnseenItem",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static UnseenItem {
            static instance: ::protobuf::rt::Lazy<UnseenItem> = ::protobuf::rt::Lazy::INIT;
            instance.get(UnseenItem::new)
        }
    }

    impl ::protobuf::Clear for UnseenItem {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.context_id = ::std::option::Option::None;
            self.asset_id = ::std::option::Option::None;
            self.amount = ::std::option::Option::None;
            self.rtime32_gained = ::std::option::Option::None;
            self.source_appid = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for UnseenItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UnseenItem {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestItemAnnouncements {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestItemAnnouncements {
    fn default() -> &'a CMsgClientRequestItemAnnouncements {
        <CMsgClientRequestItemAnnouncements as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestItemAnnouncements {
    pub fn new() -> CMsgClientRequestItemAnnouncements {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestItemAnnouncements {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestItemAnnouncements {
        CMsgClientRequestItemAnnouncements::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestItemAnnouncements>(
                "CMsgClientRequestItemAnnouncements",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestItemAnnouncements {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestItemAnnouncements> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestItemAnnouncements::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestItemAnnouncements {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestItemAnnouncements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestItemAnnouncements {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUserNotifications {
    // message fields
    pub notifications: ::protobuf::RepeatedField<cmsg_client_user_notifications::Notification>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUserNotifications {
    fn default() -> &'a CMsgClientUserNotifications {
        <CMsgClientUserNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUserNotifications {
    pub fn new() -> CMsgClientUserNotifications {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientUserNotifications {
    fn is_initialized(&self) -> bool {
        for v in &self.notifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.notifications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.notifications {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUserNotifications {
        CMsgClientUserNotifications::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_user_notifications::Notification>>(
                "notifications",
                |m: &CMsgClientUserNotifications| { &m.notifications },
                |m: &mut CMsgClientUserNotifications| { &mut m.notifications },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUserNotifications>(
                "CMsgClientUserNotifications",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUserNotifications {
        static instance: ::protobuf::rt::Lazy<CMsgClientUserNotifications> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUserNotifications::new)
    }
}

impl ::protobuf::Clear for CMsgClientUserNotifications {
    fn clear(&mut self) {
        self.notifications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUserNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUserNotifications {
}

/// Nested message and enums of message `CMsgClientUserNotifications`
pub mod cmsg_client_user_notifications {
    #[derive(PartialEq,Clone,Default)]
    pub struct Notification {
        // message fields
        user_notification_type: ::std::option::Option<u32>,
        count: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Notification {
        fn default() -> &'a Notification {
            <Notification as ::protobuf::Message>::default_instance()
        }
    }

    impl Notification {
        pub fn new() -> Notification {
            ::std::default::Default::default()
        }

        // optional uint32 user_notification_type = 1;

        pub fn get_user_notification_type(&self) -> u32 {
            self.user_notification_type.unwrap_or(0)
        }

        pub fn clear_user_notification_type(&mut self) {
            self.user_notification_type = ::std::option::Option::None;
        }

        pub fn has_user_notification_type(&self) -> bool {
            self.user_notification_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_notification_type(&mut self, v: u32) {
            self.user_notification_type = ::std::option::Option::Some(v);
        }

        // optional uint32 count = 2;

        pub fn get_count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Notification {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.user_notification_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.user_notification_type {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.user_notification_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Notification {
            Notification::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "user_notification_type",
                    |m: &Notification| { &m.user_notification_type },
                    |m: &mut Notification| { &mut m.user_notification_type },
                    Notification::get_user_notification_type,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "count",
                    |m: &Notification| { &m.count },
                    |m: &mut Notification| { &mut m.count },
                    Notification::get_count,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Notification>(
                    "CMsgClientUserNotifications.Notification",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Notification {
            static instance: ::protobuf::rt::Lazy<Notification> = ::protobuf::rt::Lazy::INIT;
            instance.get(Notification::new)
        }
    }

    impl ::protobuf::Clear for Notification {
        fn clear(&mut self) {
            self.user_notification_type = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Notification {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Notification {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCommentNotifications {
    // message fields
    count_new_comments: ::std::option::Option<u32>,
    count_new_comments_owner: ::std::option::Option<u32>,
    count_new_comments_subscriptions: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCommentNotifications {
    fn default() -> &'a CMsgClientCommentNotifications {
        <CMsgClientCommentNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCommentNotifications {
    pub fn new() -> CMsgClientCommentNotifications {
        ::std::default::Default::default()
    }

    // optional uint32 count_new_comments = 1;

    pub fn get_count_new_comments(&self) -> u32 {
        self.count_new_comments.unwrap_or(0)
    }

    pub fn clear_count_new_comments(&mut self) {
        self.count_new_comments = ::std::option::Option::None;
    }

    pub fn has_count_new_comments(&self) -> bool {
        self.count_new_comments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments(&mut self, v: u32) {
        self.count_new_comments = ::std::option::Option::Some(v);
    }

    // optional uint32 count_new_comments_owner = 2;

    pub fn get_count_new_comments_owner(&self) -> u32 {
        self.count_new_comments_owner.unwrap_or(0)
    }

    pub fn clear_count_new_comments_owner(&mut self) {
        self.count_new_comments_owner = ::std::option::Option::None;
    }

    pub fn has_count_new_comments_owner(&self) -> bool {
        self.count_new_comments_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments_owner(&mut self, v: u32) {
        self.count_new_comments_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 count_new_comments_subscriptions = 3;

    pub fn get_count_new_comments_subscriptions(&self) -> u32 {
        self.count_new_comments_subscriptions.unwrap_or(0)
    }

    pub fn clear_count_new_comments_subscriptions(&mut self) {
        self.count_new_comments_subscriptions = ::std::option::Option::None;
    }

    pub fn has_count_new_comments_subscriptions(&self) -> bool {
        self.count_new_comments_subscriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments_subscriptions(&mut self, v: u32) {
        self.count_new_comments_subscriptions = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCommentNotifications {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.count_new_comments = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.count_new_comments_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.count_new_comments_subscriptions = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.count_new_comments {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count_new_comments_owner {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count_new_comments_subscriptions {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.count_new_comments {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count_new_comments_owner {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count_new_comments_subscriptions {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCommentNotifications {
        CMsgClientCommentNotifications::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "count_new_comments",
                |m: &CMsgClientCommentNotifications| { &m.count_new_comments },
                |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments },
                CMsgClientCommentNotifications::get_count_new_comments,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "count_new_comments_owner",
                |m: &CMsgClientCommentNotifications| { &m.count_new_comments_owner },
                |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments_owner },
                CMsgClientCommentNotifications::get_count_new_comments_owner,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "count_new_comments_subscriptions",
                |m: &CMsgClientCommentNotifications| { &m.count_new_comments_subscriptions },
                |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments_subscriptions },
                CMsgClientCommentNotifications::get_count_new_comments_subscriptions,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientCommentNotifications>(
                "CMsgClientCommentNotifications",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCommentNotifications {
        static instance: ::protobuf::rt::Lazy<CMsgClientCommentNotifications> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientCommentNotifications::new)
    }
}

impl ::protobuf::Clear for CMsgClientCommentNotifications {
    fn clear(&mut self) {
        self.count_new_comments = ::std::option::Option::None;
        self.count_new_comments_owner = ::std::option::Option::None;
        self.count_new_comments_subscriptions = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCommentNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCommentNotifications {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestCommentNotifications {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestCommentNotifications {
    fn default() -> &'a CMsgClientRequestCommentNotifications {
        <CMsgClientRequestCommentNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestCommentNotifications {
    pub fn new() -> CMsgClientRequestCommentNotifications {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestCommentNotifications {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestCommentNotifications {
        CMsgClientRequestCommentNotifications::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestCommentNotifications>(
                "CMsgClientRequestCommentNotifications",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestCommentNotifications {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestCommentNotifications> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestCommentNotifications::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestCommentNotifications {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestCommentNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestCommentNotifications {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientOfflineMessageNotification {
    // message fields
    offline_messages: ::std::option::Option<u32>,
    pub friends_with_offline_messages: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientOfflineMessageNotification {
    fn default() -> &'a CMsgClientOfflineMessageNotification {
        <CMsgClientOfflineMessageNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOfflineMessageNotification {
    pub fn new() -> CMsgClientOfflineMessageNotification {
        ::std::default::Default::default()
    }

    // optional uint32 offline_messages = 1;

    pub fn get_offline_messages(&self) -> u32 {
        self.offline_messages.unwrap_or(0)
    }

    pub fn clear_offline_messages(&mut self) {
        self.offline_messages = ::std::option::Option::None;
    }

    pub fn has_offline_messages(&self) -> bool {
        self.offline_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline_messages(&mut self, v: u32) {
        self.offline_messages = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientOfflineMessageNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.offline_messages = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.friends_with_offline_messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.offline_messages {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.friends_with_offline_messages {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.offline_messages {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends_with_offline_messages {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientOfflineMessageNotification {
        CMsgClientOfflineMessageNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "offline_messages",
                |m: &CMsgClientOfflineMessageNotification| { &m.offline_messages },
                |m: &mut CMsgClientOfflineMessageNotification| { &mut m.offline_messages },
                CMsgClientOfflineMessageNotification::get_offline_messages,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "friends_with_offline_messages",
                |m: &CMsgClientOfflineMessageNotification| { &m.friends_with_offline_messages },
                |m: &mut CMsgClientOfflineMessageNotification| { &mut m.friends_with_offline_messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientOfflineMessageNotification>(
                "CMsgClientOfflineMessageNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientOfflineMessageNotification {
        static instance: ::protobuf::rt::Lazy<CMsgClientOfflineMessageNotification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientOfflineMessageNotification::new)
    }
}

impl ::protobuf::Clear for CMsgClientOfflineMessageNotification {
    fn clear(&mut self) {
        self.offline_messages = ::std::option::Option::None;
        self.friends_with_offline_messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientOfflineMessageNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientOfflineMessageNotification {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestOfflineMessageCount {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestOfflineMessageCount {
    fn default() -> &'a CMsgClientRequestOfflineMessageCount {
        <CMsgClientRequestOfflineMessageCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestOfflineMessageCount {
    pub fn new() -> CMsgClientRequestOfflineMessageCount {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestOfflineMessageCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestOfflineMessageCount {
        CMsgClientRequestOfflineMessageCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestOfflineMessageCount>(
                "CMsgClientRequestOfflineMessageCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestOfflineMessageCount {
        static instance: ::protobuf::rt::Lazy<CMsgClientRequestOfflineMessageCount> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientRequestOfflineMessageCount::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestOfflineMessageCount {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestOfflineMessageCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestOfflineMessageCount {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientChatGetFriendMessageHistory {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistory {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistory {
        <CMsgClientChatGetFriendMessageHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistory {
    pub fn new() -> CMsgClientChatGetFriendMessageHistory {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChatGetFriendMessageHistory {
        CMsgClientChatGetFriendMessageHistory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CMsgClientChatGetFriendMessageHistory| { &m.steamid },
                |m: &mut CMsgClientChatGetFriendMessageHistory| { &mut m.steamid },
                CMsgClientChatGetFriendMessageHistory::get_steamid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientChatGetFriendMessageHistory>(
                "CMsgClientChatGetFriendMessageHistory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistory {
        static instance: ::protobuf::rt::Lazy<CMsgClientChatGetFriendMessageHistory> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientChatGetFriendMessageHistory::new)
    }
}

impl ::protobuf::Clear for CMsgClientChatGetFriendMessageHistory {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChatGetFriendMessageHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistory {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientChatGetFriendMessageHistoryResponse {
    // message fields
    steamid: ::std::option::Option<u64>,
    success: ::std::option::Option<u32>,
    pub messages: ::protobuf::RepeatedField<cmsg_client_chat_get_friend_message_history_response::FriendMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryResponse {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryResponse {
        <CMsgClientChatGetFriendMessageHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryResponse {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 success = 2;

    pub fn get_success(&self) -> u32 {
        self.success.unwrap_or(0)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: u32) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.success = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.success {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.success {
            os.write_uint32(2, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryResponse {
        CMsgClientChatGetFriendMessageHistoryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.steamid },
                |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.steamid },
                CMsgClientChatGetFriendMessageHistoryResponse::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "success",
                |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.success },
                |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.success },
                CMsgClientChatGetFriendMessageHistoryResponse::get_success,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_chat_get_friend_message_history_response::FriendMessage>>(
                "messages",
                |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.messages },
                |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientChatGetFriendMessageHistoryResponse>(
                "CMsgClientChatGetFriendMessageHistoryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientChatGetFriendMessageHistoryResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientChatGetFriendMessageHistoryResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientChatGetFriendMessageHistoryResponse {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChatGetFriendMessageHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistoryResponse {
}

/// Nested message and enums of message `CMsgClientChatGetFriendMessageHistoryResponse`
pub mod cmsg_client_chat_get_friend_message_history_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct FriendMessage {
        // message fields
        accountid: ::std::option::Option<u32>,
        timestamp: ::std::option::Option<u32>,
        message: ::protobuf::SingularField<::std::string::String>,
        unread: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a FriendMessage {
        fn default() -> &'a FriendMessage {
            <FriendMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendMessage {
        pub fn new() -> FriendMessage {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn get_accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 2;

        pub fn get_timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string message = 3;

        pub fn get_message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message.clear();
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message.set_default();
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool unread = 4;

        pub fn get_unread(&self) -> bool {
            self.unread.unwrap_or(false)
        }

        pub fn clear_unread(&mut self) {
            self.unread = ::std::option::Option::None;
        }

        pub fn has_unread(&self) -> bool {
            self.unread.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unread(&mut self, v: bool) {
            self.unread = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for FriendMessage {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.unread = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.unread {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.unread {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> FriendMessage {
            FriendMessage::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "accountid",
                    |m: &FriendMessage| { &m.accountid },
                    |m: &mut FriendMessage| { &mut m.accountid },
                    FriendMessage::get_accountid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "timestamp",
                    |m: &FriendMessage| { &m.timestamp },
                    |m: &mut FriendMessage| { &mut m.timestamp },
                    FriendMessage::get_timestamp,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "message",
                    |m: &FriendMessage| { &m.message },
                    |m: &mut FriendMessage| { &mut m.message },
                    FriendMessage::get_message,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "unread",
                    |m: &FriendMessage| { &m.unread },
                    |m: &mut FriendMessage| { &mut m.unread },
                    FriendMessage::get_unread,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FriendMessage>(
                    "CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static FriendMessage {
            static instance: ::protobuf::rt::Lazy<FriendMessage> = ::protobuf::rt::Lazy::INIT;
            instance.get(FriendMessage::new)
        }
    }

    impl ::protobuf::Clear for FriendMessage {
        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.message.clear();
            self.unread = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for FriendMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FriendMessage {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        <CMsgClientChatGetFriendMessageHistoryForOfflineMessages as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        CMsgClientChatGetFriendMessageHistoryForOfflineMessages::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientChatGetFriendMessageHistoryForOfflineMessages>(
                "CMsgClientChatGetFriendMessageHistoryForOfflineMessages",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        static instance: ::protobuf::rt::Lazy<CMsgClientChatGetFriendMessageHistoryForOfflineMessages> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientChatGetFriendMessageHistoryForOfflineMessages::new)
    }
}

impl ::protobuf::Clear for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFSGetFriendsSteamLevels {
    // message fields
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevels {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevels {
        <CMsgClientFSGetFriendsSteamLevels as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevels {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevels {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientFSGetFriendsSteamLevels {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.accountids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accountids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accountids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevels {
        CMsgClientFSGetFriendsSteamLevels::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "accountids",
                |m: &CMsgClientFSGetFriendsSteamLevels| { &m.accountids },
                |m: &mut CMsgClientFSGetFriendsSteamLevels| { &mut m.accountids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFSGetFriendsSteamLevels>(
                "CMsgClientFSGetFriendsSteamLevels",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevels {
        static instance: ::protobuf::rt::Lazy<CMsgClientFSGetFriendsSteamLevels> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientFSGetFriendsSteamLevels::new)
    }
}

impl ::protobuf::Clear for CMsgClientFSGetFriendsSteamLevels {
    fn clear(&mut self) {
        self.accountids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFSGetFriendsSteamLevels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFSGetFriendsSteamLevels {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFSGetFriendsSteamLevelsResponse {
    // message fields
    pub friends: ::protobuf::RepeatedField<cmsg_client_fsget_friends_steam_levels_response::Friend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevelsResponse {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevelsResponse {
        <CMsgClientFSGetFriendsSteamLevelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevelsResponse {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.friends {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.friends)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.friends {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse {
        CMsgClientFSGetFriendsSteamLevelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_fsget_friends_steam_levels_response::Friend>>(
                "friends",
                |m: &CMsgClientFSGetFriendsSteamLevelsResponse| { &m.friends },
                |m: &mut CMsgClientFSGetFriendsSteamLevelsResponse| { &mut m.friends },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFSGetFriendsSteamLevelsResponse>(
                "CMsgClientFSGetFriendsSteamLevelsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevelsResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientFSGetFriendsSteamLevelsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientFSGetFriendsSteamLevelsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn clear(&mut self) {
        self.friends.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFSGetFriendsSteamLevelsResponse {
}

/// Nested message and enums of message `CMsgClientFSGetFriendsSteamLevelsResponse`
pub mod cmsg_client_fsget_friends_steam_levels_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Friend {
        // message fields
        accountid: ::std::option::Option<u32>,
        level: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Friend {
        fn default() -> &'a Friend {
            <Friend as ::protobuf::Message>::default_instance()
        }
    }

    impl Friend {
        pub fn new() -> Friend {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn get_accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 2;

        pub fn get_level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Friend {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Friend {
            Friend::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "accountid",
                    |m: &Friend| { &m.accountid },
                    |m: &mut Friend| { &mut m.accountid },
                    Friend::get_accountid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "level",
                    |m: &Friend| { &m.level },
                    |m: &mut Friend| { &mut m.level },
                    Friend::get_level,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Friend>(
                    "CMsgClientFSGetFriendsSteamLevelsResponse.Friend",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Friend {
            static instance: ::protobuf::rt::Lazy<Friend> = ::protobuf::rt::Lazy::INIT;
            instance.get(Friend::new)
        }
    }

    impl ::protobuf::Clear for Friend {
        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Friend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Friend {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientEmailAddrInfo {
    // message fields
    email_address: ::protobuf::SingularField<::std::string::String>,
    email_is_validated: ::std::option::Option<bool>,
    email_validation_changed: ::std::option::Option<bool>,
    credential_change_requires_code: ::std::option::Option<bool>,
    password_or_secretqa_change_requires_code: ::std::option::Option<bool>,
    remind_user_about_email: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmailAddrInfo {
    fn default() -> &'a CMsgClientEmailAddrInfo {
        <CMsgClientEmailAddrInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEmailAddrInfo {
    pub fn new() -> CMsgClientEmailAddrInfo {
        ::std::default::Default::default()
    }

    // optional string email_address = 1;

    pub fn get_email_address(&self) -> &str {
        match self.email_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_email_address(&mut self) {
        self.email_address.clear();
    }

    pub fn has_email_address(&self) -> bool {
        self.email_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        if self.email_address.is_none() {
            self.email_address.set_default();
        }
        self.email_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        self.email_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool email_is_validated = 2;

    pub fn get_email_is_validated(&self) -> bool {
        self.email_is_validated.unwrap_or(false)
    }

    pub fn clear_email_is_validated(&mut self) {
        self.email_is_validated = ::std::option::Option::None;
    }

    pub fn has_email_is_validated(&self) -> bool {
        self.email_is_validated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_is_validated(&mut self, v: bool) {
        self.email_is_validated = ::std::option::Option::Some(v);
    }

    // optional bool email_validation_changed = 3;

    pub fn get_email_validation_changed(&self) -> bool {
        self.email_validation_changed.unwrap_or(false)
    }

    pub fn clear_email_validation_changed(&mut self) {
        self.email_validation_changed = ::std::option::Option::None;
    }

    pub fn has_email_validation_changed(&self) -> bool {
        self.email_validation_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_validation_changed(&mut self, v: bool) {
        self.email_validation_changed = ::std::option::Option::Some(v);
    }

    // optional bool credential_change_requires_code = 4;

    pub fn get_credential_change_requires_code(&self) -> bool {
        self.credential_change_requires_code.unwrap_or(false)
    }

    pub fn clear_credential_change_requires_code(&mut self) {
        self.credential_change_requires_code = ::std::option::Option::None;
    }

    pub fn has_credential_change_requires_code(&self) -> bool {
        self.credential_change_requires_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_change_requires_code(&mut self, v: bool) {
        self.credential_change_requires_code = ::std::option::Option::Some(v);
    }

    // optional bool password_or_secretqa_change_requires_code = 5;

    pub fn get_password_or_secretqa_change_requires_code(&self) -> bool {
        self.password_or_secretqa_change_requires_code.unwrap_or(false)
    }

    pub fn clear_password_or_secretqa_change_requires_code(&mut self) {
        self.password_or_secretqa_change_requires_code = ::std::option::Option::None;
    }

    pub fn has_password_or_secretqa_change_requires_code(&self) -> bool {
        self.password_or_secretqa_change_requires_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_or_secretqa_change_requires_code(&mut self, v: bool) {
        self.password_or_secretqa_change_requires_code = ::std::option::Option::Some(v);
    }

    // optional bool remind_user_about_email = 6;

    pub fn get_remind_user_about_email(&self) -> bool {
        self.remind_user_about_email.unwrap_or(false)
    }

    pub fn clear_remind_user_about_email(&mut self) {
        self.remind_user_about_email = ::std::option::Option::None;
    }

    pub fn has_remind_user_about_email(&self) -> bool {
        self.remind_user_about_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remind_user_about_email(&mut self, v: bool) {
        self.remind_user_about_email = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientEmailAddrInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.email_is_validated = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.email_validation_changed = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.credential_change_requires_code = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.password_or_secretqa_change_requires_code = ::std::option::Option::Some(is.read_bool()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.remind_user_about_email = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.email_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.email_is_validated {
            my_size += 2;
        }
        if let Some(v) = self.email_validation_changed {
            my_size += 2;
        }
        if let Some(v) = self.credential_change_requires_code {
            my_size += 2;
        }
        if let Some(v) = self.password_or_secretqa_change_requires_code {
            my_size += 2;
        }
        if let Some(v) = self.remind_user_about_email {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.email_address.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.email_is_validated {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.email_validation_changed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.credential_change_requires_code {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.password_or_secretqa_change_requires_code {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.remind_user_about_email {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientEmailAddrInfo {
        CMsgClientEmailAddrInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "email_address",
                |m: &CMsgClientEmailAddrInfo| { &m.email_address },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_address },
                CMsgClientEmailAddrInfo::get_email_address,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "email_is_validated",
                |m: &CMsgClientEmailAddrInfo| { &m.email_is_validated },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_is_validated },
                CMsgClientEmailAddrInfo::get_email_is_validated,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "email_validation_changed",
                |m: &CMsgClientEmailAddrInfo| { &m.email_validation_changed },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_validation_changed },
                CMsgClientEmailAddrInfo::get_email_validation_changed,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "credential_change_requires_code",
                |m: &CMsgClientEmailAddrInfo| { &m.credential_change_requires_code },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.credential_change_requires_code },
                CMsgClientEmailAddrInfo::get_credential_change_requires_code,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "password_or_secretqa_change_requires_code",
                |m: &CMsgClientEmailAddrInfo| { &m.password_or_secretqa_change_requires_code },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.password_or_secretqa_change_requires_code },
                CMsgClientEmailAddrInfo::get_password_or_secretqa_change_requires_code,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "remind_user_about_email",
                |m: &CMsgClientEmailAddrInfo| { &m.remind_user_about_email },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.remind_user_about_email },
                CMsgClientEmailAddrInfo::get_remind_user_about_email,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientEmailAddrInfo>(
                "CMsgClientEmailAddrInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientEmailAddrInfo {
        static instance: ::protobuf::rt::Lazy<CMsgClientEmailAddrInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientEmailAddrInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientEmailAddrInfo {
    fn clear(&mut self) {
        self.email_address.clear();
        self.email_is_validated = ::std::option::Option::None;
        self.email_validation_changed = ::std::option::Option::None;
        self.credential_change_requires_code = ::std::option::Option::None;
        self.password_or_secretqa_change_requires_code = ::std::option::Option::None;
        self.remind_user_about_email = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientEmailAddrInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientEmailAddrInfo {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREEnumeratePublishedFiles {
    // message fields
    app_id: ::std::option::Option<u32>,
    query_type: ::std::option::Option<i32>,
    start_index: ::std::option::Option<u32>,
    days: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub user_tags: ::protobuf::RepeatedField<::std::string::String>,
    matching_file_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREEnumeratePublishedFiles {
    fn default() -> &'a CMsgCREEnumeratePublishedFiles {
        <CMsgCREEnumeratePublishedFiles as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREEnumeratePublishedFiles {
    pub fn new() -> CMsgCREEnumeratePublishedFiles {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 query_type = 2;

    pub fn get_query_type(&self) -> i32 {
        self.query_type.unwrap_or(0)
    }

    pub fn clear_query_type(&mut self) {
        self.query_type = ::std::option::Option::None;
    }

    pub fn has_query_type(&self) -> bool {
        self.query_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_type(&mut self, v: i32) {
        self.query_type = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 3;

    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 days = 4;

    pub fn get_days(&self) -> u32 {
        self.days.unwrap_or(0)
    }

    pub fn clear_days(&mut self) {
        self.days = ::std::option::Option::None;
    }

    pub fn has_days(&self) -> bool {
        self.days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_days(&mut self, v: u32) {
        self.days = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 5;

    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_file_type = 8;

    pub fn get_matching_file_type(&self) -> u32 {
        self.matching_file_type.unwrap_or(13u32)
    }

    pub fn clear_matching_file_type(&mut self) {
        self.matching_file_type = ::std::option::Option::None;
    }

    pub fn has_matching_file_type(&self) -> bool {
        self.matching_file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_file_type(&mut self, v: u32) {
        self.matching_file_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREEnumeratePublishedFiles {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_type = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.days = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_tags)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.matching_file_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.query_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.days {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.user_tags {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.matching_file_type {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.query_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.days {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(5, v)?;
        }
        for v in &self.tags {
            os.write_string(6, &v)?;
        };
        for v in &self.user_tags {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.matching_file_type {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREEnumeratePublishedFiles {
        CMsgCREEnumeratePublishedFiles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CMsgCREEnumeratePublishedFiles| { &m.app_id },
                |m: &mut CMsgCREEnumeratePublishedFiles| { &mut m.app_id },
                CMsgCREEnumeratePublishedFiles::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "query_type",
                |m: &CMsgCREEnumeratePublishedFiles| { &m.query_type },
                |m: &mut CMsgCREEnumeratePublishedFiles| { &mut m.query_type },
                CMsgCREEnumeratePublishedFiles::get_query_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "start_index",
                |m: &CMsgCREEnumeratePublishedFiles| { &m.start_index },
                |m: &mut CMsgCREEnumeratePublishedFiles| { &mut m.start_index },
                CMsgCREEnumeratePublishedFiles::get_start_index,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "days",
                |m: &CMsgCREEnumeratePublishedFiles| { &m.days },
                |m: &mut CMsgCREEnumeratePublishedFiles| { &mut m.days },
                CMsgCREEnumeratePublishedFiles::get_days,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "count",
                |m: &CMsgCREEnumeratePublishedFiles| { &m.count },
                |m: &mut CMsgCREEnumeratePublishedFiles| { &mut m.count },
                CMsgCREEnumeratePublishedFiles::get_count,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "tags",
                |m: &CMsgCREEnumeratePublishedFiles| { &m.tags },
                |m: &mut CMsgCREEnumeratePublishedFiles| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "user_tags",
                |m: &CMsgCREEnumeratePublishedFiles| { &m.user_tags },
                |m: &mut CMsgCREEnumeratePublishedFiles| { &mut m.user_tags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "matching_file_type",
                |m: &CMsgCREEnumeratePublishedFiles| { &m.matching_file_type },
                |m: &mut CMsgCREEnumeratePublishedFiles| { &mut m.matching_file_type },
                CMsgCREEnumeratePublishedFiles::get_matching_file_type,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgCREEnumeratePublishedFiles>(
                "CMsgCREEnumeratePublishedFiles",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREEnumeratePublishedFiles {
        static instance: ::protobuf::rt::Lazy<CMsgCREEnumeratePublishedFiles> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgCREEnumeratePublishedFiles::new)
    }
}

impl ::protobuf::Clear for CMsgCREEnumeratePublishedFiles {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.query_type = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.days = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.tags.clear();
        self.user_tags.clear();
        self.matching_file_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREEnumeratePublishedFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREEnumeratePublishedFiles {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREEnumeratePublishedFilesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub published_files: ::protobuf::RepeatedField<cmsg_creenumerate_published_files_response::PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREEnumeratePublishedFilesResponse {
    fn default() -> &'a CMsgCREEnumeratePublishedFilesResponse {
        <CMsgCREEnumeratePublishedFilesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREEnumeratePublishedFilesResponse {
    pub fn new() -> CMsgCREEnumeratePublishedFilesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 3;

    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREEnumeratePublishedFilesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.published_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.published_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREEnumeratePublishedFilesResponse {
        CMsgCREEnumeratePublishedFilesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgCREEnumeratePublishedFilesResponse| { &m.eresult },
                |m: &mut CMsgCREEnumeratePublishedFilesResponse| { &mut m.eresult },
                CMsgCREEnumeratePublishedFilesResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_creenumerate_published_files_response::PublishedFileId>>(
                "published_files",
                |m: &CMsgCREEnumeratePublishedFilesResponse| { &m.published_files },
                |m: &mut CMsgCREEnumeratePublishedFilesResponse| { &mut m.published_files },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "total_results",
                |m: &CMsgCREEnumeratePublishedFilesResponse| { &m.total_results },
                |m: &mut CMsgCREEnumeratePublishedFilesResponse| { &mut m.total_results },
                CMsgCREEnumeratePublishedFilesResponse::get_total_results,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgCREEnumeratePublishedFilesResponse>(
                "CMsgCREEnumeratePublishedFilesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREEnumeratePublishedFilesResponse {
        static instance: ::protobuf::rt::Lazy<CMsgCREEnumeratePublishedFilesResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgCREEnumeratePublishedFilesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgCREEnumeratePublishedFilesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREEnumeratePublishedFilesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREEnumeratePublishedFilesResponse {
}

/// Nested message and enums of message `CMsgCREEnumeratePublishedFilesResponse`
pub mod cmsg_creenumerate_published_files_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct PublishedFileId {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        votes_for: ::std::option::Option<i32>,
        votes_against: ::std::option::Option<i32>,
        reports: ::std::option::Option<i32>,
        score: ::std::option::Option<f32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional int32 votes_for = 2;

        pub fn get_votes_for(&self) -> i32 {
            self.votes_for.unwrap_or(0)
        }

        pub fn clear_votes_for(&mut self) {
            self.votes_for = ::std::option::Option::None;
        }

        pub fn has_votes_for(&self) -> bool {
            self.votes_for.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_for(&mut self, v: i32) {
            self.votes_for = ::std::option::Option::Some(v);
        }

        // optional int32 votes_against = 3;

        pub fn get_votes_against(&self) -> i32 {
            self.votes_against.unwrap_or(0)
        }

        pub fn clear_votes_against(&mut self) {
            self.votes_against = ::std::option::Option::None;
        }

        pub fn has_votes_against(&self) -> bool {
            self.votes_against.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_against(&mut self, v: i32) {
            self.votes_against = ::std::option::Option::Some(v);
        }

        // optional int32 reports = 4;

        pub fn get_reports(&self) -> i32 {
            self.reports.unwrap_or(0)
        }

        pub fn clear_reports(&mut self) {
            self.reports = ::std::option::Option::None;
        }

        pub fn has_reports(&self) -> bool {
            self.reports.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reports(&mut self, v: i32) {
            self.reports = ::std::option::Option::Some(v);
        }

        // optional float score = 5;

        pub fn get_score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.votes_for = ::std::option::Option::Some(is.read_int32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.votes_against = ::std::option::Option::Some(is.read_int32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.reports = ::std::option::Option::Some(is.read_int32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.votes_for {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.votes_against {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.reports {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.score {
                my_size += 5;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.votes_for {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.votes_against {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.reports {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.score {
                os.write_float(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &PublishedFileId| { &m.published_file_id },
                    |m: &mut PublishedFileId| { &mut m.published_file_id },
                    PublishedFileId::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "votes_for",
                    |m: &PublishedFileId| { &m.votes_for },
                    |m: &mut PublishedFileId| { &mut m.votes_for },
                    PublishedFileId::get_votes_for,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "votes_against",
                    |m: &PublishedFileId| { &m.votes_against },
                    |m: &mut PublishedFileId| { &mut m.votes_against },
                    PublishedFileId::get_votes_against,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "reports",
                    |m: &PublishedFileId| { &m.reports },
                    |m: &mut PublishedFileId| { &mut m.reports },
                    PublishedFileId::get_reports,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                    "score",
                    |m: &PublishedFileId| { &m.score },
                    |m: &mut PublishedFileId| { &mut m.score },
                    PublishedFileId::get_score,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileId>(
                    "CMsgCREEnumeratePublishedFilesResponse.PublishedFileId",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: ::protobuf::rt::Lazy<PublishedFileId> = ::protobuf::rt::Lazy::INIT;
            instance.get(PublishedFileId::new)
        }
    }

    impl ::protobuf::Clear for PublishedFileId {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.votes_for = ::std::option::Option::None;
            self.votes_against = ::std::option::Option::None;
            self.reports = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREItemVoteSummary {
    // message fields
    pub published_file_ids: ::protobuf::RepeatedField<cmsg_creitem_vote_summary::PublishedFileId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummary {
    fn default() -> &'a CMsgCREItemVoteSummary {
        <CMsgCREItemVoteSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummary {
    pub fn new() -> CMsgCREItemVoteSummary {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgCREItemVoteSummary {
    fn is_initialized(&self) -> bool {
        for v in &self.published_file_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.published_file_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.published_file_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.published_file_ids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREItemVoteSummary {
        CMsgCREItemVoteSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_creitem_vote_summary::PublishedFileId>>(
                "published_file_ids",
                |m: &CMsgCREItemVoteSummary| { &m.published_file_ids },
                |m: &mut CMsgCREItemVoteSummary| { &mut m.published_file_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgCREItemVoteSummary>(
                "CMsgCREItemVoteSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummary {
        static instance: ::protobuf::rt::Lazy<CMsgCREItemVoteSummary> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgCREItemVoteSummary::new)
    }
}

impl ::protobuf::Clear for CMsgCREItemVoteSummary {
    fn clear(&mut self) {
        self.published_file_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREItemVoteSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREItemVoteSummary {
}

/// Nested message and enums of message `CMsgCREItemVoteSummary`
pub mod cmsg_creitem_vote_summary {
    #[derive(PartialEq,Clone,Default)]
    pub struct PublishedFileId {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &PublishedFileId| { &m.published_file_id },
                    |m: &mut PublishedFileId| { &mut m.published_file_id },
                    PublishedFileId::get_published_file_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileId>(
                    "CMsgCREItemVoteSummary.PublishedFileId",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: ::protobuf::rt::Lazy<PublishedFileId> = ::protobuf::rt::Lazy::INIT;
            instance.get(PublishedFileId::new)
        }
    }

    impl ::protobuf::Clear for PublishedFileId {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREItemVoteSummaryResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub item_vote_summaries: ::protobuf::RepeatedField<cmsg_creitem_vote_summary_response::ItemVoteSummary>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummaryResponse {
    fn default() -> &'a CMsgCREItemVoteSummaryResponse {
        <CMsgCREItemVoteSummaryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummaryResponse {
    pub fn new() -> CMsgCREItemVoteSummaryResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREItemVoteSummaryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.item_vote_summaries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.item_vote_summaries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_vote_summaries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.item_vote_summaries {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREItemVoteSummaryResponse {
        CMsgCREItemVoteSummaryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgCREItemVoteSummaryResponse| { &m.eresult },
                |m: &mut CMsgCREItemVoteSummaryResponse| { &mut m.eresult },
                CMsgCREItemVoteSummaryResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_creitem_vote_summary_response::ItemVoteSummary>>(
                "item_vote_summaries",
                |m: &CMsgCREItemVoteSummaryResponse| { &m.item_vote_summaries },
                |m: &mut CMsgCREItemVoteSummaryResponse| { &mut m.item_vote_summaries },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgCREItemVoteSummaryResponse>(
                "CMsgCREItemVoteSummaryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummaryResponse {
        static instance: ::protobuf::rt::Lazy<CMsgCREItemVoteSummaryResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgCREItemVoteSummaryResponse::new)
    }
}

impl ::protobuf::Clear for CMsgCREItemVoteSummaryResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.item_vote_summaries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREItemVoteSummaryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREItemVoteSummaryResponse {
}

/// Nested message and enums of message `CMsgCREItemVoteSummaryResponse`
pub mod cmsg_creitem_vote_summary_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct ItemVoteSummary {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        votes_for: ::std::option::Option<i32>,
        votes_against: ::std::option::Option<i32>,
        reports: ::std::option::Option<i32>,
        score: ::std::option::Option<f32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a ItemVoteSummary {
        fn default() -> &'a ItemVoteSummary {
            <ItemVoteSummary as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemVoteSummary {
        pub fn new() -> ItemVoteSummary {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional int32 votes_for = 2;

        pub fn get_votes_for(&self) -> i32 {
            self.votes_for.unwrap_or(0)
        }

        pub fn clear_votes_for(&mut self) {
            self.votes_for = ::std::option::Option::None;
        }

        pub fn has_votes_for(&self) -> bool {
            self.votes_for.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_for(&mut self, v: i32) {
            self.votes_for = ::std::option::Option::Some(v);
        }

        // optional int32 votes_against = 3;

        pub fn get_votes_against(&self) -> i32 {
            self.votes_against.unwrap_or(0)
        }

        pub fn clear_votes_against(&mut self) {
            self.votes_against = ::std::option::Option::None;
        }

        pub fn has_votes_against(&self) -> bool {
            self.votes_against.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_against(&mut self, v: i32) {
            self.votes_against = ::std::option::Option::Some(v);
        }

        // optional int32 reports = 4;

        pub fn get_reports(&self) -> i32 {
            self.reports.unwrap_or(0)
        }

        pub fn clear_reports(&mut self) {
            self.reports = ::std::option::Option::None;
        }

        pub fn has_reports(&self) -> bool {
            self.reports.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reports(&mut self, v: i32) {
            self.reports = ::std::option::Option::Some(v);
        }

        // optional float score = 5;

        pub fn get_score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ItemVoteSummary {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.votes_for = ::std::option::Option::Some(is.read_int32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.votes_against = ::std::option::Option::Some(is.read_int32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.reports = ::std::option::Option::Some(is.read_int32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.votes_for {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.votes_against {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.reports {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.score {
                my_size += 5;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.votes_for {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.votes_against {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.reports {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.score {
                os.write_float(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> ItemVoteSummary {
            ItemVoteSummary::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &ItemVoteSummary| { &m.published_file_id },
                    |m: &mut ItemVoteSummary| { &mut m.published_file_id },
                    ItemVoteSummary::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "votes_for",
                    |m: &ItemVoteSummary| { &m.votes_for },
                    |m: &mut ItemVoteSummary| { &mut m.votes_for },
                    ItemVoteSummary::get_votes_for,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "votes_against",
                    |m: &ItemVoteSummary| { &m.votes_against },
                    |m: &mut ItemVoteSummary| { &mut m.votes_against },
                    ItemVoteSummary::get_votes_against,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "reports",
                    |m: &ItemVoteSummary| { &m.reports },
                    |m: &mut ItemVoteSummary| { &mut m.reports },
                    ItemVoteSummary::get_reports,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                    "score",
                    |m: &ItemVoteSummary| { &m.score },
                    |m: &mut ItemVoteSummary| { &mut m.score },
                    ItemVoteSummary::get_score,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ItemVoteSummary>(
                    "CMsgCREItemVoteSummaryResponse.ItemVoteSummary",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static ItemVoteSummary {
            static instance: ::protobuf::rt::Lazy<ItemVoteSummary> = ::protobuf::rt::Lazy::INIT;
            instance.get(ItemVoteSummary::new)
        }
    }

    impl ::protobuf::Clear for ItemVoteSummary {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.votes_for = ::std::option::Option::None;
            self.votes_against = ::std::option::Option::None;
            self.reports = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for ItemVoteSummary {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemVoteSummary {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREUpdateUserPublishedItemVote {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    vote_up: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREUpdateUserPublishedItemVote {
    fn default() -> &'a CMsgCREUpdateUserPublishedItemVote {
        <CMsgCREUpdateUserPublishedItemVote as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREUpdateUserPublishedItemVote {
    pub fn new() -> CMsgCREUpdateUserPublishedItemVote {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional bool vote_up = 2;

    pub fn get_vote_up(&self) -> bool {
        self.vote_up.unwrap_or(false)
    }

    pub fn clear_vote_up(&mut self) {
        self.vote_up = ::std::option::Option::None;
    }

    pub fn has_vote_up(&self) -> bool {
        self.vote_up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_up(&mut self, v: bool) {
        self.vote_up = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREUpdateUserPublishedItemVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vote_up = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.vote_up {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.vote_up {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREUpdateUserPublishedItemVote {
        CMsgCREUpdateUserPublishedItemVote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "published_file_id",
                |m: &CMsgCREUpdateUserPublishedItemVote| { &m.published_file_id },
                |m: &mut CMsgCREUpdateUserPublishedItemVote| { &mut m.published_file_id },
                CMsgCREUpdateUserPublishedItemVote::get_published_file_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "vote_up",
                |m: &CMsgCREUpdateUserPublishedItemVote| { &m.vote_up },
                |m: &mut CMsgCREUpdateUserPublishedItemVote| { &mut m.vote_up },
                CMsgCREUpdateUserPublishedItemVote::get_vote_up,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgCREUpdateUserPublishedItemVote>(
                "CMsgCREUpdateUserPublishedItemVote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREUpdateUserPublishedItemVote {
        static instance: ::protobuf::rt::Lazy<CMsgCREUpdateUserPublishedItemVote> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgCREUpdateUserPublishedItemVote::new)
    }
}

impl ::protobuf::Clear for CMsgCREUpdateUserPublishedItemVote {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.vote_up = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREUpdateUserPublishedItemVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREUpdateUserPublishedItemVote {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREUpdateUserPublishedItemVoteResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREUpdateUserPublishedItemVoteResponse {
    fn default() -> &'a CMsgCREUpdateUserPublishedItemVoteResponse {
        <CMsgCREUpdateUserPublishedItemVoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREUpdateUserPublishedItemVoteResponse {
    pub fn new() -> CMsgCREUpdateUserPublishedItemVoteResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREUpdateUserPublishedItemVoteResponse {
        CMsgCREUpdateUserPublishedItemVoteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgCREUpdateUserPublishedItemVoteResponse| { &m.eresult },
                |m: &mut CMsgCREUpdateUserPublishedItemVoteResponse| { &mut m.eresult },
                CMsgCREUpdateUserPublishedItemVoteResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgCREUpdateUserPublishedItemVoteResponse>(
                "CMsgCREUpdateUserPublishedItemVoteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREUpdateUserPublishedItemVoteResponse {
        static instance: ::protobuf::rt::Lazy<CMsgCREUpdateUserPublishedItemVoteResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgCREUpdateUserPublishedItemVoteResponse::new)
    }
}

impl ::protobuf::Clear for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREUpdateUserPublishedItemVoteResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREGetUserPublishedItemVoteDetails {
    // message fields
    pub published_file_ids: ::protobuf::RepeatedField<cmsg_creget_user_published_item_vote_details::PublishedFileId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetails {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetails {
        <CMsgCREGetUserPublishedItemVoteDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetails {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetails {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgCREGetUserPublishedItemVoteDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.published_file_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.published_file_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.published_file_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.published_file_ids {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetails {
        CMsgCREGetUserPublishedItemVoteDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_creget_user_published_item_vote_details::PublishedFileId>>(
                "published_file_ids",
                |m: &CMsgCREGetUserPublishedItemVoteDetails| { &m.published_file_ids },
                |m: &mut CMsgCREGetUserPublishedItemVoteDetails| { &mut m.published_file_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgCREGetUserPublishedItemVoteDetails>(
                "CMsgCREGetUserPublishedItemVoteDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetails {
        static instance: ::protobuf::rt::Lazy<CMsgCREGetUserPublishedItemVoteDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgCREGetUserPublishedItemVoteDetails::new)
    }
}

impl ::protobuf::Clear for CMsgCREGetUserPublishedItemVoteDetails {
    fn clear(&mut self) {
        self.published_file_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREGetUserPublishedItemVoteDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREGetUserPublishedItemVoteDetails {
}

/// Nested message and enums of message `CMsgCREGetUserPublishedItemVoteDetails`
pub mod cmsg_creget_user_published_item_vote_details {
    #[derive(PartialEq,Clone,Default)]
    pub struct PublishedFileId {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PublishedFileId {
        fn default() -> &'a PublishedFileId {
            <PublishedFileId as ::protobuf::Message>::default_instance()
        }
    }

    impl PublishedFileId {
        pub fn new() -> PublishedFileId {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PublishedFileId {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PublishedFileId {
            PublishedFileId::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &PublishedFileId| { &m.published_file_id },
                    |m: &mut PublishedFileId| { &mut m.published_file_id },
                    PublishedFileId::get_published_file_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileId>(
                    "CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PublishedFileId {
            static instance: ::protobuf::rt::Lazy<PublishedFileId> = ::protobuf::rt::Lazy::INIT;
            instance.get(PublishedFileId::new)
        }
    }

    impl ::protobuf::Clear for PublishedFileId {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PublishedFileId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PublishedFileId {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREGetUserPublishedItemVoteDetailsResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub user_item_vote_details: ::protobuf::RepeatedField<cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetailsResponse {
        <CMsgCREGetUserPublishedItemVoteDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetailsResponse {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.user_item_vote_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.user_item_vote_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.user_item_vote_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.user_item_vote_details {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse {
        CMsgCREGetUserPublishedItemVoteDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgCREGetUserPublishedItemVoteDetailsResponse| { &m.eresult },
                |m: &mut CMsgCREGetUserPublishedItemVoteDetailsResponse| { &mut m.eresult },
                CMsgCREGetUserPublishedItemVoteDetailsResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_creget_user_published_item_vote_details_response::UserItemVoteDetail>>(
                "user_item_vote_details",
                |m: &CMsgCREGetUserPublishedItemVoteDetailsResponse| { &m.user_item_vote_details },
                |m: &mut CMsgCREGetUserPublishedItemVoteDetailsResponse| { &mut m.user_item_vote_details },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgCREGetUserPublishedItemVoteDetailsResponse>(
                "CMsgCREGetUserPublishedItemVoteDetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetailsResponse {
        static instance: ::protobuf::rt::Lazy<CMsgCREGetUserPublishedItemVoteDetailsResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgCREGetUserPublishedItemVoteDetailsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.user_item_vote_details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREGetUserPublishedItemVoteDetailsResponse {
}

/// Nested message and enums of message `CMsgCREGetUserPublishedItemVoteDetailsResponse`
pub mod cmsg_creget_user_published_item_vote_details_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct UserItemVoteDetail {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        vote: ::std::option::Option<i32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a UserItemVoteDetail {
        fn default() -> &'a UserItemVoteDetail {
            <UserItemVoteDetail as ::protobuf::Message>::default_instance()
        }
    }

    impl UserItemVoteDetail {
        pub fn new() -> UserItemVoteDetail {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional int32 vote = 2;

        pub fn get_vote(&self) -> i32 {
            self.vote.unwrap_or(0i32)
        }

        pub fn clear_vote(&mut self) {
            self.vote = ::std::option::Option::None;
        }

        pub fn has_vote(&self) -> bool {
            self.vote.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote(&mut self, v: i32) {
            self.vote = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for UserItemVoteDetail {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.vote = ::std::option::Option::Some(is.read_int32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.vote {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.vote {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> UserItemVoteDetail {
            UserItemVoteDetail::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &UserItemVoteDetail| { &m.published_file_id },
                    |m: &mut UserItemVoteDetail| { &mut m.published_file_id },
                    UserItemVoteDetail::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "vote",
                    |m: &UserItemVoteDetail| { &m.vote },
                    |m: &mut UserItemVoteDetail| { &mut m.vote },
                    UserItemVoteDetail::get_vote,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserItemVoteDetail>(
                    "CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static UserItemVoteDetail {
            static instance: ::protobuf::rt::Lazy<UserItemVoteDetail> = ::protobuf::rt::Lazy::INIT;
            instance.get(UserItemVoteDetail::new)
        }
    }

    impl ::protobuf::Clear for UserItemVoteDetail {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.vote = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for UserItemVoteDetail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserItemVoteDetail {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerPingSample {
    // message fields
    my_ip: ::std::option::Option<u32>,
    gs_app_id: ::std::option::Option<i32>,
    pub gs_samples: ::protobuf::RepeatedField<cmsg_game_server_ping_sample::Sample>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerPingSample {
    fn default() -> &'a CMsgGameServerPingSample {
        <CMsgGameServerPingSample as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerPingSample {
    pub fn new() -> CMsgGameServerPingSample {
        ::std::default::Default::default()
    }

    // optional fixed32 my_ip = 1;

    pub fn get_my_ip(&self) -> u32 {
        self.my_ip.unwrap_or(0)
    }

    pub fn clear_my_ip(&mut self) {
        self.my_ip = ::std::option::Option::None;
    }

    pub fn has_my_ip(&self) -> bool {
        self.my_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_ip(&mut self, v: u32) {
        self.my_ip = ::std::option::Option::Some(v);
    }

    // optional int32 gs_app_id = 2;

    pub fn get_gs_app_id(&self) -> i32 {
        self.gs_app_id.unwrap_or(0)
    }

    pub fn clear_gs_app_id(&mut self) {
        self.gs_app_id = ::std::option::Option::None;
    }

    pub fn has_gs_app_id(&self) -> bool {
        self.gs_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gs_app_id(&mut self, v: i32) {
        self.gs_app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameServerPingSample {
    fn is_initialized(&self) -> bool {
        for v in &self.gs_samples {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.my_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.gs_app_id = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.gs_samples)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.my_ip {
            my_size += 5;
        }
        if let Some(v) = self.gs_app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.gs_samples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.my_ip {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.gs_app_id {
            os.write_int32(2, v)?;
        }
        for v in &self.gs_samples {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerPingSample {
        CMsgGameServerPingSample::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "my_ip",
                |m: &CMsgGameServerPingSample| { &m.my_ip },
                |m: &mut CMsgGameServerPingSample| { &mut m.my_ip },
                CMsgGameServerPingSample::get_my_ip,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "gs_app_id",
                |m: &CMsgGameServerPingSample| { &m.gs_app_id },
                |m: &mut CMsgGameServerPingSample| { &mut m.gs_app_id },
                CMsgGameServerPingSample::get_gs_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_game_server_ping_sample::Sample>>(
                "gs_samples",
                |m: &CMsgGameServerPingSample| { &m.gs_samples },
                |m: &mut CMsgGameServerPingSample| { &mut m.gs_samples },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgGameServerPingSample>(
                "CMsgGameServerPingSample",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerPingSample {
        static instance: ::protobuf::rt::Lazy<CMsgGameServerPingSample> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgGameServerPingSample::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerPingSample {
    fn clear(&mut self) {
        self.my_ip = ::std::option::Option::None;
        self.gs_app_id = ::std::option::Option::None;
        self.gs_samples.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerPingSample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerPingSample {
}

/// Nested message and enums of message `CMsgGameServerPingSample`
pub mod cmsg_game_server_ping_sample {
    #[derive(PartialEq,Clone,Default)]
    pub struct Sample {
        // message fields
        ip: ::std::option::Option<u32>,
        avg_ping_ms: ::std::option::Option<u32>,
        stddev_ping_ms_x10: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Sample {
        fn default() -> &'a Sample {
            <Sample as ::protobuf::Message>::default_instance()
        }
    }

    impl Sample {
        pub fn new() -> Sample {
            ::std::default::Default::default()
        }

        // optional fixed32 ip = 1;

        pub fn get_ip(&self) -> u32 {
            self.ip.unwrap_or(0)
        }

        pub fn clear_ip(&mut self) {
            self.ip = ::std::option::Option::None;
        }

        pub fn has_ip(&self) -> bool {
            self.ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ip(&mut self, v: u32) {
            self.ip = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_ping_ms = 2;

        pub fn get_avg_ping_ms(&self) -> u32 {
            self.avg_ping_ms.unwrap_or(0)
        }

        pub fn clear_avg_ping_ms(&mut self) {
            self.avg_ping_ms = ::std::option::Option::None;
        }

        pub fn has_avg_ping_ms(&self) -> bool {
            self.avg_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_ping_ms(&mut self, v: u32) {
            self.avg_ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 stddev_ping_ms_x10 = 3;

        pub fn get_stddev_ping_ms_x10(&self) -> u32 {
            self.stddev_ping_ms_x10.unwrap_or(0)
        }

        pub fn clear_stddev_ping_ms_x10(&mut self) {
            self.stddev_ping_ms_x10 = ::std::option::Option::None;
        }

        pub fn has_stddev_ping_ms_x10(&self) -> bool {
            self.stddev_ping_ms_x10.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stddev_ping_ms_x10(&mut self, v: u32) {
            self.stddev_ping_ms_x10 = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Sample {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.avg_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.stddev_ping_ms_x10 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.ip {
                my_size += 5;
            }
            if let Some(v) = self.avg_ping_ms {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.stddev_ping_ms_x10 {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.ip {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.avg_ping_ms {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.stddev_ping_ms_x10 {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Sample {
            Sample::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                    "ip",
                    |m: &Sample| { &m.ip },
                    |m: &mut Sample| { &mut m.ip },
                    Sample::get_ip,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "avg_ping_ms",
                    |m: &Sample| { &m.avg_ping_ms },
                    |m: &mut Sample| { &mut m.avg_ping_ms },
                    Sample::get_avg_ping_ms,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "stddev_ping_ms_x10",
                    |m: &Sample| { &m.stddev_ping_ms_x10 },
                    |m: &mut Sample| { &mut m.stddev_ping_ms_x10 },
                    Sample::get_stddev_ping_ms_x10,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Sample>(
                    "CMsgGameServerPingSample.Sample",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Sample {
            static instance: ::protobuf::rt::Lazy<Sample> = ::protobuf::rt::Lazy::INIT;
            instance.get(Sample::new)
        }
    }

    impl ::protobuf::Clear for Sample {
        fn clear(&mut self) {
            self.ip = ::std::option::Option::None;
            self.avg_ping_ms = ::std::option::Option::None;
            self.stddev_ping_ms_x10 = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Sample {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sample {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSGetFollowerCount {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetFollowerCount {
    fn default() -> &'a CMsgFSGetFollowerCount {
        <CMsgFSGetFollowerCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetFollowerCount {
    pub fn new() -> CMsgFSGetFollowerCount {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetFollowerCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSGetFollowerCount {
        CMsgFSGetFollowerCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id",
                |m: &CMsgFSGetFollowerCount| { &m.steam_id },
                |m: &mut CMsgFSGetFollowerCount| { &mut m.steam_id },
                CMsgFSGetFollowerCount::get_steam_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgFSGetFollowerCount>(
                "CMsgFSGetFollowerCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSGetFollowerCount {
        static instance: ::protobuf::rt::Lazy<CMsgFSGetFollowerCount> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgFSGetFollowerCount::new)
    }
}

impl ::protobuf::Clear for CMsgFSGetFollowerCount {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSGetFollowerCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetFollowerCount {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSGetFollowerCountResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    count: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetFollowerCountResponse {
    fn default() -> &'a CMsgFSGetFollowerCountResponse {
        <CMsgFSGetFollowerCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetFollowerCountResponse {
    pub fn new() -> CMsgFSGetFollowerCountResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 count = 2;

    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0i32)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetFollowerCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSGetFollowerCountResponse {
        CMsgFSGetFollowerCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgFSGetFollowerCountResponse| { &m.eresult },
                |m: &mut CMsgFSGetFollowerCountResponse| { &mut m.eresult },
                CMsgFSGetFollowerCountResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "count",
                |m: &CMsgFSGetFollowerCountResponse| { &m.count },
                |m: &mut CMsgFSGetFollowerCountResponse| { &mut m.count },
                CMsgFSGetFollowerCountResponse::get_count,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgFSGetFollowerCountResponse>(
                "CMsgFSGetFollowerCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSGetFollowerCountResponse {
        static instance: ::protobuf::rt::Lazy<CMsgFSGetFollowerCountResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgFSGetFollowerCountResponse::new)
    }
}

impl ::protobuf::Clear for CMsgFSGetFollowerCountResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSGetFollowerCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetFollowerCountResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSGetIsFollowing {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetIsFollowing {
    fn default() -> &'a CMsgFSGetIsFollowing {
        <CMsgFSGetIsFollowing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetIsFollowing {
    pub fn new() -> CMsgFSGetIsFollowing {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetIsFollowing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSGetIsFollowing {
        CMsgFSGetIsFollowing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steam_id",
                |m: &CMsgFSGetIsFollowing| { &m.steam_id },
                |m: &mut CMsgFSGetIsFollowing| { &mut m.steam_id },
                CMsgFSGetIsFollowing::get_steam_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgFSGetIsFollowing>(
                "CMsgFSGetIsFollowing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSGetIsFollowing {
        static instance: ::protobuf::rt::Lazy<CMsgFSGetIsFollowing> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgFSGetIsFollowing::new)
    }
}

impl ::protobuf::Clear for CMsgFSGetIsFollowing {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSGetIsFollowing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetIsFollowing {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSGetIsFollowingResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    is_following: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetIsFollowingResponse {
    fn default() -> &'a CMsgFSGetIsFollowingResponse {
        <CMsgFSGetIsFollowingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetIsFollowingResponse {
    pub fn new() -> CMsgFSGetIsFollowingResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool is_following = 2;

    pub fn get_is_following(&self) -> bool {
        self.is_following.unwrap_or(false)
    }

    pub fn clear_is_following(&mut self) {
        self.is_following = ::std::option::Option::None;
    }

    pub fn has_is_following(&self) -> bool {
        self.is_following.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_following(&mut self, v: bool) {
        self.is_following = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetIsFollowingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_following = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_following {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.is_following {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSGetIsFollowingResponse {
        CMsgFSGetIsFollowingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgFSGetIsFollowingResponse| { &m.eresult },
                |m: &mut CMsgFSGetIsFollowingResponse| { &mut m.eresult },
                CMsgFSGetIsFollowingResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_following",
                |m: &CMsgFSGetIsFollowingResponse| { &m.is_following },
                |m: &mut CMsgFSGetIsFollowingResponse| { &mut m.is_following },
                CMsgFSGetIsFollowingResponse::get_is_following,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgFSGetIsFollowingResponse>(
                "CMsgFSGetIsFollowingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSGetIsFollowingResponse {
        static instance: ::protobuf::rt::Lazy<CMsgFSGetIsFollowingResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgFSGetIsFollowingResponse::new)
    }
}

impl ::protobuf::Clear for CMsgFSGetIsFollowingResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.is_following = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSGetIsFollowingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetIsFollowingResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSEnumerateFollowingList {
    // message fields
    start_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSEnumerateFollowingList {
    fn default() -> &'a CMsgFSEnumerateFollowingList {
        <CMsgFSEnumerateFollowingList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSEnumerateFollowingList {
    pub fn new() -> CMsgFSEnumerateFollowingList {
        ::std::default::Default::default()
    }

    // optional uint32 start_index = 1;

    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }

    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSEnumerateFollowingList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSEnumerateFollowingList {
        CMsgFSEnumerateFollowingList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "start_index",
                |m: &CMsgFSEnumerateFollowingList| { &m.start_index },
                |m: &mut CMsgFSEnumerateFollowingList| { &mut m.start_index },
                CMsgFSEnumerateFollowingList::get_start_index,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgFSEnumerateFollowingList>(
                "CMsgFSEnumerateFollowingList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSEnumerateFollowingList {
        static instance: ::protobuf::rt::Lazy<CMsgFSEnumerateFollowingList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgFSEnumerateFollowingList::new)
    }
}

impl ::protobuf::Clear for CMsgFSEnumerateFollowingList {
    fn clear(&mut self) {
        self.start_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSEnumerateFollowingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSEnumerateFollowingList {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSEnumerateFollowingListResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    total_results: ::std::option::Option<i32>,
    pub steam_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSEnumerateFollowingListResponse {
    fn default() -> &'a CMsgFSEnumerateFollowingListResponse {
        <CMsgFSEnumerateFollowingListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSEnumerateFollowingListResponse {
    pub fn new() -> CMsgFSEnumerateFollowingListResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 total_results = 2;

    pub fn get_total_results(&self) -> i32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: i32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSEnumerateFollowingListResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_results = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steam_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 9 * self.steam_ids.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.total_results {
            os.write_int32(2, v)?;
        }
        for v in &self.steam_ids {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSEnumerateFollowingListResponse {
        CMsgFSEnumerateFollowingListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgFSEnumerateFollowingListResponse| { &m.eresult },
                |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.eresult },
                CMsgFSEnumerateFollowingListResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "total_results",
                |m: &CMsgFSEnumerateFollowingListResponse| { &m.total_results },
                |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.total_results },
                CMsgFSEnumerateFollowingListResponse::get_total_results,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "steam_ids",
                |m: &CMsgFSEnumerateFollowingListResponse| { &m.steam_ids },
                |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.steam_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgFSEnumerateFollowingListResponse>(
                "CMsgFSEnumerateFollowingListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSEnumerateFollowingListResponse {
        static instance: ::protobuf::rt::Lazy<CMsgFSEnumerateFollowingListResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgFSEnumerateFollowingListResponse::new)
    }
}

impl ::protobuf::Clear for CMsgFSEnumerateFollowingListResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.total_results = ::std::option::Option::None;
        self.steam_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSEnumerateFollowingListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSEnumerateFollowingListResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDPGetNumberOfCurrentPlayers {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDPGetNumberOfCurrentPlayers {
    fn default() -> &'a CMsgDPGetNumberOfCurrentPlayers {
        <CMsgDPGetNumberOfCurrentPlayers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDPGetNumberOfCurrentPlayers {
    pub fn new() -> CMsgDPGetNumberOfCurrentPlayers {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDPGetNumberOfCurrentPlayers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDPGetNumberOfCurrentPlayers {
        CMsgDPGetNumberOfCurrentPlayers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CMsgDPGetNumberOfCurrentPlayers| { &m.appid },
                |m: &mut CMsgDPGetNumberOfCurrentPlayers| { &mut m.appid },
                CMsgDPGetNumberOfCurrentPlayers::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgDPGetNumberOfCurrentPlayers>(
                "CMsgDPGetNumberOfCurrentPlayers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDPGetNumberOfCurrentPlayers {
        static instance: ::protobuf::rt::Lazy<CMsgDPGetNumberOfCurrentPlayers> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgDPGetNumberOfCurrentPlayers::new)
    }
}

impl ::protobuf::Clear for CMsgDPGetNumberOfCurrentPlayers {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDPGetNumberOfCurrentPlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDPGetNumberOfCurrentPlayers {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDPGetNumberOfCurrentPlayersResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    player_count: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDPGetNumberOfCurrentPlayersResponse {
    fn default() -> &'a CMsgDPGetNumberOfCurrentPlayersResponse {
        <CMsgDPGetNumberOfCurrentPlayersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDPGetNumberOfCurrentPlayersResponse {
    pub fn new() -> CMsgDPGetNumberOfCurrentPlayersResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 player_count = 2;

    pub fn get_player_count(&self) -> i32 {
        self.player_count.unwrap_or(0)
    }

    pub fn clear_player_count(&mut self) {
        self.player_count = ::std::option::Option::None;
    }

    pub fn has_player_count(&self) -> bool {
        self.player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_count(&mut self, v: i32) {
        self.player_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.player_count = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDPGetNumberOfCurrentPlayersResponse {
        CMsgDPGetNumberOfCurrentPlayersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgDPGetNumberOfCurrentPlayersResponse| { &m.eresult },
                |m: &mut CMsgDPGetNumberOfCurrentPlayersResponse| { &mut m.eresult },
                CMsgDPGetNumberOfCurrentPlayersResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "player_count",
                |m: &CMsgDPGetNumberOfCurrentPlayersResponse| { &m.player_count },
                |m: &mut CMsgDPGetNumberOfCurrentPlayersResponse| { &mut m.player_count },
                CMsgDPGetNumberOfCurrentPlayersResponse::get_player_count,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgDPGetNumberOfCurrentPlayersResponse>(
                "CMsgDPGetNumberOfCurrentPlayersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDPGetNumberOfCurrentPlayersResponse {
        static instance: ::protobuf::rt::Lazy<CMsgDPGetNumberOfCurrentPlayersResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgDPGetNumberOfCurrentPlayersResponse::new)
    }
}

impl ::protobuf::Clear for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.player_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDPGetNumberOfCurrentPlayersResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFriendUserStatusPublished {
    // message fields
    friend_steamid: ::std::option::Option<u64>,
    appid: ::std::option::Option<u32>,
    status_text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendUserStatusPublished {
    fn default() -> &'a CMsgClientFriendUserStatusPublished {
        <CMsgClientFriendUserStatusPublished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendUserStatusPublished {
    pub fn new() -> CMsgClientFriendUserStatusPublished {
        ::std::default::Default::default()
    }

    // optional fixed64 friend_steamid = 1;

    pub fn get_friend_steamid(&self) -> u64 {
        self.friend_steamid.unwrap_or(0)
    }

    pub fn clear_friend_steamid(&mut self) {
        self.friend_steamid = ::std::option::Option::None;
    }

    pub fn has_friend_steamid(&self) -> bool {
        self.friend_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_steamid(&mut self, v: u64) {
        self.friend_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 3;

    pub fn get_status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status_text(&mut self) {
        self.status_text.clear();
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text.set_default();
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientFriendUserStatusPublished {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.friend_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friend_steamid {
            my_size += 9;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friend_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.status_text.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendUserStatusPublished {
        CMsgClientFriendUserStatusPublished::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "friend_steamid",
                |m: &CMsgClientFriendUserStatusPublished| { &m.friend_steamid },
                |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.friend_steamid },
                CMsgClientFriendUserStatusPublished::get_friend_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CMsgClientFriendUserStatusPublished| { &m.appid },
                |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.appid },
                CMsgClientFriendUserStatusPublished::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "status_text",
                |m: &CMsgClientFriendUserStatusPublished| { &m.status_text },
                |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.status_text },
                CMsgClientFriendUserStatusPublished::get_status_text,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendUserStatusPublished>(
                "CMsgClientFriendUserStatusPublished",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendUserStatusPublished {
        static instance: ::protobuf::rt::Lazy<CMsgClientFriendUserStatusPublished> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientFriendUserStatusPublished::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendUserStatusPublished {
    fn clear(&mut self) {
        self.friend_steamid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.status_text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendUserStatusPublished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendUserStatusPublished {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServiceMethodLegacy {
    // message fields
    method_name: ::protobuf::SingularField<::std::string::String>,
    serialized_method: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    is_notification: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceMethodLegacy {
    fn default() -> &'a CMsgClientServiceMethodLegacy {
        <CMsgClientServiceMethodLegacy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceMethodLegacy {
    pub fn new() -> CMsgClientServiceMethodLegacy {
        ::std::default::Default::default()
    }

    // optional string method_name = 1;

    pub fn get_method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name.clear();
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name.set_default();
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes serialized_method = 2;

    pub fn get_serialized_method(&self) -> &[u8] {
        match self.serialized_method.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_method(&mut self) {
        self.serialized_method.clear();
    }

    pub fn has_serialized_method(&self) -> bool {
        self.serialized_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_method(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_method = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_method(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_method.is_none() {
            self.serialized_method.set_default();
        }
        self.serialized_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_method(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_method.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool is_notification = 3;

    pub fn get_is_notification(&self) -> bool {
        self.is_notification.unwrap_or(false)
    }

    pub fn clear_is_notification(&mut self) {
        self.is_notification = ::std::option::Option::None;
    }

    pub fn has_is_notification(&self) -> bool {
        self.is_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_notification(&mut self, v: bool) {
        self.is_notification = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServiceMethodLegacy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.method_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serialized_method)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.serialized_method.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.is_notification {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.serialized_method.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.is_notification {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServiceMethodLegacy {
        CMsgClientServiceMethodLegacy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "method_name",
                |m: &CMsgClientServiceMethodLegacy| { &m.method_name },
                |m: &mut CMsgClientServiceMethodLegacy| { &mut m.method_name },
                CMsgClientServiceMethodLegacy::get_method_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "serialized_method",
                |m: &CMsgClientServiceMethodLegacy| { &m.serialized_method },
                |m: &mut CMsgClientServiceMethodLegacy| { &mut m.serialized_method },
                CMsgClientServiceMethodLegacy::get_serialized_method,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_notification",
                |m: &CMsgClientServiceMethodLegacy| { &m.is_notification },
                |m: &mut CMsgClientServiceMethodLegacy| { &mut m.is_notification },
                CMsgClientServiceMethodLegacy::get_is_notification,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientServiceMethodLegacy>(
                "CMsgClientServiceMethodLegacy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServiceMethodLegacy {
        static instance: ::protobuf::rt::Lazy<CMsgClientServiceMethodLegacy> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientServiceMethodLegacy::new)
    }
}

impl ::protobuf::Clear for CMsgClientServiceMethodLegacy {
    fn clear(&mut self) {
        self.method_name.clear();
        self.serialized_method.clear();
        self.is_notification = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServiceMethodLegacy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceMethodLegacy {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServiceMethodLegacyResponse {
    // message fields
    method_name: ::protobuf::SingularField<::std::string::String>,
    serialized_method_response: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceMethodLegacyResponse {
    fn default() -> &'a CMsgClientServiceMethodLegacyResponse {
        <CMsgClientServiceMethodLegacyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceMethodLegacyResponse {
    pub fn new() -> CMsgClientServiceMethodLegacyResponse {
        ::std::default::Default::default()
    }

    // optional string method_name = 1;

    pub fn get_method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name.clear();
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name.set_default();
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes serialized_method_response = 2;

    pub fn get_serialized_method_response(&self) -> &[u8] {
        match self.serialized_method_response.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_method_response(&mut self) {
        self.serialized_method_response.clear();
    }

    pub fn has_serialized_method_response(&self) -> bool {
        self.serialized_method_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_method_response(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_method_response = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_method_response(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_method_response.is_none() {
            self.serialized_method_response.set_default();
        }
        self.serialized_method_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_method_response(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_method_response.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientServiceMethodLegacyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.method_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serialized_method_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.serialized_method_response.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.serialized_method_response.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServiceMethodLegacyResponse {
        CMsgClientServiceMethodLegacyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "method_name",
                |m: &CMsgClientServiceMethodLegacyResponse| { &m.method_name },
                |m: &mut CMsgClientServiceMethodLegacyResponse| { &mut m.method_name },
                CMsgClientServiceMethodLegacyResponse::get_method_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "serialized_method_response",
                |m: &CMsgClientServiceMethodLegacyResponse| { &m.serialized_method_response },
                |m: &mut CMsgClientServiceMethodLegacyResponse| { &mut m.serialized_method_response },
                CMsgClientServiceMethodLegacyResponse::get_serialized_method_response,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientServiceMethodLegacyResponse>(
                "CMsgClientServiceMethodLegacyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServiceMethodLegacyResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientServiceMethodLegacyResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientServiceMethodLegacyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientServiceMethodLegacyResponse {
    fn clear(&mut self) {
        self.method_name.clear();
        self.serialized_method_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServiceMethodLegacyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceMethodLegacyResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUIMode {
    // message fields
    uimode: ::std::option::Option<u32>,
    chat_mode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUIMode {
    fn default() -> &'a CMsgClientUIMode {
        <CMsgClientUIMode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUIMode {
    pub fn new() -> CMsgClientUIMode {
        ::std::default::Default::default()
    }

    // optional uint32 uimode = 1;

    pub fn get_uimode(&self) -> u32 {
        self.uimode.unwrap_or(0)
    }

    pub fn clear_uimode(&mut self) {
        self.uimode = ::std::option::Option::None;
    }

    pub fn has_uimode(&self) -> bool {
        self.uimode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uimode(&mut self, v: u32) {
        self.uimode = ::std::option::Option::Some(v);
    }

    // optional uint32 chat_mode = 2;

    pub fn get_chat_mode(&self) -> u32 {
        self.chat_mode.unwrap_or(0)
    }

    pub fn clear_chat_mode(&mut self) {
        self.chat_mode = ::std::option::Option::None;
    }

    pub fn has_chat_mode(&self) -> bool {
        self.chat_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_mode(&mut self, v: u32) {
        self.chat_mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUIMode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.uimode = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chat_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.uimode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_mode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.uimode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.chat_mode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUIMode {
        CMsgClientUIMode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "uimode",
                |m: &CMsgClientUIMode| { &m.uimode },
                |m: &mut CMsgClientUIMode| { &mut m.uimode },
                CMsgClientUIMode::get_uimode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "chat_mode",
                |m: &CMsgClientUIMode| { &m.chat_mode },
                |m: &mut CMsgClientUIMode| { &mut m.chat_mode },
                CMsgClientUIMode::get_chat_mode,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUIMode>(
                "CMsgClientUIMode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUIMode {
        static instance: ::protobuf::rt::Lazy<CMsgClientUIMode> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUIMode::new)
    }
}

impl ::protobuf::Clear for CMsgClientUIMode {
    fn clear(&mut self) {
        self.uimode = ::std::option::Option::None;
        self.chat_mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUIMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUIMode {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientVanityURLChangedNotification {
    // message fields
    vanity_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientVanityURLChangedNotification {
    fn default() -> &'a CMsgClientVanityURLChangedNotification {
        <CMsgClientVanityURLChangedNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVanityURLChangedNotification {
    pub fn new() -> CMsgClientVanityURLChangedNotification {
        ::std::default::Default::default()
    }

    // optional string vanity_url = 1;

    pub fn get_vanity_url(&self) -> &str {
        match self.vanity_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vanity_url(&mut self) {
        self.vanity_url.clear();
    }

    pub fn has_vanity_url(&self) -> bool {
        self.vanity_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vanity_url(&mut self, v: ::std::string::String) {
        self.vanity_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vanity_url(&mut self) -> &mut ::std::string::String {
        if self.vanity_url.is_none() {
            self.vanity_url.set_default();
        }
        self.vanity_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_vanity_url(&mut self) -> ::std::string::String {
        self.vanity_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientVanityURLChangedNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vanity_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.vanity_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.vanity_url.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientVanityURLChangedNotification {
        CMsgClientVanityURLChangedNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "vanity_url",
                |m: &CMsgClientVanityURLChangedNotification| { &m.vanity_url },
                |m: &mut CMsgClientVanityURLChangedNotification| { &mut m.vanity_url },
                CMsgClientVanityURLChangedNotification::get_vanity_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientVanityURLChangedNotification>(
                "CMsgClientVanityURLChangedNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientVanityURLChangedNotification {
        static instance: ::protobuf::rt::Lazy<CMsgClientVanityURLChangedNotification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientVanityURLChangedNotification::new)
    }
}

impl ::protobuf::Clear for CMsgClientVanityURLChangedNotification {
    fn clear(&mut self) {
        self.vanity_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientVanityURLChangedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientVanityURLChangedNotification {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAuthorizeLocalDeviceRequest {
    // message fields
    device_description: ::protobuf::SingularField<::std::string::String>,
    owner_account_id: ::std::option::Option<u32>,
    local_device_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDeviceRequest {
    fn default() -> &'a CMsgClientAuthorizeLocalDeviceRequest {
        <CMsgClientAuthorizeLocalDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDeviceRequest {
    pub fn new() -> CMsgClientAuthorizeLocalDeviceRequest {
        ::std::default::Default::default()
    }

    // optional string device_description = 1;

    pub fn get_device_description(&self) -> &str {
        match self.device_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_description(&mut self) {
        self.device_description.clear();
    }

    pub fn has_device_description(&self) -> bool {
        self.device_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_description(&mut self, v: ::std::string::String) {
        self.device_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_description(&mut self) -> &mut ::std::string::String {
        if self.device_description.is_none() {
            self.device_description.set_default();
        }
        self.device_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_description(&mut self) -> ::std::string::String {
        self.device_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 owner_account_id = 2;

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 local_device_token = 3;

    pub fn get_local_device_token(&self) -> u64 {
        self.local_device_token.unwrap_or(0)
    }

    pub fn clear_local_device_token(&mut self) {
        self.local_device_token = ::std::option::Option::None;
    }

    pub fn has_local_device_token(&self) -> bool {
        self.local_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_device_token(&mut self, v: u64) {
        self.local_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDeviceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_description)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.local_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.device_description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.local_device_token {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.device_description.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.local_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAuthorizeLocalDeviceRequest {
        CMsgClientAuthorizeLocalDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "device_description",
                |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.device_description },
                |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.device_description },
                CMsgClientAuthorizeLocalDeviceRequest::get_device_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "owner_account_id",
                |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.owner_account_id },
                |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.owner_account_id },
                CMsgClientAuthorizeLocalDeviceRequest::get_owner_account_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "local_device_token",
                |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.local_device_token },
                |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.local_device_token },
                CMsgClientAuthorizeLocalDeviceRequest::get_local_device_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAuthorizeLocalDeviceRequest>(
                "CMsgClientAuthorizeLocalDeviceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDeviceRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientAuthorizeLocalDeviceRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAuthorizeLocalDeviceRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientAuthorizeLocalDeviceRequest {
    fn clear(&mut self) {
        self.device_description.clear();
        self.owner_account_id = ::std::option::Option::None;
        self.local_device_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAuthorizeLocalDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthorizeLocalDeviceRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAuthorizeLocalDevice {
    // message fields
    eresult: ::std::option::Option<i32>,
    owner_account_id: ::std::option::Option<u32>,
    authed_device_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDevice {
    fn default() -> &'a CMsgClientAuthorizeLocalDevice {
        <CMsgClientAuthorizeLocalDevice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDevice {
    pub fn new() -> CMsgClientAuthorizeLocalDevice {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_account_id = 2;

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 authed_device_token = 3;

    pub fn get_authed_device_token(&self) -> u64 {
        self.authed_device_token.unwrap_or(0)
    }

    pub fn clear_authed_device_token(&mut self) {
        self.authed_device_token = ::std::option::Option::None;
    }

    pub fn has_authed_device_token(&self) -> bool {
        self.authed_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authed_device_token(&mut self, v: u64) {
        self.authed_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.authed_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.authed_device_token {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.authed_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAuthorizeLocalDevice {
        CMsgClientAuthorizeLocalDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientAuthorizeLocalDevice| { &m.eresult },
                |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.eresult },
                CMsgClientAuthorizeLocalDevice::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "owner_account_id",
                |m: &CMsgClientAuthorizeLocalDevice| { &m.owner_account_id },
                |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.owner_account_id },
                CMsgClientAuthorizeLocalDevice::get_owner_account_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "authed_device_token",
                |m: &CMsgClientAuthorizeLocalDevice| { &m.authed_device_token },
                |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.authed_device_token },
                CMsgClientAuthorizeLocalDevice::get_authed_device_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAuthorizeLocalDevice>(
                "CMsgClientAuthorizeLocalDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDevice {
        static instance: ::protobuf::rt::Lazy<CMsgClientAuthorizeLocalDevice> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAuthorizeLocalDevice::new)
    }
}

impl ::protobuf::Clear for CMsgClientAuthorizeLocalDevice {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.authed_device_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAuthorizeLocalDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthorizeLocalDevice {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAuthorizeLocalDeviceNotification {
    // message fields
    eresult: ::std::option::Option<i32>,
    owner_account_id: ::std::option::Option<u32>,
    local_device_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDeviceNotification {
    fn default() -> &'a CMsgClientAuthorizeLocalDeviceNotification {
        <CMsgClientAuthorizeLocalDeviceNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDeviceNotification {
    pub fn new() -> CMsgClientAuthorizeLocalDeviceNotification {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_account_id = 2;

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 local_device_token = 3;

    pub fn get_local_device_token(&self) -> u64 {
        self.local_device_token.unwrap_or(0)
    }

    pub fn clear_local_device_token(&mut self) {
        self.local_device_token = ::std::option::Option::None;
    }

    pub fn has_local_device_token(&self) -> bool {
        self.local_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_device_token(&mut self, v: u64) {
        self.local_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDeviceNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.local_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.local_device_token {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.local_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAuthorizeLocalDeviceNotification {
        CMsgClientAuthorizeLocalDeviceNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.eresult },
                |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.eresult },
                CMsgClientAuthorizeLocalDeviceNotification::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "owner_account_id",
                |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.owner_account_id },
                |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.owner_account_id },
                CMsgClientAuthorizeLocalDeviceNotification::get_owner_account_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "local_device_token",
                |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.local_device_token },
                |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.local_device_token },
                CMsgClientAuthorizeLocalDeviceNotification::get_local_device_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAuthorizeLocalDeviceNotification>(
                "CMsgClientAuthorizeLocalDeviceNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDeviceNotification {
        static instance: ::protobuf::rt::Lazy<CMsgClientAuthorizeLocalDeviceNotification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientAuthorizeLocalDeviceNotification::new)
    }
}

impl ::protobuf::Clear for CMsgClientAuthorizeLocalDeviceNotification {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.local_device_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAuthorizeLocalDeviceNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthorizeLocalDeviceNotification {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDeauthorizeDeviceRequest {
    // message fields
    deauthorization_account_id: ::std::option::Option<u32>,
    deauthorization_device_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeauthorizeDeviceRequest {
    fn default() -> &'a CMsgClientDeauthorizeDeviceRequest {
        <CMsgClientDeauthorizeDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeauthorizeDeviceRequest {
    pub fn new() -> CMsgClientDeauthorizeDeviceRequest {
        ::std::default::Default::default()
    }

    // optional uint32 deauthorization_account_id = 1;

    pub fn get_deauthorization_account_id(&self) -> u32 {
        self.deauthorization_account_id.unwrap_or(0)
    }

    pub fn clear_deauthorization_account_id(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
    }

    pub fn has_deauthorization_account_id(&self) -> bool {
        self.deauthorization_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_account_id(&mut self, v: u32) {
        self.deauthorization_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 deauthorization_device_token = 2;

    pub fn get_deauthorization_device_token(&self) -> u64 {
        self.deauthorization_device_token.unwrap_or(0)
    }

    pub fn clear_deauthorization_device_token(&mut self) {
        self.deauthorization_device_token = ::std::option::Option::None;
    }

    pub fn has_deauthorization_device_token(&self) -> bool {
        self.deauthorization_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_device_token(&mut self, v: u64) {
        self.deauthorization_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeauthorizeDeviceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deauthorization_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deauthorization_device_token = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deauthorization_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deauthorization_device_token {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deauthorization_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deauthorization_device_token {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDeauthorizeDeviceRequest {
        CMsgClientDeauthorizeDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "deauthorization_account_id",
                |m: &CMsgClientDeauthorizeDeviceRequest| { &m.deauthorization_account_id },
                |m: &mut CMsgClientDeauthorizeDeviceRequest| { &mut m.deauthorization_account_id },
                CMsgClientDeauthorizeDeviceRequest::get_deauthorization_account_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "deauthorization_device_token",
                |m: &CMsgClientDeauthorizeDeviceRequest| { &m.deauthorization_device_token },
                |m: &mut CMsgClientDeauthorizeDeviceRequest| { &mut m.deauthorization_device_token },
                CMsgClientDeauthorizeDeviceRequest::get_deauthorization_device_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDeauthorizeDeviceRequest>(
                "CMsgClientDeauthorizeDeviceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDeauthorizeDeviceRequest {
        static instance: ::protobuf::rt::Lazy<CMsgClientDeauthorizeDeviceRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientDeauthorizeDeviceRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientDeauthorizeDeviceRequest {
    fn clear(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
        self.deauthorization_device_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDeauthorizeDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeauthorizeDeviceRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDeauthorizeDevice {
    // message fields
    eresult: ::std::option::Option<i32>,
    deauthorization_account_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeauthorizeDevice {
    fn default() -> &'a CMsgClientDeauthorizeDevice {
        <CMsgClientDeauthorizeDevice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeauthorizeDevice {
    pub fn new() -> CMsgClientDeauthorizeDevice {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 deauthorization_account_id = 2;

    pub fn get_deauthorization_account_id(&self) -> u32 {
        self.deauthorization_account_id.unwrap_or(0)
    }

    pub fn clear_deauthorization_account_id(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
    }

    pub fn has_deauthorization_account_id(&self) -> bool {
        self.deauthorization_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_account_id(&mut self, v: u32) {
        self.deauthorization_account_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeauthorizeDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deauthorization_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deauthorization_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.deauthorization_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDeauthorizeDevice {
        CMsgClientDeauthorizeDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientDeauthorizeDevice| { &m.eresult },
                |m: &mut CMsgClientDeauthorizeDevice| { &mut m.eresult },
                CMsgClientDeauthorizeDevice::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "deauthorization_account_id",
                |m: &CMsgClientDeauthorizeDevice| { &m.deauthorization_account_id },
                |m: &mut CMsgClientDeauthorizeDevice| { &mut m.deauthorization_account_id },
                CMsgClientDeauthorizeDevice::get_deauthorization_account_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDeauthorizeDevice>(
                "CMsgClientDeauthorizeDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDeauthorizeDevice {
        static instance: ::protobuf::rt::Lazy<CMsgClientDeauthorizeDevice> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientDeauthorizeDevice::new)
    }
}

impl ::protobuf::Clear for CMsgClientDeauthorizeDevice {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.deauthorization_account_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDeauthorizeDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeauthorizeDevice {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUseLocalDeviceAuthorizations {
    // message fields
    pub authorization_account_id: ::std::vec::Vec<u32>,
    pub device_tokens: ::protobuf::RepeatedField<cmsg_client_use_local_device_authorizations::DeviceToken>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUseLocalDeviceAuthorizations {
    fn default() -> &'a CMsgClientUseLocalDeviceAuthorizations {
        <CMsgClientUseLocalDeviceAuthorizations as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUseLocalDeviceAuthorizations {
    pub fn new() -> CMsgClientUseLocalDeviceAuthorizations {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientUseLocalDeviceAuthorizations {
    fn is_initialized(&self) -> bool {
        for v in &self.device_tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.authorization_account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.device_tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.authorization_account_id {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.device_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.authorization_account_id {
            os.write_uint32(1, *v)?;
        };
        for v in &self.device_tokens {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUseLocalDeviceAuthorizations {
        CMsgClientUseLocalDeviceAuthorizations::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "authorization_account_id",
                |m: &CMsgClientUseLocalDeviceAuthorizations| { &m.authorization_account_id },
                |m: &mut CMsgClientUseLocalDeviceAuthorizations| { &mut m.authorization_account_id },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_use_local_device_authorizations::DeviceToken>>(
                "device_tokens",
                |m: &CMsgClientUseLocalDeviceAuthorizations| { &m.device_tokens },
                |m: &mut CMsgClientUseLocalDeviceAuthorizations| { &mut m.device_tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUseLocalDeviceAuthorizations>(
                "CMsgClientUseLocalDeviceAuthorizations",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUseLocalDeviceAuthorizations {
        static instance: ::protobuf::rt::Lazy<CMsgClientUseLocalDeviceAuthorizations> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientUseLocalDeviceAuthorizations::new)
    }
}

impl ::protobuf::Clear for CMsgClientUseLocalDeviceAuthorizations {
    fn clear(&mut self) {
        self.authorization_account_id.clear();
        self.device_tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUseLocalDeviceAuthorizations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUseLocalDeviceAuthorizations {
}

/// Nested message and enums of message `CMsgClientUseLocalDeviceAuthorizations`
pub mod cmsg_client_use_local_device_authorizations {
    #[derive(PartialEq,Clone,Default)]
    pub struct DeviceToken {
        // message fields
        owner_account_id: ::std::option::Option<u32>,
        token_id: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a DeviceToken {
        fn default() -> &'a DeviceToken {
            <DeviceToken as ::protobuf::Message>::default_instance()
        }
    }

    impl DeviceToken {
        pub fn new() -> DeviceToken {
            ::std::default::Default::default()
        }

        // optional uint32 owner_account_id = 1;

        pub fn get_owner_account_id(&self) -> u32 {
            self.owner_account_id.unwrap_or(0)
        }

        pub fn clear_owner_account_id(&mut self) {
            self.owner_account_id = ::std::option::Option::None;
        }

        pub fn has_owner_account_id(&self) -> bool {
            self.owner_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_account_id(&mut self, v: u32) {
            self.owner_account_id = ::std::option::Option::Some(v);
        }

        // optional uint64 token_id = 2;

        pub fn get_token_id(&self) -> u64 {
            self.token_id.unwrap_or(0)
        }

        pub fn clear_token_id(&mut self) {
            self.token_id = ::std::option::Option::None;
        }

        pub fn has_token_id(&self) -> bool {
            self.token_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token_id(&mut self, v: u64) {
            self.token_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for DeviceToken {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.token_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.owner_account_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.token_id {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.owner_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.token_id {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> DeviceToken {
            DeviceToken::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "owner_account_id",
                    |m: &DeviceToken| { &m.owner_account_id },
                    |m: &mut DeviceToken| { &mut m.owner_account_id },
                    DeviceToken::get_owner_account_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "token_id",
                    |m: &DeviceToken| { &m.token_id },
                    |m: &mut DeviceToken| { &mut m.token_id },
                    DeviceToken::get_token_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceToken>(
                    "CMsgClientUseLocalDeviceAuthorizations.DeviceToken",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static DeviceToken {
            static instance: ::protobuf::rt::Lazy<DeviceToken> = ::protobuf::rt::Lazy::INIT;
            instance.get(DeviceToken::new)
        }
    }

    impl ::protobuf::Clear for DeviceToken {
        fn clear(&mut self) {
            self.owner_account_id = ::std::option::Option::None;
            self.token_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for DeviceToken {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DeviceToken {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetAuthorizedDevices {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevices {
    fn default() -> &'a CMsgClientGetAuthorizedDevices {
        <CMsgClientGetAuthorizedDevices as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevices {
    pub fn new() -> CMsgClientGetAuthorizedDevices {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetAuthorizedDevices {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetAuthorizedDevices {
        CMsgClientGetAuthorizedDevices::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetAuthorizedDevices>(
                "CMsgClientGetAuthorizedDevices",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevices {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetAuthorizedDevices> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetAuthorizedDevices::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetAuthorizedDevices {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetAuthorizedDevices {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAuthorizedDevices {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetAuthorizedDevicesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub authorized_device: ::protobuf::RepeatedField<cmsg_client_get_authorized_devices_response::AuthorizedDevice>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevicesResponse {
    fn default() -> &'a CMsgClientGetAuthorizedDevicesResponse {
        <CMsgClientGetAuthorizedDevicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevicesResponse {
    pub fn new() -> CMsgClientGetAuthorizedDevicesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetAuthorizedDevicesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.authorized_device {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.authorized_device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.authorized_device {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.authorized_device {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetAuthorizedDevicesResponse {
        CMsgClientGetAuthorizedDevicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientGetAuthorizedDevicesResponse| { &m.eresult },
                |m: &mut CMsgClientGetAuthorizedDevicesResponse| { &mut m.eresult },
                CMsgClientGetAuthorizedDevicesResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_get_authorized_devices_response::AuthorizedDevice>>(
                "authorized_device",
                |m: &CMsgClientGetAuthorizedDevicesResponse| { &m.authorized_device },
                |m: &mut CMsgClientGetAuthorizedDevicesResponse| { &mut m.authorized_device },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetAuthorizedDevicesResponse>(
                "CMsgClientGetAuthorizedDevicesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevicesResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientGetAuthorizedDevicesResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientGetAuthorizedDevicesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetAuthorizedDevicesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.authorized_device.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetAuthorizedDevicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAuthorizedDevicesResponse {
}

/// Nested message and enums of message `CMsgClientGetAuthorizedDevicesResponse`
pub mod cmsg_client_get_authorized_devices_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct AuthorizedDevice {
        // message fields
        auth_device_token: ::std::option::Option<u64>,
        device_name: ::protobuf::SingularField<::std::string::String>,
        last_access_time: ::std::option::Option<u32>,
        borrower_id: ::std::option::Option<u32>,
        is_pending: ::std::option::Option<bool>,
        app_played: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a AuthorizedDevice {
        fn default() -> &'a AuthorizedDevice {
            <AuthorizedDevice as ::protobuf::Message>::default_instance()
        }
    }

    impl AuthorizedDevice {
        pub fn new() -> AuthorizedDevice {
            ::std::default::Default::default()
        }

        // optional uint64 auth_device_token = 1;

        pub fn get_auth_device_token(&self) -> u64 {
            self.auth_device_token.unwrap_or(0)
        }

        pub fn clear_auth_device_token(&mut self) {
            self.auth_device_token = ::std::option::Option::None;
        }

        pub fn has_auth_device_token(&self) -> bool {
            self.auth_device_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_device_token(&mut self, v: u64) {
            self.auth_device_token = ::std::option::Option::Some(v);
        }

        // optional string device_name = 2;

        pub fn get_device_name(&self) -> &str {
            match self.device_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_name(&mut self) {
            self.device_name.clear();
        }

        pub fn has_device_name(&self) -> bool {
            self.device_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_name(&mut self, v: ::std::string::String) {
            self.device_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
            if self.device_name.is_none() {
                self.device_name.set_default();
            }
            self.device_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_name(&mut self) -> ::std::string::String {
            self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 last_access_time = 3;

        pub fn get_last_access_time(&self) -> u32 {
            self.last_access_time.unwrap_or(0)
        }

        pub fn clear_last_access_time(&mut self) {
            self.last_access_time = ::std::option::Option::None;
        }

        pub fn has_last_access_time(&self) -> bool {
            self.last_access_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_access_time(&mut self, v: u32) {
            self.last_access_time = ::std::option::Option::Some(v);
        }

        // optional uint32 borrower_id = 4;

        pub fn get_borrower_id(&self) -> u32 {
            self.borrower_id.unwrap_or(0)
        }

        pub fn clear_borrower_id(&mut self) {
            self.borrower_id = ::std::option::Option::None;
        }

        pub fn has_borrower_id(&self) -> bool {
            self.borrower_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_borrower_id(&mut self, v: u32) {
            self.borrower_id = ::std::option::Option::Some(v);
        }

        // optional bool is_pending = 5;

        pub fn get_is_pending(&self) -> bool {
            self.is_pending.unwrap_or(false)
        }

        pub fn clear_is_pending(&mut self) {
            self.is_pending = ::std::option::Option::None;
        }

        pub fn has_is_pending(&self) -> bool {
            self.is_pending.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_pending(&mut self, v: bool) {
            self.is_pending = ::std::option::Option::Some(v);
        }

        // optional uint32 app_played = 6;

        pub fn get_app_played(&self) -> u32 {
            self.app_played.unwrap_or(0)
        }

        pub fn clear_app_played(&mut self) {
            self.app_played = ::std::option::Option::None;
        }

        pub fn has_app_played(&self) -> bool {
            self.app_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_played(&mut self, v: u32) {
            self.app_played = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AuthorizedDevice {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.auth_device_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_name)?;
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.last_access_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.borrower_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.is_pending = ::std::option::Option::Some(is.read_bool()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.app_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.auth_device_token {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.device_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.last_access_time {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.borrower_id {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.is_pending {
                my_size += 2;
            }
            if let Some(v) = self.app_played {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.auth_device_token {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.device_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.last_access_time {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.borrower_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.is_pending {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.app_played {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> AuthorizedDevice {
            AuthorizedDevice::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "auth_device_token",
                    |m: &AuthorizedDevice| { &m.auth_device_token },
                    |m: &mut AuthorizedDevice| { &mut m.auth_device_token },
                    AuthorizedDevice::get_auth_device_token,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "device_name",
                    |m: &AuthorizedDevice| { &m.device_name },
                    |m: &mut AuthorizedDevice| { &mut m.device_name },
                    AuthorizedDevice::get_device_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "last_access_time",
                    |m: &AuthorizedDevice| { &m.last_access_time },
                    |m: &mut AuthorizedDevice| { &mut m.last_access_time },
                    AuthorizedDevice::get_last_access_time,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "borrower_id",
                    |m: &AuthorizedDevice| { &m.borrower_id },
                    |m: &mut AuthorizedDevice| { &mut m.borrower_id },
                    AuthorizedDevice::get_borrower_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "is_pending",
                    |m: &AuthorizedDevice| { &m.is_pending },
                    |m: &mut AuthorizedDevice| { &mut m.is_pending },
                    AuthorizedDevice::get_is_pending,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "app_played",
                    |m: &AuthorizedDevice| { &m.app_played },
                    |m: &mut AuthorizedDevice| { &mut m.app_played },
                    AuthorizedDevice::get_app_played,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuthorizedDevice>(
                    "CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static AuthorizedDevice {
            static instance: ::protobuf::rt::Lazy<AuthorizedDevice> = ::protobuf::rt::Lazy::INIT;
            instance.get(AuthorizedDevice::new)
        }
    }

    impl ::protobuf::Clear for AuthorizedDevice {
        fn clear(&mut self) {
            self.auth_device_token = ::std::option::Option::None;
            self.device_name.clear();
            self.last_access_time = ::std::option::Option::None;
            self.borrower_id = ::std::option::Option::None;
            self.is_pending = ::std::option::Option::None;
            self.app_played = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for AuthorizedDevice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AuthorizedDevice {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSharedLibraryLockStatus {
    // message fields
    pub locked_library: ::protobuf::RepeatedField<cmsg_client_shared_library_lock_status::LockedLibrary>,
    own_library_locked_by: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryLockStatus {
    fn default() -> &'a CMsgClientSharedLibraryLockStatus {
        <CMsgClientSharedLibraryLockStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryLockStatus {
    pub fn new() -> CMsgClientSharedLibraryLockStatus {
        ::std::default::Default::default()
    }

    // optional uint32 own_library_locked_by = 2;

    pub fn get_own_library_locked_by(&self) -> u32 {
        self.own_library_locked_by.unwrap_or(0)
    }

    pub fn clear_own_library_locked_by(&mut self) {
        self.own_library_locked_by = ::std::option::Option::None;
    }

    pub fn has_own_library_locked_by(&self) -> bool {
        self.own_library_locked_by.is_some()
    }

    // Param is passed by value, moved
    pub fn set_own_library_locked_by(&mut self, v: u32) {
        self.own_library_locked_by = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSharedLibraryLockStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.locked_library {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.locked_library)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.own_library_locked_by = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.locked_library {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.own_library_locked_by {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.locked_library {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.own_library_locked_by {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSharedLibraryLockStatus {
        CMsgClientSharedLibraryLockStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_shared_library_lock_status::LockedLibrary>>(
                "locked_library",
                |m: &CMsgClientSharedLibraryLockStatus| { &m.locked_library },
                |m: &mut CMsgClientSharedLibraryLockStatus| { &mut m.locked_library },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "own_library_locked_by",
                |m: &CMsgClientSharedLibraryLockStatus| { &m.own_library_locked_by },
                |m: &mut CMsgClientSharedLibraryLockStatus| { &mut m.own_library_locked_by },
                CMsgClientSharedLibraryLockStatus::get_own_library_locked_by,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSharedLibraryLockStatus>(
                "CMsgClientSharedLibraryLockStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryLockStatus {
        static instance: ::protobuf::rt::Lazy<CMsgClientSharedLibraryLockStatus> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientSharedLibraryLockStatus::new)
    }
}

impl ::protobuf::Clear for CMsgClientSharedLibraryLockStatus {
    fn clear(&mut self) {
        self.locked_library.clear();
        self.own_library_locked_by = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSharedLibraryLockStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSharedLibraryLockStatus {
}

/// Nested message and enums of message `CMsgClientSharedLibraryLockStatus`
pub mod cmsg_client_shared_library_lock_status {
    #[derive(PartialEq,Clone,Default)]
    pub struct LockedLibrary {
        // message fields
        owner_id: ::std::option::Option<u32>,
        locked_by: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a LockedLibrary {
        fn default() -> &'a LockedLibrary {
            <LockedLibrary as ::protobuf::Message>::default_instance()
        }
    }

    impl LockedLibrary {
        pub fn new() -> LockedLibrary {
            ::std::default::Default::default()
        }

        // optional uint32 owner_id = 1;

        pub fn get_owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional uint32 locked_by = 2;

        pub fn get_locked_by(&self) -> u32 {
            self.locked_by.unwrap_or(0)
        }

        pub fn clear_locked_by(&mut self) {
            self.locked_by = ::std::option::Option::None;
        }

        pub fn has_locked_by(&self) -> bool {
            self.locked_by.is_some()
        }

        // Param is passed by value, moved
        pub fn set_locked_by(&mut self, v: u32) {
            self.locked_by = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for LockedLibrary {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.locked_by = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.locked_by {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.owner_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.locked_by {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> LockedLibrary {
            LockedLibrary::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "owner_id",
                    |m: &LockedLibrary| { &m.owner_id },
                    |m: &mut LockedLibrary| { &mut m.owner_id },
                    LockedLibrary::get_owner_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "locked_by",
                    |m: &LockedLibrary| { &m.locked_by },
                    |m: &mut LockedLibrary| { &mut m.locked_by },
                    LockedLibrary::get_locked_by,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LockedLibrary>(
                    "CMsgClientSharedLibraryLockStatus.LockedLibrary",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static LockedLibrary {
            static instance: ::protobuf::rt::Lazy<LockedLibrary> = ::protobuf::rt::Lazy::INIT;
            instance.get(LockedLibrary::new)
        }
    }

    impl ::protobuf::Clear for LockedLibrary {
        fn clear(&mut self) {
            self.owner_id = ::std::option::Option::None;
            self.locked_by = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for LockedLibrary {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LockedLibrary {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSharedLibraryStopPlaying {
    // message fields
    seconds_left: ::std::option::Option<i32>,
    pub stop_apps: ::protobuf::RepeatedField<cmsg_client_shared_library_stop_playing::StopApp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryStopPlaying {
    fn default() -> &'a CMsgClientSharedLibraryStopPlaying {
        <CMsgClientSharedLibraryStopPlaying as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryStopPlaying {
    pub fn new() -> CMsgClientSharedLibraryStopPlaying {
        ::std::default::Default::default()
    }

    // optional int32 seconds_left = 1;

    pub fn get_seconds_left(&self) -> i32 {
        self.seconds_left.unwrap_or(0)
    }

    pub fn clear_seconds_left(&mut self) {
        self.seconds_left = ::std::option::Option::None;
    }

    pub fn has_seconds_left(&self) -> bool {
        self.seconds_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_left(&mut self, v: i32) {
        self.seconds_left = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSharedLibraryStopPlaying {
    fn is_initialized(&self) -> bool {
        for v in &self.stop_apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.seconds_left = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.stop_apps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seconds_left {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stop_apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seconds_left {
            os.write_int32(1, v)?;
        }
        for v in &self.stop_apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSharedLibraryStopPlaying {
        CMsgClientSharedLibraryStopPlaying::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "seconds_left",
                |m: &CMsgClientSharedLibraryStopPlaying| { &m.seconds_left },
                |m: &mut CMsgClientSharedLibraryStopPlaying| { &mut m.seconds_left },
                CMsgClientSharedLibraryStopPlaying::get_seconds_left,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_client_shared_library_stop_playing::StopApp>>(
                "stop_apps",
                |m: &CMsgClientSharedLibraryStopPlaying| { &m.stop_apps },
                |m: &mut CMsgClientSharedLibraryStopPlaying| { &mut m.stop_apps },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSharedLibraryStopPlaying>(
                "CMsgClientSharedLibraryStopPlaying",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryStopPlaying {
        static instance: ::protobuf::rt::Lazy<CMsgClientSharedLibraryStopPlaying> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientSharedLibraryStopPlaying::new)
    }
}

impl ::protobuf::Clear for CMsgClientSharedLibraryStopPlaying {
    fn clear(&mut self) {
        self.seconds_left = ::std::option::Option::None;
        self.stop_apps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSharedLibraryStopPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSharedLibraryStopPlaying {
}

/// Nested message and enums of message `CMsgClientSharedLibraryStopPlaying`
pub mod cmsg_client_shared_library_stop_playing {
    #[derive(PartialEq,Clone,Default)]
    pub struct StopApp {
        // message fields
        app_id: ::std::option::Option<u32>,
        owner_id: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a StopApp {
        fn default() -> &'a StopApp {
            <StopApp as ::protobuf::Message>::default_instance()
        }
    }

    impl StopApp {
        pub fn new() -> StopApp {
            ::std::default::Default::default()
        }

        // optional uint32 app_id = 1;

        pub fn get_app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 2;

        pub fn get_owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for StopApp {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.app_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> StopApp {
            StopApp::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "app_id",
                    |m: &StopApp| { &m.app_id },
                    |m: &mut StopApp| { &mut m.app_id },
                    StopApp::get_app_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "owner_id",
                    |m: &StopApp| { &m.owner_id },
                    |m: &mut StopApp| { &mut m.owner_id },
                    StopApp::get_owner_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StopApp>(
                    "CMsgClientSharedLibraryStopPlaying.StopApp",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static StopApp {
            static instance: ::protobuf::rt::Lazy<StopApp> = ::protobuf::rt::Lazy::INIT;
            instance.get(StopApp::new)
        }
    }

    impl ::protobuf::Clear for StopApp {
        fn clear(&mut self) {
            self.app_id = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for StopApp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StopApp {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServiceCall {
    // message fields
    sysid_routing: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    call_handle: ::std::option::Option<u32>,
    module_crc: ::std::option::Option<u32>,
    module_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    function_id: ::std::option::Option<u32>,
    cub_output_max: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    callparameter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ping_only: ::std::option::Option<bool>,
    max_outstanding_calls: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceCall {
    fn default() -> &'a CMsgClientServiceCall {
        <CMsgClientServiceCall as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceCall {
    pub fn new() -> CMsgClientServiceCall {
        ::std::default::Default::default()
    }

    // optional bytes sysid_routing = 1;

    pub fn get_sysid_routing(&self) -> &[u8] {
        match self.sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sysid_routing(&mut self) {
        self.sysid_routing.clear();
    }

    pub fn has_sysid_routing(&self) -> bool {
        self.sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.sysid_routing = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sysid_routing.is_none() {
            self.sysid_routing.set_default();
        }
        self.sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 call_handle = 2;

    pub fn get_call_handle(&self) -> u32 {
        self.call_handle.unwrap_or(0)
    }

    pub fn clear_call_handle(&mut self) {
        self.call_handle = ::std::option::Option::None;
    }

    pub fn has_call_handle(&self) -> bool {
        self.call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_handle(&mut self, v: u32) {
        self.call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 module_crc = 3;

    pub fn get_module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 4;

    pub fn get_module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash.clear();
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash.set_default();
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 function_id = 5;

    pub fn get_function_id(&self) -> u32 {
        self.function_id.unwrap_or(0)
    }

    pub fn clear_function_id(&mut self) {
        self.function_id = ::std::option::Option::None;
    }

    pub fn has_function_id(&self) -> bool {
        self.function_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_id(&mut self, v: u32) {
        self.function_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cub_output_max = 6;

    pub fn get_cub_output_max(&self) -> u32 {
        self.cub_output_max.unwrap_or(0)
    }

    pub fn clear_cub_output_max(&mut self) {
        self.cub_output_max = ::std::option::Option::None;
    }

    pub fn has_cub_output_max(&self) -> bool {
        self.cub_output_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cub_output_max(&mut self, v: u32) {
        self.cub_output_max = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 7;

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes callparameter = 8;

    pub fn get_callparameter(&self) -> &[u8] {
        match self.callparameter.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_callparameter(&mut self) {
        self.callparameter.clear();
    }

    pub fn has_callparameter(&self) -> bool {
        self.callparameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callparameter(&mut self, v: ::std::vec::Vec<u8>) {
        self.callparameter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callparameter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.callparameter.is_none() {
            self.callparameter.set_default();
        }
        self.callparameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_callparameter(&mut self) -> ::std::vec::Vec<u8> {
        self.callparameter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool ping_only = 9;

    pub fn get_ping_only(&self) -> bool {
        self.ping_only.unwrap_or(false)
    }

    pub fn clear_ping_only(&mut self) {
        self.ping_only = ::std::option::Option::None;
    }

    pub fn has_ping_only(&self) -> bool {
        self.ping_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_only(&mut self, v: bool) {
        self.ping_only = ::std::option::Option::Some(v);
    }

    // optional uint32 max_outstanding_calls = 10;

    pub fn get_max_outstanding_calls(&self) -> u32 {
        self.max_outstanding_calls.unwrap_or(0)
    }

    pub fn clear_max_outstanding_calls(&mut self) {
        self.max_outstanding_calls = ::std::option::Option::None;
    }

    pub fn has_max_outstanding_calls(&self) -> bool {
        self.max_outstanding_calls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_outstanding_calls(&mut self, v: u32) {
        self.max_outstanding_calls = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServiceCall {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sysid_routing)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.module_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.function_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cub_output_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.callparameter)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ping_only = ::std::option::Option::Some(is.read_bool()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.max_outstanding_calls = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.call_handle {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.function_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cub_output_max {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.callparameter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.ping_only {
            my_size += 2;
        }
        if let Some(v) = self.max_outstanding_calls {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sysid_routing.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.call_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.module_crc {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.function_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cub_output_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.callparameter.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.ping_only {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.max_outstanding_calls {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServiceCall {
        CMsgClientServiceCall::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sysid_routing",
                |m: &CMsgClientServiceCall| { &m.sysid_routing },
                |m: &mut CMsgClientServiceCall| { &mut m.sysid_routing },
                CMsgClientServiceCall::get_sysid_routing,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "call_handle",
                |m: &CMsgClientServiceCall| { &m.call_handle },
                |m: &mut CMsgClientServiceCall| { &mut m.call_handle },
                CMsgClientServiceCall::get_call_handle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "module_crc",
                |m: &CMsgClientServiceCall| { &m.module_crc },
                |m: &mut CMsgClientServiceCall| { &mut m.module_crc },
                CMsgClientServiceCall::get_module_crc,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "module_hash",
                |m: &CMsgClientServiceCall| { &m.module_hash },
                |m: &mut CMsgClientServiceCall| { &mut m.module_hash },
                CMsgClientServiceCall::get_module_hash,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "function_id",
                |m: &CMsgClientServiceCall| { &m.function_id },
                |m: &mut CMsgClientServiceCall| { &mut m.function_id },
                CMsgClientServiceCall::get_function_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cub_output_max",
                |m: &CMsgClientServiceCall| { &m.cub_output_max },
                |m: &mut CMsgClientServiceCall| { &mut m.cub_output_max },
                CMsgClientServiceCall::get_cub_output_max,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "flags",
                |m: &CMsgClientServiceCall| { &m.flags },
                |m: &mut CMsgClientServiceCall| { &mut m.flags },
                CMsgClientServiceCall::get_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "callparameter",
                |m: &CMsgClientServiceCall| { &m.callparameter },
                |m: &mut CMsgClientServiceCall| { &mut m.callparameter },
                CMsgClientServiceCall::get_callparameter,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "ping_only",
                |m: &CMsgClientServiceCall| { &m.ping_only },
                |m: &mut CMsgClientServiceCall| { &mut m.ping_only },
                CMsgClientServiceCall::get_ping_only,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "max_outstanding_calls",
                |m: &CMsgClientServiceCall| { &m.max_outstanding_calls },
                |m: &mut CMsgClientServiceCall| { &mut m.max_outstanding_calls },
                CMsgClientServiceCall::get_max_outstanding_calls,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientServiceCall>(
                "CMsgClientServiceCall",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServiceCall {
        static instance: ::protobuf::rt::Lazy<CMsgClientServiceCall> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientServiceCall::new)
    }
}

impl ::protobuf::Clear for CMsgClientServiceCall {
    fn clear(&mut self) {
        self.sysid_routing.clear();
        self.call_handle = ::std::option::Option::None;
        self.module_crc = ::std::option::Option::None;
        self.module_hash.clear();
        self.function_id = ::std::option::Option::None;
        self.cub_output_max = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.callparameter.clear();
        self.ping_only = ::std::option::Option::None;
        self.max_outstanding_calls = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServiceCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceCall {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServiceModule {
    // message fields
    module_crc: ::std::option::Option<u32>,
    module_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    module_content: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceModule {
    fn default() -> &'a CMsgClientServiceModule {
        <CMsgClientServiceModule as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceModule {
    pub fn new() -> CMsgClientServiceModule {
        ::std::default::Default::default()
    }

    // optional uint32 module_crc = 1;

    pub fn get_module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 2;

    pub fn get_module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash.clear();
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash.set_default();
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes module_content = 3;

    pub fn get_module_content(&self) -> &[u8] {
        match self.module_content.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_content(&mut self) {
        self.module_content.clear();
    }

    pub fn has_module_content(&self) -> bool {
        self.module_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_content = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_content.is_none() {
            self.module_content.set_default();
        }
        self.module_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_content(&mut self) -> ::std::vec::Vec<u8> {
        self.module_content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientServiceModule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.module_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.module_content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.module_content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.module_crc {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.module_content.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServiceModule {
        CMsgClientServiceModule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "module_crc",
                |m: &CMsgClientServiceModule| { &m.module_crc },
                |m: &mut CMsgClientServiceModule| { &mut m.module_crc },
                CMsgClientServiceModule::get_module_crc,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "module_hash",
                |m: &CMsgClientServiceModule| { &m.module_hash },
                |m: &mut CMsgClientServiceModule| { &mut m.module_hash },
                CMsgClientServiceModule::get_module_hash,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "module_content",
                |m: &CMsgClientServiceModule| { &m.module_content },
                |m: &mut CMsgClientServiceModule| { &mut m.module_content },
                CMsgClientServiceModule::get_module_content,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientServiceModule>(
                "CMsgClientServiceModule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServiceModule {
        static instance: ::protobuf::rt::Lazy<CMsgClientServiceModule> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientServiceModule::new)
    }
}

impl ::protobuf::Clear for CMsgClientServiceModule {
    fn clear(&mut self) {
        self.module_crc = ::std::option::Option::None;
        self.module_hash.clear();
        self.module_content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServiceModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceModule {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServiceCallResponse {
    // message fields
    sysid_routing: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    call_handle: ::std::option::Option<u32>,
    module_crc: ::std::option::Option<u32>,
    module_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ecallresult: ::std::option::Option<u32>,
    result_content: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    os_version_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    system_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    load_address: ::std::option::Option<u64>,
    exception_record: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    portable_os_version_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    portable_system_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    was_converted: ::std::option::Option<bool>,
    internal_result: ::std::option::Option<u32>,
    current_count: ::std::option::Option<u32>,
    last_call_handle: ::std::option::Option<u32>,
    last_call_module_crc: ::std::option::Option<u32>,
    last_call_sysid_routing: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    last_ecallresult: ::std::option::Option<u32>,
    last_callissue_delta: ::std::option::Option<u32>,
    last_callcomplete_delta: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceCallResponse {
    fn default() -> &'a CMsgClientServiceCallResponse {
        <CMsgClientServiceCallResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceCallResponse {
    pub fn new() -> CMsgClientServiceCallResponse {
        ::std::default::Default::default()
    }

    // optional bytes sysid_routing = 1;

    pub fn get_sysid_routing(&self) -> &[u8] {
        match self.sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sysid_routing(&mut self) {
        self.sysid_routing.clear();
    }

    pub fn has_sysid_routing(&self) -> bool {
        self.sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.sysid_routing = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sysid_routing.is_none() {
            self.sysid_routing.set_default();
        }
        self.sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 call_handle = 2;

    pub fn get_call_handle(&self) -> u32 {
        self.call_handle.unwrap_or(0)
    }

    pub fn clear_call_handle(&mut self) {
        self.call_handle = ::std::option::Option::None;
    }

    pub fn has_call_handle(&self) -> bool {
        self.call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_handle(&mut self, v: u32) {
        self.call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 module_crc = 3;

    pub fn get_module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }

    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 4;

    pub fn get_module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_module_hash(&mut self) {
        self.module_hash.clear();
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash.set_default();
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ecallresult = 5;

    pub fn get_ecallresult(&self) -> u32 {
        self.ecallresult.unwrap_or(0)
    }

    pub fn clear_ecallresult(&mut self) {
        self.ecallresult = ::std::option::Option::None;
    }

    pub fn has_ecallresult(&self) -> bool {
        self.ecallresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecallresult(&mut self, v: u32) {
        self.ecallresult = ::std::option::Option::Some(v);
    }

    // optional bytes result_content = 6;

    pub fn get_result_content(&self) -> &[u8] {
        match self.result_content.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_result_content(&mut self) {
        self.result_content.clear();
    }

    pub fn has_result_content(&self) -> bool {
        self.result_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.result_content = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.result_content.is_none() {
            self.result_content.set_default();
        }
        self.result_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_content(&mut self) -> ::std::vec::Vec<u8> {
        self.result_content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes os_version_info = 7;

    pub fn get_os_version_info(&self) -> &[u8] {
        match self.os_version_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_os_version_info(&mut self) {
        self.os_version_info.clear();
    }

    pub fn has_os_version_info(&self) -> bool {
        self.os_version_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_version_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.os_version_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.os_version_info.is_none() {
            self.os_version_info.set_default();
        }
        self.os_version_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_version_info(&mut self) -> ::std::vec::Vec<u8> {
        self.os_version_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes system_info = 8;

    pub fn get_system_info(&self) -> &[u8] {
        match self.system_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_system_info(&mut self) {
        self.system_info.clear();
    }

    pub fn has_system_info(&self) -> bool {
        self.system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.system_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.system_info.is_none() {
            self.system_info.set_default();
        }
        self.system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_info(&mut self) -> ::std::vec::Vec<u8> {
        self.system_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 load_address = 9;

    pub fn get_load_address(&self) -> u64 {
        self.load_address.unwrap_or(0)
    }

    pub fn clear_load_address(&mut self) {
        self.load_address = ::std::option::Option::None;
    }

    pub fn has_load_address(&self) -> bool {
        self.load_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_address(&mut self, v: u64) {
        self.load_address = ::std::option::Option::Some(v);
    }

    // optional bytes exception_record = 10;

    pub fn get_exception_record(&self) -> &[u8] {
        match self.exception_record.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_exception_record(&mut self) {
        self.exception_record.clear();
    }

    pub fn has_exception_record(&self) -> bool {
        self.exception_record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception_record(&mut self, v: ::std::vec::Vec<u8>) {
        self.exception_record = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception_record(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.exception_record.is_none() {
            self.exception_record.set_default();
        }
        self.exception_record.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception_record(&mut self) -> ::std::vec::Vec<u8> {
        self.exception_record.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes portable_os_version_info = 11;

    pub fn get_portable_os_version_info(&self) -> &[u8] {
        match self.portable_os_version_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_portable_os_version_info(&mut self) {
        self.portable_os_version_info.clear();
    }

    pub fn has_portable_os_version_info(&self) -> bool {
        self.portable_os_version_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portable_os_version_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.portable_os_version_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portable_os_version_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.portable_os_version_info.is_none() {
            self.portable_os_version_info.set_default();
        }
        self.portable_os_version_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_portable_os_version_info(&mut self) -> ::std::vec::Vec<u8> {
        self.portable_os_version_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes portable_system_info = 12;

    pub fn get_portable_system_info(&self) -> &[u8] {
        match self.portable_system_info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_portable_system_info(&mut self) {
        self.portable_system_info.clear();
    }

    pub fn has_portable_system_info(&self) -> bool {
        self.portable_system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portable_system_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.portable_system_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portable_system_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.portable_system_info.is_none() {
            self.portable_system_info.set_default();
        }
        self.portable_system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_portable_system_info(&mut self) -> ::std::vec::Vec<u8> {
        self.portable_system_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool was_converted = 13;

    pub fn get_was_converted(&self) -> bool {
        self.was_converted.unwrap_or(false)
    }

    pub fn clear_was_converted(&mut self) {
        self.was_converted = ::std::option::Option::None;
    }

    pub fn has_was_converted(&self) -> bool {
        self.was_converted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_converted(&mut self, v: bool) {
        self.was_converted = ::std::option::Option::Some(v);
    }

    // optional uint32 internal_result = 14;

    pub fn get_internal_result(&self) -> u32 {
        self.internal_result.unwrap_or(0)
    }

    pub fn clear_internal_result(&mut self) {
        self.internal_result = ::std::option::Option::None;
    }

    pub fn has_internal_result(&self) -> bool {
        self.internal_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_result(&mut self, v: u32) {
        self.internal_result = ::std::option::Option::Some(v);
    }

    // optional uint32 current_count = 15;

    pub fn get_current_count(&self) -> u32 {
        self.current_count.unwrap_or(0)
    }

    pub fn clear_current_count(&mut self) {
        self.current_count = ::std::option::Option::None;
    }

    pub fn has_current_count(&self) -> bool {
        self.current_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_count(&mut self, v: u32) {
        self.current_count = ::std::option::Option::Some(v);
    }

    // optional uint32 last_call_handle = 16;

    pub fn get_last_call_handle(&self) -> u32 {
        self.last_call_handle.unwrap_or(0)
    }

    pub fn clear_last_call_handle(&mut self) {
        self.last_call_handle = ::std::option::Option::None;
    }

    pub fn has_last_call_handle(&self) -> bool {
        self.last_call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_handle(&mut self, v: u32) {
        self.last_call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 last_call_module_crc = 17;

    pub fn get_last_call_module_crc(&self) -> u32 {
        self.last_call_module_crc.unwrap_or(0)
    }

    pub fn clear_last_call_module_crc(&mut self) {
        self.last_call_module_crc = ::std::option::Option::None;
    }

    pub fn has_last_call_module_crc(&self) -> bool {
        self.last_call_module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_module_crc(&mut self, v: u32) {
        self.last_call_module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes last_call_sysid_routing = 18;

    pub fn get_last_call_sysid_routing(&self) -> &[u8] {
        match self.last_call_sysid_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_last_call_sysid_routing(&mut self) {
        self.last_call_sysid_routing.clear();
    }

    pub fn has_last_call_sysid_routing(&self) -> bool {
        self.last_call_sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.last_call_sysid_routing = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_call_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.last_call_sysid_routing.is_none() {
            self.last_call_sysid_routing.set_default();
        }
        self.last_call_sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_call_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.last_call_sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 last_ecallresult = 19;

    pub fn get_last_ecallresult(&self) -> u32 {
        self.last_ecallresult.unwrap_or(0)
    }

    pub fn clear_last_ecallresult(&mut self) {
        self.last_ecallresult = ::std::option::Option::None;
    }

    pub fn has_last_ecallresult(&self) -> bool {
        self.last_ecallresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ecallresult(&mut self, v: u32) {
        self.last_ecallresult = ::std::option::Option::Some(v);
    }

    // optional uint32 last_callissue_delta = 20;

    pub fn get_last_callissue_delta(&self) -> u32 {
        self.last_callissue_delta.unwrap_or(0)
    }

    pub fn clear_last_callissue_delta(&mut self) {
        self.last_callissue_delta = ::std::option::Option::None;
    }

    pub fn has_last_callissue_delta(&self) -> bool {
        self.last_callissue_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_callissue_delta(&mut self, v: u32) {
        self.last_callissue_delta = ::std::option::Option::Some(v);
    }

    // optional uint32 last_callcomplete_delta = 21;

    pub fn get_last_callcomplete_delta(&self) -> u32 {
        self.last_callcomplete_delta.unwrap_or(0)
    }

    pub fn clear_last_callcomplete_delta(&mut self) {
        self.last_callcomplete_delta = ::std::option::Option::None;
    }

    pub fn has_last_callcomplete_delta(&self) -> bool {
        self.last_callcomplete_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_callcomplete_delta(&mut self, v: u32) {
        self.last_callcomplete_delta = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServiceCallResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sysid_routing)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.module_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ecallresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.result_content)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.os_version_info)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.system_info)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.load_address = ::std::option::Option::Some(is.read_fixed64()?);
                },
                10 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.exception_record)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.portable_os_version_info)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.portable_system_info)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.was_converted = ::std::option::Option::Some(is.read_bool()?);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.internal_result = ::std::option::Option::Some(is.read_uint32()?);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.current_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_call_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_call_module_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.last_call_sysid_routing)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_ecallresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_callissue_delta = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_callcomplete_delta = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.call_handle {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ecallresult {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result_content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.os_version_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.system_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.load_address {
            my_size += 9;
        }
        if let Some(v) = self.exception_record.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.portable_os_version_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.portable_system_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.was_converted {
            my_size += 2;
        }
        if let Some(v) = self.internal_result {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current_count {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_call_handle {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_call_module_crc {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_call_sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.last_ecallresult {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_callissue_delta {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_callcomplete_delta {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sysid_routing.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.call_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.module_crc {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.module_hash.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.ecallresult {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.result_content.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.os_version_info.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.system_info.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.load_address {
            os.write_fixed64(9, v)?;
        }
        if let Some(v) = self.exception_record.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.portable_os_version_info.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.portable_system_info.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.was_converted {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.internal_result {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.current_count {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.last_call_handle {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.last_call_module_crc {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.last_call_sysid_routing.as_ref() {
            os.write_bytes(18, v)?;
        }
        if let Some(v) = self.last_ecallresult {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.last_callissue_delta {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.last_callcomplete_delta {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServiceCallResponse {
        CMsgClientServiceCallResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "sysid_routing",
                |m: &CMsgClientServiceCallResponse| { &m.sysid_routing },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.sysid_routing },
                CMsgClientServiceCallResponse::get_sysid_routing,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "call_handle",
                |m: &CMsgClientServiceCallResponse| { &m.call_handle },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.call_handle },
                CMsgClientServiceCallResponse::get_call_handle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "module_crc",
                |m: &CMsgClientServiceCallResponse| { &m.module_crc },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.module_crc },
                CMsgClientServiceCallResponse::get_module_crc,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "module_hash",
                |m: &CMsgClientServiceCallResponse| { &m.module_hash },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.module_hash },
                CMsgClientServiceCallResponse::get_module_hash,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "ecallresult",
                |m: &CMsgClientServiceCallResponse| { &m.ecallresult },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.ecallresult },
                CMsgClientServiceCallResponse::get_ecallresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "result_content",
                |m: &CMsgClientServiceCallResponse| { &m.result_content },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.result_content },
                CMsgClientServiceCallResponse::get_result_content,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "os_version_info",
                |m: &CMsgClientServiceCallResponse| { &m.os_version_info },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.os_version_info },
                CMsgClientServiceCallResponse::get_os_version_info,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "system_info",
                |m: &CMsgClientServiceCallResponse| { &m.system_info },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.system_info },
                CMsgClientServiceCallResponse::get_system_info,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "load_address",
                |m: &CMsgClientServiceCallResponse| { &m.load_address },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.load_address },
                CMsgClientServiceCallResponse::get_load_address,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "exception_record",
                |m: &CMsgClientServiceCallResponse| { &m.exception_record },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.exception_record },
                CMsgClientServiceCallResponse::get_exception_record,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "portable_os_version_info",
                |m: &CMsgClientServiceCallResponse| { &m.portable_os_version_info },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.portable_os_version_info },
                CMsgClientServiceCallResponse::get_portable_os_version_info,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "portable_system_info",
                |m: &CMsgClientServiceCallResponse| { &m.portable_system_info },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.portable_system_info },
                CMsgClientServiceCallResponse::get_portable_system_info,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "was_converted",
                |m: &CMsgClientServiceCallResponse| { &m.was_converted },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.was_converted },
                CMsgClientServiceCallResponse::get_was_converted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "internal_result",
                |m: &CMsgClientServiceCallResponse| { &m.internal_result },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.internal_result },
                CMsgClientServiceCallResponse::get_internal_result,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "current_count",
                |m: &CMsgClientServiceCallResponse| { &m.current_count },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.current_count },
                CMsgClientServiceCallResponse::get_current_count,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_call_handle",
                |m: &CMsgClientServiceCallResponse| { &m.last_call_handle },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_handle },
                CMsgClientServiceCallResponse::get_last_call_handle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_call_module_crc",
                |m: &CMsgClientServiceCallResponse| { &m.last_call_module_crc },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_module_crc },
                CMsgClientServiceCallResponse::get_last_call_module_crc,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "last_call_sysid_routing",
                |m: &CMsgClientServiceCallResponse| { &m.last_call_sysid_routing },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_sysid_routing },
                CMsgClientServiceCallResponse::get_last_call_sysid_routing,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_ecallresult",
                |m: &CMsgClientServiceCallResponse| { &m.last_ecallresult },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_ecallresult },
                CMsgClientServiceCallResponse::get_last_ecallresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_callissue_delta",
                |m: &CMsgClientServiceCallResponse| { &m.last_callissue_delta },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_callissue_delta },
                CMsgClientServiceCallResponse::get_last_callissue_delta,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_callcomplete_delta",
                |m: &CMsgClientServiceCallResponse| { &m.last_callcomplete_delta },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_callcomplete_delta },
                CMsgClientServiceCallResponse::get_last_callcomplete_delta,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientServiceCallResponse>(
                "CMsgClientServiceCallResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServiceCallResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientServiceCallResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientServiceCallResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientServiceCallResponse {
    fn clear(&mut self) {
        self.sysid_routing.clear();
        self.call_handle = ::std::option::Option::None;
        self.module_crc = ::std::option::Option::None;
        self.module_hash.clear();
        self.ecallresult = ::std::option::Option::None;
        self.result_content.clear();
        self.os_version_info.clear();
        self.system_info.clear();
        self.load_address = ::std::option::Option::None;
        self.exception_record.clear();
        self.portable_os_version_info.clear();
        self.portable_system_info.clear();
        self.was_converted = ::std::option::Option::None;
        self.internal_result = ::std::option::Option::None;
        self.current_count = ::std::option::Option::None;
        self.last_call_handle = ::std::option::Option::None;
        self.last_call_module_crc = ::std::option::Option::None;
        self.last_call_sysid_routing.clear();
        self.last_ecallresult = ::std::option::Option::None;
        self.last_callissue_delta = ::std::option::Option::None;
        self.last_callcomplete_delta = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServiceCallResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceCallResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAMUnlockStreaming {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockStreaming {
    fn default() -> &'a CMsgAMUnlockStreaming {
        <CMsgAMUnlockStreaming as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockStreaming {
    pub fn new() -> CMsgAMUnlockStreaming {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgAMUnlockStreaming {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAMUnlockStreaming {
        CMsgAMUnlockStreaming::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgAMUnlockStreaming>(
                "CMsgAMUnlockStreaming",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAMUnlockStreaming {
        static instance: ::protobuf::rt::Lazy<CMsgAMUnlockStreaming> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgAMUnlockStreaming::new)
    }
}

impl ::protobuf::Clear for CMsgAMUnlockStreaming {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAMUnlockStreaming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockStreaming {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAMUnlockStreamingResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    encryption_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockStreamingResponse {
    fn default() -> &'a CMsgAMUnlockStreamingResponse {
        <CMsgAMUnlockStreamingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockStreamingResponse {
    pub fn new() -> CMsgAMUnlockStreamingResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes encryption_key = 2;

    pub fn get_encryption_key(&self) -> &[u8] {
        match self.encryption_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encryption_key(&mut self) {
        self.encryption_key.clear();
    }

    pub fn has_encryption_key(&self) -> bool {
        self.encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryption_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encryption_key.is_none() {
            self.encryption_key.set_default();
        }
        self.encryption_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_key(&mut self) -> ::std::vec::Vec<u8> {
        self.encryption_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgAMUnlockStreamingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encryption_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encryption_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.encryption_key.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAMUnlockStreamingResponse {
        CMsgAMUnlockStreamingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgAMUnlockStreamingResponse| { &m.eresult },
                |m: &mut CMsgAMUnlockStreamingResponse| { &mut m.eresult },
                CMsgAMUnlockStreamingResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "encryption_key",
                |m: &CMsgAMUnlockStreamingResponse| { &m.encryption_key },
                |m: &mut CMsgAMUnlockStreamingResponse| { &mut m.encryption_key },
                CMsgAMUnlockStreamingResponse::get_encryption_key,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgAMUnlockStreamingResponse>(
                "CMsgAMUnlockStreamingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAMUnlockStreamingResponse {
        static instance: ::protobuf::rt::Lazy<CMsgAMUnlockStreamingResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgAMUnlockStreamingResponse::new)
    }
}

impl ::protobuf::Clear for CMsgAMUnlockStreamingResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.encryption_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAMUnlockStreamingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockStreamingResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAMUnlockHEVC {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockHEVC {
    fn default() -> &'a CMsgAMUnlockHEVC {
        <CMsgAMUnlockHEVC as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockHEVC {
    pub fn new() -> CMsgAMUnlockHEVC {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgAMUnlockHEVC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAMUnlockHEVC {
        CMsgAMUnlockHEVC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgAMUnlockHEVC>(
                "CMsgAMUnlockHEVC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAMUnlockHEVC {
        static instance: ::protobuf::rt::Lazy<CMsgAMUnlockHEVC> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgAMUnlockHEVC::new)
    }
}

impl ::protobuf::Clear for CMsgAMUnlockHEVC {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAMUnlockHEVC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockHEVC {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAMUnlockHEVCResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockHEVCResponse {
    fn default() -> &'a CMsgAMUnlockHEVCResponse {
        <CMsgAMUnlockHEVCResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockHEVCResponse {
    pub fn new() -> CMsgAMUnlockHEVCResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAMUnlockHEVCResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAMUnlockHEVCResponse {
        CMsgAMUnlockHEVCResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgAMUnlockHEVCResponse| { &m.eresult },
                |m: &mut CMsgAMUnlockHEVCResponse| { &mut m.eresult },
                CMsgAMUnlockHEVCResponse::get_eresult,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgAMUnlockHEVCResponse>(
                "CMsgAMUnlockHEVCResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAMUnlockHEVCResponse {
        static instance: ::protobuf::rt::Lazy<CMsgAMUnlockHEVCResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgAMUnlockHEVCResponse::new)
    }
}

impl ::protobuf::Clear for CMsgAMUnlockHEVCResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAMUnlockHEVCResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockHEVCResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPlayingSessionState {
    // message fields
    playing_blocked: ::std::option::Option<bool>,
    playing_app: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPlayingSessionState {
    fn default() -> &'a CMsgClientPlayingSessionState {
        <CMsgClientPlayingSessionState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPlayingSessionState {
    pub fn new() -> CMsgClientPlayingSessionState {
        ::std::default::Default::default()
    }

    // optional bool playing_blocked = 2;

    pub fn get_playing_blocked(&self) -> bool {
        self.playing_blocked.unwrap_or(false)
    }

    pub fn clear_playing_blocked(&mut self) {
        self.playing_blocked = ::std::option::Option::None;
    }

    pub fn has_playing_blocked(&self) -> bool {
        self.playing_blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_blocked(&mut self, v: bool) {
        self.playing_blocked = ::std::option::Option::Some(v);
    }

    // optional uint32 playing_app = 3;

    pub fn get_playing_app(&self) -> u32 {
        self.playing_app.unwrap_or(0)
    }

    pub fn clear_playing_app(&mut self) {
        self.playing_app = ::std::option::Option::None;
    }

    pub fn has_playing_app(&self) -> bool {
        self.playing_app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_app(&mut self, v: u32) {
        self.playing_app = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPlayingSessionState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.playing_blocked = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.playing_app = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.playing_blocked {
            my_size += 2;
        }
        if let Some(v) = self.playing_app {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.playing_blocked {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.playing_app {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPlayingSessionState {
        CMsgClientPlayingSessionState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "playing_blocked",
                |m: &CMsgClientPlayingSessionState| { &m.playing_blocked },
                |m: &mut CMsgClientPlayingSessionState| { &mut m.playing_blocked },
                CMsgClientPlayingSessionState::get_playing_blocked,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "playing_app",
                |m: &CMsgClientPlayingSessionState| { &m.playing_app },
                |m: &mut CMsgClientPlayingSessionState| { &mut m.playing_app },
                CMsgClientPlayingSessionState::get_playing_app,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPlayingSessionState>(
                "CMsgClientPlayingSessionState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPlayingSessionState {
        static instance: ::protobuf::rt::Lazy<CMsgClientPlayingSessionState> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientPlayingSessionState::new)
    }
}

impl ::protobuf::Clear for CMsgClientPlayingSessionState {
    fn clear(&mut self) {
        self.playing_blocked = ::std::option::Option::None;
        self.playing_app = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPlayingSessionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPlayingSessionState {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientKickPlayingSession {
    // message fields
    only_stop_game: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientKickPlayingSession {
    fn default() -> &'a CMsgClientKickPlayingSession {
        <CMsgClientKickPlayingSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientKickPlayingSession {
    pub fn new() -> CMsgClientKickPlayingSession {
        ::std::default::Default::default()
    }

    // optional bool only_stop_game = 1;

    pub fn get_only_stop_game(&self) -> bool {
        self.only_stop_game.unwrap_or(false)
    }

    pub fn clear_only_stop_game(&mut self) {
        self.only_stop_game = ::std::option::Option::None;
    }

    pub fn has_only_stop_game(&self) -> bool {
        self.only_stop_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_stop_game(&mut self, v: bool) {
        self.only_stop_game = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientKickPlayingSession {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.only_stop_game = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.only_stop_game {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.only_stop_game {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientKickPlayingSession {
        CMsgClientKickPlayingSession::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "only_stop_game",
                |m: &CMsgClientKickPlayingSession| { &m.only_stop_game },
                |m: &mut CMsgClientKickPlayingSession| { &mut m.only_stop_game },
                CMsgClientKickPlayingSession::get_only_stop_game,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientKickPlayingSession>(
                "CMsgClientKickPlayingSession",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientKickPlayingSession {
        static instance: ::protobuf::rt::Lazy<CMsgClientKickPlayingSession> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientKickPlayingSession::new)
    }
}

impl ::protobuf::Clear for CMsgClientKickPlayingSession {
    fn clear(&mut self) {
        self.only_stop_game = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientKickPlayingSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientKickPlayingSession {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientVoiceCallPreAuthorize {
    // message fields
    caller_steamid: ::std::option::Option<u64>,
    receiver_steamid: ::std::option::Option<u64>,
    caller_id: ::std::option::Option<i32>,
    hangup: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientVoiceCallPreAuthorize {
    fn default() -> &'a CMsgClientVoiceCallPreAuthorize {
        <CMsgClientVoiceCallPreAuthorize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVoiceCallPreAuthorize {
    pub fn new() -> CMsgClientVoiceCallPreAuthorize {
        ::std::default::Default::default()
    }

    // optional fixed64 caller_steamid = 1;

    pub fn get_caller_steamid(&self) -> u64 {
        self.caller_steamid.unwrap_or(0)
    }

    pub fn clear_caller_steamid(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
    }

    pub fn has_caller_steamid(&self) -> bool {
        self.caller_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_steamid(&mut self, v: u64) {
        self.caller_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;

    pub fn get_receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }

    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional int32 caller_id = 3;

    pub fn get_caller_id(&self) -> i32 {
        self.caller_id.unwrap_or(0)
    }

    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: i32) {
        self.caller_id = ::std::option::Option::Some(v);
    }

    // optional bool hangup = 4;

    pub fn get_hangup(&self) -> bool {
        self.hangup.unwrap_or(false)
    }

    pub fn clear_hangup(&mut self) {
        self.hangup = ::std::option::Option::None;
    }

    pub fn has_hangup(&self) -> bool {
        self.hangup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hangup(&mut self, v: bool) {
        self.hangup = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientVoiceCallPreAuthorize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.caller_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.receiver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.caller_id = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hangup = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.caller_steamid {
            my_size += 9;
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 9;
        }
        if let Some(v) = self.caller_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hangup {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.caller_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.caller_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hangup {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientVoiceCallPreAuthorize {
        CMsgClientVoiceCallPreAuthorize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "caller_steamid",
                |m: &CMsgClientVoiceCallPreAuthorize| { &m.caller_steamid },
                |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.caller_steamid },
                CMsgClientVoiceCallPreAuthorize::get_caller_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "receiver_steamid",
                |m: &CMsgClientVoiceCallPreAuthorize| { &m.receiver_steamid },
                |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.receiver_steamid },
                CMsgClientVoiceCallPreAuthorize::get_receiver_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "caller_id",
                |m: &CMsgClientVoiceCallPreAuthorize| { &m.caller_id },
                |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.caller_id },
                CMsgClientVoiceCallPreAuthorize::get_caller_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "hangup",
                |m: &CMsgClientVoiceCallPreAuthorize| { &m.hangup },
                |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.hangup },
                CMsgClientVoiceCallPreAuthorize::get_hangup,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientVoiceCallPreAuthorize>(
                "CMsgClientVoiceCallPreAuthorize",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientVoiceCallPreAuthorize {
        static instance: ::protobuf::rt::Lazy<CMsgClientVoiceCallPreAuthorize> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientVoiceCallPreAuthorize::new)
    }
}

impl ::protobuf::Clear for CMsgClientVoiceCallPreAuthorize {
    fn clear(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.hangup = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientVoiceCallPreAuthorize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientVoiceCallPreAuthorize {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientVoiceCallPreAuthorizeResponse {
    // message fields
    caller_steamid: ::std::option::Option<u64>,
    receiver_steamid: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    caller_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientVoiceCallPreAuthorizeResponse {
    fn default() -> &'a CMsgClientVoiceCallPreAuthorizeResponse {
        <CMsgClientVoiceCallPreAuthorizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVoiceCallPreAuthorizeResponse {
    pub fn new() -> CMsgClientVoiceCallPreAuthorizeResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 caller_steamid = 1;

    pub fn get_caller_steamid(&self) -> u64 {
        self.caller_steamid.unwrap_or(0)
    }

    pub fn clear_caller_steamid(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
    }

    pub fn has_caller_steamid(&self) -> bool {
        self.caller_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_steamid(&mut self, v: u64) {
        self.caller_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;

    pub fn get_receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }

    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 caller_id = 4;

    pub fn get_caller_id(&self) -> i32 {
        self.caller_id.unwrap_or(0)
    }

    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: i32) {
        self.caller_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientVoiceCallPreAuthorizeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.caller_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.receiver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.caller_id = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.caller_steamid {
            my_size += 9;
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.caller_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.caller_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.caller_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientVoiceCallPreAuthorizeResponse {
        CMsgClientVoiceCallPreAuthorizeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "caller_steamid",
                |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.caller_steamid },
                |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.caller_steamid },
                CMsgClientVoiceCallPreAuthorizeResponse::get_caller_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "receiver_steamid",
                |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.receiver_steamid },
                |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.receiver_steamid },
                CMsgClientVoiceCallPreAuthorizeResponse::get_receiver_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "eresult",
                |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.eresult },
                |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.eresult },
                CMsgClientVoiceCallPreAuthorizeResponse::get_eresult,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "caller_id",
                |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.caller_id },
                |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.caller_id },
                CMsgClientVoiceCallPreAuthorizeResponse::get_caller_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgClientVoiceCallPreAuthorizeResponse>(
                "CMsgClientVoiceCallPreAuthorizeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientVoiceCallPreAuthorizeResponse {
        static instance: ::protobuf::rt::Lazy<CMsgClientVoiceCallPreAuthorizeResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgClientVoiceCallPreAuthorizeResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientVoiceCallPreAuthorizeResponse {
    fn clear(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientVoiceCallPreAuthorizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientVoiceCallPreAuthorizeResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgBadgeCraftedNotification {
    // message fields
    appid: ::std::option::Option<u32>,
    badge_level: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBadgeCraftedNotification {
    fn default() -> &'a CMsgBadgeCraftedNotification {
        <CMsgBadgeCraftedNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBadgeCraftedNotification {
    pub fn new() -> CMsgBadgeCraftedNotification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 2;

    pub fn get_badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }

    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBadgeCraftedNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.badge_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.badge_level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBadgeCraftedNotification {
        CMsgBadgeCraftedNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CMsgBadgeCraftedNotification| { &m.appid },
                |m: &mut CMsgBadgeCraftedNotification| { &mut m.appid },
                CMsgBadgeCraftedNotification::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "badge_level",
                |m: &CMsgBadgeCraftedNotification| { &m.badge_level },
                |m: &mut CMsgBadgeCraftedNotification| { &mut m.badge_level },
                CMsgBadgeCraftedNotification::get_badge_level,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgBadgeCraftedNotification>(
                "CMsgBadgeCraftedNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgBadgeCraftedNotification {
        static instance: ::protobuf::rt::Lazy<CMsgBadgeCraftedNotification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgBadgeCraftedNotification::new)
    }
}

impl ::protobuf::Clear for CMsgBadgeCraftedNotification {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBadgeCraftedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBadgeCraftedNotification {
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"steammessages_clientserver_2.proto\x1a\x18steammessages_base.proto\"\
    \xb6\x04\n\x1aCMsgClientUCMAddScreenshot\x12\x14\n\x05appid\x18\x01\x20\
    \x01(\rR\x05appid\x12\x1a\n\x08filename\x18\x02\x20\x01(\tR\x08filename\
    \x12\x1c\n\tthumbname\x18\x03\x20\x01(\tR\tthumbname\x12\x1f\n\x0bvr_fil\
    ename\x18\x0e\x20\x01(\tR\nvrFilename\x12'\n\x0frtime32_created\x18\x04\
    \x20\x01(\x07R\x0ertime32Created\x12\x14\n\x05width\x18\x05\x20\x01(\rR\
    \x05width\x12\x16\n\x06height\x18\x06\x20\x01(\rR\x06height\x12\x20\n\
    \x0bpermissions\x18\x07\x20\x01(\rR\x0bpermissions\x12\x18\n\x07caption\
    \x18\x08\x20\x01(\tR\x07caption\x12#\n\rshortcut_name\x18\t\x20\x01(\tR\
    \x0cshortcutName\x121\n\x03tag\x18\n\x20\x03(\x0b2\x1f.CMsgClientUCMAddS\
    creenshot.TagR\x03tag\x12%\n\x0etagged_steamid\x18\x0b\x20\x03(\x06R\rta\
    ggedSteamid\x12\x1f\n\x0bspoiler_tag\x18\x0c\x20\x01(\x08R\nspoilerTag\
    \x125\n\x16tagged_publishedfileid\x18\r\x20\x03(\x04R\x15taggedPublished\
    fileid\x1a=\n\x03Tag\x12\x19\n\x08tag_name\x18\x01\x20\x01(\tR\x07tagNam\
    e\x12\x1b\n\ttag_value\x18\x02\x20\x01(\tR\x08tagValue\"{\n\"CMsgClientU\
    CMAddScreenshotResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x128\n\x0cscreenshotid\x18\x02\x20\x01(\x06:\x14184467440737\
    09551615R\x0cscreenshotid\"Y\n\x1dCMsgClientUCMDeleteScreenshot\x128\n\
    \x0cscreenshotid\x18\x01\x20\x01(\x06:\x1418446744073709551615R\x0cscree\
    nshotid\"D\n%CMsgClientUCMDeleteScreenshotResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\"\x83\x04\n\x18CMsgClientUCMPubl\
    ishFile\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile\
    _name\x18\x02\x20\x01(\tR\x08fileName\x12*\n\x11preview_file_name\x18\
    \x03\x20\x01(\tR\x0fpreviewFileName\x12&\n\x0fconsumer_app_id\x18\x04\
    \x20\x01(\rR\rconsumerAppId\x12\x14\n\x05title\x18\x05\x20\x01(\tR\x05ti\
    tle\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescription\x12\x12\
    \n\x04tags\x18\x08\x20\x03(\tR\x04tags\x12#\n\rworkshop_file\x18\t\x20\
    \x01(\x08R\x0cworkshopFile\x12\x1e\n\nvisibility\x18\n\x20\x01(\x05R\nvi\
    sibility\x12\x1b\n\tfile_type\x18\x0b\x20\x01(\rR\x08fileType\x12\x10\n\
    \x03url\x18\x0c\x20\x01(\tR\x03url\x12%\n\x0evideo_provider\x18\r\x20\
    \x01(\rR\rvideoProvider\x12,\n\x12video_account_name\x18\x0e\x20\x01(\tR\
    \x10videoAccountName\x12)\n\x10video_identifier\x18\x0f\x20\x01(\tR\x0fv\
    ideoIdentifier\x12\x1f\n\x0bin_progress\x18\x10\x20\x01(\x08R\ninProgres\
    s\"\xe2\x01\n\x20CMsgClientUCMPublishFileResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\x12@\n\x11published_file_id\x18\
    \x02\x20\x01(\x06:\x1418446744073709551615R\x0fpublishedFileId\x12_\n)ne\
    eds_workshop_legal_agreement_acceptance\x18\x03\x20\x01(\x08:\x05falseR%\
    needsWorkshopLegalAgreementAcceptance\"\x84\x0b\n\x20CMsgClientUCMUpdate\
    PublishedFile\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12*\n\
    \x11published_file_id\x18\x02\x20\x01(\x06R\x0fpublishedFileId\x12\x1b\n\
    \tfile_name\x18\x03\x20\x01(\tR\x08fileName\x12*\n\x11preview_file_name\
    \x18\x04\x20\x01(\tR\x0fpreviewFileName\x12\x14\n\x05title\x18\x05\x20\
    \x01(\tR\x05title\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescri\
    ption\x12\x12\n\x04tags\x18\x07\x20\x03(\tR\x04tags\x12\x1e\n\nvisibilit\
    y\x18\x08\x20\x01(\x05R\nvisibility\x12\x1f\n\x0bupdate_file\x18\t\x20\
    \x01(\x08R\nupdateFile\x12.\n\x13update_preview_file\x18\n\x20\x01(\x08R\
    \x11updatePreviewFile\x12!\n\x0cupdate_title\x18\x0b\x20\x01(\x08R\x0bup\
    dateTitle\x12-\n\x12update_description\x18\x0c\x20\x01(\x08R\x11updateDe\
    scription\x12\x1f\n\x0bupdate_tags\x18\r\x20\x01(\x08R\nupdateTags\x12+\
    \n\x11update_visibility\x18\x0e\x20\x01(\x08R\x10updateVisibility\x12-\n\
    \x12change_description\x18\x0f\x20\x01(\tR\x11changeDescription\x12\x1d\
    \n\nupdate_url\x18\x10\x20\x01(\x08R\tupdateUrl\x12\x10\n\x03url\x18\x11\
    \x20\x01(\tR\x03url\x126\n\x17update_content_manifest\x18\x12\x20\x01(\
    \x08R\x15updateContentManifest\x12)\n\x10content_manifest\x18\x13\x20\
    \x01(\x06R\x0fcontentManifest\x12\x1a\n\x08metadata\x18\x14\x20\x01(\tR\
    \x08metadata\x12'\n\x0fupdate_metadata\x18\x15\x20\x01(\x08R\x0eupdateMe\
    tadata\x12\x1d\n\x08language\x18\x16\x20\x01(\x05:\x010R\x08language\x12\
    %\n\x0eremoved_kvtags\x18\x17\x20\x03(\tR\rremovedKvtags\x12E\n\x06kvtag\
    s\x18\x18\x20\x03(\x0b2-.CMsgClientUCMUpdatePublishedFile.KeyValueTagR\
    \x06kvtags\x12O\n\x08previews\x18\x19\x20\x03(\x0b23.CMsgClientUCMUpdate\
    PublishedFile.AdditionalPreviewR\x08previews\x12,\n\x12previews_to_remov\
    e\x18\x1a\x20\x03(\x05R\x10previewsToRemove\x12*\n\x11clear_in_progress\
    \x18\x1b\x20\x01(\x08R\x0fclearInProgress\x12*\n\x11remove_all_kvtags\
    \x18\x1c\x20\x01(\x08R\x0fremoveAllKvtags\x1a5\n\x0bKeyValueTag\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value\x1a\xd3\x01\n\x11AdditionalPreview\x12,\n\x12original_file_\
    name\x18\x01\x20\x01(\tR\x10originalFileName\x12,\n\x12internal_file_nam\
    e\x18\x02\x20\x01(\tR\x10internalFileName\x12\x18\n\x07videoid\x18\x03\
    \x20\x01(\tR\x07videoid\x12!\n\x0cpreview_type\x18\x04\x20\x01(\rR\x0bpr\
    eviewType\x12%\n\x0cupdate_index\x18\x05\x20\x01(\x05:\x02-1R\x0bupdateI\
    ndex\"\xa8\x01\n(CMsgClientUCMUpdatePublishedFileResponse\x12\x1b\n\x07e\
    result\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12_\n)needs_workshop_lega\
    l_agreement_acceptance\x18\x02\x20\x01(\x08:\x05falseR%needsWorkshopLega\
    lAgreementAcceptance\"e\n\x20CMsgClientUCMDeletePublishedFile\x12*\n\x11\
    published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x15\n\x06\
    app_id\x18\x02\x20\x01(\rR\x05appId\"G\n(CMsgClientUCMDeletePublishedFil\
    eResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\"\
    \x81\x01\n(CMsgClientUCMEnumerateUserPublishedFiles\x12\x15\n\x06app_id\
    \x18\x01\x20\x01(\rR\x05appId\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\
    \rR\nstartIndex\x12\x1d\n\nsort_order\x18\x03\x20\x01(\rR\tsortOrder\"\
    \x9f\x02\n0CMsgClientUCMEnumerateUserPublishedFilesResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12j\n\x0fpublished_f\
    iles\x18\x02\x20\x03(\x0b2A.CMsgClientUCMEnumerateUserPublishedFilesResp\
    onse.PublishedFileIdR\x0epublishedFiles\x12#\n\rtotal_results\x18\x03\
    \x20\x01(\rR\x0ctotalResults\x1a=\n\x0fPublishedFileId\x12*\n\x11publish\
    ed_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\"\xce\x01\n)CMsgClie\
    ntUCMEnumerateUserSubscribedFiles\x12\x15\n\x06app_id\x18\x01\x20\x01(\r\
    R\x05appId\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\rR\nstartIndex\x12\
    \x1e\n\tlist_type\x18\x03\x20\x01(\r:\x011R\x08listType\x12/\n\x12matchi\
    ng_file_type\x18\x04\x20\x01(\r:\x010R\x10matchingFileType\x12\x18\n\x05\
    count\x18\x05\x20\x01(\r:\x0250R\x05count\"\xd5\x02\n1CMsgClientUCMEnume\
    rateUserSubscribedFilesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12m\n\x10subscribed_files\x18\x02\x20\x03(\x0b2B\
    .CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileIdR\x0fs\
    ubscribedFiles\x12#\n\rtotal_results\x18\x03\x20\x01(\rR\x0ctotalResults\
    \x1ao\n\x0fPublishedFileId\x12*\n\x11published_file_id\x18\x01\x20\x01(\
    \x06R\x0fpublishedFileId\x120\n\x12rtime32_subscribed\x18\x02\x20\x01(\
    \x07:\x010R\x11rtime32Subscribed\"\xbb\x01\n4CMsgClientUCMEnumerateUserS\
    ubscribedFilesWithUpdates\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05app\
    Id\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\rR\nstartIndex\x12\x1d\n\ns\
    tart_time\x18\x03\x20\x01(\x07R\tstartTime\x12,\n\x10desired_revision\
    \x18\x04\x20\x01(\r:\x010R\x0fdesiredRevision\"\xa0\x04\n<CMsgClientUCME\
    numerateUserSubscribedFilesWithUpdatesResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x12x\n\x10subscribed_files\x18\x02\
    \x20\x03(\x0b2M.CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResp\
    onse.PublishedFileIdR\x0fsubscribedFiles\x12#\n\rtotal_results\x18\x03\
    \x20\x01(\rR\x0ctotalResults\x1a\xa3\x02\n\x0fPublishedFileId\x12*\n\x11\
    published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x120\n\x12rti\
    me32_subscribed\x18\x02\x20\x01(\x07:\x010R\x11rtime32Subscribed\x12\x14\
    \n\x05appid\x18\x03\x20\x01(\rR\x05appid\x12#\n\rfile_hcontent\x18\x04\
    \x20\x01(\x06R\x0cfileHcontent\x12\x1b\n\tfile_size\x18\x05\x20\x01(\rR\
    \x08fileSize\x120\n\x14rtime32_last_updated\x18\x06\x20\x01(\x07R\x12rti\
    me32LastUpdated\x12(\n\x10is_depot_content\x18\x07\x20\x01(\x08R\x0eisDe\
    potContent\"f\n!CMsgClientUCMPublishedFileDeleted\x12*\n\x11published_fi\
    le_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x15\n\x06app_id\x18\
    \x02\x20\x01(\rR\x05appId\"\x88\x02\n!CMsgClientUCMPublishedFileUpdated\
    \x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\
    \x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12!\n\x0ctime_updated\
    \x18\x03\x20\x01(\rR\x0btimeUpdated\x12\x1a\n\x08hcontent\x18\x04\x20\
    \x01(\x06R\x08hcontent\x12\x1b\n\tfile_size\x18\x05\x20\x01(\x07R\x08fil\
    eSize\x12(\n\x10is_depot_content\x18\x06\x20\x01(\x08R\x0eisDepotContent\
    \x12\x1a\n\x08revision\x18\x07\x20\x01(\rR\x08revision\"\x93\x01\n$CMsgC\
    lientWorkshopItemChangesRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12*\n\x11last_time_updated\x18\x02\x20\x01(\rR\x0flastTimeUpd\
    ated\x12(\n\x10num_items_needed\x18\x03\x20\x01(\rR\x0enumItemsNeeded\"\
    \xca\x02\n%CMsgClientWorkshopItemChangesResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x1f\n\x0bupdate_time\x18\x02\
    \x20\x01(\rR\nupdateTime\x12^\n\x0eworkshop_items\x18\x05\x20\x03(\x0b27\
    .CMsgClientWorkshopItemChangesResponse.WorkshopItemInfoR\rworkshopItems\
    \x1a\x82\x01\n\x10WorkshopItemInfo\x12*\n\x11published_file_id\x18\x01\
    \x20\x01(\x06R\x0fpublishedFileId\x12!\n\x0ctime_updated\x18\x02\x20\x01\
    (\rR\x0btimeUpdated\x12\x1f\n\x0bmanifest_id\x18\x03\x20\x01(\x06R\nmani\
    festId\"\x9d\x02\n!CMsgClientWorkshopItemInfoRequest\x12\x15\n\x06app_id\
    \x18\x01\x20\x01(\rR\x05appId\x12*\n\x11last_time_updated\x18\x02\x20\
    \x01(\rR\x0flastTimeUpdated\x12V\n\x0eworkshop_items\x18\x03\x20\x03(\
    \x0b2/.CMsgClientWorkshopItemInfoRequest.WorkshopItemR\rworkshopItems\
    \x1a]\n\x0cWorkshopItem\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06\
    R\x0fpublishedFileId\x12!\n\x0ctime_updated\x18\x02\x20\x01(\rR\x0btimeU\
    pdated\"\x86\x03\n\"CMsgClientWorkshopItemInfoResponse\x12\x1b\n\x07eres\
    ult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x1f\n\x0bupdate_time\x18\
    \x02\x20\x01(\rR\nupdateTime\x12[\n\x0eworkshop_items\x18\x03\x20\x03(\
    \x0b24.CMsgClientWorkshopItemInfoResponse.WorkshopItemInfoR\rworkshopIte\
    ms\x12#\n\rprivate_items\x18\x04\x20\x03(\x06R\x0cprivateItems\x1a\x9f\
    \x01\n\x10WorkshopItemInfo\x12*\n\x11published_file_id\x18\x01\x20\x01(\
    \x06R\x0fpublishedFileId\x12!\n\x0ctime_updated\x18\x02\x20\x01(\rR\x0bt\
    imeUpdated\x12\x1f\n\x0bmanifest_id\x18\x03\x20\x01(\x06R\nmanifestId\
    \x12\x1b\n\tis_legacy\x18\x04\x20\x01(\x08R\x08isLegacy\"\xd3\x01\n%CMsg\
    ClientUCMGetPublishedFilesForUser\x12\x15\n\x06app_id\x18\x01\x20\x01(\r\
    R\x05appId\x12(\n\x10creator_steam_id\x18\x02\x20\x01(\x06R\x0ecreatorSt\
    eamId\x12#\n\rrequired_tags\x18\x03\x20\x03(\tR\x0crequiredTags\x12#\n\r\
    excluded_tags\x18\x04\x20\x03(\tR\x0cexcludedTags\x12\x1f\n\x0bstart_ind\
    ex\x18\x05\x20\x01(\rR\nstartIndex\"\x99\x02\n-CMsgClientUCMGetPublished\
    FilesForUserResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12g\n\x0fpublished_files\x18\x02\x20\x03(\x0b2>.CMsgClientU\
    CMGetPublishedFilesForUserResponse.PublishedFileIdR\x0epublishedFiles\
    \x12#\n\rtotal_results\x18\x03\x20\x01(\rR\x0ctotalResults\x1a=\n\x0fPub\
    lishedFileId\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublis\
    hedFileId\"\x84\x01\n'CMsgClientUCMSetUserPublishedFileAction\x12*\n\x11\
    published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x15\n\x06\
    app_id\x18\x02\x20\x01(\rR\x05appId\x12\x16\n\x06action\x18\x03\x20\x01(\
    \x05R\x06action\"N\n/CMsgClientUCMSetUserPublishedFileActionResponse\x12\
    \x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\"\x82\x01\n0CMs\
    gClientUCMEnumeratePublishedFilesByUserAction\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\rR\n\
    startIndex\x12\x16\n\x06action\x18\x03\x20\x01(\x05R\x06action\"\xdc\x02\
    \n8CMsgClientUCMEnumeratePublishedFilesByUserActionResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12r\n\x0fpublished_f\
    iles\x18\x02\x20\x03(\x0b2I.CMsgClientUCMEnumeratePublishedFilesByUserAc\
    tionResponse.PublishedFileIdR\x0epublishedFiles\x12#\n\rtotal_results\
    \x18\x03\x20\x01(\rR\x0ctotalResults\x1aj\n\x0fPublishedFileId\x12*\n\
    \x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12+\n\
    \x10rtime_time_stamp\x18\x02\x20\x01(\x07:\x010R\x0ertimeTimeStamp\"\x1e\
    \n\x1cCMsgClientScreenshotsChanged\"\xa5\x01\n\x1cCMsgClientUpdateUserGa\
    meInfo\x12!\n\x0csteamid_idgs\x18\x01\x20\x01(\x06R\x0bsteamidIdgs\x12\
    \x16\n\x06gameid\x18\x02\x20\x01(\x06R\x06gameid\x12\x17\n\x07game_ip\
    \x18\x03\x20\x01(\rR\x06gameIp\x12\x1b\n\tgame_port\x18\x04\x20\x01(\rR\
    \x08gamePort\x12\x14\n\x05token\x18\x05\x20\x01(\x0cR\x05token\"u\n\x1cC\
    MsgClientRichPresenceUpload\x12(\n\x10rich_presence_kv\x18\x01\x20\x01(\
    \x0cR\x0erichPresenceKv\x12+\n\x11steamid_broadcast\x18\x02\x20\x03(\x06\
    R\x10steamidBroadcast\"H\n\x1dCMsgClientRichPresenceRequest\x12'\n\x0fst\
    eamid_request\x18\x01\x20\x03(\x06R\x0esteamidRequest\"\xc8\x01\n\x1aCMs\
    gClientRichPresenceInfo\x12M\n\rrich_presence\x18\x01\x20\x03(\x0b2(.CMs\
    gClientRichPresenceInfo.RichPresenceR\x0crichPresence\x1a[\n\x0cRichPres\
    ence\x12!\n\x0csteamid_user\x18\x01\x20\x01(\x06R\x0bsteamidUser\x12(\n\
    \x10rich_presence_kv\x18\x02\x20\x01(\x0cR\x0erichPresenceKv\"5\n\x1cCMs\
    gClientCheckFileSignature\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05app\
    Id\"\xf6\x02\n$CMsgClientCheckFileSignatureResponse\x12\x15\n\x06app_id\
    \x18\x01\x20\x01(\rR\x05appId\x12\x10\n\x03pid\x18\x02\x20\x01(\rR\x03pi\
    d\x12\x18\n\x07eresult\x18\x03\x20\x01(\rR\x07eresult\x12\x1a\n\x08filen\
    ame\x18\x04\x20\x01(\tR\x08filename\x12*\n\x10esignatureresult\x18\x05\
    \x20\x01(\rR\x10esignatureresult\x12\x19\n\x08sha_file\x18\x06\x20\x01(\
    \x0cR\x07shaFile\x12(\n\x0fsignatureheader\x18\x07\x20\x01(\x0cR\x0fsign\
    atureheader\x12\x1a\n\x08filesize\x18\x08\x20\x01(\rR\x08filesize\x12\"\
    \n\x0cgetlasterror\x18\t\x20\x01(\rR\x0cgetlasterror\x12>\n\x1aevalvesig\
    naturecheckdetail\x18\n\x20\x01(\rR\x1aevalvesignaturecheckdetail\"m\n\
    \x19CMsgClientReadMachineAuth\x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\
    \x08filename\x12\x16\n\x06offset\x18\x02\x20\x01(\rR\x06offset\x12\x1c\n\
    \tcubtoread\x18\x03\x20\x01(\rR\tcubtoread\"\xae\x02\n!CMsgClientReadMac\
    hineAuthResponse\x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\
    \x12\x18\n\x07eresult\x18\x02\x20\x01(\rR\x07eresult\x12\x1a\n\x08filesi\
    ze\x18\x03\x20\x01(\rR\x08filesize\x12\x19\n\x08sha_file\x18\x04\x20\x01\
    (\x0cR\x07shaFile\x12\"\n\x0cgetlasterror\x18\x05\x20\x01(\rR\x0cgetlast\
    error\x12\x16\n\x06offset\x18\x06\x20\x01(\rR\x06offset\x12\x18\n\x07cub\
    read\x18\x07\x20\x01(\rR\x07cubread\x12\x1d\n\nbytes_read\x18\x08\x20\
    \x01(\x0cR\tbytesRead\x12'\n\x0ffilename_sentry\x18\t\x20\x01(\tR\x0efil\
    enameSentry\"\x99\x02\n\x1bCMsgClientUpdateMachineAuth\x12\x1a\n\x08file\
    name\x18\x01\x20\x01(\tR\x08filename\x12\x16\n\x06offset\x18\x02\x20\x01\
    (\rR\x06offset\x12\x1e\n\ncubtowrite\x18\x03\x20\x01(\rR\ncubtowrite\x12\
    \x14\n\x05bytes\x18\x04\x20\x01(\x0cR\x05bytes\x12\x19\n\x08otp_type\x18\
    \x05\x20\x01(\rR\x07otpType\x12%\n\x0eotp_identifier\x18\x06\x20\x01(\tR\
    \rotpIdentifier\x12)\n\x10otp_sharedsecret\x18\x07\x20\x01(\x0cR\x0fotpS\
    haredsecret\x12#\n\rotp_timedrift\x18\x08\x20\x01(\rR\x0cotpTimedrift\"\
    \xc9\x02\n#CMsgClientUpdateMachineAuthResponse\x12\x1a\n\x08filename\x18\
    \x01\x20\x01(\tR\x08filename\x12\x18\n\x07eresult\x18\x02\x20\x01(\rR\
    \x07eresult\x12\x1a\n\x08filesize\x18\x03\x20\x01(\rR\x08filesize\x12\
    \x19\n\x08sha_file\x18\x04\x20\x01(\x0cR\x07shaFile\x12\"\n\x0cgetlaster\
    ror\x18\x05\x20\x01(\rR\x0cgetlasterror\x12\x16\n\x06offset\x18\x06\x20\
    \x01(\rR\x06offset\x12\x1a\n\x08cubwrote\x18\x07\x20\x01(\rR\x08cubwrote\
    \x12\x19\n\x08otp_type\x18\x08\x20\x01(\x05R\x07otpType\x12\x1b\n\totp_v\
    alue\x18\t\x20\x01(\rR\x08otpValue\x12%\n\x0eotp_identifier\x18\n\x20\
    \x01(\tR\rotpIdentifier\"\xc1\x03\n\x1cCMsgClientRequestMachineAuth\x12\
    \x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\x12-\n\x12eresult_sen\
    tryfile\x18\x02\x20\x01(\rR\x11eresultSentryfile\x12\x1a\n\x08filesize\
    \x18\x03\x20\x01(\rR\x08filesize\x12%\n\x0esha_sentryfile\x18\x04\x20\
    \x01(\x0cR\rshaSentryfile\x12.\n\x13lock_account_action\x18\x06\x20\x01(\
    \x05R\x11lockAccountAction\x12\x19\n\x08otp_type\x18\x07\x20\x01(\rR\x07\
    otpType\x12%\n\x0eotp_identifier\x18\x08\x20\x01(\tR\rotpIdentifier\x12)\
    \n\x10otp_sharedsecret\x18\t\x20\x01(\x0cR\x0fotpSharedsecret\x12\x1b\n\
    \totp_value\x18\n\x20\x01(\rR\x08otpValue\x12!\n\x0cmachine_name\x18\x0b\
    \x20\x01(\tR\x0bmachineName\x126\n\x17machine_name_userchosen\x18\x0c\
    \x20\x01(\tR\x15machineNameUserchosen\"@\n$CMsgClientRequestMachineAuthR\
    esponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\")\n\x15CMsg\
    ClientRegisterKey\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\"\xa5\x01\
    \n\x1aCMsgClientPurchaseResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x126\n\x17purchase_result_details\x18\x02\x20\x01\
    (\x05R\x15purchaseResultDetails\x122\n\x15purchase_receipt_info\x18\x03\
    \x20\x01(\x0cR\x13purchaseReceiptInfo\"\xb6\x02\n\x1cCMsgClientActivateO\
    EMLicense\x12+\n\x11bios_manufacturer\x18\x01\x20\x01(\tR\x10biosManufac\
    turer\x12+\n\x11bios_serialnumber\x18\x02\x20\x01(\tR\x10biosSerialnumbe\
    r\x12!\n\x0clicense_file\x18\x03\x20\x01(\x0cR\x0blicenseFile\x125\n\x16\
    mainboard_manufacturer\x18\x04\x20\x01(\tR\x15mainboardManufacturer\x12+\
    \n\x11mainboard_product\x18\x05\x20\x01(\tR\x10mainboardProduct\x125\n\
    \x16mainboard_serialnumber\x18\x06\x20\x01(\tR\x15mainboardSerialnumber\
    \"J\n\x1cCMsgClientRegisterOEMMachine\x12*\n\x11oem_register_file\x18\
    \x01\x20\x01(\x0cR\x0foemRegisterFile\"@\n$CMsgClientRegisterOEMMachineR\
    esponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\"c\n\x1fCMsg\
    ClientPurchaseWithMachineID\x12\x1d\n\npackage_id\x18\x01\x20\x01(\rR\tp\
    ackageId\x12!\n\x0cmachine_info\x18\x02\x20\x01(\x0cR\x0bmachineInfo\"\
    \x90\x01\n\x20CMsgTrading_InitiateTradeRequest\x12(\n\x10trade_request_i\
    d\x18\x01\x20\x01(\rR\x0etradeRequestId\x12#\n\rother_steamid\x18\x02\
    \x20\x01(\x04R\x0cotherSteamid\x12\x1d\n\nother_name\x18\x03\x20\x01(\tR\
    \totherName\"\xa3\x04\n!CMsgTrading_InitiateTradeResponse\x12\x1a\n\x08r\
    esponse\x18\x01\x20\x01(\rR\x08response\x12(\n\x10trade_request_id\x18\
    \x02\x20\x01(\rR\x0etradeRequestId\x12#\n\rother_steamid\x18\x03\x20\x01\
    (\x04R\x0cotherSteamid\x128\n\x18steamguard_required_days\x18\x04\x20\
    \x01(\rR\x16steamguardRequiredDays\x127\n\x18new_device_cooldown_days\
    \x18\x05\x20\x01(\rR\x15newDeviceCooldownDays\x12P\n%default_password_re\
    set_probation_days\x18\x06\x20\x01(\rR!defaultPasswordResetProbationDays\
    \x12A\n\x1dpassword_reset_probation_days\x18\x07\x20\x01(\rR\x1apassword\
    ResetProbationDays\x12L\n#default_email_change_probation_days\x18\x08\
    \x20\x01(\rR\x1fdefaultEmailChangeProbationDays\x12=\n\x1bemail_change_p\
    robation_days\x18\t\x20\x01(\rR\x18emailChangeProbationDays\"E\n\x1eCMsg\
    Trading_CancelTradeRequest\x12#\n\rother_steamid\x18\x01\x20\x01(\x04R\
    \x0cotherSteamid\"?\n\x18CMsgTrading_StartSession\x12#\n\rother_steamid\
    \x18\x01\x20\x01(\x04R\x0cotherSteamid\"j\n\x19CMsgClientGetCDNAuthToken\
    \x12\x19\n\x08depot_id\x18\x01\x20\x01(\rR\x07depotId\x12\x1b\n\thost_na\
    me\x18\x02\x20\x01(\tR\x08hostName\x12\x15\n\x06app_id\x18\x03\x20\x01(\
    \rR\x05appId\"S\n\x1fCMsgClientGetDepotDecryptionKey\x12\x19\n\x08depot_\
    id\x18\x01\x20\x01(\rR\x07depotId\x12\x15\n\x06app_id\x18\x02\x20\x01(\r\
    R\x05appId\"\x93\x01\n'CMsgClientGetDepotDecryptionKeyResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x19\n\x08depot_id\
    \x18\x02\x20\x01(\rR\x07depotId\x120\n\x14depot_encryption_key\x18\x03\
    \x20\x01(\x0cR\x12depotEncryptionKey\"[\n\x1eCMsgClientCheckAppBetaPassw\
    ord\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\"\n\x0cbetapass\
    word\x18\x02\x20\x01(\tR\x0cbetapassword\"\xf1\x01\n&CMsgClientCheckAppB\
    etaPasswordResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07\
    eresult\x12Z\n\rbetapasswords\x18\x04\x20\x03(\x0b24.CMsgClientCheckAppB\
    etaPasswordResponse.BetaPasswordR\rbetapasswords\x1aN\n\x0cBetaPassword\
    \x12\x1a\n\x08betaname\x18\x01\x20\x01(\tR\x08betaname\x12\"\n\x0cbetapa\
    ssword\x18\x02\x20\x01(\tR\x0cbetapassword\"\x8b\x07\n\x1cCMsgClientUpda\
    teAppJobReport\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\
    \n\tdepot_ids\x18\x02\x20\x03(\rR\x08depotIds\x12\x1b\n\tapp_state\x18\
    \x03\x20\x01(\rR\x08appState\x12\"\n\rjob_app_error\x18\x04\x20\x01(\rR\
    \x0bjobAppError\x12#\n\rerror_details\x18\x05\x20\x01(\tR\x0cerrorDetail\
    s\x12!\n\x0cjob_duration\x18\x06\x20\x01(\rR\x0bjobDuration\x126\n\x17fi\
    les_validation_failed\x18\x07\x20\x01(\rR\x15filesValidationFailed\x120\
    \n\x14job_bytes_downloaded\x18\x08\x20\x01(\x04R\x12jobBytesDownloaded\
    \x12(\n\x10job_bytes_staged\x18\t\x20\x01(\x04R\x0ejobBytesStaged\x12%\n\
    \x0ebytes_comitted\x18\n\x20\x01(\x04R\rbytesComitted\x12&\n\x0fstart_ap\
    p_state\x18\x0b\x20\x01(\rR\rstartAppState\x12(\n\x10stats_machine_id\
    \x18\x0c\x20\x01(\x06R\x0estatsMachineId\x12\x1f\n\x0bbranch_name\x18\r\
    \x20\x01(\tR\nbranchName\x124\n\x16total_bytes_downloaded\x18\x0e\x20\
    \x01(\x04R\x14totalBytesDownloaded\x12,\n\x12total_bytes_staged\x18\x0f\
    \x20\x01(\x04R\x10totalBytesStaged\x120\n\x14total_bytes_restored\x18\
    \x10\x20\x01(\x04R\x12totalBytesRestored\x12\x1f\n\x0bis_borrowed\x18\
    \x11\x20\x01(\x08R\nisBorrowed\x12&\n\x0fis_free_weekend\x18\x12\x20\x01\
    (\x08R\risFreeWeekend\x12,\n\x12total_bytes_legacy\x18\x13\x20\x01(\x04R\
    \x10totalBytesLegacy\x12.\n\x13total_bytes_patched\x18\x14\x20\x01(\x04R\
    \x11totalBytesPatched\x12*\n\x11total_bytes_saved\x18\x15\x20\x01(\x04R\
    \x0ftotalBytesSaved\x12\x17\n\x07cell_id\x18\x16\x20\x01(\rR\x06cellId\"\
    \xb4\x02\n\x1eCMsgClientDPContentStatsReport\x12(\n\x10stats_machine_id\
    \x18\x01\x20\x01(\x06R\x0estatsMachineId\x12!\n\x0ccountry_code\x18\x02\
    \x20\x01(\tR\x0bcountryCode\x12\x17\n\x07os_type\x18\x03\x20\x01(\x05R\
    \x06osType\x12\x1a\n\x08language\x18\x04\x20\x01(\x05R\x08language\x12.\
    \n\x13num_install_folders\x18\x05\x20\x01(\rR\x11numInstallFolders\x12.\
    \n\x13num_installed_games\x18\x06\x20\x01(\rR\x11numInstalledGames\x120\
    \n\x14size_installed_games\x18\x07\x20\x01(\x04R\x12sizeInstalledGames\"\
    \x7f\n!CMsgClientGetCDNAuthTokenResponse\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\r:\x012R\x07eresult\x12\x14\n\x05token\x18\x02\x20\x01(\tR\x05\
    token\x12'\n\x0fexpiration_time\x18\x03\x20\x01(\rR\x0eexpirationTime\"\
    \x8f\x03\n\x1aCMsgDownloadRateStatistics\x12\x17\n\x07cell_id\x18\x01\
    \x20\x01(\rR\x06cellId\x12;\n\x05stats\x18\x02\x20\x03(\x0b2%.CMsgDownlo\
    adRateStatistics.StatsInfoR\x05stats\x12'\n\x0fthrottling_kbps\x18\x03\
    \x20\x01(\rR\x0ethrottlingKbps\x1a\xf1\x01\n\tStatsInfo\x12\x1f\n\x0bsou\
    rce_type\x18\x01\x20\x01(\rR\nsourceType\x12\x1b\n\tsource_id\x18\x02\
    \x20\x01(\rR\x08sourceId\x12\x18\n\x07seconds\x18\x03\x20\x01(\rR\x07sec\
    onds\x12\x14\n\x05bytes\x18\x04\x20\x01(\x04R\x05bytes\x12\x1b\n\thost_n\
    ame\x18\x05\x20\x01(\tR\x08hostName\x12\"\n\x0cmicroseconds\x18\x06\x20\
    \x01(\x04R\x0cmicroseconds\x12\x1b\n\tused_ipv6\x18\x07\x20\x01(\x08R\
    \x08usedIpv6\x12\x18\n\x07proxied\x18\x08\x20\x01(\x08R\x07proxied\"`\n\
    \x1cCMsgClientRequestAccountData\x12(\n\x10account_or_email\x18\x01\x20\
    \x01(\tR\x0eaccountOrEmail\x12\x16\n\x06action\x18\x02\x20\x01(\rR\x06ac\
    tion\"\xc8\x02\n$CMsgClientRequestAccountDataResponse\x12\x16\n\x06actio\
    n\x18\x01\x20\x01(\rR\x06action\x12\x18\n\x07eresult\x18\x02\x20\x01(\rR\
    \x07eresult\x12!\n\x0caccount_name\x18\x03\x20\x01(\tR\x0baccountName\
    \x12\x1d\n\nct_matches\x18\x04\x20\x01(\rR\tctMatches\x128\n\x18account_\
    name_suggestion1\x18\x05\x20\x01(\tR\x16accountNameSuggestion1\x128\n\
    \x18account_name_suggestion2\x18\x06\x20\x01(\tR\x16accountNameSuggestio\
    n2\x128\n\x18account_name_suggestion3\x18\x07\x20\x01(\tR\x16accountName\
    Suggestion3\"\xe6\x01\n\x1bCMsgClientUGSGetGlobalStats\x12\x16\n\x06game\
    id\x18\x01\x20\x01(\x04R\x06gameid\x124\n\x16history_days_requested\x18\
    \x02\x20\x01(\rR\x14historyDaysRequested\x12.\n\x13time_last_requested\
    \x18\x03\x20\x01(\x07R\x11timeLastRequested\x12(\n\x10first_day_cached\
    \x18\x04\x20\x01(\rR\x0efirstDayCached\x12\x1f\n\x0bdays_cached\x18\x05\
    \x20\x01(\rR\ndaysCached\"\xd8\x02\n#CMsgClientUGSGetGlobalStatsResponse\
    \x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x1c\n\t\
    timestamp\x18\x02\x20\x01(\x07R\ttimestamp\x12\x1f\n\x0bday_current\x18\
    \x03\x20\x01(\x05R\ndayCurrent\x12<\n\x04days\x18\x04\x20\x03(\x0b2(.CMs\
    gClientUGSGetGlobalStatsResponse.DayR\x04days\x1a\x96\x01\n\x03Day\x12\
    \x15\n\x06day_id\x18\x01\x20\x01(\rR\x05dayId\x12C\n\x05stats\x18\x02\
    \x20\x03(\x0b2-.CMsgClientUGSGetGlobalStatsResponse.Day.StatR\x05stats\
    \x1a3\n\x04Stat\x12\x17\n\x07stat_id\x18\x01\x20\x01(\x05R\x06statId\x12\
    \x12\n\x04data\x18\x02\x20\x01(\x03R\x04data\"\xf6\x05\n\x12CMsgGameServ\
    erData\x12\x1e\n\x0bsteam_id_gs\x18\x01\x20\x01(\x06R\tsteamIdGs\x12#\n\
    \rdeprecated_ip\x18\x02\x20\x01(\rR\x0cdeprecatedIp\x12\x1d\n\nquery_por\
    t\x18\x03\x20\x01(\rR\tqueryPort\x12\x1b\n\tgame_port\x18\x04\x20\x01(\r\
    R\x08gamePort\x12#\n\rsourcetv_port\x18\x05\x20\x01(\rR\x0csourcetvPort\
    \x12\x12\n\x04name\x18\x16\x20\x01(\tR\x04name\x126\n\x0fgame_ip_address\
    \x18\x17\x20\x01(\x0b2\x0e.CMsgIPAddressR\rgameIpAddress\x12\x15\n\x06ap\
    p_id\x18\x06\x20\x01(\rR\x05appId\x12\x18\n\x07gamedir\x18\x07\x20\x01(\
    \tR\x07gamedir\x12\x18\n\x07version\x18\x08\x20\x01(\tR\x07version\x12\
    \x18\n\x07product\x18\t\x20\x01(\tR\x07product\x12\x16\n\x06region\x18\n\
    \x20\x01(\tR\x06region\x124\n\x07players\x18\x0b\x20\x03(\x0b2\x1a.CMsgG\
    ameServerData.PlayerR\x07players\x12\x1f\n\x0bmax_players\x18\x0c\x20\
    \x01(\rR\nmaxPlayers\x12\x1b\n\tbot_count\x18\r\x20\x01(\rR\x08botCount\
    \x12\x1a\n\x08password\x18\x0e\x20\x01(\x08R\x08password\x12\x16\n\x06se\
    cure\x18\x0f\x20\x01(\x08R\x06secure\x12\x1c\n\tdedicated\x18\x10\x20\
    \x01(\x08R\tdedicated\x12\x0e\n\x02os\x18\x11\x20\x01(\tR\x02os\x12\x1b\
    \n\tgame_data\x18\x12\x20\x01(\tR\x08gameData\x12*\n\x11game_data_versio\
    n\x18\x13\x20\x01(\rR\x0fgameDataVersion\x12\x1b\n\tgame_type\x18\x14\
    \x20\x01(\tR\x08gameType\x12\x10\n\x03map\x18\x15\x20\x01(\tR\x03map\x1a\
    #\n\x06Player\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"\
    \x95\x01\n\x14CMsgGameServerRemove\x12\x19\n\x08steam_id\x18\x01\x20\x01\
    (\x06R\x07steamId\x12#\n\rdeprecated_ip\x18\x02\x20\x01(\rR\x0cdeprecate\
    dIp\x12\x1d\n\nquery_port\x18\x03\x20\x01(\rR\tqueryPort\x12\x1e\n\x02ip\
    \x18\x04\x20\x01(\x0b2\x0e.CMsgIPAddressR\x02ip\"\xbc\x01\n\x18CMsgClien\
    tGMSServerQuery\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12&\n\
    \x0fgeo_location_ip\x18\x02\x20\x01(\rR\rgeoLocationIp\x12\x1f\n\x0bregi\
    on_code\x18\x03\x20\x01(\rR\nregionCode\x12\x1f\n\x0bfilter_text\x18\x04\
    \x20\x01(\tR\nfilterText\x12\x1f\n\x0bmax_servers\x18\x05\x20\x01(\rR\nm\
    axServers\"\xaa\x02\n\x20CMsgGMSClientServerQueryResponse\x12B\n\x07serv\
    ers\x18\x01\x20\x03(\x0b2(.CMsgGMSClientServerQueryResponse.ServerR\x07s\
    ervers\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05error\x1a\xab\x01\n\x06\
    Server\x120\n\x14deprecated_server_ip\x18\x01\x20\x01(\rR\x12deprecatedS\
    erverIp\x12\x1f\n\x0bserver_port\x18\x02\x20\x01(\rR\nserverPort\x12!\n\
    \x0cauth_players\x18\x03\x20\x01(\rR\x0bauthPlayers\x12+\n\tserver_ip\
    \x18\x04\x20\x01(\x0b2\x0e.CMsgIPAddressR\x08serverIp\"k\n\x17CMsgGameSe\
    rverOutOfDate\x12\x1e\n\x0bsteam_id_gs\x18\x01\x20\x01(\x06R\tsteamIdGs\
    \x12\x16\n\x06reject\x18\x02\x20\x01(\x08R\x06reject\x12\x18\n\x07messag\
    e\x18\x03\x20\x01(\tR\x07message\"?\n\x19CMsgClientRedeemGuestPass\x12\"\
    \n\rguest_pass_id\x18\x01\x20\x01(\x06R\x0bguestPassId\"\x85\x01\n!CMsgC\
    lientRedeemGuestPassResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\
    \x012R\x07eresult\x12\x1d\n\npackage_id\x18\x02\x20\x01(\rR\tpackageId\
    \x12$\n\x0emust_own_appid\x18\x03\x20\x01(\rR\x0cmustOwnAppid\"F\n\x1fCM\
    sgClientGetClanActivityCounts\x12#\n\rsteamid_clans\x18\x01\x20\x03(\x04\
    R\x0csteamidClans\"F\n'CMsgClientGetClanActivityCountsResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\"\xaf\x01\n\x19CMsgClie\
    ntOGSReportString\x12\x20\n\x0baccumulated\x18\x01\x20\x01(\x08R\x0baccu\
    mulated\x12\x1c\n\tsessionid\x18\x02\x20\x01(\x04R\tsessionid\x12\x1a\n\
    \x08severity\x18\x03\x20\x01(\x05R\x08severity\x12\x1c\n\tformatter\x18\
    \x04\x20\x01(\tR\tformatter\x12\x18\n\x07varargs\x18\x05\x20\x01(\x0cR\
    \x07varargs\"p\n\x16CMsgClientOGSReportBug\x12\x1c\n\tsessionid\x18\x01\
    \x20\x01(\x04R\tsessionid\x12\x18\n\x07bugtext\x18\x02\x20\x01(\tR\x07bu\
    gtext\x12\x1e\n\nscreenshot\x18\x03\x20\x01(\x0cR\nscreenshot\"=\n\x17CM\
    sgGSAssociateWithClan\x12\"\n\rsteam_id_clan\x18\x01\x20\x01(\x06R\x0bst\
    eamIdClan\"b\n\x1fCMsgGSAssociateWithClanResponse\x12\"\n\rsteam_id_clan\
    \x18\x01\x20\x01(\x06R\x0bsteamIdClan\x12\x1b\n\x07eresult\x18\x02\x20\
    \x01(\r:\x012R\x07eresult\"S\n#CMsgGSComputeNewPlayerCompatibility\x12,\
    \n\x12steam_id_candidate\x18\x01\x20\x01(\x06R\x10steamIdCandidate\"\xb0\
    \x02\n+CMsgGSComputeNewPlayerCompatibilityResponse\x12,\n\x12steam_id_ca\
    ndidate\x18\x01\x20\x01(\x06R\x10steamIdCandidate\x12\x1b\n\x07eresult\
    \x18\x02\x20\x01(\r:\x012R\x07eresult\x12$\n\x0eis_clan_member\x18\x03\
    \x20\x01(\x08R\x0cisClanMember\x12'\n\x10ct_dont_like_you\x18\x04\x20\
    \x01(\x05R\rctDontLikeYou\x12'\n\x10ct_you_dont_like\x18\x05\x20\x01(\
    \x05R\rctYouDontLike\x12>\n\x1cct_clanmembers_dont_like_you\x18\x06\x20\
    \x01(\x05R\x18ctClanmembersDontLikeYou\"\x14\n\x12CMsgClientSentLogs\"\
    \x9a\x01\n\x0cCMsgGCClient\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05app\
    id\x12\x18\n\x07msgtype\x18\x02\x20\x01(\rR\x07msgtype\x12\x18\n\x07payl\
    oad\x18\x03\x20\x01(\x0cR\x07payload\x12\x18\n\x07steamid\x18\x04\x20\
    \x01(\x06R\x07steamid\x12\x16\n\x06gcname\x18\x05\x20\x01(\tR\x06gcname\
    \x12\x0e\n\x02ip\x18\x06\x20\x01(\rR\x02ip\"6\n\x1cCMsgClientRequestFree\
    License\x12\x16\n\x06appids\x18\x02\x20\x03(\rR\x06appids\"\x99\x01\n$CM\
    sgClientRequestFreeLicenseResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \r:\x012R\x07eresult\x12-\n\x12granted_packageids\x18\x02\x20\x03(\rR\
    \x11grantedPackageids\x12%\n\x0egranted_appids\x18\x03\x20\x03(\rR\rgran\
    tedAppids\"\xb8\x02\n#CMsgDRMDownloadRequestWithCrashData\x12%\n\x0edown\
    load_flags\x18\x01\x20\x01(\rR\rdownloadFlags\x120\n\x14download_types_k\
    nown\x18\x02\x20\x01(\rR\x12downloadTypesKnown\x12\x19\n\x08guid_drm\x18\
    \x03\x20\x01(\x0cR\x07guidDrm\x12\x1d\n\nguid_split\x18\x04\x20\x01(\x0c\
    R\tguidSplit\x12\x1d\n\nguid_merge\x18\x05\x20\x01(\x0cR\tguidMerge\x12\
    \x1f\n\x0bmodule_name\x18\x06\x20\x01(\tR\nmoduleName\x12\x1f\n\x0bmodul\
    e_path\x18\x07\x20\x01(\tR\nmodulePath\x12\x1d\n\ncrash_data\x18\x08\x20\
    \x01(\x0cR\tcrashData\"\xcd\x02\n\x17CMsgDRMDownloadResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\x12\x15\n\x06app_id\x18\
    \x02\x20\x01(\rR\x05appId\x12,\n\x12blob_download_type\x18\x03\x20\x01(\
    \rR\x10blobDownloadType\x12\x1d\n\nmerge_guid\x18\x04\x20\x01(\x0cR\tmer\
    geGuid\x12/\n\x14download_file_dfs_ip\x18\x05\x20\x01(\rR\x11downloadFil\
    eDfsIp\x123\n\x16download_file_dfs_port\x18\x06\x20\x01(\rR\x13downloadF\
    ileDfsPort\x12*\n\x11download_file_url\x18\x07\x20\x01(\tR\x0fdownloadFi\
    leUrl\x12\x1f\n\x0bmodule_path\x18\x08\x20\x01(\tR\nmodulePath\"\xca\x02\
    \n\x12CMsgDRMFinalResult\x12\x1b\n\x07eResult\x18\x01\x20\x01(\r:\x012R\
    \x07eResult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12,\n\x12b\
    lob_download_type\x18\x03\x20\x01(\rR\x10blobDownloadType\x12!\n\x0cerro\
    r_detail\x18\x04\x20\x01(\rR\x0berrorDetail\x12\x1d\n\nmerge_guid\x18\
    \x05\x20\x01(\x0cR\tmergeGuid\x12/\n\x14download_file_dfs_ip\x18\x06\x20\
    \x01(\rR\x11downloadFileDfsIp\x123\n\x16download_file_dfs_port\x18\x07\
    \x20\x01(\rR\x13downloadFileDfsPort\x12*\n\x11download_file_url\x18\x08\
    \x20\x01(\tR\x0fdownloadFileUrl\"=\n\x1eCMsgClientDPCheckSpecialSurvey\
    \x12\x1b\n\tsurvey_id\x18\x01\x20\x01(\rR\x08surveyId\"\xcf\x01\n&CMsgCl\
    ientDPCheckSpecialSurveyResponse\x12\x1b\n\x07eResult\x18\x01\x20\x01(\r\
    :\x012R\x07eResult\x12\x14\n\x05state\x18\x02\x20\x01(\rR\x05state\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1d\n\ncustom_url\x18\x04\
    \x20\x01(\tR\tcustomUrl\x12)\n\x10include_software\x18\x05\x20\x01(\x08R\
    \x0fincludeSoftware\x12\x14\n\x05token\x18\x06\x20\x01(\x0cR\x05token\"X\
    \n%CMsgClientDPSendSpecialSurveyResponse\x12\x1b\n\tsurvey_id\x18\x01\
    \x20\x01(\rR\x08surveyId\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\
    \"_\n*CMsgClientDPSendSpecialSurveyResponseReply\x12\x1b\n\x07eResult\
    \x18\x01\x20\x01(\r:\x012R\x07eResult\x12\x14\n\x05token\x18\x02\x20\x01\
    (\x0cR\x05token\"s\n'CMsgClientRequestForgottenPasswordEmail\x12!\n\x0ca\
    ccount_name\x18\x01\x20\x01(\tR\x0baccountName\x12%\n\x0epassword_tried\
    \x18\x02\x20\x01(\tR\rpasswordTried\"{\n/CMsgClientRequestForgottenPassw\
    ordEmailResponse\x12\x18\n\x07eResult\x18\x01\x20\x01(\rR\x07eResult\x12\
    .\n\x13use_secret_question\x18\x02\x20\x01(\x08R\x11useSecretQuestion\"\
    \xd2\x02\n\x1bCMsgClientItemAnnouncements\x12&\n\x0fcount_new_items\x18\
    \x01\x20\x01(\rR\rcountNewItems\x12J\n\x0cunseen_items\x18\x02\x20\x03(\
    \x0b2'.CMsgClientItemAnnouncements.UnseenItemR\x0bunseenItems\x1a\xbe\
    \x01\n\nUnseenItem\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\
    \x1d\n\ncontext_id\x18\x02\x20\x01(\x04R\tcontextId\x12\x19\n\x08asset_i\
    d\x18\x03\x20\x01(\x04R\x07assetId\x12\x16\n\x06amount\x18\x04\x20\x01(\
    \x04R\x06amount\x12%\n\x0ertime32_gained\x18\x05\x20\x01(\x07R\rrtime32G\
    ained\x12!\n\x0csource_appid\x18\x06\x20\x01(\rR\x0bsourceAppid\"$\n\"CM\
    sgClientRequestItemAnnouncements\"\xca\x01\n\x1bCMsgClientUserNotificati\
    ons\x12O\n\rnotifications\x18\x01\x20\x03(\x0b2).CMsgClientUserNotificat\
    ions.NotificationR\rnotifications\x1aZ\n\x0cNotification\x124\n\x16user_\
    notification_type\x18\x01\x20\x01(\rR\x14userNotificationType\x12\x14\n\
    \x05count\x18\x02\x20\x01(\rR\x05count\"\xd0\x01\n\x1eCMsgClientCommentN\
    otifications\x12,\n\x12count_new_comments\x18\x01\x20\x01(\rR\x10countNe\
    wComments\x127\n\x18count_new_comments_owner\x18\x02\x20\x01(\rR\x15coun\
    tNewCommentsOwner\x12G\n\x20count_new_comments_subscriptions\x18\x03\x20\
    \x01(\rR\x1dcountNewCommentsSubscriptions\"'\n%CMsgClientRequestCommentN\
    otifications\"\x94\x01\n$CMsgClientOfflineMessageNotification\x12)\n\x10\
    offline_messages\x18\x01\x20\x01(\rR\x0fofflineMessages\x12A\n\x1dfriend\
    s_with_offline_messages\x18\x02\x20\x03(\rR\x1afriendsWithOfflineMessage\
    s\"&\n$CMsgClientRequestOfflineMessageCount\"A\n%CMsgClientChatGetFriend\
    MessageHistory\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"\
    \xbc\x02\n-CMsgClientChatGetFriendMessageHistoryResponse\x12\x18\n\x07st\
    eamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x18\n\x07success\x18\x02\x20\
    \x01(\rR\x07success\x12X\n\x08messages\x18\x03\x20\x03(\x0b2<.CMsgClient\
    ChatGetFriendMessageHistoryResponse.FriendMessageR\x08messages\x1a}\n\rF\
    riendMessage\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x1c\
    \n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x18\n\x07message\x18\
    \x03\x20\x01(\tR\x07message\x12\x16\n\x06unread\x18\x04\x20\x01(\x08R\
    \x06unread\"9\n7CMsgClientChatGetFriendMessageHistoryForOfflineMessages\
    \"C\n!CMsgClientFSGetFriendsSteamLevels\x12\x1e\n\naccountids\x18\x01\
    \x20\x03(\rR\naccountids\"\xb6\x01\n)CMsgClientFSGetFriendsSteamLevelsRe\
    sponse\x12K\n\x07friends\x18\x01\x20\x03(\x0b21.CMsgClientFSGetFriendsSt\
    eamLevelsResponse.FriendR\x07friends\x1a<\n\x06Friend\x12\x1c\n\taccount\
    id\x18\x01\x20\x01(\rR\taccountid\x12\x14\n\x05level\x18\x02\x20\x01(\rR\
    \x05level\"\xfd\x02\n\x17CMsgClientEmailAddrInfo\x12#\n\remail_address\
    \x18\x01\x20\x01(\tR\x0cemailAddress\x12,\n\x12email_is_validated\x18\
    \x02\x20\x01(\x08R\x10emailIsValidated\x128\n\x18email_validation_change\
    d\x18\x03\x20\x01(\x08R\x16emailValidationChanged\x12E\n\x1fcredential_c\
    hange_requires_code\x18\x04\x20\x01(\x08R\x1ccredentialChangeRequiresCod\
    e\x12W\n)password_or_secretqa_change_requires_code\x18\x05\x20\x01(\x08R\
    $passwordOrSecretqaChangeRequiresCode\x125\n\x17remind_user_about_email\
    \x18\x06\x20\x01(\x08R\x14remindUserAboutEmail\"\x84\x02\n\x1eCMsgCREEnu\
    meratePublishedFiles\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\
    \x12\x1d\n\nquery_type\x18\x02\x20\x01(\x05R\tqueryType\x12\x1f\n\x0bsta\
    rt_index\x18\x03\x20\x01(\rR\nstartIndex\x12\x12\n\x04days\x18\x04\x20\
    \x01(\rR\x04days\x12\x14\n\x05count\x18\x05\x20\x01(\rR\x05count\x12\x12\
    \n\x04tags\x18\x06\x20\x03(\tR\x04tags\x12\x1b\n\tuser_tags\x18\x07\x20\
    \x03(\tR\x08userTags\x120\n\x12matching_file_type\x18\x08\x20\x01(\r:\
    \x0213R\x10matchingFileType\"\xfe\x02\n&CMsgCREEnumeratePublishedFilesRe\
    sponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12`\
    \n\x0fpublished_files\x18\x02\x20\x03(\x0b27.CMsgCREEnumeratePublishedFi\
    lesResponse.PublishedFileIdR\x0epublishedFiles\x12#\n\rtotal_results\x18\
    \x03\x20\x01(\rR\x0ctotalResults\x1a\xaf\x01\n\x0fPublishedFileId\x12*\n\
    \x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x1b\n\
    \tvotes_for\x18\x02\x20\x01(\x05R\x08votesFor\x12#\n\rvotes_against\x18\
    \x03\x20\x01(\x05R\x0cvotesAgainst\x12\x18\n\x07reports\x18\x04\x20\x01(\
    \x05R\x07reports\x12\x14\n\x05score\x18\x05\x20\x01(\x02R\x05score\"\xae\
    \x01\n\x16CMsgCREItemVoteSummary\x12U\n\x12published_file_ids\x18\x01\
    \x20\x03(\x0b2'.CMsgCREItemVoteSummary.PublishedFileIdR\x10publishedFile\
    Ids\x1a=\n\x0fPublishedFileId\x12*\n\x11published_file_id\x18\x01\x20\
    \x01(\x06R\x0fpublishedFileId\"\xd0\x02\n\x1eCMsgCREItemVoteSummaryRespo\
    nse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12_\n\
    \x13item_vote_summaries\x18\x02\x20\x03(\x0b2/.CMsgCREItemVoteSummaryRes\
    ponse.ItemVoteSummaryR\x11itemVoteSummaries\x1a\xaf\x01\n\x0fItemVoteSum\
    mary\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileI\
    d\x12\x1b\n\tvotes_for\x18\x02\x20\x01(\x05R\x08votesFor\x12#\n\rvotes_a\
    gainst\x18\x03\x20\x01(\x05R\x0cvotesAgainst\x12\x18\n\x07reports\x18\
    \x04\x20\x01(\x05R\x07reports\x12\x14\n\x05score\x18\x05\x20\x01(\x02R\
    \x05score\"i\n\"CMsgCREUpdateUserPublishedItemVote\x12*\n\x11published_f\
    ile_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x17\n\x07vote_up\x18\
    \x02\x20\x01(\x08R\x06voteUp\"I\n*CMsgCREUpdateUserPublishedItemVoteResp\
    onse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\"\xce\
    \x01\n&CMsgCREGetUserPublishedItemVoteDetails\x12e\n\x12published_file_i\
    ds\x18\x01\x20\x03(\x0b27.CMsgCREGetUserPublishedItemVoteDetails.Publish\
    edFileIdR\x10publishedFileIds\x1a=\n\x0fPublishedFileId\x12*\n\x11publis\
    hed_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\"\x9f\x02\n.CMsgCRE\
    GetUserPublishedItemVoteDetailsResponse\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12w\n\x16user_item_vote_details\x18\x02\x20\
    \x03(\x0b2B.CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteD\
    etailR\x13userItemVoteDetails\x1aW\n\x12UserItemVoteDetail\x12*\n\x11pub\
    lished_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x15\n\x04vot\
    e\x18\x02\x20\x01(\x05:\x010R\x04vote\"\xf3\x01\n\x18CMsgGameServerPingS\
    ample\x12\x13\n\x05my_ip\x18\x01\x20\x01(\x07R\x04myIp\x12\x1a\n\tgs_app\
    _id\x18\x02\x20\x01(\x05R\x07gsAppId\x12?\n\ngs_samples\x18\x03\x20\x03(\
    \x0b2\x20.CMsgGameServerPingSample.SampleR\tgsSamples\x1ae\n\x06Sample\
    \x12\x0e\n\x02ip\x18\x01\x20\x01(\x07R\x02ip\x12\x1e\n\x0bavg_ping_ms\
    \x18\x02\x20\x01(\rR\tavgPingMs\x12+\n\x12stddev_ping_ms_x10\x18\x03\x20\
    \x01(\rR\x0fstddevPingMsX10\"3\n\x16CMsgFSGetFollowerCount\x12\x19\n\x08\
    steam_id\x18\x01\x20\x01(\x06R\x07steamId\"V\n\x1eCMsgFSGetFollowerCount\
    Response\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\
    \x17\n\x05count\x18\x02\x20\x01(\x05:\x010R\x05count\"1\n\x14CMsgFSGetIs\
    Following\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"e\n\
    \x1cCMsgFSGetIsFollowingResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12(\n\x0cis_following\x18\x02\x20\x01(\x08:\x05f\
    alseR\x0bisFollowing\"?\n\x1cCMsgFSEnumerateFollowingList\x12\x1f\n\x0bs\
    tart_index\x18\x01\x20\x01(\rR\nstartIndex\"\x85\x01\n$CMsgFSEnumerateFo\
    llowingListResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07\
    eresult\x12#\n\rtotal_results\x18\x02\x20\x01(\x05R\x0ctotalResults\x12\
    \x1b\n\tsteam_ids\x18\x03\x20\x03(\x06R\x08steamIds\"7\n\x1fCMsgDPGetNum\
    berOfCurrentPlayers\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"i\n\
    'CMsgDPGetNumberOfCurrentPlayersResponse\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\x05:\x012R\x07eresult\x12!\n\x0cplayer_count\x18\x02\x20\x01(\
    \x05R\x0bplayerCount\"\x83\x01\n#CMsgClientFriendUserStatusPublished\x12\
    %\n\x0efriend_steamid\x18\x01\x20\x01(\x06R\rfriendSteamid\x12\x14\n\x05\
    appid\x18\x02\x20\x01(\rR\x05appid\x12\x1f\n\x0bstatus_text\x18\x03\x20\
    \x01(\tR\nstatusText\"\x96\x01\n\x1dCMsgClientServiceMethodLegacy\x12\
    \x1f\n\x0bmethod_name\x18\x01\x20\x01(\tR\nmethodName\x12+\n\x11serializ\
    ed_method\x18\x02\x20\x01(\x0cR\x10serializedMethod\x12'\n\x0fis_notific\
    ation\x18\x03\x20\x01(\x08R\x0eisNotification\"\x86\x01\n%CMsgClientServ\
    iceMethodLegacyResponse\x12\x1f\n\x0bmethod_name\x18\x01\x20\x01(\tR\nme\
    thodName\x12<\n\x1aserialized_method_response\x18\x02\x20\x01(\x0cR\x18s\
    erializedMethodResponse\"G\n\x10CMsgClientUIMode\x12\x16\n\x06uimode\x18\
    \x01\x20\x01(\rR\x06uimode\x12\x1b\n\tchat_mode\x18\x02\x20\x01(\rR\x08c\
    hatMode\"G\n&CMsgClientVanityURLChangedNotification\x12\x1d\n\nvanity_ur\
    l\x18\x01\x20\x01(\tR\tvanityUrl\"\xae\x01\n%CMsgClientAuthorizeLocalDev\
    iceRequest\x12-\n\x12device_description\x18\x01\x20\x01(\tR\x11deviceDes\
    cription\x12(\n\x10owner_account_id\x18\x02\x20\x01(\rR\x0eownerAccountI\
    d\x12,\n\x12local_device_token\x18\x03\x20\x01(\x04R\x10localDeviceToken\
    \"\x97\x01\n\x1eCMsgClientAuthorizeLocalDevice\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x12(\n\x10owner_account_id\x18\x02\
    \x20\x01(\rR\x0eownerAccountId\x12.\n\x13authed_device_token\x18\x03\x20\
    \x01(\x04R\x11authedDeviceToken\"\xa1\x01\n*CMsgClientAuthorizeLocalDevi\
    ceNotification\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresu\
    lt\x12(\n\x10owner_account_id\x18\x02\x20\x01(\rR\x0eownerAccountId\x12,\
    \n\x12local_device_token\x18\x03\x20\x01(\x04R\x10localDeviceToken\"\xa4\
    \x01\n\"CMsgClientDeauthorizeDeviceRequest\x12<\n\x1adeauthorization_acc\
    ount_id\x18\x01\x20\x01(\rR\x18deauthorizationAccountId\x12@\n\x1cdeauth\
    orization_device_token\x18\x02\x20\x01(\x04R\x1adeauthorizationDeviceTok\
    en\"x\n\x1bCMsgClientDeauthorizeDevice\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12<\n\x1adeauthorization_account_id\x18\x02\
    \x20\x01(\rR\x18deauthorizationAccountId\"\x90\x02\n&CMsgClientUseLocalD\
    eviceAuthorizations\x128\n\x18authorization_account_id\x18\x01\x20\x03(\
    \rR\x16authorizationAccountId\x12X\n\rdevice_tokens\x18\x02\x20\x03(\x0b\
    23.CMsgClientUseLocalDeviceAuthorizations.DeviceTokenR\x0cdeviceTokens\
    \x1aR\n\x0bDeviceToken\x12(\n\x10owner_account_id\x18\x01\x20\x01(\rR\
    \x0eownerAccountId\x12\x19\n\x08token_id\x18\x02\x20\x01(\x04R\x07tokenI\
    d\"\x20\n\x1eCMsgClientGetAuthorizedDevices\"\x97\x03\n&CMsgClientGetAut\
    horizedDevicesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12e\n\x11authorized_device\x18\x02\x20\x03(\x0b28.CMsgClien\
    tGetAuthorizedDevicesResponse.AuthorizedDeviceR\x10authorizedDevice\x1a\
    \xe8\x01\n\x10AuthorizedDevice\x12*\n\x11auth_device_token\x18\x01\x20\
    \x01(\x04R\x0fauthDeviceToken\x12\x1f\n\x0bdevice_name\x18\x02\x20\x01(\
    \tR\ndeviceName\x12(\n\x10last_access_time\x18\x03\x20\x01(\rR\x0elastAc\
    cessTime\x12\x1f\n\x0bborrower_id\x18\x04\x20\x01(\rR\nborrowerId\x12\
    \x1d\n\nis_pending\x18\x05\x20\x01(\x08R\tisPending\x12\x1d\n\napp_playe\
    d\x18\x06\x20\x01(\rR\tappPlayed\"\xf8\x01\n!CMsgClientSharedLibraryLock\
    Status\x12W\n\x0elocked_library\x18\x01\x20\x03(\x0b20.CMsgClientSharedL\
    ibraryLockStatus.LockedLibraryR\rlockedLibrary\x121\n\x15own_library_loc\
    ked_by\x18\x02\x20\x01(\rR\x12ownLibraryLockedBy\x1aG\n\rLockedLibrary\
    \x12\x19\n\x08owner_id\x18\x01\x20\x01(\rR\x07ownerId\x12\x1b\n\tlocked_\
    by\x18\x02\x20\x01(\rR\x08lockedBy\"\xce\x01\n\"CMsgClientSharedLibraryS\
    topPlaying\x12!\n\x0cseconds_left\x18\x01\x20\x01(\x05R\x0bsecondsLeft\
    \x12H\n\tstop_apps\x18\x02\x20\x03(\x0b2+.CMsgClientSharedLibraryStopPla\
    ying.StopAppR\x08stopApps\x1a;\n\x07StopApp\x12\x15\n\x06app_id\x18\x01\
    \x20\x01(\rR\x05appId\x12\x19\n\x08owner_id\x18\x02\x20\x01(\rR\x07owner\
    Id\"\xf1\x02\n\x15CMsgClientServiceCall\x12#\n\rsysid_routing\x18\x01\
    \x20\x01(\x0cR\x0csysidRouting\x12\x1f\n\x0bcall_handle\x18\x02\x20\x01(\
    \rR\ncallHandle\x12\x1d\n\nmodule_crc\x18\x03\x20\x01(\rR\tmoduleCrc\x12\
    \x1f\n\x0bmodule_hash\x18\x04\x20\x01(\x0cR\nmoduleHash\x12\x1f\n\x0bfun\
    ction_id\x18\x05\x20\x01(\rR\nfunctionId\x12$\n\x0ecub_output_max\x18\
    \x06\x20\x01(\rR\x0ccubOutputMax\x12\x14\n\x05flags\x18\x07\x20\x01(\rR\
    \x05flags\x12$\n\rcallparameter\x18\x08\x20\x01(\x0cR\rcallparameter\x12\
    \x1b\n\tping_only\x18\t\x20\x01(\x08R\x08pingOnly\x122\n\x15max_outstand\
    ing_calls\x18\n\x20\x01(\rR\x13maxOutstandingCalls\"\x80\x01\n\x17CMsgCl\
    ientServiceModule\x12\x1d\n\nmodule_crc\x18\x01\x20\x01(\rR\tmoduleCrc\
    \x12\x1f\n\x0bmodule_hash\x18\x02\x20\x01(\x0cR\nmoduleHash\x12%\n\x0emo\
    dule_content\x18\x03\x20\x01(\x0cR\rmoduleContent\"\x8a\x07\n\x1dCMsgCli\
    entServiceCallResponse\x12#\n\rsysid_routing\x18\x01\x20\x01(\x0cR\x0csy\
    sidRouting\x12\x1f\n\x0bcall_handle\x18\x02\x20\x01(\rR\ncallHandle\x12\
    \x1d\n\nmodule_crc\x18\x03\x20\x01(\rR\tmoduleCrc\x12\x1f\n\x0bmodule_ha\
    sh\x18\x04\x20\x01(\x0cR\nmoduleHash\x12\x20\n\x0becallresult\x18\x05\
    \x20\x01(\rR\x0becallresult\x12%\n\x0eresult_content\x18\x06\x20\x01(\
    \x0cR\rresultContent\x12&\n\x0fos_version_info\x18\x07\x20\x01(\x0cR\ros\
    VersionInfo\x12\x1f\n\x0bsystem_info\x18\x08\x20\x01(\x0cR\nsystemInfo\
    \x12!\n\x0cload_address\x18\t\x20\x01(\x06R\x0bloadAddress\x12)\n\x10exc\
    eption_record\x18\n\x20\x01(\x0cR\x0fexceptionRecord\x127\n\x18portable_\
    os_version_info\x18\x0b\x20\x01(\x0cR\x15portableOsVersionInfo\x120\n\
    \x14portable_system_info\x18\x0c\x20\x01(\x0cR\x12portableSystemInfo\x12\
    #\n\rwas_converted\x18\r\x20\x01(\x08R\x0cwasConverted\x12'\n\x0finterna\
    l_result\x18\x0e\x20\x01(\rR\x0einternalResult\x12#\n\rcurrent_count\x18\
    \x0f\x20\x01(\rR\x0ccurrentCount\x12(\n\x10last_call_handle\x18\x10\x20\
    \x01(\rR\x0elastCallHandle\x12/\n\x14last_call_module_crc\x18\x11\x20\
    \x01(\rR\x11lastCallModuleCrc\x125\n\x17last_call_sysid_routing\x18\x12\
    \x20\x01(\x0cR\x14lastCallSysidRouting\x12)\n\x10last_ecallresult\x18\
    \x13\x20\x01(\rR\x0flastEcallresult\x120\n\x14last_callissue_delta\x18\
    \x14\x20\x01(\rR\x12lastCallissueDelta\x126\n\x17last_callcomplete_delta\
    \x18\x15\x20\x01(\rR\x15lastCallcompleteDelta\"\x17\n\x15CMsgAMUnlockStr\
    eaming\"c\n\x1dCMsgAMUnlockStreamingResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x12%\n\x0eencryption_key\x18\x02\x20\
    \x01(\x0cR\rencryptionKey\"\x12\n\x10CMsgAMUnlockHEVC\"7\n\x18CMsgAMUnlo\
    ckHEVCResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresu\
    lt\"i\n\x1dCMsgClientPlayingSessionState\x12'\n\x0fplaying_blocked\x18\
    \x02\x20\x01(\x08R\x0eplayingBlocked\x12\x1f\n\x0bplaying_app\x18\x03\
    \x20\x01(\rR\nplayingApp\"D\n\x1cCMsgClientKickPlayingSession\x12$\n\x0e\
    only_stop_game\x18\x01\x20\x01(\x08R\x0conlyStopGame\"\xa8\x01\n\x1fCMsg\
    ClientVoiceCallPreAuthorize\x12%\n\x0ecaller_steamid\x18\x01\x20\x01(\
    \x06R\rcallerSteamid\x12)\n\x10receiver_steamid\x18\x02\x20\x01(\x06R\
    \x0freceiverSteamid\x12\x1b\n\tcaller_id\x18\x03\x20\x01(\x05R\x08caller\
    Id\x12\x16\n\x06hangup\x18\x04\x20\x01(\x08R\x06hangup\"\xb5\x01\n'CMsgC\
    lientVoiceCallPreAuthorizeResponse\x12%\n\x0ecaller_steamid\x18\x01\x20\
    \x01(\x06R\rcallerSteamid\x12)\n\x10receiver_steamid\x18\x02\x20\x01(\
    \x06R\x0freceiverSteamid\x12\x1b\n\x07eresult\x18\x03\x20\x01(\x05:\x012\
    R\x07eresult\x12\x1b\n\tcaller_id\x18\x04\x20\x01(\x05R\x08callerId\"U\n\
    \x1cCMsgBadgeCraftedNotification\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\
    \x05appid\x12\x1f\n\x0bbadge_level\x18\x02\x20\x01(\rR\nbadgeLevelB\x05H\
    \x01\x80\x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
