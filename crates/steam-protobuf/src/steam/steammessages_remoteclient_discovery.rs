// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.10.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//! Generated file from `steammessages_remoteclient_discovery.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteClientBroadcastHeader {
    // message fields
    client_id: ::std::option::Option<u64>,
    msg_type: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ERemoteClientBroadcastMsg>>,
    instance_id: ::std::option::Option<u64>,
    device_id: ::std::option::Option<u64>,
    device_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastHeader {
    fn default() -> &'a CMsgRemoteClientBroadcastHeader {
        <CMsgRemoteClientBroadcastHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastHeader {
    pub fn new() -> CMsgRemoteClientBroadcastHeader {
        ::std::default::Default::default()
    }

    // optional uint64 client_id = 1;

    pub fn get_client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // optional .ERemoteClientBroadcastMsg msg_type = 2;

    pub fn get_msg_type(&self) -> ERemoteClientBroadcastMsg {
        match self.msg_type {
            Some(e) => e.enum_value_or(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            None => ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery,
        }
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: ERemoteClientBroadcastMsg) {
        self.msg_type = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional uint64 instance_id = 3;

    pub fn get_instance_id(&self) -> u64 {
        self.instance_id.unwrap_or(0)
    }

    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u64) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional uint64 device_id = 4;

    pub fn get_device_id(&self) -> u64 {
        self.device_id.unwrap_or(0)
    }

    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u64) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // optional bytes device_token = 5;

    pub fn get_device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token.clear();
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token.set_default();
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.client_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.msg_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.device_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.device_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        if let Some(v) = self.instance_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.device_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.msg_type {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.device_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteClientBroadcastHeader {
        CMsgRemoteClientBroadcastHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "client_id",
                |m: &CMsgRemoteClientBroadcastHeader| { &m.client_id },
                |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.client_id },
                CMsgRemoteClientBroadcastHeader::get_client_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ERemoteClientBroadcastMsg>(
                "msg_type",
                |m: &CMsgRemoteClientBroadcastHeader| { &m.msg_type },
                |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.msg_type },
                ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "instance_id",
                |m: &CMsgRemoteClientBroadcastHeader| { &m.instance_id },
                |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.instance_id },
                CMsgRemoteClientBroadcastHeader::get_instance_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "device_id",
                |m: &CMsgRemoteClientBroadcastHeader| { &m.device_id },
                |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.device_id },
                CMsgRemoteClientBroadcastHeader::get_device_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "device_token",
                |m: &CMsgRemoteClientBroadcastHeader| { &m.device_token },
                |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.device_token },
                CMsgRemoteClientBroadcastHeader::get_device_token,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteClientBroadcastHeader>(
                "CMsgRemoteClientBroadcastHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastHeader {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteClientBroadcastHeader> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteClientBroadcastHeader::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteClientBroadcastHeader {
    fn clear(&mut self) {
        self.client_id = ::std::option::Option::None;
        self.msg_type = ::std::option::Option::None;
        self.instance_id = ::std::option::Option::None;
        self.device_id = ::std::option::Option::None;
        self.device_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteClientBroadcastHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastHeader {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteClientBroadcastStatus {
    // message fields
    version: ::std::option::Option<i32>,
    min_version: ::std::option::Option<i32>,
    connect_port: ::std::option::Option<u32>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    enabled_services: ::std::option::Option<u32>,
    ostype: ::std::option::Option<i32>,
    is64bit: ::std::option::Option<bool>,
    pub users: ::protobuf::RepeatedField<cmsg_remote_client_broadcast_status::User>,
    euniverse: ::std::option::Option<i32>,
    timestamp: ::std::option::Option<u32>,
    screen_locked: ::std::option::Option<bool>,
    games_running: ::std::option::Option<bool>,
    pub mac_addresses: ::protobuf::RepeatedField<::std::string::String>,
    download_lan_peer_group: ::std::option::Option<u32>,
    broadcasting_active: ::std::option::Option<bool>,
    vr_active: ::std::option::Option<bool>,
    content_cache_port: ::std::option::Option<u32>,
    pub ip_addresses: ::protobuf::RepeatedField<::std::string::String>,
    public_ip_address: ::protobuf::SingularField<::std::string::String>,
    remoteplay_active: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastStatus {
    fn default() -> &'a CMsgRemoteClientBroadcastStatus {
        <CMsgRemoteClientBroadcastStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastStatus {
    pub fn new() -> CMsgRemoteClientBroadcastStatus {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional int32 min_version = 2;

    pub fn get_min_version(&self) -> i32 {
        self.min_version.unwrap_or(0)
    }

    pub fn clear_min_version(&mut self) {
        self.min_version = ::std::option::Option::None;
    }

    pub fn has_min_version(&self) -> bool {
        self.min_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_version(&mut self, v: i32) {
        self.min_version = ::std::option::Option::Some(v);
    }

    // optional uint32 connect_port = 3;

    pub fn get_connect_port(&self) -> u32 {
        self.connect_port.unwrap_or(0)
    }

    pub fn clear_connect_port(&mut self) {
        self.connect_port = ::std::option::Option::None;
    }

    pub fn has_connect_port(&self) -> bool {
        self.connect_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_port(&mut self, v: u32) {
        self.connect_port = ::std::option::Option::Some(v);
    }

    // optional string hostname = 4;

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 enabled_services = 6;

    pub fn get_enabled_services(&self) -> u32 {
        self.enabled_services.unwrap_or(0)
    }

    pub fn clear_enabled_services(&mut self) {
        self.enabled_services = ::std::option::Option::None;
    }

    pub fn has_enabled_services(&self) -> bool {
        self.enabled_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled_services(&mut self, v: u32) {
        self.enabled_services = ::std::option::Option::Some(v);
    }

    // optional int32 ostype = 7;

    pub fn get_ostype(&self) -> i32 {
        self.ostype.unwrap_or(0i32)
    }

    pub fn clear_ostype(&mut self) {
        self.ostype = ::std::option::Option::None;
    }

    pub fn has_ostype(&self) -> bool {
        self.ostype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ostype(&mut self, v: i32) {
        self.ostype = ::std::option::Option::Some(v);
    }

    // optional bool is64bit = 8;

    pub fn get_is64bit(&self) -> bool {
        self.is64bit.unwrap_or(false)
    }

    pub fn clear_is64bit(&mut self) {
        self.is64bit = ::std::option::Option::None;
    }

    pub fn has_is64bit(&self) -> bool {
        self.is64bit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is64bit(&mut self, v: bool) {
        self.is64bit = ::std::option::Option::Some(v);
    }

    // optional int32 euniverse = 11;

    pub fn get_euniverse(&self) -> i32 {
        self.euniverse.unwrap_or(0)
    }

    pub fn clear_euniverse(&mut self) {
        self.euniverse = ::std::option::Option::None;
    }

    pub fn has_euniverse(&self) -> bool {
        self.euniverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_euniverse(&mut self, v: i32) {
        self.euniverse = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 12;

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bool screen_locked = 13;

    pub fn get_screen_locked(&self) -> bool {
        self.screen_locked.unwrap_or(false)
    }

    pub fn clear_screen_locked(&mut self) {
        self.screen_locked = ::std::option::Option::None;
    }

    pub fn has_screen_locked(&self) -> bool {
        self.screen_locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_locked(&mut self, v: bool) {
        self.screen_locked = ::std::option::Option::Some(v);
    }

    // optional bool games_running = 14;

    pub fn get_games_running(&self) -> bool {
        self.games_running.unwrap_or(false)
    }

    pub fn clear_games_running(&mut self) {
        self.games_running = ::std::option::Option::None;
    }

    pub fn has_games_running(&self) -> bool {
        self.games_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_running(&mut self, v: bool) {
        self.games_running = ::std::option::Option::Some(v);
    }

    // optional uint32 download_lan_peer_group = 16;

    pub fn get_download_lan_peer_group(&self) -> u32 {
        self.download_lan_peer_group.unwrap_or(0)
    }

    pub fn clear_download_lan_peer_group(&mut self) {
        self.download_lan_peer_group = ::std::option::Option::None;
    }

    pub fn has_download_lan_peer_group(&self) -> bool {
        self.download_lan_peer_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_lan_peer_group(&mut self, v: u32) {
        self.download_lan_peer_group = ::std::option::Option::Some(v);
    }

    // optional bool broadcasting_active = 17;

    pub fn get_broadcasting_active(&self) -> bool {
        self.broadcasting_active.unwrap_or(false)
    }

    pub fn clear_broadcasting_active(&mut self) {
        self.broadcasting_active = ::std::option::Option::None;
    }

    pub fn has_broadcasting_active(&self) -> bool {
        self.broadcasting_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcasting_active(&mut self, v: bool) {
        self.broadcasting_active = ::std::option::Option::Some(v);
    }

    // optional bool vr_active = 18;

    pub fn get_vr_active(&self) -> bool {
        self.vr_active.unwrap_or(false)
    }

    pub fn clear_vr_active(&mut self) {
        self.vr_active = ::std::option::Option::None;
    }

    pub fn has_vr_active(&self) -> bool {
        self.vr_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_active(&mut self, v: bool) {
        self.vr_active = ::std::option::Option::Some(v);
    }

    // optional uint32 content_cache_port = 19;

    pub fn get_content_cache_port(&self) -> u32 {
        self.content_cache_port.unwrap_or(0)
    }

    pub fn clear_content_cache_port(&mut self) {
        self.content_cache_port = ::std::option::Option::None;
    }

    pub fn has_content_cache_port(&self) -> bool {
        self.content_cache_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_cache_port(&mut self, v: u32) {
        self.content_cache_port = ::std::option::Option::Some(v);
    }

    // optional string public_ip_address = 21;

    pub fn get_public_ip_address(&self) -> &str {
        match self.public_ip_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_public_ip_address(&mut self) {
        self.public_ip_address.clear();
    }

    pub fn has_public_ip_address(&self) -> bool {
        self.public_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip_address(&mut self, v: ::std::string::String) {
        self.public_ip_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip_address(&mut self) -> &mut ::std::string::String {
        if self.public_ip_address.is_none() {
            self.public_ip_address.set_default();
        }
        self.public_ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_ip_address(&mut self) -> ::std::string::String {
        self.public_ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool remoteplay_active = 22;

    pub fn get_remoteplay_active(&self) -> bool {
        self.remoteplay_active.unwrap_or(false)
    }

    pub fn clear_remoteplay_active(&mut self) {
        self.remoteplay_active = ::std::option::Option::None;
    }

    pub fn has_remoteplay_active(&self) -> bool {
        self.remoteplay_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteplay_active(&mut self, v: bool) {
        self.remoteplay_active = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.min_version = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connect_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enabled_services = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ostype = ::std::option::Option::Some(is.read_int32()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is64bit = ::std::option::Option::Some(is.read_bool()?);
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.users)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.euniverse = ::std::option::Option::Some(is.read_int32()?);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.screen_locked = ::std::option::Option::Some(is.read_bool()?);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.games_running = ::std::option::Option::Some(is.read_bool()?);
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mac_addresses)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.download_lan_peer_group = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.broadcasting_active = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.vr_active = ::std::option::Option::Some(is.read_bool()?);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content_cache_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ip_addresses)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.public_ip_address)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.remoteplay_active = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.min_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connect_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.enabled_services {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ostype {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is64bit {
            my_size += 2;
        }
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.euniverse {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screen_locked {
            my_size += 2;
        }
        if let Some(v) = self.games_running {
            my_size += 2;
        }
        for value in &self.mac_addresses {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.download_lan_peer_group {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.broadcasting_active {
            my_size += 3;
        }
        if let Some(v) = self.vr_active {
            my_size += 3;
        }
        if let Some(v) = self.content_cache_port {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ip_addresses {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        if let Some(v) = self.public_ip_address.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.remoteplay_active {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.min_version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.connect_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.enabled_services {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ostype {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.is64bit {
            os.write_bool(8, v)?;
        }
        for v in &self.users {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.euniverse {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.screen_locked {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.games_running {
            os.write_bool(14, v)?;
        }
        for v in &self.mac_addresses {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.download_lan_peer_group {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.broadcasting_active {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.vr_active {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.content_cache_port {
            os.write_uint32(19, v)?;
        }
        for v in &self.ip_addresses {
            os.write_string(20, &v)?;
        };
        if let Some(v) = self.public_ip_address.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.remoteplay_active {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteClientBroadcastStatus {
        CMsgRemoteClientBroadcastStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "version",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.version },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.version },
                CMsgRemoteClientBroadcastStatus::get_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "min_version",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.min_version },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.min_version },
                CMsgRemoteClientBroadcastStatus::get_min_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "connect_port",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.connect_port },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.connect_port },
                CMsgRemoteClientBroadcastStatus::get_connect_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "hostname",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.hostname },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.hostname },
                CMsgRemoteClientBroadcastStatus::get_hostname,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "enabled_services",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.enabled_services },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.enabled_services },
                CMsgRemoteClientBroadcastStatus::get_enabled_services,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "ostype",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.ostype },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.ostype },
                CMsgRemoteClientBroadcastStatus::get_ostype,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is64bit",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.is64bit },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.is64bit },
                CMsgRemoteClientBroadcastStatus::get_is64bit,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cmsg_remote_client_broadcast_status::User>>(
                "users",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.users },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.users },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "euniverse",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.euniverse },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.euniverse },
                CMsgRemoteClientBroadcastStatus::get_euniverse,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "timestamp",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.timestamp },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.timestamp },
                CMsgRemoteClientBroadcastStatus::get_timestamp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "screen_locked",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.screen_locked },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.screen_locked },
                CMsgRemoteClientBroadcastStatus::get_screen_locked,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "games_running",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.games_running },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.games_running },
                CMsgRemoteClientBroadcastStatus::get_games_running,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "mac_addresses",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.mac_addresses },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.mac_addresses },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "download_lan_peer_group",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.download_lan_peer_group },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.download_lan_peer_group },
                CMsgRemoteClientBroadcastStatus::get_download_lan_peer_group,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "broadcasting_active",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.broadcasting_active },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.broadcasting_active },
                CMsgRemoteClientBroadcastStatus::get_broadcasting_active,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "vr_active",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.vr_active },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.vr_active },
                CMsgRemoteClientBroadcastStatus::get_vr_active,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "content_cache_port",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.content_cache_port },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.content_cache_port },
                CMsgRemoteClientBroadcastStatus::get_content_cache_port,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "ip_addresses",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.ip_addresses },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.ip_addresses },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "public_ip_address",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.public_ip_address },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.public_ip_address },
                CMsgRemoteClientBroadcastStatus::get_public_ip_address,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "remoteplay_active",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.remoteplay_active },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.remoteplay_active },
                CMsgRemoteClientBroadcastStatus::get_remoteplay_active,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteClientBroadcastStatus>(
                "CMsgRemoteClientBroadcastStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastStatus {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteClientBroadcastStatus> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteClientBroadcastStatus::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteClientBroadcastStatus {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.min_version = ::std::option::Option::None;
        self.connect_port = ::std::option::Option::None;
        self.hostname.clear();
        self.enabled_services = ::std::option::Option::None;
        self.ostype = ::std::option::Option::None;
        self.is64bit = ::std::option::Option::None;
        self.users.clear();
        self.euniverse = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.screen_locked = ::std::option::Option::None;
        self.games_running = ::std::option::Option::None;
        self.mac_addresses.clear();
        self.download_lan_peer_group = ::std::option::Option::None;
        self.broadcasting_active = ::std::option::Option::None;
        self.vr_active = ::std::option::Option::None;
        self.content_cache_port = ::std::option::Option::None;
        self.ip_addresses.clear();
        self.public_ip_address.clear();
        self.remoteplay_active = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteClientBroadcastStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastStatus {
}

/// Nested message and enums of message `CMsgRemoteClientBroadcastStatus`
pub mod cmsg_remote_client_broadcast_status {
    #[derive(PartialEq,Clone,Default)]
    pub struct User {
        // message fields
        steamid: ::std::option::Option<u64>,
        auth_key_id: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a User {
        fn default() -> &'a User {
            <User as ::protobuf::Message>::default_instance()
        }
    }

    impl User {
        pub fn new() -> User {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn get_steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional uint32 auth_key_id = 2;

        pub fn get_auth_key_id(&self) -> u32 {
            self.auth_key_id.unwrap_or(0)
        }

        pub fn clear_auth_key_id(&mut self) {
            self.auth_key_id = ::std::option::Option::None;
        }

        pub fn has_auth_key_id(&self) -> bool {
            self.auth_key_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_key_id(&mut self, v: u32) {
            self.auth_key_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for User {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.auth_key_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 9;
            }
            if let Some(v) = self.auth_key_id {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.auth_key_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> User {
            User::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steamid",
                    |m: &User| { &m.steamid },
                    |m: &mut User| { &mut m.steamid },
                    User::get_steamid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "auth_key_id",
                    |m: &User| { &m.auth_key_id },
                    |m: &mut User| { &mut m.auth_key_id },
                    User::get_auth_key_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<User>(
                    "CMsgRemoteClientBroadcastStatus.User",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static User {
            static instance: ::protobuf::rt::Lazy<User> = ::protobuf::rt::Lazy::INIT;
            instance.get(User::new)
        }
    }

    impl ::protobuf::Clear for User {
        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.auth_key_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for User {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for User {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteClientBroadcastDiscovery {
    // message fields
    seq_num: ::std::option::Option<u32>,
    pub client_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastDiscovery {
    fn default() -> &'a CMsgRemoteClientBroadcastDiscovery {
        <CMsgRemoteClientBroadcastDiscovery as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastDiscovery {
    pub fn new() -> CMsgRemoteClientBroadcastDiscovery {
        ::std::default::Default::default()
    }

    // optional uint32 seq_num = 1;

    pub fn get_seq_num(&self) -> u32 {
        self.seq_num.unwrap_or(0)
    }

    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: u32) {
        self.seq_num = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastDiscovery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.seq_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.client_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seq_num {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.client_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seq_num {
            os.write_uint32(1, v)?;
        }
        for v in &self.client_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteClientBroadcastDiscovery {
        CMsgRemoteClientBroadcastDiscovery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "seq_num",
                |m: &CMsgRemoteClientBroadcastDiscovery| { &m.seq_num },
                |m: &mut CMsgRemoteClientBroadcastDiscovery| { &mut m.seq_num },
                CMsgRemoteClientBroadcastDiscovery::get_seq_num,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64>(
                "client_ids",
                |m: &CMsgRemoteClientBroadcastDiscovery| { &m.client_ids },
                |m: &mut CMsgRemoteClientBroadcastDiscovery| { &mut m.client_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteClientBroadcastDiscovery>(
                "CMsgRemoteClientBroadcastDiscovery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastDiscovery {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteClientBroadcastDiscovery> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteClientBroadcastDiscovery::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteClientBroadcastDiscovery {
    fn clear(&mut self) {
        self.seq_num = ::std::option::Option::None;
        self.client_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteClientBroadcastDiscovery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastDiscovery {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteClientBroadcastClientIDDeconflict {
    // message fields
    pub client_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastClientIDDeconflict {
    fn default() -> &'a CMsgRemoteClientBroadcastClientIDDeconflict {
        <CMsgRemoteClientBroadcastClientIDDeconflict as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastClientIDDeconflict {
    pub fn new() -> CMsgRemoteClientBroadcastClientIDDeconflict {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.client_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.client_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.client_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteClientBroadcastClientIDDeconflict {
        CMsgRemoteClientBroadcastClientIDDeconflict::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64>(
                "client_ids",
                |m: &CMsgRemoteClientBroadcastClientIDDeconflict| { &m.client_ids },
                |m: &mut CMsgRemoteClientBroadcastClientIDDeconflict| { &mut m.client_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteClientBroadcastClientIDDeconflict>(
                "CMsgRemoteClientBroadcastClientIDDeconflict",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastClientIDDeconflict {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteClientBroadcastClientIDDeconflict> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteClientBroadcastClientIDDeconflict::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn clear(&mut self) {
        self.client_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastClientIDDeconflict {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceAuthorizationRequest {
    // message fields
    device_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    device_name: ::protobuf::SingularField<::std::string::String>,
    encrypted_request: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationRequest {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationRequest {
        <CMsgRemoteDeviceAuthorizationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationRequest {
    pub fn new() -> CMsgRemoteDeviceAuthorizationRequest {
        ::std::default::Default::default()
    }

    // required bytes device_token = 1;

    pub fn get_device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token.clear();
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token.set_default();
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string device_name = 2;

    pub fn get_device_name(&self) -> &str {
        match self.device_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_name(&mut self) {
        self.device_name.clear();
    }

    pub fn has_device_name(&self) -> bool {
        self.device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        if self.device_name.is_none() {
            self.device_name.set_default();
        }
        self.device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes encrypted_request = 3;

    pub fn get_encrypted_request(&self) -> &[u8] {
        match self.encrypted_request.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_request(&mut self) {
        self.encrypted_request.clear();
    }

    pub fn has_encrypted_request(&self) -> bool {
        self.encrypted_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_request(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_request = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_request(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_request.is_none() {
            self.encrypted_request.set_default();
        }
        self.encrypted_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_request(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_request.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationRequest {
    fn is_initialized(&self) -> bool {
        if self.device_token.is_none() {
            return false;
        }
        if self.encrypted_request.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.device_token)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encrypted_request)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.device_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.encrypted_request.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.device_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.encrypted_request.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceAuthorizationRequest {
        CMsgRemoteDeviceAuthorizationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "device_token",
                |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.device_token },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.device_token },
                CMsgRemoteDeviceAuthorizationRequest::get_device_token,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "device_name",
                |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.device_name },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.device_name },
                CMsgRemoteDeviceAuthorizationRequest::get_device_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "encrypted_request",
                |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.encrypted_request },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.encrypted_request },
                CMsgRemoteDeviceAuthorizationRequest::get_encrypted_request,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteDeviceAuthorizationRequest>(
                "CMsgRemoteDeviceAuthorizationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationRequest {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteDeviceAuthorizationRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteDeviceAuthorizationRequest::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceAuthorizationRequest {
    fn clear(&mut self) {
        self.device_token.clear();
        self.device_name.clear();
        self.encrypted_request.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceAuthorizationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationRequest {
}

/// Nested message and enums of message `CMsgRemoteDeviceAuthorizationRequest`
pub mod cmsg_remote_device_authorization_request {
    #[derive(PartialEq,Clone,Default)]
    pub struct CKeyEscrow_Ticket {
        // message fields
        password: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        identifier: ::std::option::Option<u64>,
        payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
        timestamp: ::std::option::Option<u32>,
        usage: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EKeyEscrowUsage>>,
        device_name: ::protobuf::SingularField<::std::string::String>,
        device_model: ::protobuf::SingularField<::std::string::String>,
        device_serial: ::protobuf::SingularField<::std::string::String>,
        device_provisioning_id: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a CKeyEscrow_Ticket {
        fn default() -> &'a CKeyEscrow_Ticket {
            <CKeyEscrow_Ticket as ::protobuf::Message>::default_instance()
        }
    }

    impl CKeyEscrow_Ticket {
        pub fn new() -> CKeyEscrow_Ticket {
            ::std::default::Default::default()
        }

        // optional bytes password = 1;

        pub fn get_password(&self) -> &[u8] {
            match self.password.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_password(&mut self) {
            self.password.clear();
        }

        pub fn has_password(&self) -> bool {
            self.password.is_some()
        }

        // Param is passed by value, moved
        pub fn set_password(&mut self, v: ::std::vec::Vec<u8>) {
            self.password = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_password(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.password.is_none() {
                self.password.set_default();
            }
            self.password.as_mut().unwrap()
        }

        // Take field
        pub fn take_password(&mut self) -> ::std::vec::Vec<u8> {
            self.password.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint64 identifier = 2;

        pub fn get_identifier(&self) -> u64 {
            self.identifier.unwrap_or(0)
        }

        pub fn clear_identifier(&mut self) {
            self.identifier = ::std::option::Option::None;
        }

        pub fn has_identifier(&self) -> bool {
            self.identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_identifier(&mut self, v: u64) {
            self.identifier = ::std::option::Option::Some(v);
        }

        // optional bytes payload = 3;

        pub fn get_payload(&self) -> &[u8] {
            match self.payload.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_payload(&mut self) {
            self.payload.clear();
        }

        pub fn has_payload(&self) -> bool {
            self.payload.is_some()
        }

        // Param is passed by value, moved
        pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
            self.payload = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.payload.is_none() {
                self.payload.set_default();
            }
            self.payload.as_mut().unwrap()
        }

        // Take field
        pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
            self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 timestamp = 4;

        pub fn get_timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional .CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage usage = 5;

        pub fn get_usage(&self) -> EKeyEscrowUsage {
            match self.usage {
                Some(e) => e.enum_value_or(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                None => EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice,
            }
        }

        pub fn clear_usage(&mut self) {
            self.usage = ::std::option::Option::None;
        }

        pub fn has_usage(&self) -> bool {
            self.usage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_usage(&mut self, v: EKeyEscrowUsage) {
            self.usage = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
        }

        // optional string device_name = 6;

        pub fn get_device_name(&self) -> &str {
            match self.device_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_name(&mut self) {
            self.device_name.clear();
        }

        pub fn has_device_name(&self) -> bool {
            self.device_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_name(&mut self, v: ::std::string::String) {
            self.device_name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
            if self.device_name.is_none() {
                self.device_name.set_default();
            }
            self.device_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_name(&mut self) -> ::std::string::String {
            self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string device_model = 7;

        pub fn get_device_model(&self) -> &str {
            match self.device_model.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_model(&mut self) {
            self.device_model.clear();
        }

        pub fn has_device_model(&self) -> bool {
            self.device_model.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_model(&mut self, v: ::std::string::String) {
            self.device_model = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_model(&mut self) -> &mut ::std::string::String {
            if self.device_model.is_none() {
                self.device_model.set_default();
            }
            self.device_model.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_model(&mut self) -> ::std::string::String {
            self.device_model.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string device_serial = 8;

        pub fn get_device_serial(&self) -> &str {
            match self.device_serial.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_serial(&mut self) {
            self.device_serial.clear();
        }

        pub fn has_device_serial(&self) -> bool {
            self.device_serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_serial(&mut self, v: ::std::string::String) {
            self.device_serial = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_serial(&mut self) -> &mut ::std::string::String {
            if self.device_serial.is_none() {
                self.device_serial.set_default();
            }
            self.device_serial.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_serial(&mut self) -> ::std::string::String {
            self.device_serial.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 device_provisioning_id = 9;

        pub fn get_device_provisioning_id(&self) -> u32 {
            self.device_provisioning_id.unwrap_or(0)
        }

        pub fn clear_device_provisioning_id(&mut self) {
            self.device_provisioning_id = ::std::option::Option::None;
        }

        pub fn has_device_provisioning_id(&self) -> bool {
            self.device_provisioning_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_provisioning_id(&mut self, v: u32) {
            self.device_provisioning_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for CKeyEscrow_Ticket {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.password)?;
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.identifier = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    3 => {
                        ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.usage = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    6 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_name)?;
                    },
                    7 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_model)?;
                    },
                    8 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_serial)?;
                    },
                    9 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.device_provisioning_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.password.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.identifier {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.payload.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.usage {
                my_size += ::protobuf::rt::enum_or_unknown_size(5, v);
            }
            if let Some(v) = self.device_name.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.device_model.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.device_serial.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.device_provisioning_id {
                my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.password.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.identifier {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.payload.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.usage {
                os.write_enum(5, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.device_name.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.device_model.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.device_serial.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.device_provisioning_id {
                os.write_uint32(9, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> CKeyEscrow_Ticket {
            CKeyEscrow_Ticket::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "password",
                    |m: &CKeyEscrow_Ticket| { &m.password },
                    |m: &mut CKeyEscrow_Ticket| { &mut m.password },
                    CKeyEscrow_Ticket::get_password,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "identifier",
                    |m: &CKeyEscrow_Ticket| { &m.identifier },
                    |m: &mut CKeyEscrow_Ticket| { &mut m.identifier },
                    CKeyEscrow_Ticket::get_identifier,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                    "payload",
                    |m: &CKeyEscrow_Ticket| { &m.payload },
                    |m: &mut CKeyEscrow_Ticket| { &mut m.payload },
                    CKeyEscrow_Ticket::get_payload,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "timestamp",
                    |m: &CKeyEscrow_Ticket| { &m.timestamp },
                    |m: &mut CKeyEscrow_Ticket| { &mut m.timestamp },
                    CKeyEscrow_Ticket::get_timestamp,
                ));
                fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EKeyEscrowUsage>(
                    "usage",
                    |m: &CKeyEscrow_Ticket| { &m.usage },
                    |m: &mut CKeyEscrow_Ticket| { &mut m.usage },
                    EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "device_name",
                    |m: &CKeyEscrow_Ticket| { &m.device_name },
                    |m: &mut CKeyEscrow_Ticket| { &mut m.device_name },
                    CKeyEscrow_Ticket::get_device_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "device_model",
                    |m: &CKeyEscrow_Ticket| { &m.device_model },
                    |m: &mut CKeyEscrow_Ticket| { &mut m.device_model },
                    CKeyEscrow_Ticket::get_device_model,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "device_serial",
                    |m: &CKeyEscrow_Ticket| { &m.device_serial },
                    |m: &mut CKeyEscrow_Ticket| { &mut m.device_serial },
                    CKeyEscrow_Ticket::get_device_serial,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "device_provisioning_id",
                    |m: &CKeyEscrow_Ticket| { &m.device_provisioning_id },
                    |m: &mut CKeyEscrow_Ticket| { &mut m.device_provisioning_id },
                    CKeyEscrow_Ticket::get_device_provisioning_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CKeyEscrow_Ticket>(
                    "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static CKeyEscrow_Ticket {
            static instance: ::protobuf::rt::Lazy<CKeyEscrow_Ticket> = ::protobuf::rt::Lazy::INIT;
            instance.get(CKeyEscrow_Ticket::new)
        }
    }

    impl ::protobuf::Clear for CKeyEscrow_Ticket {
        fn clear(&mut self) {
            self.password.clear();
            self.identifier = ::std::option::Option::None;
            self.payload.clear();
            self.timestamp = ::std::option::Option::None;
            self.usage = ::std::option::Option::None;
            self.device_name.clear();
            self.device_model.clear();
            self.device_serial.clear();
            self.device_provisioning_id = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for CKeyEscrow_Ticket {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CKeyEscrow_Ticket {
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum EKeyEscrowUsage {
        k_EKeyEscrowUsageStreamingDevice = 0,
    }

    impl ::protobuf::ProtobufEnum for EKeyEscrowUsage {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EKeyEscrowUsage> {
            match value {
                0 => ::std::option::Option::Some(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [EKeyEscrowUsage] = &[
                EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice,
            ];
            values
        }

        fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new::<EKeyEscrowUsage>("CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage", super::file_descriptor_proto())
            })
        }
    }

    impl ::std::default::Default for EKeyEscrowUsage {
        fn default() -> Self {
            EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EKeyEscrowUsage {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceAuthorizationCancelRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationCancelRequest {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationCancelRequest {
        <CMsgRemoteDeviceAuthorizationCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationCancelRequest {
    pub fn new() -> CMsgRemoteDeviceAuthorizationCancelRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceAuthorizationCancelRequest {
        CMsgRemoteDeviceAuthorizationCancelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteDeviceAuthorizationCancelRequest>(
                "CMsgRemoteDeviceAuthorizationCancelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationCancelRequest {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteDeviceAuthorizationCancelRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteDeviceAuthorizationCancelRequest::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationCancelRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceAuthorizationResponse {
    // message fields
    result: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ERemoteDeviceAuthorizationResult>>,
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationResponse {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationResponse {
        <CMsgRemoteDeviceAuthorizationResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationResponse {
    pub fn new() -> CMsgRemoteDeviceAuthorizationResponse {
        ::std::default::Default::default()
    }

    // required .ERemoteDeviceAuthorizationResult result = 1;

    pub fn get_result(&self) -> ERemoteDeviceAuthorizationResult {
        match self.result {
            Some(e) => e.enum_value_or(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            None => ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceAuthorizationResult) {
        self.result = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional fixed64 steamid = 2;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceAuthorizationResponse {
        CMsgRemoteDeviceAuthorizationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ERemoteDeviceAuthorizationResult>(
                "result",
                |m: &CMsgRemoteDeviceAuthorizationResponse| { &m.result },
                |m: &mut CMsgRemoteDeviceAuthorizationResponse| { &mut m.result },
                ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CMsgRemoteDeviceAuthorizationResponse| { &m.steamid },
                |m: &mut CMsgRemoteDeviceAuthorizationResponse| { &mut m.steamid },
                CMsgRemoteDeviceAuthorizationResponse::get_steamid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteDeviceAuthorizationResponse>(
                "CMsgRemoteDeviceAuthorizationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationResponse {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteDeviceAuthorizationResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteDeviceAuthorizationResponse::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceAuthorizationResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceAuthorizationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceStreamingRequest {
    // message fields
    request_id: ::std::option::Option<u32>,
    maximum_resolution_x: ::std::option::Option<i32>,
    maximum_resolution_y: ::std::option::Option<i32>,
    audio_channel_count: ::std::option::Option<i32>,
    device_version: ::protobuf::SingularField<::std::string::String>,
    stream_desktop: ::std::option::Option<bool>,
    device_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pin: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    enable_video_streaming: ::std::option::Option<bool>,
    enable_audio_streaming: ::std::option::Option<bool>,
    enable_input_streaming: ::std::option::Option<bool>,
    network_test: ::std::option::Option<bool>,
    client_id: ::std::option::Option<u64>,
    pub supported_transport: ::std::vec::Vec<::protobuf::ProtobufEnumOrUnknown<EStreamTransport>>,
    restricted: ::std::option::Option<bool>,
    form_factor: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamDeviceFormFactor>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingRequest {
    fn default() -> &'a CMsgRemoteDeviceStreamingRequest {
        <CMsgRemoteDeviceStreamingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingRequest {
    pub fn new() -> CMsgRemoteDeviceStreamingRequest {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_resolution_x = 2;

    pub fn get_maximum_resolution_x(&self) -> i32 {
        self.maximum_resolution_x.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_x(&mut self) {
        self.maximum_resolution_x = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_x(&self) -> bool {
        self.maximum_resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_x(&mut self, v: i32) {
        self.maximum_resolution_x = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_resolution_y = 3;

    pub fn get_maximum_resolution_y(&self) -> i32 {
        self.maximum_resolution_y.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_y(&mut self) {
        self.maximum_resolution_y = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_y(&self) -> bool {
        self.maximum_resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_y(&mut self, v: i32) {
        self.maximum_resolution_y = ::std::option::Option::Some(v);
    }

    // optional int32 audio_channel_count = 4;

    pub fn get_audio_channel_count(&self) -> i32 {
        self.audio_channel_count.unwrap_or(2i32)
    }

    pub fn clear_audio_channel_count(&mut self) {
        self.audio_channel_count = ::std::option::Option::None;
    }

    pub fn has_audio_channel_count(&self) -> bool {
        self.audio_channel_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channel_count(&mut self, v: i32) {
        self.audio_channel_count = ::std::option::Option::Some(v);
    }

    // optional string device_version = 5;

    pub fn get_device_version(&self) -> &str {
        match self.device_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_version(&mut self) {
        self.device_version.clear();
    }

    pub fn has_device_version(&self) -> bool {
        self.device_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_version(&mut self, v: ::std::string::String) {
        self.device_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_version(&mut self) -> &mut ::std::string::String {
        if self.device_version.is_none() {
            self.device_version.set_default();
        }
        self.device_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_version(&mut self) -> ::std::string::String {
        self.device_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool stream_desktop = 6;

    pub fn get_stream_desktop(&self) -> bool {
        self.stream_desktop.unwrap_or(false)
    }

    pub fn clear_stream_desktop(&mut self) {
        self.stream_desktop = ::std::option::Option::None;
    }

    pub fn has_stream_desktop(&self) -> bool {
        self.stream_desktop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_desktop(&mut self, v: bool) {
        self.stream_desktop = ::std::option::Option::Some(v);
    }

    // optional bytes device_token = 7;

    pub fn get_device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token.clear();
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token.set_default();
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pin = 8;

    pub fn get_pin(&self) -> &[u8] {
        match self.pin.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pin(&mut self) {
        self.pin.clear();
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::vec::Vec<u8>) {
        self.pin = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pin.is_none() {
            self.pin.set_default();
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::vec::Vec<u8> {
        self.pin.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool enable_video_streaming = 9;

    pub fn get_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.unwrap_or(true)
    }

    pub fn clear_enable_video_streaming(&mut self) {
        self.enable_video_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_streaming(&mut self, v: bool) {
        self.enable_video_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_audio_streaming = 10;

    pub fn get_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.unwrap_or(true)
    }

    pub fn clear_enable_audio_streaming(&mut self) {
        self.enable_audio_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_streaming(&mut self, v: bool) {
        self.enable_audio_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_input_streaming = 11;

    pub fn get_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.unwrap_or(true)
    }

    pub fn clear_enable_input_streaming(&mut self) {
        self.enable_input_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_input_streaming(&mut self, v: bool) {
        self.enable_input_streaming = ::std::option::Option::Some(v);
    }

    // optional bool network_test = 12;

    pub fn get_network_test(&self) -> bool {
        self.network_test.unwrap_or(false)
    }

    pub fn clear_network_test(&mut self) {
        self.network_test = ::std::option::Option::None;
    }

    pub fn has_network_test(&self) -> bool {
        self.network_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_test(&mut self, v: bool) {
        self.network_test = ::std::option::Option::Some(v);
    }

    // optional uint64 client_id = 13;

    pub fn get_client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // optional bool restricted = 15;

    pub fn get_restricted(&self) -> bool {
        self.restricted.unwrap_or(false)
    }

    pub fn clear_restricted(&mut self) {
        self.restricted = ::std::option::Option::None;
    }

    pub fn has_restricted(&self) -> bool {
        self.restricted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restricted(&mut self, v: bool) {
        self.restricted = ::std::option::Option::Some(v);
    }

    // optional .EStreamDeviceFormFactor form_factor = 16;

    pub fn get_form_factor(&self) -> EStreamDeviceFormFactor {
        match self.form_factor {
            Some(e) => e.enum_value_or(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            None => EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown,
        }
    }

    pub fn clear_form_factor(&mut self) {
        self.form_factor = ::std::option::Option::None;
    }

    pub fn has_form_factor(&self) -> bool {
        self.form_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_form_factor(&mut self, v: EStreamDeviceFormFactor) {
        self.form_factor = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingRequest {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maximum_resolution_x = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maximum_resolution_y = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.audio_channel_count = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_version)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stream_desktop = ::std::option::Option::Some(is.read_bool()?);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.device_token)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pin)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_video_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_audio_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_input_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.network_test = ::std::option::Option::Some(is.read_bool()?);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.client_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                14 => {
                    ::protobuf::rt::read_repeated_enum_or_unknown_into(wire_type, is, &mut self.supported_transport)?
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.restricted = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.form_factor = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_resolution_x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_resolution_y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.audio_channel_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.device_version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.stream_desktop {
            my_size += 2;
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.pin.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.enable_video_streaming {
            my_size += 2;
        }
        if let Some(v) = self.enable_audio_streaming {
            my_size += 2;
        }
        if let Some(v) = self.enable_input_streaming {
            my_size += 2;
        }
        if let Some(v) = self.network_test {
            my_size += 2;
        }
        if let Some(v) = self.client_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.supported_transport {
            my_size += ::protobuf::rt::enum_or_unknown_size(14, *value);
        };
        if let Some(v) = self.restricted {
            my_size += 2;
        }
        if let Some(v) = self.form_factor {
            my_size += ::protobuf::rt::enum_or_unknown_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.maximum_resolution_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.maximum_resolution_y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.audio_channel_count {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.device_version.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.stream_desktop {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.pin.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.enable_video_streaming {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.enable_audio_streaming {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.enable_input_streaming {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.network_test {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.client_id {
            os.write_uint64(13, v)?;
        }
        for v in &self.supported_transport {
            os.write_enum(14, ::protobuf::ProtobufEnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.restricted {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.form_factor {
            os.write_enum(16, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceStreamingRequest {
        CMsgRemoteDeviceStreamingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "request_id",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.request_id },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.request_id },
                CMsgRemoteDeviceStreamingRequest::get_request_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "maximum_resolution_x",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.maximum_resolution_x },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.maximum_resolution_x },
                CMsgRemoteDeviceStreamingRequest::get_maximum_resolution_x,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "maximum_resolution_y",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.maximum_resolution_y },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.maximum_resolution_y },
                CMsgRemoteDeviceStreamingRequest::get_maximum_resolution_y,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "audio_channel_count",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.audio_channel_count },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.audio_channel_count },
                CMsgRemoteDeviceStreamingRequest::get_audio_channel_count,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "device_version",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.device_version },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.device_version },
                CMsgRemoteDeviceStreamingRequest::get_device_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "stream_desktop",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.stream_desktop },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.stream_desktop },
                CMsgRemoteDeviceStreamingRequest::get_stream_desktop,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "device_token",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.device_token },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.device_token },
                CMsgRemoteDeviceStreamingRequest::get_device_token,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "pin",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.pin },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.pin },
                CMsgRemoteDeviceStreamingRequest::get_pin,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_video_streaming",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_video_streaming },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_video_streaming },
                CMsgRemoteDeviceStreamingRequest::get_enable_video_streaming,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_audio_streaming",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_audio_streaming },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_audio_streaming },
                CMsgRemoteDeviceStreamingRequest::get_enable_audio_streaming,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_input_streaming",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_input_streaming },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_input_streaming },
                CMsgRemoteDeviceStreamingRequest::get_enable_input_streaming,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "network_test",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.network_test },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.network_test },
                CMsgRemoteDeviceStreamingRequest::get_network_test,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "client_id",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.client_id },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.client_id },
                CMsgRemoteDeviceStreamingRequest::get_client_id,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeEnumOrUnknown<EStreamTransport>>(
                "supported_transport",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.supported_transport },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.supported_transport },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "restricted",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.restricted },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.restricted },
                CMsgRemoteDeviceStreamingRequest::get_restricted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamDeviceFormFactor>(
                "form_factor",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.form_factor },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.form_factor },
                EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteDeviceStreamingRequest>(
                "CMsgRemoteDeviceStreamingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingRequest {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteDeviceStreamingRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteDeviceStreamingRequest::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceStreamingRequest {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.maximum_resolution_x = ::std::option::Option::None;
        self.maximum_resolution_y = ::std::option::Option::None;
        self.audio_channel_count = ::std::option::Option::None;
        self.device_version.clear();
        self.stream_desktop = ::std::option::Option::None;
        self.device_token.clear();
        self.pin.clear();
        self.enable_video_streaming = ::std::option::Option::None;
        self.enable_audio_streaming = ::std::option::Option::None;
        self.enable_input_streaming = ::std::option::Option::None;
        self.network_test = ::std::option::Option::None;
        self.client_id = ::std::option::Option::None;
        self.supported_transport.clear();
        self.restricted = ::std::option::Option::None;
        self.form_factor = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceStreamingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceStreamingCancelRequest {
    // message fields
    request_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingCancelRequest {
    fn default() -> &'a CMsgRemoteDeviceStreamingCancelRequest {
        <CMsgRemoteDeviceStreamingCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingCancelRequest {
    pub fn new() -> CMsgRemoteDeviceStreamingCancelRequest {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingCancelRequest {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceStreamingCancelRequest {
        CMsgRemoteDeviceStreamingCancelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "request_id",
                |m: &CMsgRemoteDeviceStreamingCancelRequest| { &m.request_id },
                |m: &mut CMsgRemoteDeviceStreamingCancelRequest| { &mut m.request_id },
                CMsgRemoteDeviceStreamingCancelRequest::get_request_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteDeviceStreamingCancelRequest>(
                "CMsgRemoteDeviceStreamingCancelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingCancelRequest {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteDeviceStreamingCancelRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteDeviceStreamingCancelRequest::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceStreamingCancelRequest {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceStreamingCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingCancelRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceStreamingResponse {
    // message fields
    request_id: ::std::option::Option<u32>,
    result: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ERemoteDeviceStreamingResult>>,
    port: ::std::option::Option<u32>,
    encrypted_session_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    transport: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamTransport>>,
    relay_server: ::protobuf::SingularField<::std::string::String>,
    cert: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingResponse {
    fn default() -> &'a CMsgRemoteDeviceStreamingResponse {
        <CMsgRemoteDeviceStreamingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingResponse {
    pub fn new() -> CMsgRemoteDeviceStreamingResponse {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required .ERemoteDeviceStreamingResult result = 2;

    pub fn get_result(&self) -> ERemoteDeviceStreamingResult {
        match self.result {
            Some(e) => e.enum_value_or(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            None => ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceStreamingResult) {
        self.result = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional uint32 port = 3;

    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional bytes encrypted_session_key = 4;

    pub fn get_encrypted_session_key(&self) -> &[u8] {
        match self.encrypted_session_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_session_key(&mut self) {
        self.encrypted_session_key.clear();
    }

    pub fn has_encrypted_session_key(&self) -> bool {
        self.encrypted_session_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_session_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_session_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_session_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_session_key.is_none() {
            self.encrypted_session_key.set_default();
        }
        self.encrypted_session_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_session_key(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_session_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EStreamTransport transport = 6;

    pub fn get_transport(&self) -> EStreamTransport {
        match self.transport {
            Some(e) => e.enum_value_or(EStreamTransport::k_EStreamTransportUDP),
            None => EStreamTransport::k_EStreamTransportUDP,
        }
    }

    pub fn clear_transport(&mut self) {
        self.transport = ::std::option::Option::None;
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: EStreamTransport) {
        self.transport = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional string relay_server = 7;

    pub fn get_relay_server(&self) -> &str {
        match self.relay_server.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_relay_server(&mut self) {
        self.relay_server.clear();
    }

    pub fn has_relay_server(&self) -> bool {
        self.relay_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_server(&mut self, v: ::std::string::String) {
        self.relay_server = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relay_server(&mut self) -> &mut ::std::string::String {
        if self.relay_server.is_none() {
            self.relay_server.set_default();
        }
        self.relay_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_relay_server(&mut self) -> ::std::string::String {
        self.relay_server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cert = 8;

    pub fn get_cert(&self) -> &str {
        match self.cert.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::std::string::String) {
        self.cert = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::std::string::String {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> ::std::string::String {
        self.cert.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.port = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encrypted_session_key)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.transport = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relay_server)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cert)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encrypted_session_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.transport {
            my_size += ::protobuf::rt::enum_or_unknown_size(6, v);
        }
        if let Some(v) = self.relay_server.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.cert.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.encrypted_session_key.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.transport {
            os.write_enum(6, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.relay_server.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.cert.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceStreamingResponse {
        CMsgRemoteDeviceStreamingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "request_id",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.request_id },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.request_id },
                CMsgRemoteDeviceStreamingResponse::get_request_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ERemoteDeviceStreamingResult>(
                "result",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.result },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.result },
                ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "port",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.port },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.port },
                CMsgRemoteDeviceStreamingResponse::get_port,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "encrypted_session_key",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.encrypted_session_key },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.encrypted_session_key },
                CMsgRemoteDeviceStreamingResponse::get_encrypted_session_key,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamTransport>(
                "transport",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.transport },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.transport },
                EStreamTransport::k_EStreamTransportUDP,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "relay_server",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.relay_server },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.relay_server },
                CMsgRemoteDeviceStreamingResponse::get_relay_server,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "cert",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.cert },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.cert },
                CMsgRemoteDeviceStreamingResponse::get_cert,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteDeviceStreamingResponse>(
                "CMsgRemoteDeviceStreamingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingResponse {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteDeviceStreamingResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteDeviceStreamingResponse::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceStreamingResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.encrypted_session_key.clear();
        self.transport = ::std::option::Option::None;
        self.relay_server.clear();
        self.cert.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceStreamingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceProofRequest {
    // message fields
    challenge: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceProofRequest {
    fn default() -> &'a CMsgRemoteDeviceProofRequest {
        <CMsgRemoteDeviceProofRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceProofRequest {
    pub fn new() -> CMsgRemoteDeviceProofRequest {
        ::std::default::Default::default()
    }

    // required bytes challenge = 1;

    pub fn get_challenge(&self) -> &[u8] {
        match self.challenge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_challenge(&mut self) {
        self.challenge.clear();
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: ::std::vec::Vec<u8>) {
        self.challenge = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.challenge.is_none() {
            self.challenge.set_default();
        }
        self.challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge(&mut self) -> ::std::vec::Vec<u8> {
        self.challenge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceProofRequest {
    fn is_initialized(&self) -> bool {
        if self.challenge.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.challenge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.challenge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.challenge.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceProofRequest {
        CMsgRemoteDeviceProofRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "challenge",
                |m: &CMsgRemoteDeviceProofRequest| { &m.challenge },
                |m: &mut CMsgRemoteDeviceProofRequest| { &mut m.challenge },
                CMsgRemoteDeviceProofRequest::get_challenge,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteDeviceProofRequest>(
                "CMsgRemoteDeviceProofRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceProofRequest {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteDeviceProofRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteDeviceProofRequest::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceProofRequest {
    fn clear(&mut self) {
        self.challenge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceProofRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceProofRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceProofResponse {
    // message fields
    response: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceProofResponse {
    fn default() -> &'a CMsgRemoteDeviceProofResponse {
        <CMsgRemoteDeviceProofResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceProofResponse {
    pub fn new() -> CMsgRemoteDeviceProofResponse {
        ::std::default::Default::default()
    }

    // required bytes response = 1;

    pub fn get_response(&self) -> &[u8] {
        match self.response.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: ::std::vec::Vec<u8>) {
        self.response = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> ::std::vec::Vec<u8> {
        self.response.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceProofResponse {
    fn is_initialized(&self) -> bool {
        if self.response.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceProofResponse {
        CMsgRemoteDeviceProofResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "response",
                |m: &CMsgRemoteDeviceProofResponse| { &m.response },
                |m: &mut CMsgRemoteDeviceProofResponse| { &mut m.response },
                CMsgRemoteDeviceProofResponse::get_response,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteDeviceProofResponse>(
                "CMsgRemoteDeviceProofResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceProofResponse {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteDeviceProofResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteDeviceProofResponse::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceProofResponse {
    fn clear(&mut self) {
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceProofResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceProofResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceStreamTransportSignal {
    // message fields
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamTransportSignal {
    fn default() -> &'a CMsgRemoteDeviceStreamTransportSignal {
        <CMsgRemoteDeviceStreamTransportSignal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamTransportSignal {
    pub fn new() -> CMsgRemoteDeviceStreamTransportSignal {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 2;

    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamTransportSignal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceStreamTransportSignal {
        CMsgRemoteDeviceStreamTransportSignal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "token",
                |m: &CMsgRemoteDeviceStreamTransportSignal| { &m.token },
                |m: &mut CMsgRemoteDeviceStreamTransportSignal| { &mut m.token },
                CMsgRemoteDeviceStreamTransportSignal::get_token,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "payload",
                |m: &CMsgRemoteDeviceStreamTransportSignal| { &m.payload },
                |m: &mut CMsgRemoteDeviceStreamTransportSignal| { &mut m.payload },
                CMsgRemoteDeviceStreamTransportSignal::get_payload,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CMsgRemoteDeviceStreamTransportSignal>(
                "CMsgRemoteDeviceStreamTransportSignal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamTransportSignal {
        static instance: ::protobuf::rt::Lazy<CMsgRemoteDeviceStreamTransportSignal> = ::protobuf::rt::Lazy::INIT;
        instance.get(CMsgRemoteDeviceStreamTransportSignal::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceStreamTransportSignal {
    fn clear(&mut self) {
        self.token.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceStreamTransportSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamTransportSignal {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum ERemoteClientBroadcastMsg {
    k_ERemoteClientBroadcastMsgDiscovery = 0,
    k_ERemoteClientBroadcastMsgStatus = 1,
    k_ERemoteClientBroadcastMsgOffline = 2,
    k_ERemoteDeviceAuthorizationRequest = 3,
    k_ERemoteDeviceAuthorizationResponse = 4,
    k_ERemoteDeviceStreamingRequest = 5,
    k_ERemoteDeviceStreamingResponse = 6,
    k_ERemoteDeviceProofRequest = 7,
    k_ERemoteDeviceProofResponse = 8,
    k_ERemoteDeviceAuthorizationCancelRequest = 9,
    k_ERemoteDeviceStreamingCancelRequest = 10,
    k_ERemoteClientBroadcastMsgClientIDDeconflict = 11,
    k_ERemoteDeviceStreamTransportSignal = 12,
}

impl ::protobuf::ProtobufEnum for ERemoteClientBroadcastMsg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteClientBroadcastMsg> {
        match value {
            0 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            1 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus),
            2 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline),
            3 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest),
            4 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse),
            5 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest),
            6 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse),
            7 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest),
            8 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse),
            9 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest),
            10 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest),
            11 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict),
            12 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ERemoteClientBroadcastMsg] = &[
            ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery,
            ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus,
            ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest,
            ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<ERemoteClientBroadcastMsg>("ERemoteClientBroadcastMsg", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for ERemoteClientBroadcastMsg {
    fn default() -> Self {
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery
    }
}

impl ::protobuf::reflect::ProtobufValue for ERemoteClientBroadcastMsg {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum ERemoteClientService {
    k_ERemoteClientServiceNone = 0,
    k_ERemoteClientServiceRemoteControl = 1,
    k_ERemoteClientServiceGameStreaming = 2,
    k_ERemoteClientServiceSiteLicense = 4,
    k_ERemoteClientServiceContentCache = 8,
}

impl ::protobuf::ProtobufEnum for ERemoteClientService {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteClientService> {
        match value {
            0 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceNone),
            1 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceRemoteControl),
            2 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceGameStreaming),
            4 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceSiteLicense),
            8 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentCache),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ERemoteClientService] = &[
            ERemoteClientService::k_ERemoteClientServiceNone,
            ERemoteClientService::k_ERemoteClientServiceRemoteControl,
            ERemoteClientService::k_ERemoteClientServiceGameStreaming,
            ERemoteClientService::k_ERemoteClientServiceSiteLicense,
            ERemoteClientService::k_ERemoteClientServiceContentCache,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<ERemoteClientService>("ERemoteClientService", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for ERemoteClientService {
    fn default() -> Self {
        ERemoteClientService::k_ERemoteClientServiceNone
    }
}

impl ::protobuf::reflect::ProtobufValue for ERemoteClientService {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum ERemoteDeviceAuthorizationResult {
    k_ERemoteDeviceAuthorizationSuccess = 0,
    k_ERemoteDeviceAuthorizationDenied = 1,
    k_ERemoteDeviceAuthorizationNotLoggedIn = 2,
    k_ERemoteDeviceAuthorizationOffline = 3,
    k_ERemoteDeviceAuthorizationBusy = 4,
    k_ERemoteDeviceAuthorizationInProgress = 5,
    k_ERemoteDeviceAuthorizationTimedOut = 6,
    k_ERemoteDeviceAuthorizationFailed = 7,
    k_ERemoteDeviceAuthorizationCanceled = 8,
}

impl ::protobuf::ProtobufEnum for ERemoteDeviceAuthorizationResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteDeviceAuthorizationResult> {
        match value {
            0 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            1 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied),
            2 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn),
            3 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline),
            4 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy),
            5 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress),
            6 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut),
            7 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed),
            8 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ERemoteDeviceAuthorizationResult] = &[
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<ERemoteDeviceAuthorizationResult>("ERemoteDeviceAuthorizationResult", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for ERemoteDeviceAuthorizationResult {
    fn default() -> Self {
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess
    }
}

impl ::protobuf::reflect::ProtobufValue for ERemoteDeviceAuthorizationResult {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamDeviceFormFactor {
    k_EStreamDeviceFormFactorUnknown = 0,
    k_EStreamDeviceFormFactorPhone = 1,
    k_EStreamDeviceFormFactorTablet = 2,
    k_EStreamDeviceFormFactorComputer = 3,
    k_EStreamDeviceFormFactorTV = 4,
}

impl ::protobuf::ProtobufEnum for EStreamDeviceFormFactor {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDeviceFormFactor> {
        match value {
            0 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            1 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone),
            2 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet),
            3 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer),
            4 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamDeviceFormFactor] = &[
            EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown,
            EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone,
            EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet,
            EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer,
            EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamDeviceFormFactor>("EStreamDeviceFormFactor", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EStreamDeviceFormFactor {
    fn default() -> Self {
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamDeviceFormFactor {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamTransport {
    k_EStreamTransportNone = 0,
    k_EStreamTransportUDP = 1,
    k_EStreamTransportUDPRelay = 2,
    k_EStreamTransportWebRTC = 3,
    k_EStreamTransportSDR = 4,
    k_EStreamTransportUDP_SNS = 5,
    k_EStreamTransportUDPRelay_SNS = 6,
}

impl ::protobuf::ProtobufEnum for EStreamTransport {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamTransport> {
        match value {
            0 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportNone),
            1 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP),
            2 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay),
            3 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportWebRTC),
            4 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportSDR),
            5 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP_SNS),
            6 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay_SNS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamTransport] = &[
            EStreamTransport::k_EStreamTransportNone,
            EStreamTransport::k_EStreamTransportUDP,
            EStreamTransport::k_EStreamTransportUDPRelay,
            EStreamTransport::k_EStreamTransportWebRTC,
            EStreamTransport::k_EStreamTransportSDR,
            EStreamTransport::k_EStreamTransportUDP_SNS,
            EStreamTransport::k_EStreamTransportUDPRelay_SNS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamTransport>("EStreamTransport", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EStreamTransport {
    fn default() -> Self {
        EStreamTransport::k_EStreamTransportNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamTransport {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum ERemoteDeviceStreamingResult {
    k_ERemoteDeviceStreamingSuccess = 0,
    k_ERemoteDeviceStreamingUnauthorized = 1,
    k_ERemoteDeviceStreamingScreenLocked = 2,
    k_ERemoteDeviceStreamingFailed = 3,
    k_ERemoteDeviceStreamingBusy = 4,
    k_ERemoteDeviceStreamingInProgress = 5,
    k_ERemoteDeviceStreamingCanceled = 6,
    k_ERemoteDeviceStreamingDriversNotInstalled = 7,
    k_ERemoteDeviceStreamingDisabled = 8,
    k_ERemoteDeviceStreamingBroadcastingActive = 9,
    k_ERemoteDeviceStreamingVRActive = 10,
    k_ERemoteDeviceStreamingPINRequired = 11,
    k_ERemoteDeviceStreamingTransportUnavailable = 12,
    k_ERemoteDeviceStreamingInvisible = 13,
}

impl ::protobuf::ProtobufEnum for ERemoteDeviceStreamingResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteDeviceStreamingResult> {
        match value {
            0 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            1 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized),
            2 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked),
            3 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed),
            4 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy),
            5 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress),
            6 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled),
            7 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled),
            8 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled),
            9 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive),
            10 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive),
            11 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired),
            12 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable),
            13 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ERemoteDeviceStreamingResult] = &[
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<ERemoteDeviceStreamingResult>("ERemoteDeviceStreamingResult", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for ERemoteDeviceStreamingResult {
    fn default() -> Self {
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess
    }
}

impl ::protobuf::reflect::ProtobufValue for ERemoteDeviceStreamingResult {
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n*steammessages_remoteclient_discovery.proto\"\xfc\x01\n\x1fCMsgRemoteC\
    lientBroadcastHeader\x12\x1b\n\tclient_id\x18\x01\x20\x01(\x04R\x08clien\
    tId\x12[\n\x08msg_type\x18\x02\x20\x01(\x0e2\x1a.ERemoteClientBroadcastM\
    sg:$k_ERemoteClientBroadcastMsgDiscoveryR\x07msgType\x12\x1f\n\x0binstan\
    ce_id\x18\x03\x20\x01(\x04R\ninstanceId\x12\x1b\n\tdevice_id\x18\x04\x20\
    \x01(\x04R\x08deviceId\x12!\n\x0cdevice_token\x18\x05\x20\x01(\x0cR\x0bd\
    eviceToken\"\xd4\x06\n\x1fCMsgRemoteClientBroadcastStatus\x12\x18\n\x07v\
    ersion\x18\x01\x20\x01(\x05R\x07version\x12\x1f\n\x0bmin_version\x18\x02\
    \x20\x01(\x05R\nminVersion\x12!\n\x0cconnect_port\x18\x03\x20\x01(\rR\
    \x0bconnectPort\x12\x1a\n\x08hostname\x18\x04\x20\x01(\tR\x08hostname\
    \x12)\n\x10enabled_services\x18\x06\x20\x01(\rR\x0fenabledServices\x12\
    \x19\n\x06ostype\x18\x07\x20\x01(\x05:\x010R\x06ostype\x12\x18\n\x07is64\
    bit\x18\x08\x20\x01(\x08R\x07is64bit\x12;\n\x05users\x18\t\x20\x03(\x0b2\
    %.CMsgRemoteClientBroadcastStatus.UserR\x05users\x12\x1c\n\teuniverse\
    \x18\x0b\x20\x01(\x05R\teuniverse\x12\x1c\n\ttimestamp\x18\x0c\x20\x01(\
    \rR\ttimestamp\x12#\n\rscreen_locked\x18\r\x20\x01(\x08R\x0cscreenLocked\
    \x12#\n\rgames_running\x18\x0e\x20\x01(\x08R\x0cgamesRunning\x12#\n\rmac\
    _addresses\x18\x0f\x20\x03(\tR\x0cmacAddresses\x125\n\x17download_lan_pe\
    er_group\x18\x10\x20\x01(\rR\x14downloadLanPeerGroup\x12/\n\x13broadcast\
    ing_active\x18\x11\x20\x01(\x08R\x12broadcastingActive\x12\x1b\n\tvr_act\
    ive\x18\x12\x20\x01(\x08R\x08vrActive\x12,\n\x12content_cache_port\x18\
    \x13\x20\x01(\rR\x10contentCachePort\x12!\n\x0cip_addresses\x18\x14\x20\
    \x03(\tR\x0bipAddresses\x12*\n\x11public_ip_address\x18\x15\x20\x01(\tR\
    \x0fpublicIpAddress\x12+\n\x11remoteplay_active\x18\x16\x20\x01(\x08R\
    \x10remoteplayActive\x1a@\n\x04User\x12\x18\n\x07steamid\x18\x01\x20\x01\
    (\x06R\x07steamid\x12\x1e\n\x0bauth_key_id\x18\x02\x20\x01(\rR\tauthKeyI\
    d\"\\\n\"CMsgRemoteClientBroadcastDiscovery\x12\x17\n\x07seq_num\x18\x01\
    \x20\x01(\rR\x06seqNum\x12\x1d\n\nclient_ids\x18\x02\x20\x03(\x04R\tclie\
    ntIds\"L\n+CMsgRemoteClientBroadcastClientIDDeconflict\x12\x1d\n\nclient\
    _ids\x18\x02\x20\x03(\x04R\tclientIds\"\xe8\x04\n$CMsgRemoteDeviceAuthor\
    izationRequest\x12!\n\x0cdevice_token\x18\x01\x20\x02(\x0cR\x0bdeviceTok\
    en\x12\x1f\n\x0bdevice_name\x18\x02\x20\x01(\tR\ndeviceName\x12+\n\x11en\
    crypted_request\x18\x03\x20\x02(\x0cR\x10encryptedRequest\x1a\x95\x03\n\
    \x11CKeyEscrow_Ticket\x12\x1a\n\x08password\x18\x01\x20\x01(\x0cR\x08pas\
    sword\x12\x1e\n\nidentifier\x18\x02\x20\x01(\x04R\nidentifier\x12\x18\n\
    \x07payload\x18\x03\x20\x01(\x0cR\x07payload\x12\x1c\n\ttimestamp\x18\
    \x04\x20\x01(\rR\ttimestamp\x12m\n\x05usage\x18\x05\x20\x01(\x0e25.CMsgR\
    emoteDeviceAuthorizationRequest.EKeyEscrowUsage:\x20k_EKeyEscrowUsageStr\
    eamingDeviceR\x05usage\x12\x1f\n\x0bdevice_name\x18\x06\x20\x01(\tR\ndev\
    iceName\x12!\n\x0cdevice_model\x18\x07\x20\x01(\tR\x0bdeviceModel\x12#\n\
    \rdevice_serial\x18\x08\x20\x01(\tR\x0cdeviceSerial\x124\n\x16device_pro\
    visioning_id\x18\t\x20\x01(\rR\x14deviceProvisioningId\"7\n\x0fEKeyEscro\
    wUsage\x12$\n\x20k_EKeyEscrowUsageStreamingDevice\x10\0\",\n*CMsgRemoteD\
    eviceAuthorizationCancelRequest\"\xa1\x01\n%CMsgRemoteDeviceAuthorizatio\
    nResponse\x12^\n\x06result\x18\x01\x20\x02(\x0e2!.ERemoteDeviceAuthoriza\
    tionResult:#k_ERemoteDeviceAuthorizationSuccessR\x06result\x12\x18\n\x07\
    steamid\x18\x02\x20\x01(\x06R\x07steamid\"\x90\x06\n\x20CMsgRemoteDevice\
    StreamingRequest\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequestId\
    \x120\n\x14maximum_resolution_x\x18\x02\x20\x01(\x05R\x12maximumResoluti\
    onX\x120\n\x14maximum_resolution_y\x18\x03\x20\x01(\x05R\x12maximumResol\
    utionY\x121\n\x13audio_channel_count\x18\x04\x20\x01(\x05:\x012R\x11audi\
    oChannelCount\x12%\n\x0edevice_version\x18\x05\x20\x01(\tR\rdeviceVersio\
    n\x12%\n\x0estream_desktop\x18\x06\x20\x01(\x08R\rstreamDesktop\x12!\n\
    \x0cdevice_token\x18\x07\x20\x01(\x0cR\x0bdeviceToken\x12\x10\n\x03pin\
    \x18\x08\x20\x01(\x0cR\x03pin\x12:\n\x16enable_video_streaming\x18\t\x20\
    \x01(\x08:\x04trueR\x14enableVideoStreaming\x12:\n\x16enable_audio_strea\
    ming\x18\n\x20\x01(\x08:\x04trueR\x14enableAudioStreaming\x12:\n\x16enab\
    le_input_streaming\x18\x0b\x20\x01(\x08:\x04trueR\x14enableInputStreamin\
    g\x12!\n\x0cnetwork_test\x18\x0c\x20\x01(\x08R\x0bnetworkTest\x12\x1b\n\
    \tclient_id\x18\r\x20\x01(\x04R\x08clientId\x12B\n\x13supported_transpor\
    t\x18\x0e\x20\x03(\x0e2\x11.EStreamTransportR\x12supportedTransport\x12\
    \x1e\n\nrestricted\x18\x0f\x20\x01(\x08R\nrestricted\x12[\n\x0bform_fact\
    or\x18\x10\x20\x01(\x0e2\x18.EStreamDeviceFormFactor:\x20k_EStreamDevice\
    FormFactorUnknownR\nformFactor\"G\n&CMsgRemoteDeviceStreamingCancelReque\
    st\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequestId\"\xe1\x02\n!CMsg\
    RemoteDeviceStreamingResponse\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\
    \trequestId\x12V\n\x06result\x18\x02\x20\x02(\x0e2\x1d.ERemoteDeviceStre\
    amingResult:\x1fk_ERemoteDeviceStreamingSuccessR\x06result\x12\x12\n\x04\
    port\x18\x03\x20\x01(\rR\x04port\x122\n\x15encrypted_session_key\x18\x04\
    \x20\x01(\x0cR\x13encryptedSessionKey\x12F\n\ttransport\x18\x06\x20\x01(\
    \x0e2\x11.EStreamTransport:\x15k_EStreamTransportUDPR\ttransport\x12!\n\
    \x0crelay_server\x18\x07\x20\x01(\tR\x0brelayServer\x12\x12\n\x04cert\
    \x18\x08\x20\x01(\tR\x04cert\"<\n\x1cCMsgRemoteDeviceProofRequest\x12\
    \x1c\n\tchallenge\x18\x01\x20\x02(\x0cR\tchallenge\";\n\x1dCMsgRemoteDev\
    iceProofResponse\x12\x1a\n\x08response\x18\x01\x20\x02(\x0cR\x08response\
    \"W\n%CMsgRemoteDeviceStreamTransportSignal\x12\x14\n\x05token\x18\x01\
    \x20\x01(\x0cR\x05token\x12\x18\n\x07payload\x18\x02\x20\x01(\x0cR\x07pa\
    yload*\xac\x04\n\x19ERemoteClientBroadcastMsg\x12(\n$k_ERemoteClientBroa\
    dcastMsgDiscovery\x10\0\x12%\n!k_ERemoteClientBroadcastMsgStatus\x10\x01\
    \x12&\n\"k_ERemoteClientBroadcastMsgOffline\x10\x02\x12'\n#k_ERemoteDevi\
    ceAuthorizationRequest\x10\x03\x12(\n$k_ERemoteDeviceAuthorizationRespon\
    se\x10\x04\x12#\n\x1fk_ERemoteDeviceStreamingRequest\x10\x05\x12$\n\x20k\
    _ERemoteDeviceStreamingResponse\x10\x06\x12\x1f\n\x1bk_ERemoteDeviceProo\
    fRequest\x10\x07\x12\x20\n\x1ck_ERemoteDeviceProofResponse\x10\x08\x12-\
    \n)k_ERemoteDeviceAuthorizationCancelRequest\x10\t\x12)\n%k_ERemoteDevic\
    eStreamingCancelRequest\x10\n\x121\n-k_ERemoteClientBroadcastMsgClientID\
    Deconflict\x10\x0b\x12(\n$k_ERemoteDeviceStreamTransportSignal\x10\x0c*\
    \xd7\x01\n\x14ERemoteClientService\x12\x1e\n\x1ak_ERemoteClientServiceNo\
    ne\x10\0\x12'\n#k_ERemoteClientServiceRemoteControl\x10\x01\x12'\n#k_ERe\
    moteClientServiceGameStreaming\x10\x02\x12%\n!k_ERemoteClientServiceSite\
    License\x10\x04\x12&\n\"k_ERemoteClientServiceContentCache\x10\x08*\x97\
    \x03\n\x20ERemoteDeviceAuthorizationResult\x12'\n#k_ERemoteDeviceAuthori\
    zationSuccess\x10\0\x12&\n\"k_ERemoteDeviceAuthorizationDenied\x10\x01\
    \x12+\n'k_ERemoteDeviceAuthorizationNotLoggedIn\x10\x02\x12'\n#k_ERemote\
    DeviceAuthorizationOffline\x10\x03\x12$\n\x20k_ERemoteDeviceAuthorizatio\
    nBusy\x10\x04\x12*\n&k_ERemoteDeviceAuthorizationInProgress\x10\x05\x12(\
    \n$k_ERemoteDeviceAuthorizationTimedOut\x10\x06\x12&\n\"k_ERemoteDeviceA\
    uthorizationFailed\x10\x07\x12(\n$k_ERemoteDeviceAuthorizationCanceled\
    \x10\x08*\xd0\x01\n\x17EStreamDeviceFormFactor\x12$\n\x20k_EStreamDevice\
    FormFactorUnknown\x10\0\x12\"\n\x1ek_EStreamDeviceFormFactorPhone\x10\
    \x01\x12#\n\x1fk_EStreamDeviceFormFactorTablet\x10\x02\x12%\n!k_EStreamD\
    eviceFormFactorComputer\x10\x03\x12\x1f\n\x1bk_EStreamDeviceFormFactorTV\
    \x10\x04*\xe5\x01\n\x10EStreamTransport\x12\x1a\n\x16k_EStreamTransportN\
    one\x10\0\x12\x19\n\x15k_EStreamTransportUDP\x10\x01\x12\x1e\n\x1ak_EStr\
    eamTransportUDPRelay\x10\x02\x12\x1c\n\x18k_EStreamTransportWebRTC\x10\
    \x03\x12\x19\n\x15k_EStreamTransportSDR\x10\x04\x12\x1d\n\x19k_EStreamTr\
    ansportUDP_SNS\x10\x05\x12\"\n\x1ek_EStreamTransportUDPRelay_SNS\x10\x06\
    *\xda\x04\n\x1cERemoteDeviceStreamingResult\x12#\n\x1fk_ERemoteDeviceStr\
    eamingSuccess\x10\0\x12(\n$k_ERemoteDeviceStreamingUnauthorized\x10\x01\
    \x12(\n$k_ERemoteDeviceStreamingScreenLocked\x10\x02\x12\"\n\x1ek_ERemot\
    eDeviceStreamingFailed\x10\x03\x12\x20\n\x1ck_ERemoteDeviceStreamingBusy\
    \x10\x04\x12&\n\"k_ERemoteDeviceStreamingInProgress\x10\x05\x12$\n\x20k_\
    ERemoteDeviceStreamingCanceled\x10\x06\x12/\n+k_ERemoteDeviceStreamingDr\
    iversNotInstalled\x10\x07\x12$\n\x20k_ERemoteDeviceStreamingDisabled\x10\
    \x08\x12.\n*k_ERemoteDeviceStreamingBroadcastingActive\x10\t\x12$\n\x20k\
    _ERemoteDeviceStreamingVRActive\x10\n\x12'\n#k_ERemoteDeviceStreamingPIN\
    Required\x10\x0b\x120\n,k_ERemoteDeviceStreamingTransportUnavailable\x10\
    \x0c\x12%\n!k_ERemoteDeviceStreamingInvisible\x10\rB\x02H\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
