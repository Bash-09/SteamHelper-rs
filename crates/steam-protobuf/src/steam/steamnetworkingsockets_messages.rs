// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steamnetworkingsockets_messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamDatagramSessionCryptInfo {
    // message fields
    key_type: ::std::option::Option<CMsgSteamDatagramSessionCryptInfo_EKeyType>,
    key_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    nonce: ::std::option::Option<u64>,
    protocol_version: ::std::option::Option<u32>,
    pub ciphers: ::std::vec::Vec<ESteamNetworkingSocketsCipher>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramSessionCryptInfo {
    fn default() -> &'a CMsgSteamDatagramSessionCryptInfo {
        <CMsgSteamDatagramSessionCryptInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramSessionCryptInfo {
    pub fn new() -> CMsgSteamDatagramSessionCryptInfo {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramSessionCryptInfo.EKeyType key_type = 1;


    pub fn get_key_type(&self) -> CMsgSteamDatagramSessionCryptInfo_EKeyType {
        self.key_type.unwrap_or(CMsgSteamDatagramSessionCryptInfo_EKeyType::INVALID)
    }
    pub fn clear_key_type(&mut self) {
        self.key_type = ::std::option::Option::None;
    }

    pub fn has_key_type(&self) -> bool {
        self.key_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_type(&mut self, v: CMsgSteamDatagramSessionCryptInfo_EKeyType) {
        self.key_type = ::std::option::Option::Some(v);
    }

    // optional bytes key_data = 2;


    pub fn get_key_data(&self) -> &[u8] {
        match self.key_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key_data(&mut self) {
        self.key_data.clear();
    }

    pub fn has_key_data(&self) -> bool {
        self.key_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_data.is_none() {
            self.key_data.set_default();
        }
        self.key_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::std::vec::Vec<u8> {
        self.key_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 nonce = 3;


    pub fn get_nonce(&self) -> u64 {
        self.nonce.unwrap_or(0)
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 4;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // repeated .ESteamNetworkingSocketsCipher ciphers = 5;


    pub fn get_ciphers(&self) -> &[ESteamNetworkingSocketsCipher] {
        &self.ciphers
    }
    pub fn clear_ciphers(&mut self) {
        self.ciphers.clear();
    }

    // Param is passed by value, moved
    pub fn set_ciphers(&mut self, v: ::std::vec::Vec<ESteamNetworkingSocketsCipher>) {
        self.ciphers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ciphers(&mut self) -> &mut ::std::vec::Vec<ESteamNetworkingSocketsCipher> {
        &mut self.ciphers
    }

    // Take field
    pub fn take_ciphers(&mut self) -> ::std::vec::Vec<ESteamNetworkingSocketsCipher> {
        ::std::mem::replace(&mut self.ciphers, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramSessionCryptInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.key_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key_data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.nonce = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.ciphers, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.key_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.nonce {
            my_size += 9;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ciphers {
            my_size += ::protobuf::rt::enum_size(5, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.key_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.nonce {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(4, v)?;
        }
        for v in &self.ciphers {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramSessionCryptInfo {
        CMsgSteamDatagramSessionCryptInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgSteamDatagramSessionCryptInfo_EKeyType>>(
                "key_type",
                |m: &CMsgSteamDatagramSessionCryptInfo| { &m.key_type },
                |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.key_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key_data",
                |m: &CMsgSteamDatagramSessionCryptInfo| { &m.key_data },
                |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.key_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "nonce",
                |m: &CMsgSteamDatagramSessionCryptInfo| { &m.nonce },
                |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamDatagramSessionCryptInfo| { &m.protocol_version },
                |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.protocol_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ESteamNetworkingSocketsCipher>>(
                "ciphers",
                |m: &CMsgSteamDatagramSessionCryptInfo| { &m.ciphers },
                |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.ciphers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramSessionCryptInfo>(
                "CMsgSteamDatagramSessionCryptInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramSessionCryptInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramSessionCryptInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramSessionCryptInfo::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramSessionCryptInfo {
    fn clear(&mut self) {
        self.key_type = ::std::option::Option::None;
        self.key_data.clear();
        self.nonce = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.ciphers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramSessionCryptInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramSessionCryptInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum CMsgSteamDatagramSessionCryptInfo_EKeyType {
    INVALID = 0,
    CURVE25519 = 1,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramSessionCryptInfo_EKeyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramSessionCryptInfo_EKeyType> {
        match value {
            0 => ::std::option::Option::Some(CMsgSteamDatagramSessionCryptInfo_EKeyType::INVALID),
            1 => ::std::option::Option::Some(CMsgSteamDatagramSessionCryptInfo_EKeyType::CURVE25519),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramSessionCryptInfo_EKeyType] = &[
            CMsgSteamDatagramSessionCryptInfo_EKeyType::INVALID,
            CMsgSteamDatagramSessionCryptInfo_EKeyType::CURVE25519,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramSessionCryptInfo_EKeyType>("CMsgSteamDatagramSessionCryptInfo.EKeyType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramSessionCryptInfo_EKeyType {
}

impl ::std::default::Default for CMsgSteamDatagramSessionCryptInfo_EKeyType {
    fn default() -> Self {
        CMsgSteamDatagramSessionCryptInfo_EKeyType::INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramSessionCryptInfo_EKeyType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamDatagramSessionCryptInfoSigned {
    // message fields
    info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramSessionCryptInfoSigned {
    fn default() -> &'a CMsgSteamDatagramSessionCryptInfoSigned {
        <CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramSessionCryptInfoSigned {
    pub fn new() -> CMsgSteamDatagramSessionCryptInfoSigned {
        ::std::default::Default::default()
    }

    // optional bytes info = 1;


    pub fn get_info(&self) -> &[u8] {
        match self.info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::vec::Vec<u8> {
        self.info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramSessionCryptInfoSigned {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramSessionCryptInfoSigned {
        CMsgSteamDatagramSessionCryptInfoSigned::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "info",
                |m: &CMsgSteamDatagramSessionCryptInfoSigned| { &m.info },
                |m: &mut CMsgSteamDatagramSessionCryptInfoSigned| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &CMsgSteamDatagramSessionCryptInfoSigned| { &m.signature },
                |m: &mut CMsgSteamDatagramSessionCryptInfoSigned| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramSessionCryptInfoSigned>(
                "CMsgSteamDatagramSessionCryptInfoSigned",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramSessionCryptInfoSigned {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramSessionCryptInfoSigned> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramSessionCryptInfoSigned::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramSessionCryptInfoSigned {
    fn clear(&mut self) {
        self.info.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramSessionCryptInfoSigned {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramSessionCryptInfoSigned {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamDatagramDiagnostic {
    // message fields
    severity: ::std::option::Option<u32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDiagnostic {
    fn default() -> &'a CMsgSteamDatagramDiagnostic {
        <CMsgSteamDatagramDiagnostic as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDiagnostic {
    pub fn new() -> CMsgSteamDatagramDiagnostic {
        ::std::default::Default::default()
    }

    // optional uint32 severity = 1;


    pub fn get_severity(&self) -> u32 {
        self.severity.unwrap_or(0)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: u32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDiagnostic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.severity {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramDiagnostic {
        CMsgSteamDatagramDiagnostic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "severity",
                |m: &CMsgSteamDatagramDiagnostic| { &m.severity },
                |m: &mut CMsgSteamDatagramDiagnostic| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &CMsgSteamDatagramDiagnostic| { &m.text },
                |m: &mut CMsgSteamDatagramDiagnostic| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramDiagnostic>(
                "CMsgSteamDatagramDiagnostic",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramDiagnostic {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramDiagnostic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramDiagnostic::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramDiagnostic {
    fn clear(&mut self) {
        self.severity = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramDiagnostic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDiagnostic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamDatagramLinkInstantaneousStats {
    // message fields
    out_packets_per_sec_x10: ::std::option::Option<u32>,
    out_bytes_per_sec: ::std::option::Option<u32>,
    in_packets_per_sec_x10: ::std::option::Option<u32>,
    in_bytes_per_sec: ::std::option::Option<u32>,
    ping_ms: ::std::option::Option<u32>,
    packets_dropped_pct: ::std::option::Option<u32>,
    packets_weird_sequence_pct: ::std::option::Option<u32>,
    peak_jitter_usec: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLinkInstantaneousStats {
    fn default() -> &'a CMsgSteamDatagramLinkInstantaneousStats {
        <CMsgSteamDatagramLinkInstantaneousStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLinkInstantaneousStats {
    pub fn new() -> CMsgSteamDatagramLinkInstantaneousStats {
        ::std::default::Default::default()
    }

    // optional uint32 out_packets_per_sec_x10 = 1;


    pub fn get_out_packets_per_sec_x10(&self) -> u32 {
        self.out_packets_per_sec_x10.unwrap_or(0)
    }
    pub fn clear_out_packets_per_sec_x10(&mut self) {
        self.out_packets_per_sec_x10 = ::std::option::Option::None;
    }

    pub fn has_out_packets_per_sec_x10(&self) -> bool {
        self.out_packets_per_sec_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_packets_per_sec_x10(&mut self, v: u32) {
        self.out_packets_per_sec_x10 = ::std::option::Option::Some(v);
    }

    // optional uint32 out_bytes_per_sec = 2;


    pub fn get_out_bytes_per_sec(&self) -> u32 {
        self.out_bytes_per_sec.unwrap_or(0)
    }
    pub fn clear_out_bytes_per_sec(&mut self) {
        self.out_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_out_bytes_per_sec(&self) -> bool {
        self.out_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_bytes_per_sec(&mut self, v: u32) {
        self.out_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 in_packets_per_sec_x10 = 3;


    pub fn get_in_packets_per_sec_x10(&self) -> u32 {
        self.in_packets_per_sec_x10.unwrap_or(0)
    }
    pub fn clear_in_packets_per_sec_x10(&mut self) {
        self.in_packets_per_sec_x10 = ::std::option::Option::None;
    }

    pub fn has_in_packets_per_sec_x10(&self) -> bool {
        self.in_packets_per_sec_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_packets_per_sec_x10(&mut self, v: u32) {
        self.in_packets_per_sec_x10 = ::std::option::Option::Some(v);
    }

    // optional uint32 in_bytes_per_sec = 4;


    pub fn get_in_bytes_per_sec(&self) -> u32 {
        self.in_bytes_per_sec.unwrap_or(0)
    }
    pub fn clear_in_bytes_per_sec(&mut self) {
        self.in_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_in_bytes_per_sec(&self) -> bool {
        self.in_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_bytes_per_sec(&mut self, v: u32) {
        self.in_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ms = 5;


    pub fn get_ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }
    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 packets_dropped_pct = 6;


    pub fn get_packets_dropped_pct(&self) -> u32 {
        self.packets_dropped_pct.unwrap_or(0)
    }
    pub fn clear_packets_dropped_pct(&mut self) {
        self.packets_dropped_pct = ::std::option::Option::None;
    }

    pub fn has_packets_dropped_pct(&self) -> bool {
        self.packets_dropped_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_dropped_pct(&mut self, v: u32) {
        self.packets_dropped_pct = ::std::option::Option::Some(v);
    }

    // optional uint32 packets_weird_sequence_pct = 7;


    pub fn get_packets_weird_sequence_pct(&self) -> u32 {
        self.packets_weird_sequence_pct.unwrap_or(0)
    }
    pub fn clear_packets_weird_sequence_pct(&mut self) {
        self.packets_weird_sequence_pct = ::std::option::Option::None;
    }

    pub fn has_packets_weird_sequence_pct(&self) -> bool {
        self.packets_weird_sequence_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_weird_sequence_pct(&mut self, v: u32) {
        self.packets_weird_sequence_pct = ::std::option::Option::Some(v);
    }

    // optional uint32 peak_jitter_usec = 8;


    pub fn get_peak_jitter_usec(&self) -> u32 {
        self.peak_jitter_usec.unwrap_or(0)
    }
    pub fn clear_peak_jitter_usec(&mut self) {
        self.peak_jitter_usec = ::std::option::Option::None;
    }

    pub fn has_peak_jitter_usec(&self) -> bool {
        self.peak_jitter_usec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peak_jitter_usec(&mut self, v: u32) {
        self.peak_jitter_usec = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramLinkInstantaneousStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.out_packets_per_sec_x10 = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.out_bytes_per_sec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.in_packets_per_sec_x10 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.in_bytes_per_sec = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ms = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packets_dropped_pct = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packets_weird_sequence_pct = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peak_jitter_usec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.out_packets_per_sec_x10 {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.out_bytes_per_sec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_packets_per_sec_x10 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_bytes_per_sec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ms {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_dropped_pct {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_weird_sequence_pct {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.peak_jitter_usec {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.out_packets_per_sec_x10 {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.out_bytes_per_sec {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.in_packets_per_sec_x10 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_bytes_per_sec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.packets_dropped_pct {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.packets_weird_sequence_pct {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.peak_jitter_usec {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramLinkInstantaneousStats {
        CMsgSteamDatagramLinkInstantaneousStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "out_packets_per_sec_x10",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.out_packets_per_sec_x10 },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.out_packets_per_sec_x10 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "out_bytes_per_sec",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.out_bytes_per_sec },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.out_bytes_per_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "in_packets_per_sec_x10",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.in_packets_per_sec_x10 },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.in_packets_per_sec_x10 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "in_bytes_per_sec",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.in_bytes_per_sec },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.in_bytes_per_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ms",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.ping_ms },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packets_dropped_pct",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.packets_dropped_pct },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.packets_dropped_pct },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packets_weird_sequence_pct",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.packets_weird_sequence_pct },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.packets_weird_sequence_pct },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "peak_jitter_usec",
                |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.peak_jitter_usec },
                |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.peak_jitter_usec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramLinkInstantaneousStats>(
                "CMsgSteamDatagramLinkInstantaneousStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramLinkInstantaneousStats {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramLinkInstantaneousStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramLinkInstantaneousStats::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramLinkInstantaneousStats {
    fn clear(&mut self) {
        self.out_packets_per_sec_x10 = ::std::option::Option::None;
        self.out_bytes_per_sec = ::std::option::Option::None;
        self.in_packets_per_sec_x10 = ::std::option::Option::None;
        self.in_bytes_per_sec = ::std::option::Option::None;
        self.ping_ms = ::std::option::Option::None;
        self.packets_dropped_pct = ::std::option::Option::None;
        self.packets_weird_sequence_pct = ::std::option::Option::None;
        self.peak_jitter_usec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramLinkInstantaneousStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramLinkInstantaneousStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamDatagramLinkLifetimeStats {
    // message fields
    connected_seconds: ::std::option::Option<u32>,
    packets_sent: ::std::option::Option<u64>,
    kb_sent: ::std::option::Option<u64>,
    packets_recv: ::std::option::Option<u64>,
    kb_recv: ::std::option::Option<u64>,
    packets_recv_sequenced: ::std::option::Option<u64>,
    packets_recv_dropped: ::std::option::Option<u64>,
    packets_recv_out_of_order: ::std::option::Option<u64>,
    packets_recv_duplicate: ::std::option::Option<u64>,
    packets_recv_lurch: ::std::option::Option<u64>,
    quality_histogram_100: ::std::option::Option<u32>,
    quality_histogram_99: ::std::option::Option<u32>,
    quality_histogram_97: ::std::option::Option<u32>,
    quality_histogram_95: ::std::option::Option<u32>,
    quality_histogram_90: ::std::option::Option<u32>,
    quality_histogram_75: ::std::option::Option<u32>,
    quality_histogram_50: ::std::option::Option<u32>,
    quality_histogram_1: ::std::option::Option<u32>,
    quality_histogram_dead: ::std::option::Option<u32>,
    quality_ntile_2nd: ::std::option::Option<u32>,
    quality_ntile_5th: ::std::option::Option<u32>,
    quality_ntile_25th: ::std::option::Option<u32>,
    quality_ntile_50th: ::std::option::Option<u32>,
    ping_histogram_25: ::std::option::Option<u32>,
    ping_histogram_50: ::std::option::Option<u32>,
    ping_histogram_75: ::std::option::Option<u32>,
    ping_histogram_100: ::std::option::Option<u32>,
    ping_histogram_125: ::std::option::Option<u32>,
    ping_histogram_150: ::std::option::Option<u32>,
    ping_histogram_200: ::std::option::Option<u32>,
    ping_histogram_300: ::std::option::Option<u32>,
    ping_histogram_max: ::std::option::Option<u32>,
    ping_ntile_5th: ::std::option::Option<u32>,
    ping_ntile_50th: ::std::option::Option<u32>,
    ping_ntile_75th: ::std::option::Option<u32>,
    ping_ntile_95th: ::std::option::Option<u32>,
    ping_ntile_98th: ::std::option::Option<u32>,
    jitter_histogram_negligible: ::std::option::Option<u32>,
    jitter_histogram_1: ::std::option::Option<u32>,
    jitter_histogram_2: ::std::option::Option<u32>,
    jitter_histogram_5: ::std::option::Option<u32>,
    jitter_histogram_10: ::std::option::Option<u32>,
    jitter_histogram_20: ::std::option::Option<u32>,
    txspeed_max: ::std::option::Option<u32>,
    txspeed_histogram_16: ::std::option::Option<u32>,
    txspeed_histogram_32: ::std::option::Option<u32>,
    txspeed_histogram_64: ::std::option::Option<u32>,
    txspeed_histogram_128: ::std::option::Option<u32>,
    txspeed_histogram_256: ::std::option::Option<u32>,
    txspeed_histogram_512: ::std::option::Option<u32>,
    txspeed_histogram_1024: ::std::option::Option<u32>,
    txspeed_histogram_max: ::std::option::Option<u32>,
    txspeed_ntile_5th: ::std::option::Option<u32>,
    txspeed_ntile_50th: ::std::option::Option<u32>,
    txspeed_ntile_75th: ::std::option::Option<u32>,
    txspeed_ntile_95th: ::std::option::Option<u32>,
    txspeed_ntile_98th: ::std::option::Option<u32>,
    rxspeed_max: ::std::option::Option<u32>,
    rxspeed_histogram_16: ::std::option::Option<u32>,
    rxspeed_histogram_32: ::std::option::Option<u32>,
    rxspeed_histogram_64: ::std::option::Option<u32>,
    rxspeed_histogram_128: ::std::option::Option<u32>,
    rxspeed_histogram_256: ::std::option::Option<u32>,
    rxspeed_histogram_512: ::std::option::Option<u32>,
    rxspeed_histogram_1024: ::std::option::Option<u32>,
    rxspeed_histogram_max: ::std::option::Option<u32>,
    rxspeed_ntile_5th: ::std::option::Option<u32>,
    rxspeed_ntile_50th: ::std::option::Option<u32>,
    rxspeed_ntile_75th: ::std::option::Option<u32>,
    rxspeed_ntile_95th: ::std::option::Option<u32>,
    rxspeed_ntile_98th: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLinkLifetimeStats {
    fn default() -> &'a CMsgSteamDatagramLinkLifetimeStats {
        <CMsgSteamDatagramLinkLifetimeStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLinkLifetimeStats {
    pub fn new() -> CMsgSteamDatagramLinkLifetimeStats {
        ::std::default::Default::default()
    }

    // optional uint32 connected_seconds = 2;


    pub fn get_connected_seconds(&self) -> u32 {
        self.connected_seconds.unwrap_or(0)
    }
    pub fn clear_connected_seconds(&mut self) {
        self.connected_seconds = ::std::option::Option::None;
    }

    pub fn has_connected_seconds(&self) -> bool {
        self.connected_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connected_seconds(&mut self, v: u32) {
        self.connected_seconds = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_sent = 3;


    pub fn get_packets_sent(&self) -> u64 {
        self.packets_sent.unwrap_or(0)
    }
    pub fn clear_packets_sent(&mut self) {
        self.packets_sent = ::std::option::Option::None;
    }

    pub fn has_packets_sent(&self) -> bool {
        self.packets_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_sent(&mut self, v: u64) {
        self.packets_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 kb_sent = 4;


    pub fn get_kb_sent(&self) -> u64 {
        self.kb_sent.unwrap_or(0)
    }
    pub fn clear_kb_sent(&mut self) {
        self.kb_sent = ::std::option::Option::None;
    }

    pub fn has_kb_sent(&self) -> bool {
        self.kb_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kb_sent(&mut self, v: u64) {
        self.kb_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv = 5;


    pub fn get_packets_recv(&self) -> u64 {
        self.packets_recv.unwrap_or(0)
    }
    pub fn clear_packets_recv(&mut self) {
        self.packets_recv = ::std::option::Option::None;
    }

    pub fn has_packets_recv(&self) -> bool {
        self.packets_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv(&mut self, v: u64) {
        self.packets_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 kb_recv = 6;


    pub fn get_kb_recv(&self) -> u64 {
        self.kb_recv.unwrap_or(0)
    }
    pub fn clear_kb_recv(&mut self) {
        self.kb_recv = ::std::option::Option::None;
    }

    pub fn has_kb_recv(&self) -> bool {
        self.kb_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kb_recv(&mut self, v: u64) {
        self.kb_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_sequenced = 7;


    pub fn get_packets_recv_sequenced(&self) -> u64 {
        self.packets_recv_sequenced.unwrap_or(0)
    }
    pub fn clear_packets_recv_sequenced(&mut self) {
        self.packets_recv_sequenced = ::std::option::Option::None;
    }

    pub fn has_packets_recv_sequenced(&self) -> bool {
        self.packets_recv_sequenced.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_sequenced(&mut self, v: u64) {
        self.packets_recv_sequenced = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_dropped = 8;


    pub fn get_packets_recv_dropped(&self) -> u64 {
        self.packets_recv_dropped.unwrap_or(0)
    }
    pub fn clear_packets_recv_dropped(&mut self) {
        self.packets_recv_dropped = ::std::option::Option::None;
    }

    pub fn has_packets_recv_dropped(&self) -> bool {
        self.packets_recv_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_dropped(&mut self, v: u64) {
        self.packets_recv_dropped = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_out_of_order = 9;


    pub fn get_packets_recv_out_of_order(&self) -> u64 {
        self.packets_recv_out_of_order.unwrap_or(0)
    }
    pub fn clear_packets_recv_out_of_order(&mut self) {
        self.packets_recv_out_of_order = ::std::option::Option::None;
    }

    pub fn has_packets_recv_out_of_order(&self) -> bool {
        self.packets_recv_out_of_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_out_of_order(&mut self, v: u64) {
        self.packets_recv_out_of_order = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_duplicate = 10;


    pub fn get_packets_recv_duplicate(&self) -> u64 {
        self.packets_recv_duplicate.unwrap_or(0)
    }
    pub fn clear_packets_recv_duplicate(&mut self) {
        self.packets_recv_duplicate = ::std::option::Option::None;
    }

    pub fn has_packets_recv_duplicate(&self) -> bool {
        self.packets_recv_duplicate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_duplicate(&mut self, v: u64) {
        self.packets_recv_duplicate = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_lurch = 11;


    pub fn get_packets_recv_lurch(&self) -> u64 {
        self.packets_recv_lurch.unwrap_or(0)
    }
    pub fn clear_packets_recv_lurch(&mut self) {
        self.packets_recv_lurch = ::std::option::Option::None;
    }

    pub fn has_packets_recv_lurch(&self) -> bool {
        self.packets_recv_lurch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_lurch(&mut self, v: u64) {
        self.packets_recv_lurch = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_100 = 21;


    pub fn get_quality_histogram_100(&self) -> u32 {
        self.quality_histogram_100.unwrap_or(0)
    }
    pub fn clear_quality_histogram_100(&mut self) {
        self.quality_histogram_100 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_100(&self) -> bool {
        self.quality_histogram_100.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_100(&mut self, v: u32) {
        self.quality_histogram_100 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_99 = 22;


    pub fn get_quality_histogram_99(&self) -> u32 {
        self.quality_histogram_99.unwrap_or(0)
    }
    pub fn clear_quality_histogram_99(&mut self) {
        self.quality_histogram_99 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_99(&self) -> bool {
        self.quality_histogram_99.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_99(&mut self, v: u32) {
        self.quality_histogram_99 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_97 = 23;


    pub fn get_quality_histogram_97(&self) -> u32 {
        self.quality_histogram_97.unwrap_or(0)
    }
    pub fn clear_quality_histogram_97(&mut self) {
        self.quality_histogram_97 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_97(&self) -> bool {
        self.quality_histogram_97.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_97(&mut self, v: u32) {
        self.quality_histogram_97 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_95 = 24;


    pub fn get_quality_histogram_95(&self) -> u32 {
        self.quality_histogram_95.unwrap_or(0)
    }
    pub fn clear_quality_histogram_95(&mut self) {
        self.quality_histogram_95 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_95(&self) -> bool {
        self.quality_histogram_95.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_95(&mut self, v: u32) {
        self.quality_histogram_95 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_90 = 25;


    pub fn get_quality_histogram_90(&self) -> u32 {
        self.quality_histogram_90.unwrap_or(0)
    }
    pub fn clear_quality_histogram_90(&mut self) {
        self.quality_histogram_90 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_90(&self) -> bool {
        self.quality_histogram_90.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_90(&mut self, v: u32) {
        self.quality_histogram_90 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_75 = 26;


    pub fn get_quality_histogram_75(&self) -> u32 {
        self.quality_histogram_75.unwrap_or(0)
    }
    pub fn clear_quality_histogram_75(&mut self) {
        self.quality_histogram_75 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_75(&self) -> bool {
        self.quality_histogram_75.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_75(&mut self, v: u32) {
        self.quality_histogram_75 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_50 = 27;


    pub fn get_quality_histogram_50(&self) -> u32 {
        self.quality_histogram_50.unwrap_or(0)
    }
    pub fn clear_quality_histogram_50(&mut self) {
        self.quality_histogram_50 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_50(&self) -> bool {
        self.quality_histogram_50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_50(&mut self, v: u32) {
        self.quality_histogram_50 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_1 = 28;


    pub fn get_quality_histogram_1(&self) -> u32 {
        self.quality_histogram_1.unwrap_or(0)
    }
    pub fn clear_quality_histogram_1(&mut self) {
        self.quality_histogram_1 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_1(&self) -> bool {
        self.quality_histogram_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_1(&mut self, v: u32) {
        self.quality_histogram_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_dead = 29;


    pub fn get_quality_histogram_dead(&self) -> u32 {
        self.quality_histogram_dead.unwrap_or(0)
    }
    pub fn clear_quality_histogram_dead(&mut self) {
        self.quality_histogram_dead = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_dead(&self) -> bool {
        self.quality_histogram_dead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_dead(&mut self, v: u32) {
        self.quality_histogram_dead = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_2nd = 30;


    pub fn get_quality_ntile_2nd(&self) -> u32 {
        self.quality_ntile_2nd.unwrap_or(0)
    }
    pub fn clear_quality_ntile_2nd(&mut self) {
        self.quality_ntile_2nd = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_2nd(&self) -> bool {
        self.quality_ntile_2nd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_2nd(&mut self, v: u32) {
        self.quality_ntile_2nd = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_5th = 31;


    pub fn get_quality_ntile_5th(&self) -> u32 {
        self.quality_ntile_5th.unwrap_or(0)
    }
    pub fn clear_quality_ntile_5th(&mut self) {
        self.quality_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_5th(&self) -> bool {
        self.quality_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_5th(&mut self, v: u32) {
        self.quality_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_25th = 32;


    pub fn get_quality_ntile_25th(&self) -> u32 {
        self.quality_ntile_25th.unwrap_or(0)
    }
    pub fn clear_quality_ntile_25th(&mut self) {
        self.quality_ntile_25th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_25th(&self) -> bool {
        self.quality_ntile_25th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_25th(&mut self, v: u32) {
        self.quality_ntile_25th = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_50th = 33;


    pub fn get_quality_ntile_50th(&self) -> u32 {
        self.quality_ntile_50th.unwrap_or(0)
    }
    pub fn clear_quality_ntile_50th(&mut self) {
        self.quality_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_50th(&self) -> bool {
        self.quality_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_50th(&mut self, v: u32) {
        self.quality_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_25 = 41;


    pub fn get_ping_histogram_25(&self) -> u32 {
        self.ping_histogram_25.unwrap_or(0)
    }
    pub fn clear_ping_histogram_25(&mut self) {
        self.ping_histogram_25 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_25(&self) -> bool {
        self.ping_histogram_25.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_25(&mut self, v: u32) {
        self.ping_histogram_25 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_50 = 42;


    pub fn get_ping_histogram_50(&self) -> u32 {
        self.ping_histogram_50.unwrap_or(0)
    }
    pub fn clear_ping_histogram_50(&mut self) {
        self.ping_histogram_50 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_50(&self) -> bool {
        self.ping_histogram_50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_50(&mut self, v: u32) {
        self.ping_histogram_50 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_75 = 43;


    pub fn get_ping_histogram_75(&self) -> u32 {
        self.ping_histogram_75.unwrap_or(0)
    }
    pub fn clear_ping_histogram_75(&mut self) {
        self.ping_histogram_75 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_75(&self) -> bool {
        self.ping_histogram_75.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_75(&mut self, v: u32) {
        self.ping_histogram_75 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_100 = 44;


    pub fn get_ping_histogram_100(&self) -> u32 {
        self.ping_histogram_100.unwrap_or(0)
    }
    pub fn clear_ping_histogram_100(&mut self) {
        self.ping_histogram_100 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_100(&self) -> bool {
        self.ping_histogram_100.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_100(&mut self, v: u32) {
        self.ping_histogram_100 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_125 = 45;


    pub fn get_ping_histogram_125(&self) -> u32 {
        self.ping_histogram_125.unwrap_or(0)
    }
    pub fn clear_ping_histogram_125(&mut self) {
        self.ping_histogram_125 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_125(&self) -> bool {
        self.ping_histogram_125.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_125(&mut self, v: u32) {
        self.ping_histogram_125 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_150 = 46;


    pub fn get_ping_histogram_150(&self) -> u32 {
        self.ping_histogram_150.unwrap_or(0)
    }
    pub fn clear_ping_histogram_150(&mut self) {
        self.ping_histogram_150 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_150(&self) -> bool {
        self.ping_histogram_150.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_150(&mut self, v: u32) {
        self.ping_histogram_150 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_200 = 47;


    pub fn get_ping_histogram_200(&self) -> u32 {
        self.ping_histogram_200.unwrap_or(0)
    }
    pub fn clear_ping_histogram_200(&mut self) {
        self.ping_histogram_200 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_200(&self) -> bool {
        self.ping_histogram_200.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_200(&mut self, v: u32) {
        self.ping_histogram_200 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_300 = 48;


    pub fn get_ping_histogram_300(&self) -> u32 {
        self.ping_histogram_300.unwrap_or(0)
    }
    pub fn clear_ping_histogram_300(&mut self) {
        self.ping_histogram_300 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_300(&self) -> bool {
        self.ping_histogram_300.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_300(&mut self, v: u32) {
        self.ping_histogram_300 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_max = 49;


    pub fn get_ping_histogram_max(&self) -> u32 {
        self.ping_histogram_max.unwrap_or(0)
    }
    pub fn clear_ping_histogram_max(&mut self) {
        self.ping_histogram_max = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_max(&self) -> bool {
        self.ping_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_max(&mut self, v: u32) {
        self.ping_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_5th = 50;


    pub fn get_ping_ntile_5th(&self) -> u32 {
        self.ping_ntile_5th.unwrap_or(0)
    }
    pub fn clear_ping_ntile_5th(&mut self) {
        self.ping_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_5th(&self) -> bool {
        self.ping_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_5th(&mut self, v: u32) {
        self.ping_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_50th = 51;


    pub fn get_ping_ntile_50th(&self) -> u32 {
        self.ping_ntile_50th.unwrap_or(0)
    }
    pub fn clear_ping_ntile_50th(&mut self) {
        self.ping_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_50th(&self) -> bool {
        self.ping_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_50th(&mut self, v: u32) {
        self.ping_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_75th = 52;


    pub fn get_ping_ntile_75th(&self) -> u32 {
        self.ping_ntile_75th.unwrap_or(0)
    }
    pub fn clear_ping_ntile_75th(&mut self) {
        self.ping_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_75th(&self) -> bool {
        self.ping_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_75th(&mut self, v: u32) {
        self.ping_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_95th = 53;


    pub fn get_ping_ntile_95th(&self) -> u32 {
        self.ping_ntile_95th.unwrap_or(0)
    }
    pub fn clear_ping_ntile_95th(&mut self) {
        self.ping_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_95th(&self) -> bool {
        self.ping_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_95th(&mut self, v: u32) {
        self.ping_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_98th = 54;


    pub fn get_ping_ntile_98th(&self) -> u32 {
        self.ping_ntile_98th.unwrap_or(0)
    }
    pub fn clear_ping_ntile_98th(&mut self) {
        self.ping_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_98th(&self) -> bool {
        self.ping_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_98th(&mut self, v: u32) {
        self.ping_ntile_98th = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_negligible = 61;


    pub fn get_jitter_histogram_negligible(&self) -> u32 {
        self.jitter_histogram_negligible.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_negligible(&mut self) {
        self.jitter_histogram_negligible = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_negligible(&self) -> bool {
        self.jitter_histogram_negligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_negligible(&mut self, v: u32) {
        self.jitter_histogram_negligible = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_1 = 62;


    pub fn get_jitter_histogram_1(&self) -> u32 {
        self.jitter_histogram_1.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_1(&mut self) {
        self.jitter_histogram_1 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_1(&self) -> bool {
        self.jitter_histogram_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_1(&mut self, v: u32) {
        self.jitter_histogram_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_2 = 63;


    pub fn get_jitter_histogram_2(&self) -> u32 {
        self.jitter_histogram_2.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_2(&mut self) {
        self.jitter_histogram_2 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_2(&self) -> bool {
        self.jitter_histogram_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_2(&mut self, v: u32) {
        self.jitter_histogram_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_5 = 64;


    pub fn get_jitter_histogram_5(&self) -> u32 {
        self.jitter_histogram_5.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_5(&mut self) {
        self.jitter_histogram_5 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_5(&self) -> bool {
        self.jitter_histogram_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_5(&mut self, v: u32) {
        self.jitter_histogram_5 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_10 = 65;


    pub fn get_jitter_histogram_10(&self) -> u32 {
        self.jitter_histogram_10.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_10(&mut self) {
        self.jitter_histogram_10 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_10(&self) -> bool {
        self.jitter_histogram_10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_10(&mut self, v: u32) {
        self.jitter_histogram_10 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_20 = 66;


    pub fn get_jitter_histogram_20(&self) -> u32 {
        self.jitter_histogram_20.unwrap_or(0)
    }
    pub fn clear_jitter_histogram_20(&mut self) {
        self.jitter_histogram_20 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_20(&self) -> bool {
        self.jitter_histogram_20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_20(&mut self, v: u32) {
        self.jitter_histogram_20 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_max = 67;


    pub fn get_txspeed_max(&self) -> u32 {
        self.txspeed_max.unwrap_or(0)
    }
    pub fn clear_txspeed_max(&mut self) {
        self.txspeed_max = ::std::option::Option::None;
    }

    pub fn has_txspeed_max(&self) -> bool {
        self.txspeed_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_max(&mut self, v: u32) {
        self.txspeed_max = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_16 = 68;


    pub fn get_txspeed_histogram_16(&self) -> u32 {
        self.txspeed_histogram_16.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_16(&mut self) {
        self.txspeed_histogram_16 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_16(&self) -> bool {
        self.txspeed_histogram_16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_16(&mut self, v: u32) {
        self.txspeed_histogram_16 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_32 = 69;


    pub fn get_txspeed_histogram_32(&self) -> u32 {
        self.txspeed_histogram_32.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_32(&mut self) {
        self.txspeed_histogram_32 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_32(&self) -> bool {
        self.txspeed_histogram_32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_32(&mut self, v: u32) {
        self.txspeed_histogram_32 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_64 = 70;


    pub fn get_txspeed_histogram_64(&self) -> u32 {
        self.txspeed_histogram_64.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_64(&mut self) {
        self.txspeed_histogram_64 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_64(&self) -> bool {
        self.txspeed_histogram_64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_64(&mut self, v: u32) {
        self.txspeed_histogram_64 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_128 = 71;


    pub fn get_txspeed_histogram_128(&self) -> u32 {
        self.txspeed_histogram_128.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_128(&mut self) {
        self.txspeed_histogram_128 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_128(&self) -> bool {
        self.txspeed_histogram_128.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_128(&mut self, v: u32) {
        self.txspeed_histogram_128 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_256 = 72;


    pub fn get_txspeed_histogram_256(&self) -> u32 {
        self.txspeed_histogram_256.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_256(&mut self) {
        self.txspeed_histogram_256 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_256(&self) -> bool {
        self.txspeed_histogram_256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_256(&mut self, v: u32) {
        self.txspeed_histogram_256 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_512 = 73;


    pub fn get_txspeed_histogram_512(&self) -> u32 {
        self.txspeed_histogram_512.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_512(&mut self) {
        self.txspeed_histogram_512 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_512(&self) -> bool {
        self.txspeed_histogram_512.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_512(&mut self, v: u32) {
        self.txspeed_histogram_512 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_1024 = 74;


    pub fn get_txspeed_histogram_1024(&self) -> u32 {
        self.txspeed_histogram_1024.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_1024(&mut self) {
        self.txspeed_histogram_1024 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_1024(&self) -> bool {
        self.txspeed_histogram_1024.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_1024(&mut self, v: u32) {
        self.txspeed_histogram_1024 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_max = 75;


    pub fn get_txspeed_histogram_max(&self) -> u32 {
        self.txspeed_histogram_max.unwrap_or(0)
    }
    pub fn clear_txspeed_histogram_max(&mut self) {
        self.txspeed_histogram_max = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_max(&self) -> bool {
        self.txspeed_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_max(&mut self, v: u32) {
        self.txspeed_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_5th = 76;


    pub fn get_txspeed_ntile_5th(&self) -> u32 {
        self.txspeed_ntile_5th.unwrap_or(0)
    }
    pub fn clear_txspeed_ntile_5th(&mut self) {
        self.txspeed_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_5th(&self) -> bool {
        self.txspeed_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_5th(&mut self, v: u32) {
        self.txspeed_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_50th = 77;


    pub fn get_txspeed_ntile_50th(&self) -> u32 {
        self.txspeed_ntile_50th.unwrap_or(0)
    }
    pub fn clear_txspeed_ntile_50th(&mut self) {
        self.txspeed_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_50th(&self) -> bool {
        self.txspeed_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_50th(&mut self, v: u32) {
        self.txspeed_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_75th = 78;


    pub fn get_txspeed_ntile_75th(&self) -> u32 {
        self.txspeed_ntile_75th.unwrap_or(0)
    }
    pub fn clear_txspeed_ntile_75th(&mut self) {
        self.txspeed_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_75th(&self) -> bool {
        self.txspeed_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_75th(&mut self, v: u32) {
        self.txspeed_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_95th = 79;


    pub fn get_txspeed_ntile_95th(&self) -> u32 {
        self.txspeed_ntile_95th.unwrap_or(0)
    }
    pub fn clear_txspeed_ntile_95th(&mut self) {
        self.txspeed_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_95th(&self) -> bool {
        self.txspeed_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_95th(&mut self, v: u32) {
        self.txspeed_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_98th = 80;


    pub fn get_txspeed_ntile_98th(&self) -> u32 {
        self.txspeed_ntile_98th.unwrap_or(0)
    }
    pub fn clear_txspeed_ntile_98th(&mut self) {
        self.txspeed_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_98th(&self) -> bool {
        self.txspeed_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_98th(&mut self, v: u32) {
        self.txspeed_ntile_98th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_max = 81;


    pub fn get_rxspeed_max(&self) -> u32 {
        self.rxspeed_max.unwrap_or(0)
    }
    pub fn clear_rxspeed_max(&mut self) {
        self.rxspeed_max = ::std::option::Option::None;
    }

    pub fn has_rxspeed_max(&self) -> bool {
        self.rxspeed_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_max(&mut self, v: u32) {
        self.rxspeed_max = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_16 = 82;


    pub fn get_rxspeed_histogram_16(&self) -> u32 {
        self.rxspeed_histogram_16.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_16(&mut self) {
        self.rxspeed_histogram_16 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_16(&self) -> bool {
        self.rxspeed_histogram_16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_16(&mut self, v: u32) {
        self.rxspeed_histogram_16 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_32 = 83;


    pub fn get_rxspeed_histogram_32(&self) -> u32 {
        self.rxspeed_histogram_32.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_32(&mut self) {
        self.rxspeed_histogram_32 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_32(&self) -> bool {
        self.rxspeed_histogram_32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_32(&mut self, v: u32) {
        self.rxspeed_histogram_32 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_64 = 84;


    pub fn get_rxspeed_histogram_64(&self) -> u32 {
        self.rxspeed_histogram_64.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_64(&mut self) {
        self.rxspeed_histogram_64 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_64(&self) -> bool {
        self.rxspeed_histogram_64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_64(&mut self, v: u32) {
        self.rxspeed_histogram_64 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_128 = 85;


    pub fn get_rxspeed_histogram_128(&self) -> u32 {
        self.rxspeed_histogram_128.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_128(&mut self) {
        self.rxspeed_histogram_128 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_128(&self) -> bool {
        self.rxspeed_histogram_128.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_128(&mut self, v: u32) {
        self.rxspeed_histogram_128 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_256 = 86;


    pub fn get_rxspeed_histogram_256(&self) -> u32 {
        self.rxspeed_histogram_256.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_256(&mut self) {
        self.rxspeed_histogram_256 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_256(&self) -> bool {
        self.rxspeed_histogram_256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_256(&mut self, v: u32) {
        self.rxspeed_histogram_256 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_512 = 87;


    pub fn get_rxspeed_histogram_512(&self) -> u32 {
        self.rxspeed_histogram_512.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_512(&mut self) {
        self.rxspeed_histogram_512 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_512(&self) -> bool {
        self.rxspeed_histogram_512.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_512(&mut self, v: u32) {
        self.rxspeed_histogram_512 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_1024 = 88;


    pub fn get_rxspeed_histogram_1024(&self) -> u32 {
        self.rxspeed_histogram_1024.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_1024(&mut self) {
        self.rxspeed_histogram_1024 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_1024(&self) -> bool {
        self.rxspeed_histogram_1024.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_1024(&mut self, v: u32) {
        self.rxspeed_histogram_1024 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_max = 89;


    pub fn get_rxspeed_histogram_max(&self) -> u32 {
        self.rxspeed_histogram_max.unwrap_or(0)
    }
    pub fn clear_rxspeed_histogram_max(&mut self) {
        self.rxspeed_histogram_max = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_max(&self) -> bool {
        self.rxspeed_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_max(&mut self, v: u32) {
        self.rxspeed_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_5th = 90;


    pub fn get_rxspeed_ntile_5th(&self) -> u32 {
        self.rxspeed_ntile_5th.unwrap_or(0)
    }
    pub fn clear_rxspeed_ntile_5th(&mut self) {
        self.rxspeed_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_5th(&self) -> bool {
        self.rxspeed_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_5th(&mut self, v: u32) {
        self.rxspeed_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_50th = 91;


    pub fn get_rxspeed_ntile_50th(&self) -> u32 {
        self.rxspeed_ntile_50th.unwrap_or(0)
    }
    pub fn clear_rxspeed_ntile_50th(&mut self) {
        self.rxspeed_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_50th(&self) -> bool {
        self.rxspeed_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_50th(&mut self, v: u32) {
        self.rxspeed_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_75th = 92;


    pub fn get_rxspeed_ntile_75th(&self) -> u32 {
        self.rxspeed_ntile_75th.unwrap_or(0)
    }
    pub fn clear_rxspeed_ntile_75th(&mut self) {
        self.rxspeed_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_75th(&self) -> bool {
        self.rxspeed_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_75th(&mut self, v: u32) {
        self.rxspeed_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_95th = 93;


    pub fn get_rxspeed_ntile_95th(&self) -> u32 {
        self.rxspeed_ntile_95th.unwrap_or(0)
    }
    pub fn clear_rxspeed_ntile_95th(&mut self) {
        self.rxspeed_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_95th(&self) -> bool {
        self.rxspeed_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_95th(&mut self, v: u32) {
        self.rxspeed_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_98th = 94;


    pub fn get_rxspeed_ntile_98th(&self) -> u32 {
        self.rxspeed_ntile_98th.unwrap_or(0)
    }
    pub fn clear_rxspeed_ntile_98th(&mut self) {
        self.rxspeed_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_98th(&self) -> bool {
        self.rxspeed_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_98th(&mut self, v: u32) {
        self.rxspeed_ntile_98th = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramLinkLifetimeStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.connected_seconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_sent = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.kb_sent = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.kb_recv = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv_sequenced = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv_dropped = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv_out_of_order = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv_duplicate = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packets_recv_lurch = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_100 = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_99 = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_97 = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_95 = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_90 = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_75 = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_50 = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_1 = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_histogram_dead = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_ntile_2nd = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_ntile_5th = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_ntile_25th = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality_ntile_50th = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_25 = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_50 = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_75 = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_100 = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_125 = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_150 = ::std::option::Option::Some(tmp);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_200 = ::std::option::Option::Some(tmp);
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_300 = ::std::option::Option::Some(tmp);
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_histogram_max = ::std::option::Option::Some(tmp);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ntile_5th = ::std::option::Option::Some(tmp);
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ntile_50th = ::std::option::Option::Some(tmp);
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ntile_75th = ::std::option::Option::Some(tmp);
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ntile_95th = ::std::option::Option::Some(tmp);
                },
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ntile_98th = ::std::option::Option::Some(tmp);
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_negligible = ::std::option::Option::Some(tmp);
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_1 = ::std::option::Option::Some(tmp);
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_2 = ::std::option::Option::Some(tmp);
                },
                64 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_5 = ::std::option::Option::Some(tmp);
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_10 = ::std::option::Option::Some(tmp);
                },
                66 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jitter_histogram_20 = ::std::option::Option::Some(tmp);
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_max = ::std::option::Option::Some(tmp);
                },
                68 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_16 = ::std::option::Option::Some(tmp);
                },
                69 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_32 = ::std::option::Option::Some(tmp);
                },
                70 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_64 = ::std::option::Option::Some(tmp);
                },
                71 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_128 = ::std::option::Option::Some(tmp);
                },
                72 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_256 = ::std::option::Option::Some(tmp);
                },
                73 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_512 = ::std::option::Option::Some(tmp);
                },
                74 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_1024 = ::std::option::Option::Some(tmp);
                },
                75 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_histogram_max = ::std::option::Option::Some(tmp);
                },
                76 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_ntile_5th = ::std::option::Option::Some(tmp);
                },
                77 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_ntile_50th = ::std::option::Option::Some(tmp);
                },
                78 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_ntile_75th = ::std::option::Option::Some(tmp);
                },
                79 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_ntile_95th = ::std::option::Option::Some(tmp);
                },
                80 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txspeed_ntile_98th = ::std::option::Option::Some(tmp);
                },
                81 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_max = ::std::option::Option::Some(tmp);
                },
                82 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_16 = ::std::option::Option::Some(tmp);
                },
                83 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_32 = ::std::option::Option::Some(tmp);
                },
                84 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_64 = ::std::option::Option::Some(tmp);
                },
                85 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_128 = ::std::option::Option::Some(tmp);
                },
                86 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_256 = ::std::option::Option::Some(tmp);
                },
                87 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_512 = ::std::option::Option::Some(tmp);
                },
                88 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_1024 = ::std::option::Option::Some(tmp);
                },
                89 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_histogram_max = ::std::option::Option::Some(tmp);
                },
                90 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_ntile_5th = ::std::option::Option::Some(tmp);
                },
                91 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_ntile_50th = ::std::option::Option::Some(tmp);
                },
                92 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_ntile_75th = ::std::option::Option::Some(tmp);
                },
                93 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_ntile_95th = ::std::option::Option::Some(tmp);
                },
                94 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rxspeed_ntile_98th = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connected_seconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_sent {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kb_sent {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kb_recv {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv_sequenced {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv_dropped {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv_out_of_order {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv_duplicate {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets_recv_lurch {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_100 {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_99 {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_97 {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_95 {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_90 {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_75 {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_50 {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_1 {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_histogram_dead {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_ntile_2nd {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_ntile_5th {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_ntile_25th {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality_ntile_50th {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_25 {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_50 {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_75 {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_100 {
            my_size += ::protobuf::rt::value_size(44, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_125 {
            my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_150 {
            my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_200 {
            my_size += ::protobuf::rt::value_size(47, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_300 {
            my_size += ::protobuf::rt::value_size(48, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_histogram_max {
            my_size += ::protobuf::rt::value_size(49, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ntile_5th {
            my_size += ::protobuf::rt::value_size(50, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ntile_50th {
            my_size += ::protobuf::rt::value_size(51, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ntile_75th {
            my_size += ::protobuf::rt::value_size(52, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ntile_95th {
            my_size += ::protobuf::rt::value_size(53, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_ntile_98th {
            my_size += ::protobuf::rt::value_size(54, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_negligible {
            my_size += ::protobuf::rt::value_size(61, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_1 {
            my_size += ::protobuf::rt::value_size(62, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_2 {
            my_size += ::protobuf::rt::value_size(63, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_5 {
            my_size += ::protobuf::rt::value_size(64, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_10 {
            my_size += ::protobuf::rt::value_size(65, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jitter_histogram_20 {
            my_size += ::protobuf::rt::value_size(66, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_max {
            my_size += ::protobuf::rt::value_size(67, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_16 {
            my_size += ::protobuf::rt::value_size(68, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_32 {
            my_size += ::protobuf::rt::value_size(69, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_64 {
            my_size += ::protobuf::rt::value_size(70, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_128 {
            my_size += ::protobuf::rt::value_size(71, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_256 {
            my_size += ::protobuf::rt::value_size(72, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_512 {
            my_size += ::protobuf::rt::value_size(73, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_1024 {
            my_size += ::protobuf::rt::value_size(74, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_histogram_max {
            my_size += ::protobuf::rt::value_size(75, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_ntile_5th {
            my_size += ::protobuf::rt::value_size(76, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_ntile_50th {
            my_size += ::protobuf::rt::value_size(77, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_ntile_75th {
            my_size += ::protobuf::rt::value_size(78, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_ntile_95th {
            my_size += ::protobuf::rt::value_size(79, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txspeed_ntile_98th {
            my_size += ::protobuf::rt::value_size(80, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_max {
            my_size += ::protobuf::rt::value_size(81, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_16 {
            my_size += ::protobuf::rt::value_size(82, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_32 {
            my_size += ::protobuf::rt::value_size(83, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_64 {
            my_size += ::protobuf::rt::value_size(84, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_128 {
            my_size += ::protobuf::rt::value_size(85, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_256 {
            my_size += ::protobuf::rt::value_size(86, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_512 {
            my_size += ::protobuf::rt::value_size(87, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_1024 {
            my_size += ::protobuf::rt::value_size(88, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_histogram_max {
            my_size += ::protobuf::rt::value_size(89, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_ntile_5th {
            my_size += ::protobuf::rt::value_size(90, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_ntile_50th {
            my_size += ::protobuf::rt::value_size(91, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_ntile_75th {
            my_size += ::protobuf::rt::value_size(92, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_ntile_95th {
            my_size += ::protobuf::rt::value_size(93, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rxspeed_ntile_98th {
            my_size += ::protobuf::rt::value_size(94, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connected_seconds {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.packets_sent {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.kb_sent {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.packets_recv {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.kb_recv {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.packets_recv_sequenced {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.packets_recv_dropped {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.packets_recv_out_of_order {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.packets_recv_duplicate {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.packets_recv_lurch {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.quality_histogram_100 {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.quality_histogram_99 {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.quality_histogram_97 {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.quality_histogram_95 {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.quality_histogram_90 {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.quality_histogram_75 {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.quality_histogram_50 {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.quality_histogram_1 {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.quality_histogram_dead {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.quality_ntile_2nd {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.quality_ntile_5th {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.quality_ntile_25th {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.quality_ntile_50th {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.ping_histogram_25 {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.ping_histogram_50 {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.ping_histogram_75 {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.ping_histogram_100 {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.ping_histogram_125 {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.ping_histogram_150 {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.ping_histogram_200 {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.ping_histogram_300 {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.ping_histogram_max {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.ping_ntile_5th {
            os.write_uint32(50, v)?;
        }
        if let Some(v) = self.ping_ntile_50th {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.ping_ntile_75th {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.ping_ntile_95th {
            os.write_uint32(53, v)?;
        }
        if let Some(v) = self.ping_ntile_98th {
            os.write_uint32(54, v)?;
        }
        if let Some(v) = self.jitter_histogram_negligible {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.jitter_histogram_1 {
            os.write_uint32(62, v)?;
        }
        if let Some(v) = self.jitter_histogram_2 {
            os.write_uint32(63, v)?;
        }
        if let Some(v) = self.jitter_histogram_5 {
            os.write_uint32(64, v)?;
        }
        if let Some(v) = self.jitter_histogram_10 {
            os.write_uint32(65, v)?;
        }
        if let Some(v) = self.jitter_histogram_20 {
            os.write_uint32(66, v)?;
        }
        if let Some(v) = self.txspeed_max {
            os.write_uint32(67, v)?;
        }
        if let Some(v) = self.txspeed_histogram_16 {
            os.write_uint32(68, v)?;
        }
        if let Some(v) = self.txspeed_histogram_32 {
            os.write_uint32(69, v)?;
        }
        if let Some(v) = self.txspeed_histogram_64 {
            os.write_uint32(70, v)?;
        }
        if let Some(v) = self.txspeed_histogram_128 {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.txspeed_histogram_256 {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.txspeed_histogram_512 {
            os.write_uint32(73, v)?;
        }
        if let Some(v) = self.txspeed_histogram_1024 {
            os.write_uint32(74, v)?;
        }
        if let Some(v) = self.txspeed_histogram_max {
            os.write_uint32(75, v)?;
        }
        if let Some(v) = self.txspeed_ntile_5th {
            os.write_uint32(76, v)?;
        }
        if let Some(v) = self.txspeed_ntile_50th {
            os.write_uint32(77, v)?;
        }
        if let Some(v) = self.txspeed_ntile_75th {
            os.write_uint32(78, v)?;
        }
        if let Some(v) = self.txspeed_ntile_95th {
            os.write_uint32(79, v)?;
        }
        if let Some(v) = self.txspeed_ntile_98th {
            os.write_uint32(80, v)?;
        }
        if let Some(v) = self.rxspeed_max {
            os.write_uint32(81, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_16 {
            os.write_uint32(82, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_32 {
            os.write_uint32(83, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_64 {
            os.write_uint32(84, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_128 {
            os.write_uint32(85, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_256 {
            os.write_uint32(86, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_512 {
            os.write_uint32(87, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_1024 {
            os.write_uint32(88, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_max {
            os.write_uint32(89, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_5th {
            os.write_uint32(90, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_50th {
            os.write_uint32(91, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_75th {
            os.write_uint32(92, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_95th {
            os.write_uint32(93, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_98th {
            os.write_uint32(94, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramLinkLifetimeStats {
        CMsgSteamDatagramLinkLifetimeStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "connected_seconds",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.connected_seconds },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.connected_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_sent",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_sent },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "kb_sent",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.kb_sent },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.kb_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "kb_recv",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.kb_recv },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.kb_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv_sequenced",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_sequenced },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_sequenced },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv_dropped",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_dropped },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_dropped },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv_out_of_order",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_out_of_order },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_out_of_order },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv_duplicate",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_duplicate },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_duplicate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "packets_recv_lurch",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_lurch },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_lurch },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_100",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_100 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_100 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_99",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_99 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_99 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_97",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_97 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_97 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_95",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_95 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_95 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_90",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_90 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_90 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_75",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_75 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_75 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_50",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_50 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_50 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_1",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_1 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_histogram_dead",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_dead },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_dead },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_ntile_2nd",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_2nd },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_2nd },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_ntile_5th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_5th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_5th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_ntile_25th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_25th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_25th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality_ntile_50th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_50th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_50th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_25",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_25 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_25 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_50",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_50 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_50 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_75",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_75 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_75 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_100",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_100 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_100 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_125",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_125 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_125 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_150",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_150 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_150 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_200",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_200 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_200 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_300",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_300 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_300 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_histogram_max",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_max },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ntile_5th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_5th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_5th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ntile_50th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_50th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_50th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ntile_75th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_75th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_75th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ntile_95th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_95th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_95th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ntile_98th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_98th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_98th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_negligible",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_negligible },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_negligible },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_1",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_1 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_2",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_2 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_5",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_5 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_10",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_10 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_10 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jitter_histogram_20",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_20 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_20 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_max",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_max },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_16",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_16 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_16 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_32",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_32 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_32 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_64",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_64 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_64 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_128",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_128 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_128 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_256",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_256 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_256 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_512",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_512 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_512 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_1024",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_1024 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_1024 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_histogram_max",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_max },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_ntile_5th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_5th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_5th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_ntile_50th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_50th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_50th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_ntile_75th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_75th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_75th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_ntile_95th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_95th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_95th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "txspeed_ntile_98th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_98th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_98th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_max",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_max },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_16",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_16 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_16 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_32",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_32 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_32 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_64",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_64 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_64 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_128",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_128 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_128 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_256",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_256 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_256 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_512",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_512 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_512 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_1024",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_1024 },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_1024 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_histogram_max",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_max },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_ntile_5th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_5th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_5th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_ntile_50th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_50th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_50th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_ntile_75th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_75th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_75th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_ntile_95th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_95th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_95th },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rxspeed_ntile_98th",
                |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_98th },
                |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_98th },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramLinkLifetimeStats>(
                "CMsgSteamDatagramLinkLifetimeStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramLinkLifetimeStats {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramLinkLifetimeStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramLinkLifetimeStats::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramLinkLifetimeStats {
    fn clear(&mut self) {
        self.connected_seconds = ::std::option::Option::None;
        self.packets_sent = ::std::option::Option::None;
        self.kb_sent = ::std::option::Option::None;
        self.packets_recv = ::std::option::Option::None;
        self.kb_recv = ::std::option::Option::None;
        self.packets_recv_sequenced = ::std::option::Option::None;
        self.packets_recv_dropped = ::std::option::Option::None;
        self.packets_recv_out_of_order = ::std::option::Option::None;
        self.packets_recv_duplicate = ::std::option::Option::None;
        self.packets_recv_lurch = ::std::option::Option::None;
        self.quality_histogram_100 = ::std::option::Option::None;
        self.quality_histogram_99 = ::std::option::Option::None;
        self.quality_histogram_97 = ::std::option::Option::None;
        self.quality_histogram_95 = ::std::option::Option::None;
        self.quality_histogram_90 = ::std::option::Option::None;
        self.quality_histogram_75 = ::std::option::Option::None;
        self.quality_histogram_50 = ::std::option::Option::None;
        self.quality_histogram_1 = ::std::option::Option::None;
        self.quality_histogram_dead = ::std::option::Option::None;
        self.quality_ntile_2nd = ::std::option::Option::None;
        self.quality_ntile_5th = ::std::option::Option::None;
        self.quality_ntile_25th = ::std::option::Option::None;
        self.quality_ntile_50th = ::std::option::Option::None;
        self.ping_histogram_25 = ::std::option::Option::None;
        self.ping_histogram_50 = ::std::option::Option::None;
        self.ping_histogram_75 = ::std::option::Option::None;
        self.ping_histogram_100 = ::std::option::Option::None;
        self.ping_histogram_125 = ::std::option::Option::None;
        self.ping_histogram_150 = ::std::option::Option::None;
        self.ping_histogram_200 = ::std::option::Option::None;
        self.ping_histogram_300 = ::std::option::Option::None;
        self.ping_histogram_max = ::std::option::Option::None;
        self.ping_ntile_5th = ::std::option::Option::None;
        self.ping_ntile_50th = ::std::option::Option::None;
        self.ping_ntile_75th = ::std::option::Option::None;
        self.ping_ntile_95th = ::std::option::Option::None;
        self.ping_ntile_98th = ::std::option::Option::None;
        self.jitter_histogram_negligible = ::std::option::Option::None;
        self.jitter_histogram_1 = ::std::option::Option::None;
        self.jitter_histogram_2 = ::std::option::Option::None;
        self.jitter_histogram_5 = ::std::option::Option::None;
        self.jitter_histogram_10 = ::std::option::Option::None;
        self.jitter_histogram_20 = ::std::option::Option::None;
        self.txspeed_max = ::std::option::Option::None;
        self.txspeed_histogram_16 = ::std::option::Option::None;
        self.txspeed_histogram_32 = ::std::option::Option::None;
        self.txspeed_histogram_64 = ::std::option::Option::None;
        self.txspeed_histogram_128 = ::std::option::Option::None;
        self.txspeed_histogram_256 = ::std::option::Option::None;
        self.txspeed_histogram_512 = ::std::option::Option::None;
        self.txspeed_histogram_1024 = ::std::option::Option::None;
        self.txspeed_histogram_max = ::std::option::Option::None;
        self.txspeed_ntile_5th = ::std::option::Option::None;
        self.txspeed_ntile_50th = ::std::option::Option::None;
        self.txspeed_ntile_75th = ::std::option::Option::None;
        self.txspeed_ntile_95th = ::std::option::Option::None;
        self.txspeed_ntile_98th = ::std::option::Option::None;
        self.rxspeed_max = ::std::option::Option::None;
        self.rxspeed_histogram_16 = ::std::option::Option::None;
        self.rxspeed_histogram_32 = ::std::option::Option::None;
        self.rxspeed_histogram_64 = ::std::option::Option::None;
        self.rxspeed_histogram_128 = ::std::option::Option::None;
        self.rxspeed_histogram_256 = ::std::option::Option::None;
        self.rxspeed_histogram_512 = ::std::option::Option::None;
        self.rxspeed_histogram_1024 = ::std::option::Option::None;
        self.rxspeed_histogram_max = ::std::option::Option::None;
        self.rxspeed_ntile_5th = ::std::option::Option::None;
        self.rxspeed_ntile_50th = ::std::option::Option::None;
        self.rxspeed_ntile_75th = ::std::option::Option::None;
        self.rxspeed_ntile_95th = ::std::option::Option::None;
        self.rxspeed_ntile_98th = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramLinkLifetimeStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramLinkLifetimeStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamDatagramConnectionQuality {
    // message fields
    pub instantaneous: ::protobuf::SingularPtrField<CMsgSteamDatagramLinkInstantaneousStats>,
    pub lifetime: ::protobuf::SingularPtrField<CMsgSteamDatagramLinkLifetimeStats>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionQuality {
    fn default() -> &'a CMsgSteamDatagramConnectionQuality {
        <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionQuality {
    pub fn new() -> CMsgSteamDatagramConnectionQuality {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramLinkInstantaneousStats instantaneous = 1;


    pub fn get_instantaneous(&self) -> &CMsgSteamDatagramLinkInstantaneousStats {
        self.instantaneous.as_ref().unwrap_or_else(|| <CMsgSteamDatagramLinkInstantaneousStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_instantaneous(&mut self) {
        self.instantaneous.clear();
    }

    pub fn has_instantaneous(&self) -> bool {
        self.instantaneous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instantaneous(&mut self, v: CMsgSteamDatagramLinkInstantaneousStats) {
        self.instantaneous = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instantaneous(&mut self) -> &mut CMsgSteamDatagramLinkInstantaneousStats {
        if self.instantaneous.is_none() {
            self.instantaneous.set_default();
        }
        self.instantaneous.as_mut().unwrap()
    }

    // Take field
    pub fn take_instantaneous(&mut self) -> CMsgSteamDatagramLinkInstantaneousStats {
        self.instantaneous.take().unwrap_or_else(|| CMsgSteamDatagramLinkInstantaneousStats::new())
    }

    // optional .CMsgSteamDatagramLinkLifetimeStats lifetime = 2;


    pub fn get_lifetime(&self) -> &CMsgSteamDatagramLinkLifetimeStats {
        self.lifetime.as_ref().unwrap_or_else(|| <CMsgSteamDatagramLinkLifetimeStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lifetime(&mut self) {
        self.lifetime.clear();
    }

    pub fn has_lifetime(&self) -> bool {
        self.lifetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime(&mut self, v: CMsgSteamDatagramLinkLifetimeStats) {
        self.lifetime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lifetime(&mut self) -> &mut CMsgSteamDatagramLinkLifetimeStats {
        if self.lifetime.is_none() {
            self.lifetime.set_default();
        }
        self.lifetime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lifetime(&mut self) -> CMsgSteamDatagramLinkLifetimeStats {
        self.lifetime.take().unwrap_or_else(|| CMsgSteamDatagramLinkLifetimeStats::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionQuality {
    fn is_initialized(&self) -> bool {
        for v in &self.instantaneous {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lifetime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instantaneous)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lifetime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instantaneous.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lifetime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instantaneous.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lifetime.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionQuality {
        CMsgSteamDatagramConnectionQuality::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramLinkInstantaneousStats>>(
                "instantaneous",
                |m: &CMsgSteamDatagramConnectionQuality| { &m.instantaneous },
                |m: &mut CMsgSteamDatagramConnectionQuality| { &mut m.instantaneous },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramLinkLifetimeStats>>(
                "lifetime",
                |m: &CMsgSteamDatagramConnectionQuality| { &m.lifetime },
                |m: &mut CMsgSteamDatagramConnectionQuality| { &mut m.lifetime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionQuality>(
                "CMsgSteamDatagramConnectionQuality",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionQuality {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionQuality> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionQuality::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionQuality {
    fn clear(&mut self) {
        self.instantaneous.clear();
        self.lifetime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionQuality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionQuality {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgICERendezvous {
    // message fields
    pub auth: ::protobuf::SingularPtrField<CMsgICERendezvous_Auth>,
    pub add_candidate: ::protobuf::SingularPtrField<CMsgICERendezvous_Candidate>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgICERendezvous {
    fn default() -> &'a CMsgICERendezvous {
        <CMsgICERendezvous as ::protobuf::Message>::default_instance()
    }
}

impl CMsgICERendezvous {
    pub fn new() -> CMsgICERendezvous {
        ::std::default::Default::default()
    }

    // optional .CMsgICERendezvous.Auth auth = 2;


    pub fn get_auth(&self) -> &CMsgICERendezvous_Auth {
        self.auth.as_ref().unwrap_or_else(|| <CMsgICERendezvous_Auth as ::protobuf::Message>::default_instance())
    }
    pub fn clear_auth(&mut self) {
        self.auth.clear();
    }

    pub fn has_auth(&self) -> bool {
        self.auth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth(&mut self, v: CMsgICERendezvous_Auth) {
        self.auth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth(&mut self) -> &mut CMsgICERendezvous_Auth {
        if self.auth.is_none() {
            self.auth.set_default();
        }
        self.auth.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth(&mut self) -> CMsgICERendezvous_Auth {
        self.auth.take().unwrap_or_else(|| CMsgICERendezvous_Auth::new())
    }

    // optional .CMsgICERendezvous.Candidate add_candidate = 1;


    pub fn get_add_candidate(&self) -> &CMsgICERendezvous_Candidate {
        self.add_candidate.as_ref().unwrap_or_else(|| <CMsgICERendezvous_Candidate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_add_candidate(&mut self) {
        self.add_candidate.clear();
    }

    pub fn has_add_candidate(&self) -> bool {
        self.add_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_candidate(&mut self, v: CMsgICERendezvous_Candidate) {
        self.add_candidate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_add_candidate(&mut self) -> &mut CMsgICERendezvous_Candidate {
        if self.add_candidate.is_none() {
            self.add_candidate.set_default();
        }
        self.add_candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_add_candidate(&mut self) -> CMsgICERendezvous_Candidate {
        self.add_candidate.take().unwrap_or_else(|| CMsgICERendezvous_Candidate::new())
    }
}

impl ::protobuf::Message for CMsgICERendezvous {
    fn is_initialized(&self) -> bool {
        for v in &self.auth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.add_candidate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.auth)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.add_candidate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.auth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.add_candidate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.auth.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.add_candidate.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgICERendezvous {
        CMsgICERendezvous::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgICERendezvous_Auth>>(
                "auth",
                |m: &CMsgICERendezvous| { &m.auth },
                |m: &mut CMsgICERendezvous| { &mut m.auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgICERendezvous_Candidate>>(
                "add_candidate",
                |m: &CMsgICERendezvous| { &m.add_candidate },
                |m: &mut CMsgICERendezvous| { &mut m.add_candidate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgICERendezvous>(
                "CMsgICERendezvous",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgICERendezvous {
        static instance: ::protobuf::rt::LazyV2<CMsgICERendezvous> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgICERendezvous::new)
    }
}

impl ::protobuf::Clear for CMsgICERendezvous {
    fn clear(&mut self) {
        self.auth.clear();
        self.add_candidate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgICERendezvous {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgICERendezvous {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgICERendezvous_Auth {
    // message fields
    pwd_frag: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgICERendezvous_Auth {
    fn default() -> &'a CMsgICERendezvous_Auth {
        <CMsgICERendezvous_Auth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgICERendezvous_Auth {
    pub fn new() -> CMsgICERendezvous_Auth {
        ::std::default::Default::default()
    }

    // optional string pwd_frag = 1;


    pub fn get_pwd_frag(&self) -> &str {
        match self.pwd_frag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pwd_frag(&mut self) {
        self.pwd_frag.clear();
    }

    pub fn has_pwd_frag(&self) -> bool {
        self.pwd_frag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pwd_frag(&mut self, v: ::std::string::String) {
        self.pwd_frag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pwd_frag(&mut self) -> &mut ::std::string::String {
        if self.pwd_frag.is_none() {
            self.pwd_frag.set_default();
        }
        self.pwd_frag.as_mut().unwrap()
    }

    // Take field
    pub fn take_pwd_frag(&mut self) -> ::std::string::String {
        self.pwd_frag.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgICERendezvous_Auth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pwd_frag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pwd_frag.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pwd_frag.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgICERendezvous_Auth {
        CMsgICERendezvous_Auth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pwd_frag",
                |m: &CMsgICERendezvous_Auth| { &m.pwd_frag },
                |m: &mut CMsgICERendezvous_Auth| { &mut m.pwd_frag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgICERendezvous_Auth>(
                "CMsgICERendezvous.Auth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgICERendezvous_Auth {
        static instance: ::protobuf::rt::LazyV2<CMsgICERendezvous_Auth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgICERendezvous_Auth::new)
    }
}

impl ::protobuf::Clear for CMsgICERendezvous_Auth {
    fn clear(&mut self) {
        self.pwd_frag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgICERendezvous_Auth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgICERendezvous_Auth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgICERendezvous_Candidate {
    // message fields
    candidate: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgICERendezvous_Candidate {
    fn default() -> &'a CMsgICERendezvous_Candidate {
        <CMsgICERendezvous_Candidate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgICERendezvous_Candidate {
    pub fn new() -> CMsgICERendezvous_Candidate {
        ::std::default::Default::default()
    }

    // optional string candidate = 3;


    pub fn get_candidate(&self) -> &str {
        match self.candidate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        if self.candidate.is_none() {
            self.candidate.set_default();
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        self.candidate.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgICERendezvous_Candidate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.candidate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.candidate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.candidate.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgICERendezvous_Candidate {
        CMsgICERendezvous_Candidate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "candidate",
                |m: &CMsgICERendezvous_Candidate| { &m.candidate },
                |m: &mut CMsgICERendezvous_Candidate| { &mut m.candidate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgICERendezvous_Candidate>(
                "CMsgICERendezvous.Candidate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgICERendezvous_Candidate {
        static instance: ::protobuf::rt::LazyV2<CMsgICERendezvous_Candidate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgICERendezvous_Candidate::new)
    }
}

impl ::protobuf::Clear for CMsgICERendezvous_Candidate {
    fn clear(&mut self) {
        self.candidate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgICERendezvous_Candidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgICERendezvous_Candidate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamNetworkingP2PRendezvous {
    // message fields
    from_identity: ::protobuf::SingularField<::std::string::String>,
    from_connection_id: ::std::option::Option<u32>,
    to_identity: ::protobuf::SingularField<::std::string::String>,
    to_connection_id: ::std::option::Option<u32>,
    sdr_routes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ack_peer_routes_revision: ::std::option::Option<u32>,
    ice_enabled: ::std::option::Option<bool>,
    pub connect_request: ::protobuf::SingularPtrField<CMsgSteamNetworkingP2PRendezvous_ConnectRequest>,
    pub connect_ok: ::protobuf::SingularPtrField<CMsgSteamNetworkingP2PRendezvous_ConnectOK>,
    pub connection_closed: ::protobuf::SingularPtrField<CMsgSteamNetworkingP2PRendezvous_ConnectionClosed>,
    ack_reliable_msg: ::std::option::Option<u32>,
    first_reliable_msg: ::std::option::Option<u32>,
    pub reliable_messages: ::protobuf::RepeatedField<CMsgSteamNetworkingP2PRendezvous_ReliableMessage>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamNetworkingP2PRendezvous {
    fn default() -> &'a CMsgSteamNetworkingP2PRendezvous {
        <CMsgSteamNetworkingP2PRendezvous as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamNetworkingP2PRendezvous {
    pub fn new() -> CMsgSteamNetworkingP2PRendezvous {
        ::std::default::Default::default()
    }

    // optional string from_identity = 8;


    pub fn get_from_identity(&self) -> &str {
        match self.from_identity.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_from_identity(&mut self) {
        self.from_identity.clear();
    }

    pub fn has_from_identity(&self) -> bool {
        self.from_identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_identity(&mut self, v: ::std::string::String) {
        self.from_identity = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_identity(&mut self) -> &mut ::std::string::String {
        if self.from_identity.is_none() {
            self.from_identity.set_default();
        }
        self.from_identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_identity(&mut self) -> ::std::string::String {
        self.from_identity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 from_connection_id = 9;


    pub fn get_from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }
    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional string to_identity = 10;


    pub fn get_to_identity(&self) -> &str {
        match self.to_identity.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_to_identity(&mut self) {
        self.to_identity.clear();
    }

    pub fn has_to_identity(&self) -> bool {
        self.to_identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_identity(&mut self, v: ::std::string::String) {
        self.to_identity = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_identity(&mut self) -> &mut ::std::string::String {
        if self.to_identity.is_none() {
            self.to_identity.set_default();
        }
        self.to_identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_to_identity(&mut self) -> ::std::string::String {
        self.to_identity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 to_connection_id = 1;


    pub fn get_to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }
    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional bytes sdr_routes = 2;


    pub fn get_sdr_routes(&self) -> &[u8] {
        match self.sdr_routes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sdr_routes(&mut self) {
        self.sdr_routes.clear();
    }

    pub fn has_sdr_routes(&self) -> bool {
        self.sdr_routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdr_routes(&mut self, v: ::std::vec::Vec<u8>) {
        self.sdr_routes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdr_routes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sdr_routes.is_none() {
            self.sdr_routes.set_default();
        }
        self.sdr_routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdr_routes(&mut self) -> ::std::vec::Vec<u8> {
        self.sdr_routes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ack_peer_routes_revision = 3;


    pub fn get_ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }
    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional bool ice_enabled = 7;


    pub fn get_ice_enabled(&self) -> bool {
        self.ice_enabled.unwrap_or(false)
    }
    pub fn clear_ice_enabled(&mut self) {
        self.ice_enabled = ::std::option::Option::None;
    }

    pub fn has_ice_enabled(&self) -> bool {
        self.ice_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ice_enabled(&mut self, v: bool) {
        self.ice_enabled = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamNetworkingP2PRendezvous.ConnectRequest connect_request = 4;


    pub fn get_connect_request(&self) -> &CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
        self.connect_request.as_ref().unwrap_or_else(|| <CMsgSteamNetworkingP2PRendezvous_ConnectRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connect_request(&mut self) {
        self.connect_request.clear();
    }

    pub fn has_connect_request(&self) -> bool {
        self.connect_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_request(&mut self, v: CMsgSteamNetworkingP2PRendezvous_ConnectRequest) {
        self.connect_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_request(&mut self) -> &mut CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
        if self.connect_request.is_none() {
            self.connect_request.set_default();
        }
        self.connect_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_request(&mut self) -> CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
        self.connect_request.take().unwrap_or_else(|| CMsgSteamNetworkingP2PRendezvous_ConnectRequest::new())
    }

    // optional .CMsgSteamNetworkingP2PRendezvous.ConnectOK connect_ok = 5;


    pub fn get_connect_ok(&self) -> &CMsgSteamNetworkingP2PRendezvous_ConnectOK {
        self.connect_ok.as_ref().unwrap_or_else(|| <CMsgSteamNetworkingP2PRendezvous_ConnectOK as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connect_ok(&mut self) {
        self.connect_ok.clear();
    }

    pub fn has_connect_ok(&self) -> bool {
        self.connect_ok.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_ok(&mut self, v: CMsgSteamNetworkingP2PRendezvous_ConnectOK) {
        self.connect_ok = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_ok(&mut self) -> &mut CMsgSteamNetworkingP2PRendezvous_ConnectOK {
        if self.connect_ok.is_none() {
            self.connect_ok.set_default();
        }
        self.connect_ok.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_ok(&mut self) -> CMsgSteamNetworkingP2PRendezvous_ConnectOK {
        self.connect_ok.take().unwrap_or_else(|| CMsgSteamNetworkingP2PRendezvous_ConnectOK::new())
    }

    // optional .CMsgSteamNetworkingP2PRendezvous.ConnectionClosed connection_closed = 6;


    pub fn get_connection_closed(&self) -> &CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
        self.connection_closed.as_ref().unwrap_or_else(|| <CMsgSteamNetworkingP2PRendezvous_ConnectionClosed as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connection_closed(&mut self) {
        self.connection_closed.clear();
    }

    pub fn has_connection_closed(&self) -> bool {
        self.connection_closed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_closed(&mut self, v: CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) {
        self.connection_closed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_closed(&mut self) -> &mut CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
        if self.connection_closed.is_none() {
            self.connection_closed.set_default();
        }
        self.connection_closed.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_closed(&mut self) -> CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
        self.connection_closed.take().unwrap_or_else(|| CMsgSteamNetworkingP2PRendezvous_ConnectionClosed::new())
    }

    // optional uint32 ack_reliable_msg = 11;


    pub fn get_ack_reliable_msg(&self) -> u32 {
        self.ack_reliable_msg.unwrap_or(0)
    }
    pub fn clear_ack_reliable_msg(&mut self) {
        self.ack_reliable_msg = ::std::option::Option::None;
    }

    pub fn has_ack_reliable_msg(&self) -> bool {
        self.ack_reliable_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_reliable_msg(&mut self, v: u32) {
        self.ack_reliable_msg = ::std::option::Option::Some(v);
    }

    // optional uint32 first_reliable_msg = 12;


    pub fn get_first_reliable_msg(&self) -> u32 {
        self.first_reliable_msg.unwrap_or(0)
    }
    pub fn clear_first_reliable_msg(&mut self) {
        self.first_reliable_msg = ::std::option::Option::None;
    }

    pub fn has_first_reliable_msg(&self) -> bool {
        self.first_reliable_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_reliable_msg(&mut self, v: u32) {
        self.first_reliable_msg = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamNetworkingP2PRendezvous.ReliableMessage reliable_messages = 13;


    pub fn get_reliable_messages(&self) -> &[CMsgSteamNetworkingP2PRendezvous_ReliableMessage] {
        &self.reliable_messages
    }
    pub fn clear_reliable_messages(&mut self) {
        self.reliable_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_reliable_messages(&mut self, v: ::protobuf::RepeatedField<CMsgSteamNetworkingP2PRendezvous_ReliableMessage>) {
        self.reliable_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reliable_messages(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamNetworkingP2PRendezvous_ReliableMessage> {
        &mut self.reliable_messages
    }

    // Take field
    pub fn take_reliable_messages(&mut self) -> ::protobuf::RepeatedField<CMsgSteamNetworkingP2PRendezvous_ReliableMessage> {
        ::std::mem::replace(&mut self.reliable_messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamNetworkingP2PRendezvous {
    fn is_initialized(&self) -> bool {
        for v in &self.connect_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connect_ok {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connection_closed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reliable_messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.from_identity)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_connection_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.to_identity)?;
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sdr_routes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_peer_routes_revision = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ice_enabled = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connect_request)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connect_ok)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connection_closed)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_reliable_msg = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_reliable_msg = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reliable_messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.from_identity.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.from_connection_id {
            my_size += 5;
        }
        if let Some(ref v) = self.to_identity.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.to_connection_id {
            my_size += 5;
        }
        if let Some(ref v) = self.sdr_routes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ice_enabled {
            my_size += 2;
        }
        if let Some(ref v) = self.connect_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.connect_ok.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.connection_closed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ack_reliable_msg {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_reliable_msg {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.reliable_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.from_identity.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(ref v) = self.to_identity.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.sdr_routes.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ice_enabled {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.connect_request.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.connect_ok.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.connection_closed.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.ack_reliable_msg {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.first_reliable_msg {
            os.write_uint32(12, v)?;
        }
        for v in &self.reliable_messages {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamNetworkingP2PRendezvous {
        CMsgSteamNetworkingP2PRendezvous::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from_identity",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.from_identity },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.from_identity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_connection_id",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.from_connection_id },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.from_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "to_identity",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.to_identity },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.to_identity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_connection_id",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.to_connection_id },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.to_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sdr_routes",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.sdr_routes },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.sdr_routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_peer_routes_revision",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.ack_peer_routes_revision },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.ack_peer_routes_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ice_enabled",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.ice_enabled },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.ice_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamNetworkingP2PRendezvous_ConnectRequest>>(
                "connect_request",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.connect_request },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.connect_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamNetworkingP2PRendezvous_ConnectOK>>(
                "connect_ok",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.connect_ok },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.connect_ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamNetworkingP2PRendezvous_ConnectionClosed>>(
                "connection_closed",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.connection_closed },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.connection_closed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_reliable_msg",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.ack_reliable_msg },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.ack_reliable_msg },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "first_reliable_msg",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.first_reliable_msg },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.first_reliable_msg },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamNetworkingP2PRendezvous_ReliableMessage>>(
                "reliable_messages",
                |m: &CMsgSteamNetworkingP2PRendezvous| { &m.reliable_messages },
                |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.reliable_messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamNetworkingP2PRendezvous>(
                "CMsgSteamNetworkingP2PRendezvous",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamNetworkingP2PRendezvous {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamNetworkingP2PRendezvous> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamNetworkingP2PRendezvous::new)
    }
}

impl ::protobuf::Clear for CMsgSteamNetworkingP2PRendezvous {
    fn clear(&mut self) {
        self.from_identity.clear();
        self.from_connection_id = ::std::option::Option::None;
        self.to_identity.clear();
        self.to_connection_id = ::std::option::Option::None;
        self.sdr_routes.clear();
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.ice_enabled = ::std::option::Option::None;
        self.connect_request.clear();
        self.connect_ok.clear();
        self.connection_closed.clear();
        self.ack_reliable_msg = ::std::option::Option::None;
        self.first_reliable_msg = ::std::option::Option::None;
        self.reliable_messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamNetworkingP2PRendezvous {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamNetworkingP2PRendezvous {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
    // message fields
    pub crypt: ::protobuf::SingularPtrField<CMsgSteamDatagramSessionCryptInfoSigned>,
    pub cert: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
    to_virtual_port: ::std::option::Option<u32>,
    from_virtual_port: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
    fn default() -> &'a CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
        <CMsgSteamNetworkingP2PRendezvous_ConnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
    pub fn new() -> CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 6;


    pub fn get_crypt(&self) -> &CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.as_ref().unwrap_or_else(|| <CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crypt(&mut self) {
        self.crypt.clear();
    }

    pub fn has_crypt(&self) -> bool {
        self.crypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crypt(&mut self, v: CMsgSteamDatagramSessionCryptInfoSigned) {
        self.crypt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crypt(&mut self) -> &mut CMsgSteamDatagramSessionCryptInfoSigned {
        if self.crypt.is_none() {
            self.crypt.set_default();
        }
        self.crypt.as_mut().unwrap()
    }

    // Take field
    pub fn take_crypt(&mut self) -> CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.take().unwrap_or_else(|| CMsgSteamDatagramSessionCryptInfoSigned::new())
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 7;


    pub fn get_cert(&self) -> &super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned::new())
    }

    // optional uint32 to_virtual_port = 9;


    pub fn get_to_virtual_port(&self) -> u32 {
        self.to_virtual_port.unwrap_or(0)
    }
    pub fn clear_to_virtual_port(&mut self) {
        self.to_virtual_port = ::std::option::Option::None;
    }

    pub fn has_to_virtual_port(&self) -> bool {
        self.to_virtual_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_virtual_port(&mut self, v: u32) {
        self.to_virtual_port = ::std::option::Option::Some(v);
    }

    // optional uint32 from_virtual_port = 10;


    pub fn get_from_virtual_port(&self) -> u32 {
        self.from_virtual_port.unwrap_or(0)
    }
    pub fn clear_from_virtual_port(&mut self) {
        self.from_virtual_port = ::std::option::Option::None;
    }

    pub fn has_from_virtual_port(&self) -> bool {
        self.from_virtual_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_virtual_port(&mut self, v: u32) {
        self.from_virtual_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.crypt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crypt)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.to_virtual_port = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.from_virtual_port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.to_virtual_port {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_virtual_port {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.crypt.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.to_virtual_port {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.from_virtual_port {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
        CMsgSteamNetworkingP2PRendezvous_ConnectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramSessionCryptInfoSigned>>(
                "crypt",
                |m: &CMsgSteamNetworkingP2PRendezvous_ConnectRequest| { &m.crypt },
                |m: &mut CMsgSteamNetworkingP2PRendezvous_ConnectRequest| { &mut m.crypt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamNetworkingP2PRendezvous_ConnectRequest| { &m.cert },
                |m: &mut CMsgSteamNetworkingP2PRendezvous_ConnectRequest| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "to_virtual_port",
                |m: &CMsgSteamNetworkingP2PRendezvous_ConnectRequest| { &m.to_virtual_port },
                |m: &mut CMsgSteamNetworkingP2PRendezvous_ConnectRequest| { &mut m.to_virtual_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "from_virtual_port",
                |m: &CMsgSteamNetworkingP2PRendezvous_ConnectRequest| { &m.from_virtual_port },
                |m: &mut CMsgSteamNetworkingP2PRendezvous_ConnectRequest| { &mut m.from_virtual_port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamNetworkingP2PRendezvous_ConnectRequest>(
                "CMsgSteamNetworkingP2PRendezvous.ConnectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamNetworkingP2PRendezvous_ConnectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamNetworkingP2PRendezvous_ConnectRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
    fn clear(&mut self) {
        self.crypt.clear();
        self.cert.clear();
        self.to_virtual_port = ::std::option::Option::None;
        self.from_virtual_port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamNetworkingP2PRendezvous_ConnectOK {
    // message fields
    pub crypt: ::protobuf::SingularPtrField<CMsgSteamDatagramSessionCryptInfoSigned>,
    pub cert: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamNetworkingP2PRendezvous_ConnectOK {
    fn default() -> &'a CMsgSteamNetworkingP2PRendezvous_ConnectOK {
        <CMsgSteamNetworkingP2PRendezvous_ConnectOK as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamNetworkingP2PRendezvous_ConnectOK {
    pub fn new() -> CMsgSteamNetworkingP2PRendezvous_ConnectOK {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 5;


    pub fn get_crypt(&self) -> &CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.as_ref().unwrap_or_else(|| <CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crypt(&mut self) {
        self.crypt.clear();
    }

    pub fn has_crypt(&self) -> bool {
        self.crypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crypt(&mut self, v: CMsgSteamDatagramSessionCryptInfoSigned) {
        self.crypt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crypt(&mut self) -> &mut CMsgSteamDatagramSessionCryptInfoSigned {
        if self.crypt.is_none() {
            self.crypt.set_default();
        }
        self.crypt.as_mut().unwrap()
    }

    // Take field
    pub fn take_crypt(&mut self) -> CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.take().unwrap_or_else(|| CMsgSteamDatagramSessionCryptInfoSigned::new())
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 6;


    pub fn get_cert(&self) -> &super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned::new())
    }
}

impl ::protobuf::Message for CMsgSteamNetworkingP2PRendezvous_ConnectOK {
    fn is_initialized(&self) -> bool {
        for v in &self.crypt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crypt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.crypt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamNetworkingP2PRendezvous_ConnectOK {
        CMsgSteamNetworkingP2PRendezvous_ConnectOK::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramSessionCryptInfoSigned>>(
                "crypt",
                |m: &CMsgSteamNetworkingP2PRendezvous_ConnectOK| { &m.crypt },
                |m: &mut CMsgSteamNetworkingP2PRendezvous_ConnectOK| { &mut m.crypt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamNetworkingP2PRendezvous_ConnectOK| { &m.cert },
                |m: &mut CMsgSteamNetworkingP2PRendezvous_ConnectOK| { &mut m.cert },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamNetworkingP2PRendezvous_ConnectOK>(
                "CMsgSteamNetworkingP2PRendezvous.ConnectOK",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamNetworkingP2PRendezvous_ConnectOK {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamNetworkingP2PRendezvous_ConnectOK> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamNetworkingP2PRendezvous_ConnectOK::new)
    }
}

impl ::protobuf::Clear for CMsgSteamNetworkingP2PRendezvous_ConnectOK {
    fn clear(&mut self) {
        self.crypt.clear();
        self.cert.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamNetworkingP2PRendezvous_ConnectOK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamNetworkingP2PRendezvous_ConnectOK {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
    // message fields
    debug: ::protobuf::SingularField<::std::string::String>,
    reason_code: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
    fn default() -> &'a CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
        <CMsgSteamNetworkingP2PRendezvous_ConnectionClosed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
    pub fn new() -> CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
        ::std::default::Default::default()
    }

    // optional string debug = 5;


    pub fn get_debug(&self) -> &str {
        match self.debug.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_debug(&mut self) {
        self.debug.clear();
    }

    pub fn has_debug(&self) -> bool {
        self.debug.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: ::std::string::String) {
        self.debug = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug(&mut self) -> &mut ::std::string::String {
        if self.debug.is_none() {
            self.debug.set_default();
        }
        self.debug.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug(&mut self) -> ::std::string::String {
        self.debug.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 reason_code = 6;


    pub fn get_reason_code(&self) -> u32 {
        self.reason_code.unwrap_or(0)
    }
    pub fn clear_reason_code(&mut self) {
        self.reason_code = ::std::option::Option::None;
    }

    pub fn has_reason_code(&self) -> bool {
        self.reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason_code(&mut self, v: u32) {
        self.reason_code = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.debug)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason_code = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.debug.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.reason_code {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.debug.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.reason_code {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
        CMsgSteamNetworkingP2PRendezvous_ConnectionClosed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "debug",
                |m: &CMsgSteamNetworkingP2PRendezvous_ConnectionClosed| { &m.debug },
                |m: &mut CMsgSteamNetworkingP2PRendezvous_ConnectionClosed| { &mut m.debug },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reason_code",
                |m: &CMsgSteamNetworkingP2PRendezvous_ConnectionClosed| { &m.reason_code },
                |m: &mut CMsgSteamNetworkingP2PRendezvous_ConnectionClosed| { &mut m.reason_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamNetworkingP2PRendezvous_ConnectionClosed>(
                "CMsgSteamNetworkingP2PRendezvous.ConnectionClosed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamNetworkingP2PRendezvous_ConnectionClosed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamNetworkingP2PRendezvous_ConnectionClosed::new)
    }
}

impl ::protobuf::Clear for CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
    fn clear(&mut self) {
        self.debug.clear();
        self.reason_code = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
    // message fields
    pub ice: ::protobuf::SingularPtrField<CMsgICERendezvous>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
    fn default() -> &'a CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
        <CMsgSteamNetworkingP2PRendezvous_ReliableMessage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
    pub fn new() -> CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
        ::std::default::Default::default()
    }

    // optional .CMsgICERendezvous ice = 1;


    pub fn get_ice(&self) -> &CMsgICERendezvous {
        self.ice.as_ref().unwrap_or_else(|| <CMsgICERendezvous as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ice(&mut self) {
        self.ice.clear();
    }

    pub fn has_ice(&self) -> bool {
        self.ice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ice(&mut self, v: CMsgICERendezvous) {
        self.ice = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ice(&mut self) -> &mut CMsgICERendezvous {
        if self.ice.is_none() {
            self.ice.set_default();
        }
        self.ice.as_mut().unwrap()
    }

    // Take field
    pub fn take_ice(&mut self) -> CMsgICERendezvous {
        self.ice.take().unwrap_or_else(|| CMsgICERendezvous::new())
    }
}

impl ::protobuf::Message for CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.ice {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ice)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ice.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
        CMsgSteamNetworkingP2PRendezvous_ReliableMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgICERendezvous>>(
                "ice",
                |m: &CMsgSteamNetworkingP2PRendezvous_ReliableMessage| { &m.ice },
                |m: &mut CMsgSteamNetworkingP2PRendezvous_ReliableMessage| { &mut m.ice },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamNetworkingP2PRendezvous_ReliableMessage>(
                "CMsgSteamNetworkingP2PRendezvous.ReliableMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamNetworkingP2PRendezvous_ReliableMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamNetworkingP2PRendezvous_ReliableMessage::new)
    }
}

impl ::protobuf::Clear for CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
    fn clear(&mut self) {
        self.ice.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgSteamNetworkingICESessionSummary {
    // message fields
    failure_reason_code: ::std::option::Option<u32>,
    local_candidate_types: ::std::option::Option<u32>,
    remote_candidate_types: ::std::option::Option<u32>,
    initial_route_kind: ::std::option::Option<u32>,
    initial_ping: ::std::option::Option<u32>,
    initial_score: ::std::option::Option<u32>,
    negotiation_ms: ::std::option::Option<u32>,
    selected_seconds: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamNetworkingICESessionSummary {
    fn default() -> &'a CMsgSteamNetworkingICESessionSummary {
        <CMsgSteamNetworkingICESessionSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamNetworkingICESessionSummary {
    pub fn new() -> CMsgSteamNetworkingICESessionSummary {
        ::std::default::Default::default()
    }

    // optional uint32 failure_reason_code = 7;


    pub fn get_failure_reason_code(&self) -> u32 {
        self.failure_reason_code.unwrap_or(0)
    }
    pub fn clear_failure_reason_code(&mut self) {
        self.failure_reason_code = ::std::option::Option::None;
    }

    pub fn has_failure_reason_code(&self) -> bool {
        self.failure_reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failure_reason_code(&mut self, v: u32) {
        self.failure_reason_code = ::std::option::Option::Some(v);
    }

    // optional uint32 local_candidate_types = 1;


    pub fn get_local_candidate_types(&self) -> u32 {
        self.local_candidate_types.unwrap_or(0)
    }
    pub fn clear_local_candidate_types(&mut self) {
        self.local_candidate_types = ::std::option::Option::None;
    }

    pub fn has_local_candidate_types(&self) -> bool {
        self.local_candidate_types.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_candidate_types(&mut self, v: u32) {
        self.local_candidate_types = ::std::option::Option::Some(v);
    }

    // optional uint32 remote_candidate_types = 2;


    pub fn get_remote_candidate_types(&self) -> u32 {
        self.remote_candidate_types.unwrap_or(0)
    }
    pub fn clear_remote_candidate_types(&mut self) {
        self.remote_candidate_types = ::std::option::Option::None;
    }

    pub fn has_remote_candidate_types(&self) -> bool {
        self.remote_candidate_types.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_candidate_types(&mut self, v: u32) {
        self.remote_candidate_types = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_route_kind = 3;


    pub fn get_initial_route_kind(&self) -> u32 {
        self.initial_route_kind.unwrap_or(0)
    }
    pub fn clear_initial_route_kind(&mut self) {
        self.initial_route_kind = ::std::option::Option::None;
    }

    pub fn has_initial_route_kind(&self) -> bool {
        self.initial_route_kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_route_kind(&mut self, v: u32) {
        self.initial_route_kind = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_ping = 4;


    pub fn get_initial_ping(&self) -> u32 {
        self.initial_ping.unwrap_or(0)
    }
    pub fn clear_initial_ping(&mut self) {
        self.initial_ping = ::std::option::Option::None;
    }

    pub fn has_initial_ping(&self) -> bool {
        self.initial_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_ping(&mut self, v: u32) {
        self.initial_ping = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_score = 6;


    pub fn get_initial_score(&self) -> u32 {
        self.initial_score.unwrap_or(0)
    }
    pub fn clear_initial_score(&mut self) {
        self.initial_score = ::std::option::Option::None;
    }

    pub fn has_initial_score(&self) -> bool {
        self.initial_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_score(&mut self, v: u32) {
        self.initial_score = ::std::option::Option::Some(v);
    }

    // optional uint32 negotiation_ms = 5;


    pub fn get_negotiation_ms(&self) -> u32 {
        self.negotiation_ms.unwrap_or(0)
    }
    pub fn clear_negotiation_ms(&mut self) {
        self.negotiation_ms = ::std::option::Option::None;
    }

    pub fn has_negotiation_ms(&self) -> bool {
        self.negotiation_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negotiation_ms(&mut self, v: u32) {
        self.negotiation_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 selected_seconds = 12;


    pub fn get_selected_seconds(&self) -> u32 {
        self.selected_seconds.unwrap_or(0)
    }
    pub fn clear_selected_seconds(&mut self) {
        self.selected_seconds = ::std::option::Option::None;
    }

    pub fn has_selected_seconds(&self) -> bool {
        self.selected_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_seconds(&mut self, v: u32) {
        self.selected_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamNetworkingICESessionSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.failure_reason_code = ::std::option::Option::Some(tmp);
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_candidate_types = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remote_candidate_types = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_route_kind = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_ping = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_score = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.negotiation_ms = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selected_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.failure_reason_code {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.local_candidate_types {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remote_candidate_types {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_route_kind {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_ping {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_score {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.negotiation_ms {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.selected_seconds {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.failure_reason_code {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.local_candidate_types {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.remote_candidate_types {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.initial_route_kind {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.initial_ping {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initial_score {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.negotiation_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.selected_seconds {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamNetworkingICESessionSummary {
        CMsgSteamNetworkingICESessionSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "failure_reason_code",
                |m: &CMsgSteamNetworkingICESessionSummary| { &m.failure_reason_code },
                |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.failure_reason_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "local_candidate_types",
                |m: &CMsgSteamNetworkingICESessionSummary| { &m.local_candidate_types },
                |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.local_candidate_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "remote_candidate_types",
                |m: &CMsgSteamNetworkingICESessionSummary| { &m.remote_candidate_types },
                |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.remote_candidate_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_route_kind",
                |m: &CMsgSteamNetworkingICESessionSummary| { &m.initial_route_kind },
                |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.initial_route_kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_ping",
                |m: &CMsgSteamNetworkingICESessionSummary| { &m.initial_ping },
                |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.initial_ping },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_score",
                |m: &CMsgSteamNetworkingICESessionSummary| { &m.initial_score },
                |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.initial_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "negotiation_ms",
                |m: &CMsgSteamNetworkingICESessionSummary| { &m.negotiation_ms },
                |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.negotiation_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "selected_seconds",
                |m: &CMsgSteamNetworkingICESessionSummary| { &m.selected_seconds },
                |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.selected_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamNetworkingICESessionSummary>(
                "CMsgSteamNetworkingICESessionSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamNetworkingICESessionSummary {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamNetworkingICESessionSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamNetworkingICESessionSummary::new)
    }
}

impl ::protobuf::Clear for CMsgSteamNetworkingICESessionSummary {
    fn clear(&mut self) {
        self.failure_reason_code = ::std::option::Option::None;
        self.local_candidate_types = ::std::option::Option::None;
        self.remote_candidate_types = ::std::option::Option::None;
        self.initial_route_kind = ::std::option::Option::None;
        self.initial_ping = ::std::option::Option::None;
        self.initial_score = ::std::option::Option::None;
        self.negotiation_ms = ::std::option::Option::None;
        self.selected_seconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamNetworkingICESessionSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamNetworkingICESessionSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum ESteamNetworkingSocketsCipher {
    k_ESteamNetworkingSocketsCipher_INVALID = 0,
    k_ESteamNetworkingSocketsCipher_NULL = 1,
    k_ESteamNetworkingSocketsCipher_AES_256_GCM = 2,
}

impl ::protobuf::ProtobufEnum for ESteamNetworkingSocketsCipher {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamNetworkingSocketsCipher> {
        match value {
            0 => ::std::option::Option::Some(ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_INVALID),
            1 => ::std::option::Option::Some(ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_NULL),
            2 => ::std::option::Option::Some(ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_AES_256_GCM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ESteamNetworkingSocketsCipher] = &[
            ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_INVALID,
            ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_NULL,
            ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_AES_256_GCM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ESteamNetworkingSocketsCipher>("ESteamNetworkingSocketsCipher", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ESteamNetworkingSocketsCipher {
}

impl ::std::default::Default for ESteamNetworkingSocketsCipher {
    fn default() -> Self {
        ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for ESteamNetworkingSocketsCipher {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%steamnetworkingsockets_messages.proto\x1a+steamnetworkingsockets_mess\
    ages_certs.proto\"\xb3\x02\n!CMsgSteamDatagramSessionCryptInfo\x12O\n\
    \x08key_type\x18\x01\x20\x01(\x0e2+.CMsgSteamDatagramSessionCryptInfo.EK\
    eyType:\x07INVALIDR\x07keyType\x12\x19\n\x08key_data\x18\x02\x20\x01(\
    \x0cR\x07keyData\x12\x14\n\x05nonce\x18\x03\x20\x01(\x06R\x05nonce\x12)\
    \n\x10protocol_version\x18\x04\x20\x01(\rR\x0fprotocolVersion\x128\n\x07\
    ciphers\x18\x05\x20\x03(\x0e2\x1e.ESteamNetworkingSocketsCipherR\x07ciph\
    ers\"'\n\x08EKeyType\x12\x0b\n\x07INVALID\x10\0\x12\x0e\n\nCURVE25519\
    \x10\x01\"[\n'CMsgSteamDatagramSessionCryptInfoSigned\x12\x12\n\x04info\
    \x18\x01\x20\x01(\x0cR\x04info\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0c\
    R\tsignature\"M\n\x1bCMsgSteamDatagramDiagnostic\x12\x1a\n\x08severity\
    \x18\x01\x20\x01(\rR\x08severity\x12\x12\n\x04text\x18\x02\x20\x01(\tR\
    \x04text\"\x97\x03\n'CMsgSteamDatagramLinkInstantaneousStats\x124\n\x17o\
    ut_packets_per_sec_x10\x18\x01\x20\x01(\rR\x13outPacketsPerSecX10\x12)\n\
    \x11out_bytes_per_sec\x18\x02\x20\x01(\rR\x0eoutBytesPerSec\x122\n\x16in\
    _packets_per_sec_x10\x18\x03\x20\x01(\rR\x12inPacketsPerSecX10\x12'\n\
    \x10in_bytes_per_sec\x18\x04\x20\x01(\rR\rinBytesPerSec\x12\x17\n\x07pin\
    g_ms\x18\x05\x20\x01(\rR\x06pingMs\x12.\n\x13packets_dropped_pct\x18\x06\
    \x20\x01(\rR\x11packetsDroppedPct\x12;\n\x1apackets_weird_sequence_pct\
    \x18\x07\x20\x01(\rR\x17packetsWeirdSequencePct\x12(\n\x10peak_jitter_us\
    ec\x18\x08\x20\x01(\rR\x0epeakJitterUsec\"\x93\x1a\n\"CMsgSteamDatagramL\
    inkLifetimeStats\x12+\n\x11connected_seconds\x18\x02\x20\x01(\rR\x10conn\
    ectedSeconds\x12!\n\x0cpackets_sent\x18\x03\x20\x01(\x04R\x0bpacketsSent\
    \x12\x17\n\x07kb_sent\x18\x04\x20\x01(\x04R\x06kbSent\x12!\n\x0cpackets_\
    recv\x18\x05\x20\x01(\x04R\x0bpacketsRecv\x12\x17\n\x07kb_recv\x18\x06\
    \x20\x01(\x04R\x06kbRecv\x124\n\x16packets_recv_sequenced\x18\x07\x20\
    \x01(\x04R\x14packetsRecvSequenced\x120\n\x14packets_recv_dropped\x18\
    \x08\x20\x01(\x04R\x12packetsRecvDropped\x128\n\x19packets_recv_out_of_o\
    rder\x18\t\x20\x01(\x04R\x15packetsRecvOutOfOrder\x124\n\x16packets_recv\
    _duplicate\x18\n\x20\x01(\x04R\x14packetsRecvDuplicate\x12,\n\x12packets\
    _recv_lurch\x18\x0b\x20\x01(\x04R\x10packetsRecvLurch\x122\n\x15quality_\
    histogram_100\x18\x15\x20\x01(\rR\x13qualityHistogram100\x120\n\x14quali\
    ty_histogram_99\x18\x16\x20\x01(\rR\x12qualityHistogram99\x120\n\x14qual\
    ity_histogram_97\x18\x17\x20\x01(\rR\x12qualityHistogram97\x120\n\x14qua\
    lity_histogram_95\x18\x18\x20\x01(\rR\x12qualityHistogram95\x120\n\x14qu\
    ality_histogram_90\x18\x19\x20\x01(\rR\x12qualityHistogram90\x120\n\x14q\
    uality_histogram_75\x18\x1a\x20\x01(\rR\x12qualityHistogram75\x120\n\x14\
    quality_histogram_50\x18\x1b\x20\x01(\rR\x12qualityHistogram50\x12.\n\
    \x13quality_histogram_1\x18\x1c\x20\x01(\rR\x11qualityHistogram1\x124\n\
    \x16quality_histogram_dead\x18\x1d\x20\x01(\rR\x14qualityHistogramDead\
    \x12*\n\x11quality_ntile_2nd\x18\x1e\x20\x01(\rR\x0fqualityNtile2nd\x12*\
    \n\x11quality_ntile_5th\x18\x1f\x20\x01(\rR\x0fqualityNtile5th\x12,\n\
    \x12quality_ntile_25th\x18\x20\x20\x01(\rR\x10qualityNtile25th\x12,\n\
    \x12quality_ntile_50th\x18!\x20\x01(\rR\x10qualityNtile50th\x12*\n\x11pi\
    ng_histogram_25\x18)\x20\x01(\rR\x0fpingHistogram25\x12*\n\x11ping_histo\
    gram_50\x18*\x20\x01(\rR\x0fpingHistogram50\x12*\n\x11ping_histogram_75\
    \x18+\x20\x01(\rR\x0fpingHistogram75\x12,\n\x12ping_histogram_100\x18,\
    \x20\x01(\rR\x10pingHistogram100\x12,\n\x12ping_histogram_125\x18-\x20\
    \x01(\rR\x10pingHistogram125\x12,\n\x12ping_histogram_150\x18.\x20\x01(\
    \rR\x10pingHistogram150\x12,\n\x12ping_histogram_200\x18/\x20\x01(\rR\
    \x10pingHistogram200\x12,\n\x12ping_histogram_300\x180\x20\x01(\rR\x10pi\
    ngHistogram300\x12,\n\x12ping_histogram_max\x181\x20\x01(\rR\x10pingHist\
    ogramMax\x12$\n\x0eping_ntile_5th\x182\x20\x01(\rR\x0cpingNtile5th\x12&\
    \n\x0fping_ntile_50th\x183\x20\x01(\rR\rpingNtile50th\x12&\n\x0fping_nti\
    le_75th\x184\x20\x01(\rR\rpingNtile75th\x12&\n\x0fping_ntile_95th\x185\
    \x20\x01(\rR\rpingNtile95th\x12&\n\x0fping_ntile_98th\x186\x20\x01(\rR\r\
    pingNtile98th\x12>\n\x1bjitter_histogram_negligible\x18=\x20\x01(\rR\x19\
    jitterHistogramNegligible\x12,\n\x12jitter_histogram_1\x18>\x20\x01(\rR\
    \x10jitterHistogram1\x12,\n\x12jitter_histogram_2\x18?\x20\x01(\rR\x10ji\
    tterHistogram2\x12,\n\x12jitter_histogram_5\x18@\x20\x01(\rR\x10jitterHi\
    stogram5\x12.\n\x13jitter_histogram_10\x18A\x20\x01(\rR\x11jitterHistogr\
    am10\x12.\n\x13jitter_histogram_20\x18B\x20\x01(\rR\x11jitterHistogram20\
    \x12\x1f\n\x0btxspeed_max\x18C\x20\x01(\rR\ntxspeedMax\x120\n\x14txspeed\
    _histogram_16\x18D\x20\x01(\rR\x12txspeedHistogram16\x120\n\x14txspeed_h\
    istogram_32\x18E\x20\x01(\rR\x12txspeedHistogram32\x120\n\x14txspeed_his\
    togram_64\x18F\x20\x01(\rR\x12txspeedHistogram64\x122\n\x15txspeed_histo\
    gram_128\x18G\x20\x01(\rR\x13txspeedHistogram128\x122\n\x15txspeed_histo\
    gram_256\x18H\x20\x01(\rR\x13txspeedHistogram256\x122\n\x15txspeed_histo\
    gram_512\x18I\x20\x01(\rR\x13txspeedHistogram512\x124\n\x16txspeed_histo\
    gram_1024\x18J\x20\x01(\rR\x14txspeedHistogram1024\x122\n\x15txspeed_his\
    togram_max\x18K\x20\x01(\rR\x13txspeedHistogramMax\x12*\n\x11txspeed_nti\
    le_5th\x18L\x20\x01(\rR\x0ftxspeedNtile5th\x12,\n\x12txspeed_ntile_50th\
    \x18M\x20\x01(\rR\x10txspeedNtile50th\x12,\n\x12txspeed_ntile_75th\x18N\
    \x20\x01(\rR\x10txspeedNtile75th\x12,\n\x12txspeed_ntile_95th\x18O\x20\
    \x01(\rR\x10txspeedNtile95th\x12,\n\x12txspeed_ntile_98th\x18P\x20\x01(\
    \rR\x10txspeedNtile98th\x12\x1f\n\x0brxspeed_max\x18Q\x20\x01(\rR\nrxspe\
    edMax\x120\n\x14rxspeed_histogram_16\x18R\x20\x01(\rR\x12rxspeedHistogra\
    m16\x120\n\x14rxspeed_histogram_32\x18S\x20\x01(\rR\x12rxspeedHistogram3\
    2\x120\n\x14rxspeed_histogram_64\x18T\x20\x01(\rR\x12rxspeedHistogram64\
    \x122\n\x15rxspeed_histogram_128\x18U\x20\x01(\rR\x13rxspeedHistogram128\
    \x122\n\x15rxspeed_histogram_256\x18V\x20\x01(\rR\x13rxspeedHistogram256\
    \x122\n\x15rxspeed_histogram_512\x18W\x20\x01(\rR\x13rxspeedHistogram512\
    \x124\n\x16rxspeed_histogram_1024\x18X\x20\x01(\rR\x14rxspeedHistogram10\
    24\x122\n\x15rxspeed_histogram_max\x18Y\x20\x01(\rR\x13rxspeedHistogramM\
    ax\x12*\n\x11rxspeed_ntile_5th\x18Z\x20\x01(\rR\x0frxspeedNtile5th\x12,\
    \n\x12rxspeed_ntile_50th\x18[\x20\x01(\rR\x10rxspeedNtile50th\x12,\n\x12\
    rxspeed_ntile_75th\x18\\\x20\x01(\rR\x10rxspeedNtile75th\x12,\n\x12rxspe\
    ed_ntile_95th\x18]\x20\x01(\rR\x10rxspeedNtile95th\x12,\n\x12rxspeed_nti\
    le_98th\x18^\x20\x01(\rR\x10rxspeedNtile98th\"\xb5\x01\n\"CMsgSteamDatag\
    ramConnectionQuality\x12N\n\rinstantaneous\x18\x01\x20\x01(\x0b2(.CMsgSt\
    eamDatagramLinkInstantaneousStatsR\rinstantaneous\x12?\n\x08lifetime\x18\
    \x02\x20\x01(\x0b2#.CMsgSteamDatagramLinkLifetimeStatsR\x08lifetime\"\
    \xd1\x01\n\x11CMsgICERendezvous\x12+\n\x04auth\x18\x02\x20\x01(\x0b2\x17\
    .CMsgICERendezvous.AuthR\x04auth\x12A\n\radd_candidate\x18\x01\x20\x01(\
    \x0b2\x1c.CMsgICERendezvous.CandidateR\x0caddCandidate\x1a!\n\x04Auth\
    \x12\x19\n\x08pwd_frag\x18\x01\x20\x01(\tR\x07pwdFrag\x1a)\n\tCandidate\
    \x12\x1c\n\tcandidate\x18\x03\x20\x01(\tR\tcandidate\"\xe4\t\n\x20CMsgSt\
    eamNetworkingP2PRendezvous\x12#\n\rfrom_identity\x18\x08\x20\x01(\tR\x0c\
    fromIdentity\x12,\n\x12from_connection_id\x18\t\x20\x01(\x07R\x10fromCon\
    nectionId\x12\x1f\n\x0bto_identity\x18\n\x20\x01(\tR\ntoIdentity\x12(\n\
    \x10to_connection_id\x18\x01\x20\x01(\x07R\x0etoConnectionId\x12\x1d\n\n\
    sdr_routes\x18\x02\x20\x01(\x0cR\tsdrRoutes\x127\n\x18ack_peer_routes_re\
    vision\x18\x03\x20\x01(\rR\x15ackPeerRoutesRevision\x12\x1f\n\x0bice_ena\
    bled\x18\x07\x20\x01(\x08R\niceEnabled\x12Y\n\x0fconnect_request\x18\x04\
    \x20\x01(\x0b20.CMsgSteamNetworkingP2PRendezvous.ConnectRequestR\x0econn\
    ectRequest\x12J\n\nconnect_ok\x18\x05\x20\x01(\x0b2+.CMsgSteamNetworking\
    P2PRendezvous.ConnectOKR\tconnectOk\x12_\n\x11connection_closed\x18\x06\
    \x20\x01(\x0b22.CMsgSteamNetworkingP2PRendezvous.ConnectionClosedR\x10co\
    nnectionClosed\x12(\n\x10ack_reliable_msg\x18\x0b\x20\x01(\rR\x0eackReli\
    ableMsg\x12,\n\x12first_reliable_msg\x18\x0c\x20\x01(\rR\x10firstReliabl\
    eMsg\x12^\n\x11reliable_messages\x18\r\x20\x03(\x0b21.CMsgSteamNetworkin\
    gP2PRendezvous.ReliableMessageR\x10reliableMessages\x1a\xdd\x01\n\x0eCon\
    nectRequest\x12>\n\x05crypt\x18\x06\x20\x01(\x0b2(.CMsgSteamDatagramSess\
    ionCryptInfoSignedR\x05crypt\x127\n\x04cert\x18\x07\x20\x01(\x0b2#.CMsgS\
    teamDatagramCertificateSignedR\x04cert\x12&\n\x0fto_virtual_port\x18\t\
    \x20\x01(\rR\rtoVirtualPort\x12*\n\x11from_virtual_port\x18\n\x20\x01(\r\
    R\x0ffromVirtualPort\x1a\x84\x01\n\tConnectOK\x12>\n\x05crypt\x18\x05\
    \x20\x01(\x0b2(.CMsgSteamDatagramSessionCryptInfoSignedR\x05crypt\x127\n\
    \x04cert\x18\x06\x20\x01(\x0b2#.CMsgSteamDatagramCertificateSignedR\x04c\
    ert\x1aI\n\x10ConnectionClosed\x12\x14\n\x05debug\x18\x05\x20\x01(\tR\
    \x05debug\x12\x1f\n\x0breason_code\x18\x06\x20\x01(\rR\nreasonCode\x1a7\
    \n\x0fReliableMessage\x12$\n\x03ice\x18\x01\x20\x01(\x0b2\x12.CMsgICERen\
    dezvousR\x03ice\"\x88\x03\n$CMsgSteamNetworkingICESessionSummary\x12.\n\
    \x13failure_reason_code\x18\x07\x20\x01(\rR\x11failureReasonCode\x122\n\
    \x15local_candidate_types\x18\x01\x20\x01(\rR\x13localCandidateTypes\x12\
    4\n\x16remote_candidate_types\x18\x02\x20\x01(\rR\x14remoteCandidateType\
    s\x12,\n\x12initial_route_kind\x18\x03\x20\x01(\rR\x10initialRouteKind\
    \x12!\n\x0cinitial_ping\x18\x04\x20\x01(\rR\x0binitialPing\x12#\n\riniti\
    al_score\x18\x06\x20\x01(\rR\x0cinitialScore\x12%\n\x0enegotiation_ms\
    \x18\x05\x20\x01(\rR\rnegotiationMs\x12)\n\x10selected_seconds\x18\x0c\
    \x20\x01(\rR\x0fselectedSeconds*\xa7\x01\n\x1dESteamNetworkingSocketsCip\
    her\x12+\n'k_ESteamNetworkingSocketsCipher_INVALID\x10\0\x12(\n$k_ESteam\
    NetworkingSocketsCipher_NULL\x10\x01\x12/\n+k_ESteamNetworkingSocketsCip\
    her_AES_256_GCM\x10\x02B\x05H\x01\x80\x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
